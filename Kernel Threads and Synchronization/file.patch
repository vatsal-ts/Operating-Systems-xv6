diff -ruN xv6-public/bio.d copy-xv6/bio.d
--- xv6-public/bio.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/bio.d	2022-09-05 23:26:12.744781076 +0530
@@ -0,0 +1,2 @@
+bio.o: bio.c /usr/include/stdc-predef.h types.h defs.h param.h spinlock.h \
+ sleeplock.h fs.h buf.h
Binary files xv6-public/bio.o and copy-xv6/bio.o differ
diff -ruN xv6-public/bootasm.d copy-xv6/bootasm.d
--- xv6-public/bootasm.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/bootasm.d	2022-09-05 23:26:12.704781077 +0530
@@ -0,0 +1 @@
+bootasm.o: bootasm.S asm.h memlayout.h mmu.h
Binary files xv6-public/bootasm.o and copy-xv6/bootasm.o differ
Binary files xv6-public/bootblock and copy-xv6/bootblock differ
diff -ruN xv6-public/bootblock.asm copy-xv6/bootblock.asm
--- xv6-public/bootblock.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/bootblock.asm	2022-09-05 23:26:12.712781077 +0530
@@ -0,0 +1,361 @@
+
+bootblock.o:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00007c00 <start>:
+# with %cs=0 %ip=7c00.
+
+.code16                       # Assemble for 16-bit mode
+.globl start
+start:
+  cli                         # BIOS enabled interrupts; disable
+    7c00:	fa                   	cli    
+
+  # Zero data segment registers DS, ES, and SS.
+  xorw    %ax,%ax             # Set %ax to zero
+    7c01:	31 c0                	xor    %eax,%eax
+  movw    %ax,%ds             # -> Data Segment
+    7c03:	8e d8                	mov    %eax,%ds
+  movw    %ax,%es             # -> Extra Segment
+    7c05:	8e c0                	mov    %eax,%es
+  movw    %ax,%ss             # -> Stack Segment
+    7c07:	8e d0                	mov    %eax,%ss
+
+00007c09 <seta20.1>:
+
+  # Physical address line A20 is tied to zero so that the first PCs 
+  # with 2 MB would run software that assumed 1 MB.  Undo that.
+seta20.1:
+  inb     $0x64,%al               # Wait for not busy
+    7c09:	e4 64                	in     $0x64,%al
+  testb   $0x2,%al
+    7c0b:	a8 02                	test   $0x2,%al
+  jnz     seta20.1
+    7c0d:	75 fa                	jne    7c09 <seta20.1>
+
+  movb    $0xd1,%al               # 0xd1 -> port 0x64
+    7c0f:	b0 d1                	mov    $0xd1,%al
+  outb    %al,$0x64
+    7c11:	e6 64                	out    %al,$0x64
+
+00007c13 <seta20.2>:
+
+seta20.2:
+  inb     $0x64,%al               # Wait for not busy
+    7c13:	e4 64                	in     $0x64,%al
+  testb   $0x2,%al
+    7c15:	a8 02                	test   $0x2,%al
+  jnz     seta20.2
+    7c17:	75 fa                	jne    7c13 <seta20.2>
+
+  movb    $0xdf,%al               # 0xdf -> port 0x60
+    7c19:	b0 df                	mov    $0xdf,%al
+  outb    %al,$0x60
+    7c1b:	e6 60                	out    %al,$0x60
+
+  # Switch from real to protected mode.  Use a bootstrap GDT that makes
+  # virtual addresses map directly to physical addresses so that the
+  # effective memory map doesn't change during the transition.
+  lgdt    gdtdesc
+    7c1d:	0f 01 16             	lgdtl  (%esi)
+    7c20:	78 7c                	js     7c9e <readsect+0xe>
+  movl    %cr0, %eax
+    7c22:	0f 20 c0             	mov    %cr0,%eax
+  orl     $CR0_PE, %eax
+    7c25:	66 83 c8 01          	or     $0x1,%ax
+  movl    %eax, %cr0
+    7c29:	0f 22 c0             	mov    %eax,%cr0
+
+//PAGEBREAK!
+  # Complete the transition to 32-bit protected mode by using a long jmp
+  # to reload %cs and %eip.  The segment descriptors are set up with no
+  # translation, so that the mapping is still the identity mapping.
+  ljmp    $(SEG_KCODE<<3), $start32
+    7c2c:	ea                   	.byte 0xea
+    7c2d:	31 7c 08 00          	xor    %edi,0x0(%eax,%ecx,1)
+
+00007c31 <start32>:
+
+.code32  # Tell assembler to generate 32-bit code now.
+start32:
+  # Set up the protected-mode data segment registers
+  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
+    7c31:	66 b8 10 00          	mov    $0x10,%ax
+  movw    %ax, %ds                # -> DS: Data Segment
+    7c35:	8e d8                	mov    %eax,%ds
+  movw    %ax, %es                # -> ES: Extra Segment
+    7c37:	8e c0                	mov    %eax,%es
+  movw    %ax, %ss                # -> SS: Stack Segment
+    7c39:	8e d0                	mov    %eax,%ss
+  movw    $0, %ax                 # Zero segments not ready for use
+    7c3b:	66 b8 00 00          	mov    $0x0,%ax
+  movw    %ax, %fs                # -> FS
+    7c3f:	8e e0                	mov    %eax,%fs
+  movw    %ax, %gs                # -> GS
+    7c41:	8e e8                	mov    %eax,%gs
+
+  # Set up the stack pointer and call into C.
+  movl    $start, %esp
+    7c43:	bc 00 7c 00 00       	mov    $0x7c00,%esp
+  call    bootmain
+    7c48:	e8 fc 00 00 00       	call   7d49 <bootmain>
+
+  # If bootmain returns (it shouldn't), trigger a Bochs
+  # breakpoint if running under Bochs, then loop.
+  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
+    7c4d:	66 b8 00 8a          	mov    $0x8a00,%ax
+  movw    %ax, %dx
+    7c51:	66 89 c2             	mov    %ax,%dx
+  outw    %ax, %dx
+    7c54:	66 ef                	out    %ax,(%dx)
+  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
+    7c56:	66 b8 e0 8a          	mov    $0x8ae0,%ax
+  outw    %ax, %dx
+    7c5a:	66 ef                	out    %ax,(%dx)
+
+00007c5c <spin>:
+spin:
+  jmp     spin
+    7c5c:	eb fe                	jmp    7c5c <spin>
+    7c5e:	66 90                	xchg   %ax,%ax
+
+00007c60 <gdt>:
+	...
+    7c68:	ff                   	(bad)  
+    7c69:	ff 00                	incl   (%eax)
+    7c6b:	00 00                	add    %al,(%eax)
+    7c6d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
+    7c74:	00                   	.byte 0x0
+    7c75:	92                   	xchg   %eax,%edx
+    7c76:	cf                   	iret   
+	...
+
+00007c78 <gdtdesc>:
+    7c78:	17                   	pop    %ss
+    7c79:	00 60 7c             	add    %ah,0x7c(%eax)
+	...
+
+00007c7e <waitdisk>:
+  entry();
+}
+
+void
+waitdisk(void)
+{
+    7c7e:	f3 0f 1e fb          	endbr32 
+static inline uchar
+inb(ushort port)
+{
+  uchar data;
+
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+    7c82:	ba f7 01 00 00       	mov    $0x1f7,%edx
+    7c87:	ec                   	in     (%dx),%al
+  // Wait for disk ready.
+  while((inb(0x1F7) & 0xC0) != 0x40)
+    7c88:	83 e0 c0             	and    $0xffffffc0,%eax
+    7c8b:	3c 40                	cmp    $0x40,%al
+    7c8d:	75 f8                	jne    7c87 <waitdisk+0x9>
+    ;
+}
+    7c8f:	c3                   	ret    
+
+00007c90 <readsect>:
+
+// Read a single sector at offset into dst.
+void
+readsect(void *dst, uint offset)
+{
+    7c90:	f3 0f 1e fb          	endbr32 
+    7c94:	55                   	push   %ebp
+    7c95:	89 e5                	mov    %esp,%ebp
+    7c97:	57                   	push   %edi
+    7c98:	53                   	push   %ebx
+    7c99:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  // Issue command.
+  waitdisk();
+    7c9c:	e8 dd ff ff ff       	call   7c7e <waitdisk>
+}
+
+static inline void
+outb(ushort port, uchar data)
+{
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+    7ca1:	b8 01 00 00 00       	mov    $0x1,%eax
+    7ca6:	ba f2 01 00 00       	mov    $0x1f2,%edx
+    7cab:	ee                   	out    %al,(%dx)
+    7cac:	ba f3 01 00 00       	mov    $0x1f3,%edx
+    7cb1:	89 d8                	mov    %ebx,%eax
+    7cb3:	ee                   	out    %al,(%dx)
+  outb(0x1F2, 1);   // count = 1
+  outb(0x1F3, offset);
+  outb(0x1F4, offset >> 8);
+    7cb4:	89 d8                	mov    %ebx,%eax
+    7cb6:	c1 e8 08             	shr    $0x8,%eax
+    7cb9:	ba f4 01 00 00       	mov    $0x1f4,%edx
+    7cbe:	ee                   	out    %al,(%dx)
+  outb(0x1F5, offset >> 16);
+    7cbf:	89 d8                	mov    %ebx,%eax
+    7cc1:	c1 e8 10             	shr    $0x10,%eax
+    7cc4:	ba f5 01 00 00       	mov    $0x1f5,%edx
+    7cc9:	ee                   	out    %al,(%dx)
+  outb(0x1F6, (offset >> 24) | 0xE0);
+    7cca:	89 d8                	mov    %ebx,%eax
+    7ccc:	c1 e8 18             	shr    $0x18,%eax
+    7ccf:	83 c8 e0             	or     $0xffffffe0,%eax
+    7cd2:	ba f6 01 00 00       	mov    $0x1f6,%edx
+    7cd7:	ee                   	out    %al,(%dx)
+    7cd8:	b8 20 00 00 00       	mov    $0x20,%eax
+    7cdd:	ba f7 01 00 00       	mov    $0x1f7,%edx
+    7ce2:	ee                   	out    %al,(%dx)
+  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
+
+  // Read data.
+  waitdisk();
+    7ce3:	e8 96 ff ff ff       	call   7c7e <waitdisk>
+  asm volatile("cld; rep insl" :
+    7ce8:	8b 7d 08             	mov    0x8(%ebp),%edi
+    7ceb:	b9 80 00 00 00       	mov    $0x80,%ecx
+    7cf0:	ba f0 01 00 00       	mov    $0x1f0,%edx
+    7cf5:	fc                   	cld    
+    7cf6:	f3 6d                	rep insl (%dx),%es:(%edi)
+  insl(0x1F0, dst, SECTSIZE/4);
+}
+    7cf8:	5b                   	pop    %ebx
+    7cf9:	5f                   	pop    %edi
+    7cfa:	5d                   	pop    %ebp
+    7cfb:	c3                   	ret    
+
+00007cfc <readseg>:
+
+// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
+// Might copy more than asked.
+void
+readseg(uchar* pa, uint count, uint offset)
+{
+    7cfc:	f3 0f 1e fb          	endbr32 
+    7d00:	55                   	push   %ebp
+    7d01:	89 e5                	mov    %esp,%ebp
+    7d03:	57                   	push   %edi
+    7d04:	56                   	push   %esi
+    7d05:	53                   	push   %ebx
+    7d06:	83 ec 0c             	sub    $0xc,%esp
+    7d09:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    7d0c:	8b 75 10             	mov    0x10(%ebp),%esi
+  uchar* epa;
+
+  epa = pa + count;
+    7d0f:	89 df                	mov    %ebx,%edi
+    7d11:	03 7d 0c             	add    0xc(%ebp),%edi
+
+  // Round down to sector boundary.
+  pa -= offset % SECTSIZE;
+    7d14:	89 f0                	mov    %esi,%eax
+    7d16:	25 ff 01 00 00       	and    $0x1ff,%eax
+    7d1b:	29 c3                	sub    %eax,%ebx
+
+  // Translate from bytes to sectors; kernel starts at sector 1.
+  offset = (offset / SECTSIZE) + 1;
+    7d1d:	c1 ee 09             	shr    $0x9,%esi
+    7d20:	83 c6 01             	add    $0x1,%esi
+
+  // If this is too slow, we could read lots of sectors at a time.
+  // We'd write more to memory than asked, but it doesn't matter --
+  // we load in increasing order.
+  for(; pa < epa; pa += SECTSIZE, offset++)
+    7d23:	39 df                	cmp    %ebx,%edi
+    7d25:	76 1a                	jbe    7d41 <readseg+0x45>
+    readsect(pa, offset);
+    7d27:	83 ec 08             	sub    $0x8,%esp
+    7d2a:	56                   	push   %esi
+    7d2b:	53                   	push   %ebx
+    7d2c:	e8 5f ff ff ff       	call   7c90 <readsect>
+  for(; pa < epa; pa += SECTSIZE, offset++)
+    7d31:	81 c3 00 02 00 00    	add    $0x200,%ebx
+    7d37:	83 c6 01             	add    $0x1,%esi
+    7d3a:	83 c4 10             	add    $0x10,%esp
+    7d3d:	39 df                	cmp    %ebx,%edi
+    7d3f:	77 e6                	ja     7d27 <readseg+0x2b>
+}
+    7d41:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    7d44:	5b                   	pop    %ebx
+    7d45:	5e                   	pop    %esi
+    7d46:	5f                   	pop    %edi
+    7d47:	5d                   	pop    %ebp
+    7d48:	c3                   	ret    
+
+00007d49 <bootmain>:
+{
+    7d49:	f3 0f 1e fb          	endbr32 
+    7d4d:	55                   	push   %ebp
+    7d4e:	89 e5                	mov    %esp,%ebp
+    7d50:	57                   	push   %edi
+    7d51:	56                   	push   %esi
+    7d52:	53                   	push   %ebx
+    7d53:	83 ec 10             	sub    $0x10,%esp
+  readseg((uchar*)elf, 4096, 0);
+    7d56:	6a 00                	push   $0x0
+    7d58:	68 00 10 00 00       	push   $0x1000
+    7d5d:	68 00 00 01 00       	push   $0x10000
+    7d62:	e8 95 ff ff ff       	call   7cfc <readseg>
+  if(elf->magic != ELF_MAGIC)
+    7d67:	83 c4 10             	add    $0x10,%esp
+    7d6a:	81 3d 00 00 01 00 7f 	cmpl   $0x464c457f,0x10000
+    7d71:	45 4c 46 
+    7d74:	75 21                	jne    7d97 <bootmain+0x4e>
+  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
+    7d76:	a1 1c 00 01 00       	mov    0x1001c,%eax
+    7d7b:	8d 98 00 00 01 00    	lea    0x10000(%eax),%ebx
+  eph = ph + elf->phnum;
+    7d81:	0f b7 35 2c 00 01 00 	movzwl 0x1002c,%esi
+    7d88:	c1 e6 05             	shl    $0x5,%esi
+    7d8b:	01 de                	add    %ebx,%esi
+  for(; ph < eph; ph++){
+    7d8d:	39 f3                	cmp    %esi,%ebx
+    7d8f:	72 15                	jb     7da6 <bootmain+0x5d>
+  entry();
+    7d91:	ff 15 18 00 01 00    	call   *0x10018
+}
+    7d97:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    7d9a:	5b                   	pop    %ebx
+    7d9b:	5e                   	pop    %esi
+    7d9c:	5f                   	pop    %edi
+    7d9d:	5d                   	pop    %ebp
+    7d9e:	c3                   	ret    
+  for(; ph < eph; ph++){
+    7d9f:	83 c3 20             	add    $0x20,%ebx
+    7da2:	39 de                	cmp    %ebx,%esi
+    7da4:	76 eb                	jbe    7d91 <bootmain+0x48>
+    pa = (uchar*)ph->paddr;
+    7da6:	8b 7b 0c             	mov    0xc(%ebx),%edi
+    readseg(pa, ph->filesz, ph->off);
+    7da9:	83 ec 04             	sub    $0x4,%esp
+    7dac:	ff 73 04             	pushl  0x4(%ebx)
+    7daf:	ff 73 10             	pushl  0x10(%ebx)
+    7db2:	57                   	push   %edi
+    7db3:	e8 44 ff ff ff       	call   7cfc <readseg>
+    if(ph->memsz > ph->filesz)
+    7db8:	8b 4b 14             	mov    0x14(%ebx),%ecx
+    7dbb:	8b 43 10             	mov    0x10(%ebx),%eax
+    7dbe:	83 c4 10             	add    $0x10,%esp
+    7dc1:	39 c1                	cmp    %eax,%ecx
+    7dc3:	76 da                	jbe    7d9f <bootmain+0x56>
+      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
+    7dc5:	01 c7                	add    %eax,%edi
+    7dc7:	29 c1                	sub    %eax,%ecx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    7dc9:	b8 00 00 00 00       	mov    $0x0,%eax
+    7dce:	fc                   	cld    
+    7dcf:	f3 aa                	rep stos %al,%es:(%edi)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+    7dd1:	eb cc                	jmp    7d9f <bootmain+0x56>
Binary files xv6-public/bootblock.o and copy-xv6/bootblock.o differ
Binary files xv6-public/bootblockother.o and copy-xv6/bootblockother.o differ
diff -ruN xv6-public/bootmain.d copy-xv6/bootmain.d
--- xv6-public/bootmain.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/bootmain.d	2022-09-05 23:26:12.696781077 +0530
@@ -0,0 +1 @@
+bootmain.o: bootmain.c types.h elf.h x86.h memlayout.h
Binary files xv6-public/bootmain.o and copy-xv6/bootmain.o differ
Binary files xv6-public/_cat and copy-xv6/_cat differ
diff -ruN xv6-public/cat.asm copy-xv6/cat.asm
--- xv6-public/cat.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/cat.asm	2022-09-05 23:26:11.820781093 +0530
@@ -0,0 +1,1305 @@
+
+_cat:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+  }
+}
+
+int
+main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	57                   	push   %edi
+  12:	56                   	push   %esi
+  13:	be 01 00 00 00       	mov    $0x1,%esi
+  18:	53                   	push   %ebx
+  19:	51                   	push   %ecx
+  1a:	83 ec 18             	sub    $0x18,%esp
+  1d:	8b 01                	mov    (%ecx),%eax
+  1f:	8b 59 04             	mov    0x4(%ecx),%ebx
+  22:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  25:	83 c3 04             	add    $0x4,%ebx
+  int fd, i;
+
+  if(argc <= 1){
+  28:	83 f8 01             	cmp    $0x1,%eax
+  2b:	7e 50                	jle    7d <main+0x7d>
+  2d:	8d 76 00             	lea    0x0(%esi),%esi
+    cat(0);
+    exit();
+  }
+
+  for(i = 1; i < argc; i++){
+    if((fd = open(argv[i], 0)) < 0){
+  30:	83 ec 08             	sub    $0x8,%esp
+  33:	6a 00                	push   $0x0
+  35:	ff 33                	pushl  (%ebx)
+  37:	e8 77 03 00 00       	call   3b3 <open>
+  3c:	83 c4 10             	add    $0x10,%esp
+  3f:	89 c7                	mov    %eax,%edi
+  41:	85 c0                	test   %eax,%eax
+  43:	78 24                	js     69 <main+0x69>
+      printf(1, "cat: cannot open %s\n", argv[i]);
+      exit();
+    }
+    cat(fd);
+  45:	83 ec 0c             	sub    $0xc,%esp
+  for(i = 1; i < argc; i++){
+  48:	83 c6 01             	add    $0x1,%esi
+  4b:	83 c3 04             	add    $0x4,%ebx
+    cat(fd);
+  4e:	50                   	push   %eax
+  4f:	e8 3c 00 00 00       	call   90 <cat>
+    close(fd);
+  54:	89 3c 24             	mov    %edi,(%esp)
+  57:	e8 3f 03 00 00       	call   39b <close>
+  for(i = 1; i < argc; i++){
+  5c:	83 c4 10             	add    $0x10,%esp
+  5f:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
+  62:	75 cc                	jne    30 <main+0x30>
+  }
+  exit();
+  64:	e8 0a 03 00 00       	call   373 <exit>
+      printf(1, "cat: cannot open %s\n", argv[i]);
+  69:	50                   	push   %eax
+  6a:	ff 33                	pushl  (%ebx)
+  6c:	68 7b 08 00 00       	push   $0x87b
+  71:	6a 01                	push   $0x1
+  73:	e8 78 04 00 00       	call   4f0 <printf>
+      exit();
+  78:	e8 f6 02 00 00       	call   373 <exit>
+    cat(0);
+  7d:	83 ec 0c             	sub    $0xc,%esp
+  80:	6a 00                	push   $0x0
+  82:	e8 09 00 00 00       	call   90 <cat>
+    exit();
+  87:	e8 e7 02 00 00       	call   373 <exit>
+  8c:	66 90                	xchg   %ax,%ax
+  8e:	66 90                	xchg   %ax,%ax
+
+00000090 <cat>:
+{
+  90:	f3 0f 1e fb          	endbr32 
+  94:	55                   	push   %ebp
+  95:	89 e5                	mov    %esp,%ebp
+  97:	56                   	push   %esi
+  98:	8b 75 08             	mov    0x8(%ebp),%esi
+  9b:	53                   	push   %ebx
+  while((n = read(fd, buf, sizeof(buf))) > 0) {
+  9c:	eb 19                	jmp    b7 <cat+0x27>
+  9e:	66 90                	xchg   %ax,%ax
+    if (write(1, buf, n) != n) {
+  a0:	83 ec 04             	sub    $0x4,%esp
+  a3:	53                   	push   %ebx
+  a4:	68 a0 0b 00 00       	push   $0xba0
+  a9:	6a 01                	push   $0x1
+  ab:	e8 e3 02 00 00       	call   393 <write>
+  b0:	83 c4 10             	add    $0x10,%esp
+  b3:	39 d8                	cmp    %ebx,%eax
+  b5:	75 25                	jne    dc <cat+0x4c>
+  while((n = read(fd, buf, sizeof(buf))) > 0) {
+  b7:	83 ec 04             	sub    $0x4,%esp
+  ba:	68 00 02 00 00       	push   $0x200
+  bf:	68 a0 0b 00 00       	push   $0xba0
+  c4:	56                   	push   %esi
+  c5:	e8 c1 02 00 00       	call   38b <read>
+  ca:	83 c4 10             	add    $0x10,%esp
+  cd:	89 c3                	mov    %eax,%ebx
+  cf:	85 c0                	test   %eax,%eax
+  d1:	7f cd                	jg     a0 <cat+0x10>
+  if(n < 0){
+  d3:	75 1b                	jne    f0 <cat+0x60>
+}
+  d5:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  d8:	5b                   	pop    %ebx
+  d9:	5e                   	pop    %esi
+  da:	5d                   	pop    %ebp
+  db:	c3                   	ret    
+      printf(1, "cat: write error\n");
+  dc:	83 ec 08             	sub    $0x8,%esp
+  df:	68 58 08 00 00       	push   $0x858
+  e4:	6a 01                	push   $0x1
+  e6:	e8 05 04 00 00       	call   4f0 <printf>
+      exit();
+  eb:	e8 83 02 00 00       	call   373 <exit>
+    printf(1, "cat: read error\n");
+  f0:	50                   	push   %eax
+  f1:	50                   	push   %eax
+  f2:	68 6a 08 00 00       	push   $0x86a
+  f7:	6a 01                	push   $0x1
+  f9:	e8 f2 03 00 00       	call   4f0 <printf>
+    exit();
+  fe:	e8 70 02 00 00       	call   373 <exit>
+ 103:	66 90                	xchg   %ax,%ax
+ 105:	66 90                	xchg   %ax,%ax
+ 107:	66 90                	xchg   %ax,%ax
+ 109:	66 90                	xchg   %ax,%ax
+ 10b:	66 90                	xchg   %ax,%ax
+ 10d:	66 90                	xchg   %ax,%ax
+ 10f:	90                   	nop
+
+00000110 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 110:	f3 0f 1e fb          	endbr32 
+ 114:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+ 115:	31 c0                	xor    %eax,%eax
+{
+ 117:	89 e5                	mov    %esp,%ebp
+ 119:	53                   	push   %ebx
+ 11a:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 11d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+ 120:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+ 124:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+ 127:	83 c0 01             	add    $0x1,%eax
+ 12a:	84 d2                	test   %dl,%dl
+ 12c:	75 f2                	jne    120 <strcpy+0x10>
+    ;
+  return os;
+}
+ 12e:	89 c8                	mov    %ecx,%eax
+ 130:	5b                   	pop    %ebx
+ 131:	5d                   	pop    %ebp
+ 132:	c3                   	ret    
+ 133:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 13a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000140 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 140:	f3 0f 1e fb          	endbr32 
+ 144:	55                   	push   %ebp
+ 145:	89 e5                	mov    %esp,%ebp
+ 147:	53                   	push   %ebx
+ 148:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 14b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+ 14e:	0f b6 01             	movzbl (%ecx),%eax
+ 151:	0f b6 1a             	movzbl (%edx),%ebx
+ 154:	84 c0                	test   %al,%al
+ 156:	75 19                	jne    171 <strcmp+0x31>
+ 158:	eb 26                	jmp    180 <strcmp+0x40>
+ 15a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 160:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+ 164:	83 c1 01             	add    $0x1,%ecx
+ 167:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+ 16a:	0f b6 1a             	movzbl (%edx),%ebx
+ 16d:	84 c0                	test   %al,%al
+ 16f:	74 0f                	je     180 <strcmp+0x40>
+ 171:	38 d8                	cmp    %bl,%al
+ 173:	74 eb                	je     160 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+ 175:	29 d8                	sub    %ebx,%eax
+}
+ 177:	5b                   	pop    %ebx
+ 178:	5d                   	pop    %ebp
+ 179:	c3                   	ret    
+ 17a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 180:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+ 182:	29 d8                	sub    %ebx,%eax
+}
+ 184:	5b                   	pop    %ebx
+ 185:	5d                   	pop    %ebp
+ 186:	c3                   	ret    
+ 187:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 18e:	66 90                	xchg   %ax,%ax
+
+00000190 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 190:	f3 0f 1e fb          	endbr32 
+ 194:	55                   	push   %ebp
+ 195:	89 e5                	mov    %esp,%ebp
+ 197:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 19a:	80 3a 00             	cmpb   $0x0,(%edx)
+ 19d:	74 21                	je     1c0 <strlen+0x30>
+ 19f:	31 c0                	xor    %eax,%eax
+ 1a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1a8:	83 c0 01             	add    $0x1,%eax
+ 1ab:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+ 1af:	89 c1                	mov    %eax,%ecx
+ 1b1:	75 f5                	jne    1a8 <strlen+0x18>
+    ;
+  return n;
+}
+ 1b3:	89 c8                	mov    %ecx,%eax
+ 1b5:	5d                   	pop    %ebp
+ 1b6:	c3                   	ret    
+ 1b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1be:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+ 1c0:	31 c9                	xor    %ecx,%ecx
+}
+ 1c2:	5d                   	pop    %ebp
+ 1c3:	89 c8                	mov    %ecx,%eax
+ 1c5:	c3                   	ret    
+ 1c6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1cd:	8d 76 00             	lea    0x0(%esi),%esi
+
+000001d0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 1d0:	f3 0f 1e fb          	endbr32 
+ 1d4:	55                   	push   %ebp
+ 1d5:	89 e5                	mov    %esp,%ebp
+ 1d7:	57                   	push   %edi
+ 1d8:	8b 55 08             	mov    0x8(%ebp),%edx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+ 1db:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 1de:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1e1:	89 d7                	mov    %edx,%edi
+ 1e3:	fc                   	cld    
+ 1e4:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+ 1e6:	89 d0                	mov    %edx,%eax
+ 1e8:	5f                   	pop    %edi
+ 1e9:	5d                   	pop    %ebp
+ 1ea:	c3                   	ret    
+ 1eb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 1ef:	90                   	nop
+
+000001f0 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 1f0:	f3 0f 1e fb          	endbr32 
+ 1f4:	55                   	push   %ebp
+ 1f5:	89 e5                	mov    %esp,%ebp
+ 1f7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1fa:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+ 1fe:	0f b6 10             	movzbl (%eax),%edx
+ 201:	84 d2                	test   %dl,%dl
+ 203:	75 16                	jne    21b <strchr+0x2b>
+ 205:	eb 21                	jmp    228 <strchr+0x38>
+ 207:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 20e:	66 90                	xchg   %ax,%ax
+ 210:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+ 214:	83 c0 01             	add    $0x1,%eax
+ 217:	84 d2                	test   %dl,%dl
+ 219:	74 0d                	je     228 <strchr+0x38>
+    if(*s == c)
+ 21b:	38 d1                	cmp    %dl,%cl
+ 21d:	75 f1                	jne    210 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+ 21f:	5d                   	pop    %ebp
+ 220:	c3                   	ret    
+ 221:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+ 228:	31 c0                	xor    %eax,%eax
+}
+ 22a:	5d                   	pop    %ebp
+ 22b:	c3                   	ret    
+ 22c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000230 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 230:	f3 0f 1e fb          	endbr32 
+ 234:	55                   	push   %ebp
+ 235:	89 e5                	mov    %esp,%ebp
+ 237:	57                   	push   %edi
+ 238:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 239:	31 f6                	xor    %esi,%esi
+{
+ 23b:	53                   	push   %ebx
+ 23c:	89 f3                	mov    %esi,%ebx
+ 23e:	83 ec 1c             	sub    $0x1c,%esp
+ 241:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+ 244:	eb 33                	jmp    279 <gets+0x49>
+ 246:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 24d:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+ 250:	83 ec 04             	sub    $0x4,%esp
+ 253:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ 256:	6a 01                	push   $0x1
+ 258:	50                   	push   %eax
+ 259:	6a 00                	push   $0x0
+ 25b:	e8 2b 01 00 00       	call   38b <read>
+    if(cc < 1)
+ 260:	83 c4 10             	add    $0x10,%esp
+ 263:	85 c0                	test   %eax,%eax
+ 265:	7e 1c                	jle    283 <gets+0x53>
+      break;
+    buf[i++] = c;
+ 267:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ 26b:	83 c7 01             	add    $0x1,%edi
+ 26e:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+ 271:	3c 0a                	cmp    $0xa,%al
+ 273:	74 23                	je     298 <gets+0x68>
+ 275:	3c 0d                	cmp    $0xd,%al
+ 277:	74 1f                	je     298 <gets+0x68>
+  for(i=0; i+1 < max; ){
+ 279:	83 c3 01             	add    $0x1,%ebx
+ 27c:	89 fe                	mov    %edi,%esi
+ 27e:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+ 281:	7c cd                	jl     250 <gets+0x20>
+ 283:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+ 285:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+ 288:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 28b:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 28e:	5b                   	pop    %ebx
+ 28f:	5e                   	pop    %esi
+ 290:	5f                   	pop    %edi
+ 291:	5d                   	pop    %ebp
+ 292:	c3                   	ret    
+ 293:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 297:	90                   	nop
+ 298:	8b 75 08             	mov    0x8(%ebp),%esi
+ 29b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 29e:	01 de                	add    %ebx,%esi
+ 2a0:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+ 2a2:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 2a5:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 2a8:	5b                   	pop    %ebx
+ 2a9:	5e                   	pop    %esi
+ 2aa:	5f                   	pop    %edi
+ 2ab:	5d                   	pop    %ebp
+ 2ac:	c3                   	ret    
+ 2ad:	8d 76 00             	lea    0x0(%esi),%esi
+
+000002b0 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 2b0:	f3 0f 1e fb          	endbr32 
+ 2b4:	55                   	push   %ebp
+ 2b5:	89 e5                	mov    %esp,%ebp
+ 2b7:	56                   	push   %esi
+ 2b8:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 2b9:	83 ec 08             	sub    $0x8,%esp
+ 2bc:	6a 00                	push   $0x0
+ 2be:	ff 75 08             	pushl  0x8(%ebp)
+ 2c1:	e8 ed 00 00 00       	call   3b3 <open>
+  if(fd < 0)
+ 2c6:	83 c4 10             	add    $0x10,%esp
+ 2c9:	85 c0                	test   %eax,%eax
+ 2cb:	78 2b                	js     2f8 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+ 2cd:	83 ec 08             	sub    $0x8,%esp
+ 2d0:	ff 75 0c             	pushl  0xc(%ebp)
+ 2d3:	89 c3                	mov    %eax,%ebx
+ 2d5:	50                   	push   %eax
+ 2d6:	e8 f0 00 00 00       	call   3cb <fstat>
+  close(fd);
+ 2db:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+ 2de:	89 c6                	mov    %eax,%esi
+  close(fd);
+ 2e0:	e8 b6 00 00 00       	call   39b <close>
+  return r;
+ 2e5:	83 c4 10             	add    $0x10,%esp
+}
+ 2e8:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 2eb:	89 f0                	mov    %esi,%eax
+ 2ed:	5b                   	pop    %ebx
+ 2ee:	5e                   	pop    %esi
+ 2ef:	5d                   	pop    %ebp
+ 2f0:	c3                   	ret    
+ 2f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+ 2f8:	be ff ff ff ff       	mov    $0xffffffff,%esi
+ 2fd:	eb e9                	jmp    2e8 <stat+0x38>
+ 2ff:	90                   	nop
+
+00000300 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 300:	f3 0f 1e fb          	endbr32 
+ 304:	55                   	push   %ebp
+ 305:	89 e5                	mov    %esp,%ebp
+ 307:	53                   	push   %ebx
+ 308:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 30b:	0f be 02             	movsbl (%edx),%eax
+ 30e:	8d 48 d0             	lea    -0x30(%eax),%ecx
+ 311:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+ 314:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+ 319:	77 1a                	ja     335 <atoi+0x35>
+ 31b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 31f:	90                   	nop
+    n = n*10 + *s++ - '0';
+ 320:	83 c2 01             	add    $0x1,%edx
+ 323:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+ 326:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+ 32a:	0f be 02             	movsbl (%edx),%eax
+ 32d:	8d 58 d0             	lea    -0x30(%eax),%ebx
+ 330:	80 fb 09             	cmp    $0x9,%bl
+ 333:	76 eb                	jbe    320 <atoi+0x20>
+  return n;
+}
+ 335:	89 c8                	mov    %ecx,%eax
+ 337:	5b                   	pop    %ebx
+ 338:	5d                   	pop    %ebp
+ 339:	c3                   	ret    
+ 33a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000340 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 340:	f3 0f 1e fb          	endbr32 
+ 344:	55                   	push   %ebp
+ 345:	89 e5                	mov    %esp,%ebp
+ 347:	57                   	push   %edi
+ 348:	8b 45 10             	mov    0x10(%ebp),%eax
+ 34b:	8b 55 08             	mov    0x8(%ebp),%edx
+ 34e:	56                   	push   %esi
+ 34f:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 352:	85 c0                	test   %eax,%eax
+ 354:	7e 0f                	jle    365 <memmove+0x25>
+ 356:	01 d0                	add    %edx,%eax
+  dst = vdst;
+ 358:	89 d7                	mov    %edx,%edi
+ 35a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+ 360:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+ 361:	39 f8                	cmp    %edi,%eax
+ 363:	75 fb                	jne    360 <memmove+0x20>
+  return vdst;
+}
+ 365:	5e                   	pop    %esi
+ 366:	89 d0                	mov    %edx,%eax
+ 368:	5f                   	pop    %edi
+ 369:	5d                   	pop    %ebp
+ 36a:	c3                   	ret    
+
+0000036b <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 36b:	b8 01 00 00 00       	mov    $0x1,%eax
+ 370:	cd 40                	int    $0x40
+ 372:	c3                   	ret    
+
+00000373 <exit>:
+SYSCALL(exit)
+ 373:	b8 02 00 00 00       	mov    $0x2,%eax
+ 378:	cd 40                	int    $0x40
+ 37a:	c3                   	ret    
+
+0000037b <wait>:
+SYSCALL(wait)
+ 37b:	b8 03 00 00 00       	mov    $0x3,%eax
+ 380:	cd 40                	int    $0x40
+ 382:	c3                   	ret    
+
+00000383 <pipe>:
+SYSCALL(pipe)
+ 383:	b8 04 00 00 00       	mov    $0x4,%eax
+ 388:	cd 40                	int    $0x40
+ 38a:	c3                   	ret    
+
+0000038b <read>:
+SYSCALL(read)
+ 38b:	b8 05 00 00 00       	mov    $0x5,%eax
+ 390:	cd 40                	int    $0x40
+ 392:	c3                   	ret    
+
+00000393 <write>:
+SYSCALL(write)
+ 393:	b8 10 00 00 00       	mov    $0x10,%eax
+ 398:	cd 40                	int    $0x40
+ 39a:	c3                   	ret    
+
+0000039b <close>:
+SYSCALL(close)
+ 39b:	b8 15 00 00 00       	mov    $0x15,%eax
+ 3a0:	cd 40                	int    $0x40
+ 3a2:	c3                   	ret    
+
+000003a3 <kill>:
+SYSCALL(kill)
+ 3a3:	b8 06 00 00 00       	mov    $0x6,%eax
+ 3a8:	cd 40                	int    $0x40
+ 3aa:	c3                   	ret    
+
+000003ab <exec>:
+SYSCALL(exec)
+ 3ab:	b8 07 00 00 00       	mov    $0x7,%eax
+ 3b0:	cd 40                	int    $0x40
+ 3b2:	c3                   	ret    
+
+000003b3 <open>:
+SYSCALL(open)
+ 3b3:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 3b8:	cd 40                	int    $0x40
+ 3ba:	c3                   	ret    
+
+000003bb <mknod>:
+SYSCALL(mknod)
+ 3bb:	b8 11 00 00 00       	mov    $0x11,%eax
+ 3c0:	cd 40                	int    $0x40
+ 3c2:	c3                   	ret    
+
+000003c3 <unlink>:
+SYSCALL(unlink)
+ 3c3:	b8 12 00 00 00       	mov    $0x12,%eax
+ 3c8:	cd 40                	int    $0x40
+ 3ca:	c3                   	ret    
+
+000003cb <fstat>:
+SYSCALL(fstat)
+ 3cb:	b8 08 00 00 00       	mov    $0x8,%eax
+ 3d0:	cd 40                	int    $0x40
+ 3d2:	c3                   	ret    
+
+000003d3 <link>:
+SYSCALL(link)
+ 3d3:	b8 13 00 00 00       	mov    $0x13,%eax
+ 3d8:	cd 40                	int    $0x40
+ 3da:	c3                   	ret    
+
+000003db <mkdir>:
+SYSCALL(mkdir)
+ 3db:	b8 14 00 00 00       	mov    $0x14,%eax
+ 3e0:	cd 40                	int    $0x40
+ 3e2:	c3                   	ret    
+
+000003e3 <chdir>:
+SYSCALL(chdir)
+ 3e3:	b8 09 00 00 00       	mov    $0x9,%eax
+ 3e8:	cd 40                	int    $0x40
+ 3ea:	c3                   	ret    
+
+000003eb <dup>:
+SYSCALL(dup)
+ 3eb:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 3f0:	cd 40                	int    $0x40
+ 3f2:	c3                   	ret    
+
+000003f3 <getpid>:
+SYSCALL(getpid)
+ 3f3:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 3f8:	cd 40                	int    $0x40
+ 3fa:	c3                   	ret    
+
+000003fb <sbrk>:
+SYSCALL(sbrk)
+ 3fb:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 400:	cd 40                	int    $0x40
+ 402:	c3                   	ret    
+
+00000403 <sleep>:
+SYSCALL(sleep)
+ 403:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 408:	cd 40                	int    $0x40
+ 40a:	c3                   	ret    
+
+0000040b <uptime>:
+SYSCALL(uptime)
+ 40b:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 410:	cd 40                	int    $0x40
+ 412:	c3                   	ret    
+
+00000413 <draw>:
+SYSCALL(draw)
+ 413:	b8 16 00 00 00       	mov    $0x16,%eax
+ 418:	cd 40                	int    $0x40
+ 41a:	c3                   	ret    
+
+0000041b <thread_create>:
+
+SYSCALL(thread_create)
+ 41b:	b8 17 00 00 00       	mov    $0x17,%eax
+ 420:	cd 40                	int    $0x40
+ 422:	c3                   	ret    
+
+00000423 <thread_join>:
+SYSCALL(thread_join)
+ 423:	b8 18 00 00 00       	mov    $0x18,%eax
+ 428:	cd 40                	int    $0x40
+ 42a:	c3                   	ret    
+
+0000042b <thread_exit>:
+SYSCALL(thread_exit)
+ 42b:	b8 19 00 00 00       	mov    $0x19,%eax
+ 430:	cd 40                	int    $0x40
+ 432:	c3                   	ret    
+ 433:	66 90                	xchg   %ax,%ax
+ 435:	66 90                	xchg   %ax,%ax
+ 437:	66 90                	xchg   %ax,%ax
+ 439:	66 90                	xchg   %ax,%ax
+ 43b:	66 90                	xchg   %ax,%ax
+ 43d:	66 90                	xchg   %ax,%ax
+ 43f:	90                   	nop
+
+00000440 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 440:	55                   	push   %ebp
+ 441:	89 e5                	mov    %esp,%ebp
+ 443:	57                   	push   %edi
+ 444:	56                   	push   %esi
+ 445:	53                   	push   %ebx
+ 446:	83 ec 3c             	sub    $0x3c,%esp
+ 449:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+ 44c:	89 d1                	mov    %edx,%ecx
+{
+ 44e:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  if(sgn && xx < 0){
+ 451:	85 d2                	test   %edx,%edx
+ 453:	0f 89 7f 00 00 00    	jns    4d8 <printint+0x98>
+ 459:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
+ 45d:	74 79                	je     4d8 <printint+0x98>
+    neg = 1;
+ 45f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+    x = -xx;
+ 466:	f7 d9                	neg    %ecx
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 468:	31 db                	xor    %ebx,%ebx
+ 46a:	8d 75 d7             	lea    -0x29(%ebp),%esi
+ 46d:	8d 76 00             	lea    0x0(%esi),%esi
+  do{
+    buf[i++] = digits[x % base];
+ 470:	89 c8                	mov    %ecx,%eax
+ 472:	31 d2                	xor    %edx,%edx
+ 474:	89 cf                	mov    %ecx,%edi
+ 476:	f7 75 c4             	divl   -0x3c(%ebp)
+ 479:	0f b6 92 98 08 00 00 	movzbl 0x898(%edx),%edx
+ 480:	89 45 c0             	mov    %eax,-0x40(%ebp)
+ 483:	89 d8                	mov    %ebx,%eax
+ 485:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+ 488:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+    buf[i++] = digits[x % base];
+ 48b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
+  }while((x /= base) != 0);
+ 48e:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
+ 491:	76 dd                	jbe    470 <printint+0x30>
+  if(neg)
+ 493:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+ 496:	85 c9                	test   %ecx,%ecx
+ 498:	74 0c                	je     4a6 <printint+0x66>
+    buf[i++] = '-';
+ 49a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+ 49f:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+ 4a1:	ba 2d 00 00 00       	mov    $0x2d,%edx
+
+  while(--i >= 0)
+ 4a6:	8b 7d b8             	mov    -0x48(%ebp),%edi
+ 4a9:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+ 4ad:	eb 07                	jmp    4b6 <printint+0x76>
+ 4af:	90                   	nop
+ 4b0:	0f b6 13             	movzbl (%ebx),%edx
+ 4b3:	83 eb 01             	sub    $0x1,%ebx
+  write(fd, &c, 1);
+ 4b6:	83 ec 04             	sub    $0x4,%esp
+ 4b9:	88 55 d7             	mov    %dl,-0x29(%ebp)
+ 4bc:	6a 01                	push   $0x1
+ 4be:	56                   	push   %esi
+ 4bf:	57                   	push   %edi
+ 4c0:	e8 ce fe ff ff       	call   393 <write>
+  while(--i >= 0)
+ 4c5:	83 c4 10             	add    $0x10,%esp
+ 4c8:	39 de                	cmp    %ebx,%esi
+ 4ca:	75 e4                	jne    4b0 <printint+0x70>
+    putc(fd, buf[i]);
+}
+ 4cc:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 4cf:	5b                   	pop    %ebx
+ 4d0:	5e                   	pop    %esi
+ 4d1:	5f                   	pop    %edi
+ 4d2:	5d                   	pop    %ebp
+ 4d3:	c3                   	ret    
+ 4d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  neg = 0;
+ 4d8:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+ 4df:	eb 87                	jmp    468 <printint+0x28>
+ 4e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 4e8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 4ef:	90                   	nop
+
+000004f0 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 4f0:	f3 0f 1e fb          	endbr32 
+ 4f4:	55                   	push   %ebp
+ 4f5:	89 e5                	mov    %esp,%ebp
+ 4f7:	57                   	push   %edi
+ 4f8:	56                   	push   %esi
+ 4f9:	53                   	push   %ebx
+ 4fa:	83 ec 2c             	sub    $0x2c,%esp
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 4fd:	8b 75 0c             	mov    0xc(%ebp),%esi
+ 500:	0f b6 1e             	movzbl (%esi),%ebx
+ 503:	84 db                	test   %bl,%bl
+ 505:	0f 84 b4 00 00 00    	je     5bf <printf+0xcf>
+  ap = (uint*)(void*)&fmt + 1;
+ 50b:	8d 45 10             	lea    0x10(%ebp),%eax
+ 50e:	83 c6 01             	add    $0x1,%esi
+  write(fd, &c, 1);
+ 511:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  state = 0;
+ 514:	31 d2                	xor    %edx,%edx
+  ap = (uint*)(void*)&fmt + 1;
+ 516:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 519:	eb 33                	jmp    54e <printf+0x5e>
+ 51b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 51f:	90                   	nop
+ 520:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+ 523:	ba 25 00 00 00       	mov    $0x25,%edx
+      if(c == '%'){
+ 528:	83 f8 25             	cmp    $0x25,%eax
+ 52b:	74 17                	je     544 <printf+0x54>
+  write(fd, &c, 1);
+ 52d:	83 ec 04             	sub    $0x4,%esp
+ 530:	88 5d e7             	mov    %bl,-0x19(%ebp)
+ 533:	6a 01                	push   $0x1
+ 535:	57                   	push   %edi
+ 536:	ff 75 08             	pushl  0x8(%ebp)
+ 539:	e8 55 fe ff ff       	call   393 <write>
+ 53e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+      } else {
+        putc(fd, c);
+ 541:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; fmt[i]; i++){
+ 544:	0f b6 1e             	movzbl (%esi),%ebx
+ 547:	83 c6 01             	add    $0x1,%esi
+ 54a:	84 db                	test   %bl,%bl
+ 54c:	74 71                	je     5bf <printf+0xcf>
+    c = fmt[i] & 0xff;
+ 54e:	0f be cb             	movsbl %bl,%ecx
+ 551:	0f b6 c3             	movzbl %bl,%eax
+    if(state == 0){
+ 554:	85 d2                	test   %edx,%edx
+ 556:	74 c8                	je     520 <printf+0x30>
+      }
+    } else if(state == '%'){
+ 558:	83 fa 25             	cmp    $0x25,%edx
+ 55b:	75 e7                	jne    544 <printf+0x54>
+      if(c == 'd'){
+ 55d:	83 f8 64             	cmp    $0x64,%eax
+ 560:	0f 84 9a 00 00 00    	je     600 <printf+0x110>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+ 566:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
+ 56c:	83 f9 70             	cmp    $0x70,%ecx
+ 56f:	74 5f                	je     5d0 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+ 571:	83 f8 73             	cmp    $0x73,%eax
+ 574:	0f 84 d6 00 00 00    	je     650 <printf+0x160>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 57a:	83 f8 63             	cmp    $0x63,%eax
+ 57d:	0f 84 8d 00 00 00    	je     610 <printf+0x120>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+ 583:	83 f8 25             	cmp    $0x25,%eax
+ 586:	0f 84 b4 00 00 00    	je     640 <printf+0x150>
+  write(fd, &c, 1);
+ 58c:	83 ec 04             	sub    $0x4,%esp
+ 58f:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
+ 593:	6a 01                	push   $0x1
+ 595:	57                   	push   %edi
+ 596:	ff 75 08             	pushl  0x8(%ebp)
+ 599:	e8 f5 fd ff ff       	call   393 <write>
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+ 59e:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 5a1:	83 c4 0c             	add    $0xc,%esp
+ 5a4:	6a 01                	push   $0x1
+ 5a6:	83 c6 01             	add    $0x1,%esi
+ 5a9:	57                   	push   %edi
+ 5aa:	ff 75 08             	pushl  0x8(%ebp)
+ 5ad:	e8 e1 fd ff ff       	call   393 <write>
+  for(i = 0; fmt[i]; i++){
+ 5b2:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
+        putc(fd, c);
+ 5b6:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 5b9:	31 d2                	xor    %edx,%edx
+  for(i = 0; fmt[i]; i++){
+ 5bb:	84 db                	test   %bl,%bl
+ 5bd:	75 8f                	jne    54e <printf+0x5e>
+    }
+  }
+}
+ 5bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 5c2:	5b                   	pop    %ebx
+ 5c3:	5e                   	pop    %esi
+ 5c4:	5f                   	pop    %edi
+ 5c5:	5d                   	pop    %ebp
+ 5c6:	c3                   	ret    
+ 5c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 5ce:	66 90                	xchg   %ax,%ax
+        printint(fd, *ap, 16, 0);
+ 5d0:	83 ec 0c             	sub    $0xc,%esp
+ 5d3:	b9 10 00 00 00       	mov    $0x10,%ecx
+ 5d8:	6a 00                	push   $0x0
+ 5da:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+ 5dd:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5e0:	8b 13                	mov    (%ebx),%edx
+ 5e2:	e8 59 fe ff ff       	call   440 <printint>
+        ap++;
+ 5e7:	89 d8                	mov    %ebx,%eax
+ 5e9:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 5ec:	31 d2                	xor    %edx,%edx
+        ap++;
+ 5ee:	83 c0 04             	add    $0x4,%eax
+ 5f1:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 5f4:	e9 4b ff ff ff       	jmp    544 <printf+0x54>
+ 5f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        printint(fd, *ap, 10, 1);
+ 600:	83 ec 0c             	sub    $0xc,%esp
+ 603:	b9 0a 00 00 00       	mov    $0xa,%ecx
+ 608:	6a 01                	push   $0x1
+ 60a:	eb ce                	jmp    5da <printf+0xea>
+ 60c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        putc(fd, *ap);
+ 610:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+  write(fd, &c, 1);
+ 613:	83 ec 04             	sub    $0x4,%esp
+        putc(fd, *ap);
+ 616:	8b 03                	mov    (%ebx),%eax
+  write(fd, &c, 1);
+ 618:	6a 01                	push   $0x1
+        ap++;
+ 61a:	83 c3 04             	add    $0x4,%ebx
+  write(fd, &c, 1);
+ 61d:	57                   	push   %edi
+ 61e:	ff 75 08             	pushl  0x8(%ebp)
+        putc(fd, *ap);
+ 621:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 624:	e8 6a fd ff ff       	call   393 <write>
+        ap++;
+ 629:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+ 62c:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 62f:	31 d2                	xor    %edx,%edx
+ 631:	e9 0e ff ff ff       	jmp    544 <printf+0x54>
+ 636:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 63d:	8d 76 00             	lea    0x0(%esi),%esi
+        putc(fd, c);
+ 640:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 643:	83 ec 04             	sub    $0x4,%esp
+ 646:	e9 59 ff ff ff       	jmp    5a4 <printf+0xb4>
+ 64b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 64f:	90                   	nop
+        s = (char*)*ap;
+ 650:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 653:	8b 18                	mov    (%eax),%ebx
+        ap++;
+ 655:	83 c0 04             	add    $0x4,%eax
+ 658:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        if(s == 0)
+ 65b:	85 db                	test   %ebx,%ebx
+ 65d:	74 17                	je     676 <printf+0x186>
+        while(*s != 0){
+ 65f:	0f b6 03             	movzbl (%ebx),%eax
+      state = 0;
+ 662:	31 d2                	xor    %edx,%edx
+        while(*s != 0){
+ 664:	84 c0                	test   %al,%al
+ 666:	0f 84 d8 fe ff ff    	je     544 <printf+0x54>
+ 66c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 66f:	89 de                	mov    %ebx,%esi
+ 671:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 674:	eb 1a                	jmp    690 <printf+0x1a0>
+          s = "(null)";
+ 676:	bb 90 08 00 00       	mov    $0x890,%ebx
+        while(*s != 0){
+ 67b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 67e:	b8 28 00 00 00       	mov    $0x28,%eax
+ 683:	89 de                	mov    %ebx,%esi
+ 685:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 688:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 68f:	90                   	nop
+  write(fd, &c, 1);
+ 690:	83 ec 04             	sub    $0x4,%esp
+          s++;
+ 693:	83 c6 01             	add    $0x1,%esi
+ 696:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 699:	6a 01                	push   $0x1
+ 69b:	57                   	push   %edi
+ 69c:	53                   	push   %ebx
+ 69d:	e8 f1 fc ff ff       	call   393 <write>
+        while(*s != 0){
+ 6a2:	0f b6 06             	movzbl (%esi),%eax
+ 6a5:	83 c4 10             	add    $0x10,%esp
+ 6a8:	84 c0                	test   %al,%al
+ 6aa:	75 e4                	jne    690 <printf+0x1a0>
+ 6ac:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+      state = 0;
+ 6af:	31 d2                	xor    %edx,%edx
+ 6b1:	e9 8e fe ff ff       	jmp    544 <printf+0x54>
+ 6b6:	66 90                	xchg   %ax,%ax
+ 6b8:	66 90                	xchg   %ax,%ax
+ 6ba:	66 90                	xchg   %ax,%ax
+ 6bc:	66 90                	xchg   %ax,%ax
+ 6be:	66 90                	xchg   %ax,%ax
+
+000006c0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 6c0:	f3 0f 1e fb          	endbr32 
+ 6c4:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 6c5:	a1 80 0b 00 00       	mov    0xb80,%eax
+{
+ 6ca:	89 e5                	mov    %esp,%ebp
+ 6cc:	57                   	push   %edi
+ 6cd:	56                   	push   %esi
+ 6ce:	53                   	push   %ebx
+ 6cf:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 6d2:	8b 10                	mov    (%eax),%edx
+  bp = (Header*)ap - 1;
+ 6d4:	8d 4b f8             	lea    -0x8(%ebx),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 6d7:	39 c8                	cmp    %ecx,%eax
+ 6d9:	73 15                	jae    6f0 <free+0x30>
+ 6db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 6df:	90                   	nop
+ 6e0:	39 d1                	cmp    %edx,%ecx
+ 6e2:	72 14                	jb     6f8 <free+0x38>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 6e4:	39 d0                	cmp    %edx,%eax
+ 6e6:	73 10                	jae    6f8 <free+0x38>
+{
+ 6e8:	89 d0                	mov    %edx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 6ea:	8b 10                	mov    (%eax),%edx
+ 6ec:	39 c8                	cmp    %ecx,%eax
+ 6ee:	72 f0                	jb     6e0 <free+0x20>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 6f0:	39 d0                	cmp    %edx,%eax
+ 6f2:	72 f4                	jb     6e8 <free+0x28>
+ 6f4:	39 d1                	cmp    %edx,%ecx
+ 6f6:	73 f0                	jae    6e8 <free+0x28>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 6f8:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ 6fb:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
+ 6fe:	39 fa                	cmp    %edi,%edx
+ 700:	74 1e                	je     720 <free+0x60>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+ 702:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 705:	8b 50 04             	mov    0x4(%eax),%edx
+ 708:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 70b:	39 f1                	cmp    %esi,%ecx
+ 70d:	74 28                	je     737 <free+0x77>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+ 70f:	89 08                	mov    %ecx,(%eax)
+  freep = p;
+}
+ 711:	5b                   	pop    %ebx
+  freep = p;
+ 712:	a3 80 0b 00 00       	mov    %eax,0xb80
+}
+ 717:	5e                   	pop    %esi
+ 718:	5f                   	pop    %edi
+ 719:	5d                   	pop    %ebp
+ 71a:	c3                   	ret    
+ 71b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 71f:	90                   	nop
+    bp->s.size += p->s.ptr->s.size;
+ 720:	03 72 04             	add    0x4(%edx),%esi
+ 723:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 726:	8b 10                	mov    (%eax),%edx
+ 728:	8b 12                	mov    (%edx),%edx
+ 72a:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 72d:	8b 50 04             	mov    0x4(%eax),%edx
+ 730:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 733:	39 f1                	cmp    %esi,%ecx
+ 735:	75 d8                	jne    70f <free+0x4f>
+    p->s.size += bp->s.size;
+ 737:	03 53 fc             	add    -0x4(%ebx),%edx
+  freep = p;
+ 73a:	a3 80 0b 00 00       	mov    %eax,0xb80
+    p->s.size += bp->s.size;
+ 73f:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 742:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ 745:	89 10                	mov    %edx,(%eax)
+}
+ 747:	5b                   	pop    %ebx
+ 748:	5e                   	pop    %esi
+ 749:	5f                   	pop    %edi
+ 74a:	5d                   	pop    %ebp
+ 74b:	c3                   	ret    
+ 74c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000750 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 750:	f3 0f 1e fb          	endbr32 
+ 754:	55                   	push   %ebp
+ 755:	89 e5                	mov    %esp,%ebp
+ 757:	57                   	push   %edi
+ 758:	56                   	push   %esi
+ 759:	53                   	push   %ebx
+ 75a:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 75d:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+ 760:	8b 3d 80 0b 00 00    	mov    0xb80,%edi
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 766:	8d 70 07             	lea    0x7(%eax),%esi
+ 769:	c1 ee 03             	shr    $0x3,%esi
+ 76c:	83 c6 01             	add    $0x1,%esi
+  if((prevp = freep) == 0){
+ 76f:	85 ff                	test   %edi,%edi
+ 771:	0f 84 a9 00 00 00    	je     820 <malloc+0xd0>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 777:	8b 07                	mov    (%edi),%eax
+    if(p->s.size >= nunits){
+ 779:	8b 48 04             	mov    0x4(%eax),%ecx
+ 77c:	39 f1                	cmp    %esi,%ecx
+ 77e:	73 6d                	jae    7ed <malloc+0x9d>
+ 780:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+ 786:	bb 00 10 00 00       	mov    $0x1000,%ebx
+ 78b:	0f 43 de             	cmovae %esi,%ebx
+  p = sbrk(nu * sizeof(Header));
+ 78e:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
+ 795:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+ 798:	eb 17                	jmp    7b1 <malloc+0x61>
+ 79a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7a0:	8b 10                	mov    (%eax),%edx
+    if(p->s.size >= nunits){
+ 7a2:	8b 4a 04             	mov    0x4(%edx),%ecx
+ 7a5:	39 f1                	cmp    %esi,%ecx
+ 7a7:	73 4f                	jae    7f8 <malloc+0xa8>
+ 7a9:	8b 3d 80 0b 00 00    	mov    0xb80,%edi
+ 7af:	89 d0                	mov    %edx,%eax
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 7b1:	39 c7                	cmp    %eax,%edi
+ 7b3:	75 eb                	jne    7a0 <malloc+0x50>
+  p = sbrk(nu * sizeof(Header));
+ 7b5:	83 ec 0c             	sub    $0xc,%esp
+ 7b8:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 7bb:	e8 3b fc ff ff       	call   3fb <sbrk>
+  if(p == (char*)-1)
+ 7c0:	83 c4 10             	add    $0x10,%esp
+ 7c3:	83 f8 ff             	cmp    $0xffffffff,%eax
+ 7c6:	74 1b                	je     7e3 <malloc+0x93>
+  hp->s.size = nu;
+ 7c8:	89 58 04             	mov    %ebx,0x4(%eax)
+  free((void*)(hp + 1));
+ 7cb:	83 ec 0c             	sub    $0xc,%esp
+ 7ce:	83 c0 08             	add    $0x8,%eax
+ 7d1:	50                   	push   %eax
+ 7d2:	e8 e9 fe ff ff       	call   6c0 <free>
+  return freep;
+ 7d7:	a1 80 0b 00 00       	mov    0xb80,%eax
+      if((p = morecore(nunits)) == 0)
+ 7dc:	83 c4 10             	add    $0x10,%esp
+ 7df:	85 c0                	test   %eax,%eax
+ 7e1:	75 bd                	jne    7a0 <malloc+0x50>
+        return 0;
+  }
+}
+ 7e3:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return 0;
+ 7e6:	31 c0                	xor    %eax,%eax
+}
+ 7e8:	5b                   	pop    %ebx
+ 7e9:	5e                   	pop    %esi
+ 7ea:	5f                   	pop    %edi
+ 7eb:	5d                   	pop    %ebp
+ 7ec:	c3                   	ret    
+    if(p->s.size >= nunits){
+ 7ed:	89 c2                	mov    %eax,%edx
+ 7ef:	89 f8                	mov    %edi,%eax
+ 7f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+ 7f8:	39 ce                	cmp    %ecx,%esi
+ 7fa:	74 54                	je     850 <malloc+0x100>
+        p->s.size -= nunits;
+ 7fc:	29 f1                	sub    %esi,%ecx
+ 7fe:	89 4a 04             	mov    %ecx,0x4(%edx)
+        p += p->s.size;
+ 801:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
+        p->s.size = nunits;
+ 804:	89 72 04             	mov    %esi,0x4(%edx)
+      freep = prevp;
+ 807:	a3 80 0b 00 00       	mov    %eax,0xb80
+}
+ 80c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return (void*)(p + 1);
+ 80f:	8d 42 08             	lea    0x8(%edx),%eax
+}
+ 812:	5b                   	pop    %ebx
+ 813:	5e                   	pop    %esi
+ 814:	5f                   	pop    %edi
+ 815:	5d                   	pop    %ebp
+ 816:	c3                   	ret    
+ 817:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 81e:	66 90                	xchg   %ax,%ax
+    base.s.ptr = freep = prevp = &base;
+ 820:	c7 05 80 0b 00 00 84 	movl   $0xb84,0xb80
+ 827:	0b 00 00 
+    base.s.size = 0;
+ 82a:	bf 84 0b 00 00       	mov    $0xb84,%edi
+    base.s.ptr = freep = prevp = &base;
+ 82f:	c7 05 84 0b 00 00 84 	movl   $0xb84,0xb84
+ 836:	0b 00 00 
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 839:	89 f8                	mov    %edi,%eax
+    base.s.size = 0;
+ 83b:	c7 05 88 0b 00 00 00 	movl   $0x0,0xb88
+ 842:	00 00 00 
+    if(p->s.size >= nunits){
+ 845:	e9 36 ff ff ff       	jmp    780 <malloc+0x30>
+ 84a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        prevp->s.ptr = p->s.ptr;
+ 850:	8b 0a                	mov    (%edx),%ecx
+ 852:	89 08                	mov    %ecx,(%eax)
+ 854:	eb b1                	jmp    807 <malloc+0xb7>
diff -ruN xv6-public/cat.d copy-xv6/cat.d
--- xv6-public/cat.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/cat.d	2022-09-05 23:26:11.808781093 +0530
@@ -0,0 +1 @@
+cat.o: cat.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/cat.o and copy-xv6/cat.o differ
diff -ruN xv6-public/cat.sym copy-xv6/cat.sym
--- xv6-public/cat.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/cat.sym	2022-09-05 23:26:11.820781093 +0530
@@ -0,0 +1,63 @@
+00000000 .text
+00000858 .rodata
+000008ac .eh_frame
+00000b80 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 cat.c
+00000000 ulib.c
+00000000 printf.c
+00000440 printint
+00000898 digits.1097
+00000000 umalloc.c
+00000b80 freep
+00000b84 base
+00000110 strcpy
+000004f0 printf
+0000042b thread_exit
+00000340 memmove
+000003bb mknod
+00000230 gets
+000003f3 getpid
+00000090 cat
+00000750 malloc
+00000403 sleep
+00000383 pipe
+00000393 write
+000003cb fstat
+000003a3 kill
+000003e3 chdir
+000003ab exec
+0000037b wait
+0000038b read
+000003c3 unlink
+0000036b fork
+000003fb sbrk
+0000040b uptime
+00000b7c __bss_start
+000001d0 memset
+00000000 main
+00000140 strcmp
+000003eb dup
+00000ba0 buf
+000002b0 stat
+00000b7c _edata
+00000da0 _end
+000003d3 link
+00000373 exit
+00000300 atoi
+00000413 draw
+00000190 strlen
+000003b3 open
+000001f0 strchr
+0000041b thread_create
+000003db mkdir
+0000039b close
+00000423 thread_join
+000006c0 free
Binary files xv6-public/computer-networking-a-top-down-approach-8th-edition.pdf and copy-xv6/computer-networking-a-top-down-approach-8th-edition.pdf differ
diff -ruN xv6-public/console.d copy-xv6/console.d
--- xv6-public/console.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/console.d	2022-09-05 23:26:12.812781075 +0530
@@ -0,0 +1,3 @@
+console.o: console.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ traps.h spinlock.h sleeplock.h fs.h file.h memlayout.h mmu.h proc.h \
+ x86.h
Binary files xv6-public/console.o and copy-xv6/console.o differ
Binary files xv6-public/_customArtTest and copy-xv6/_customArtTest differ
diff -ruN xv6-public/defs.h copy-xv6/defs.h
--- xv6-public/defs.h	2022-09-05 23:23:48.536715198 +0530
+++ copy-xv6/defs.h	2022-09-04 00:26:42.612631000 +0530
@@ -120,7 +120,10 @@
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
-
+//thread links
+int             thread_create(void(*fcn)(void*), void* arg, void* stack);
+int             thread_join(void);
+void            thread_exit(void);
 // swtch.S
 void            swtch(struct context**, struct context*);
 
@@ -188,3 +191,5 @@
 
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+
+//user defined threads
Binary files xv6-public/_drawtest and copy-xv6/_drawtest differ
diff -ruN xv6-public/drawtest.asm copy-xv6/drawtest.asm
--- xv6-public/drawtest.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/drawtest.asm	2022-09-05 23:26:12.592781079 +0530
@@ -0,0 +1,1200 @@
+
+_drawtest:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(void)
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	51                   	push   %ecx
+  12:	83 ec 0c             	sub    $0xc,%esp
+	static char buf[2000];
+	printf(1,"draw sys call returns %d\n",draw((void*) buf,2000));
+  15:	68 d0 07 00 00       	push   $0x7d0
+  1a:	68 80 0a 00 00       	push   $0xa80
+  1f:	e8 2f 03 00 00       	call   353 <draw>
+  24:	83 c4 0c             	add    $0xc,%esp
+  27:	50                   	push   %eax
+  28:	68 98 07 00 00       	push   $0x798
+  2d:	6a 01                	push   $0x1
+  2f:	e8 fc 03 00 00       	call   430 <printf>
+
+	printf(1,"%s",buf);
+  34:	83 c4 0c             	add    $0xc,%esp
+  37:	68 80 0a 00 00       	push   $0xa80
+  3c:	68 b2 07 00 00       	push   $0x7b2
+  41:	6a 01                	push   $0x1
+  43:	e8 e8 03 00 00       	call   430 <printf>
+	exit();
+  48:	e8 66 02 00 00       	call   2b3 <exit>
+  4d:	66 90                	xchg   %ax,%ax
+  4f:	90                   	nop
+
+00000050 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+  50:	f3 0f 1e fb          	endbr32 
+  54:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  55:	31 c0                	xor    %eax,%eax
+{
+  57:	89 e5                	mov    %esp,%ebp
+  59:	53                   	push   %ebx
+  5a:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  5d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+  60:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+  64:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+  67:	83 c0 01             	add    $0x1,%eax
+  6a:	84 d2                	test   %dl,%dl
+  6c:	75 f2                	jne    60 <strcpy+0x10>
+    ;
+  return os;
+}
+  6e:	89 c8                	mov    %ecx,%eax
+  70:	5b                   	pop    %ebx
+  71:	5d                   	pop    %ebp
+  72:	c3                   	ret    
+  73:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000080 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  80:	f3 0f 1e fb          	endbr32 
+  84:	55                   	push   %ebp
+  85:	89 e5                	mov    %esp,%ebp
+  87:	53                   	push   %ebx
+  88:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  8b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+  8e:	0f b6 01             	movzbl (%ecx),%eax
+  91:	0f b6 1a             	movzbl (%edx),%ebx
+  94:	84 c0                	test   %al,%al
+  96:	75 19                	jne    b1 <strcmp+0x31>
+  98:	eb 26                	jmp    c0 <strcmp+0x40>
+  9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  a0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+  a4:	83 c1 01             	add    $0x1,%ecx
+  a7:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+  aa:	0f b6 1a             	movzbl (%edx),%ebx
+  ad:	84 c0                	test   %al,%al
+  af:	74 0f                	je     c0 <strcmp+0x40>
+  b1:	38 d8                	cmp    %bl,%al
+  b3:	74 eb                	je     a0 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+  b5:	29 d8                	sub    %ebx,%eax
+}
+  b7:	5b                   	pop    %ebx
+  b8:	5d                   	pop    %ebp
+  b9:	c3                   	ret    
+  ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  c0:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+  c2:	29 d8                	sub    %ebx,%eax
+}
+  c4:	5b                   	pop    %ebx
+  c5:	5d                   	pop    %ebp
+  c6:	c3                   	ret    
+  c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  ce:	66 90                	xchg   %ax,%ax
+
+000000d0 <strlen>:
+
+uint
+strlen(const char *s)
+{
+  d0:	f3 0f 1e fb          	endbr32 
+  d4:	55                   	push   %ebp
+  d5:	89 e5                	mov    %esp,%ebp
+  d7:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+  da:	80 3a 00             	cmpb   $0x0,(%edx)
+  dd:	74 21                	je     100 <strlen+0x30>
+  df:	31 c0                	xor    %eax,%eax
+  e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  e8:	83 c0 01             	add    $0x1,%eax
+  eb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+  ef:	89 c1                	mov    %eax,%ecx
+  f1:	75 f5                	jne    e8 <strlen+0x18>
+    ;
+  return n;
+}
+  f3:	89 c8                	mov    %ecx,%eax
+  f5:	5d                   	pop    %ebp
+  f6:	c3                   	ret    
+  f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  fe:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+ 100:	31 c9                	xor    %ecx,%ecx
+}
+ 102:	5d                   	pop    %ebp
+ 103:	89 c8                	mov    %ecx,%eax
+ 105:	c3                   	ret    
+ 106:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 10d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000110 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 110:	f3 0f 1e fb          	endbr32 
+ 114:	55                   	push   %ebp
+ 115:	89 e5                	mov    %esp,%ebp
+ 117:	57                   	push   %edi
+ 118:	8b 55 08             	mov    0x8(%ebp),%edx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+ 11b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 11e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 121:	89 d7                	mov    %edx,%edi
+ 123:	fc                   	cld    
+ 124:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+ 126:	89 d0                	mov    %edx,%eax
+ 128:	5f                   	pop    %edi
+ 129:	5d                   	pop    %ebp
+ 12a:	c3                   	ret    
+ 12b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 12f:	90                   	nop
+
+00000130 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 130:	f3 0f 1e fb          	endbr32 
+ 134:	55                   	push   %ebp
+ 135:	89 e5                	mov    %esp,%ebp
+ 137:	8b 45 08             	mov    0x8(%ebp),%eax
+ 13a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+ 13e:	0f b6 10             	movzbl (%eax),%edx
+ 141:	84 d2                	test   %dl,%dl
+ 143:	75 16                	jne    15b <strchr+0x2b>
+ 145:	eb 21                	jmp    168 <strchr+0x38>
+ 147:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 14e:	66 90                	xchg   %ax,%ax
+ 150:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+ 154:	83 c0 01             	add    $0x1,%eax
+ 157:	84 d2                	test   %dl,%dl
+ 159:	74 0d                	je     168 <strchr+0x38>
+    if(*s == c)
+ 15b:	38 d1                	cmp    %dl,%cl
+ 15d:	75 f1                	jne    150 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+ 15f:	5d                   	pop    %ebp
+ 160:	c3                   	ret    
+ 161:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+ 168:	31 c0                	xor    %eax,%eax
+}
+ 16a:	5d                   	pop    %ebp
+ 16b:	c3                   	ret    
+ 16c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000170 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 170:	f3 0f 1e fb          	endbr32 
+ 174:	55                   	push   %ebp
+ 175:	89 e5                	mov    %esp,%ebp
+ 177:	57                   	push   %edi
+ 178:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 179:	31 f6                	xor    %esi,%esi
+{
+ 17b:	53                   	push   %ebx
+ 17c:	89 f3                	mov    %esi,%ebx
+ 17e:	83 ec 1c             	sub    $0x1c,%esp
+ 181:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+ 184:	eb 33                	jmp    1b9 <gets+0x49>
+ 186:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 18d:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+ 190:	83 ec 04             	sub    $0x4,%esp
+ 193:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ 196:	6a 01                	push   $0x1
+ 198:	50                   	push   %eax
+ 199:	6a 00                	push   $0x0
+ 19b:	e8 2b 01 00 00       	call   2cb <read>
+    if(cc < 1)
+ 1a0:	83 c4 10             	add    $0x10,%esp
+ 1a3:	85 c0                	test   %eax,%eax
+ 1a5:	7e 1c                	jle    1c3 <gets+0x53>
+      break;
+    buf[i++] = c;
+ 1a7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ 1ab:	83 c7 01             	add    $0x1,%edi
+ 1ae:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+ 1b1:	3c 0a                	cmp    $0xa,%al
+ 1b3:	74 23                	je     1d8 <gets+0x68>
+ 1b5:	3c 0d                	cmp    $0xd,%al
+ 1b7:	74 1f                	je     1d8 <gets+0x68>
+  for(i=0; i+1 < max; ){
+ 1b9:	83 c3 01             	add    $0x1,%ebx
+ 1bc:	89 fe                	mov    %edi,%esi
+ 1be:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+ 1c1:	7c cd                	jl     190 <gets+0x20>
+ 1c3:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+ 1c5:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+ 1c8:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 1cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 1ce:	5b                   	pop    %ebx
+ 1cf:	5e                   	pop    %esi
+ 1d0:	5f                   	pop    %edi
+ 1d1:	5d                   	pop    %ebp
+ 1d2:	c3                   	ret    
+ 1d3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 1d7:	90                   	nop
+ 1d8:	8b 75 08             	mov    0x8(%ebp),%esi
+ 1db:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1de:	01 de                	add    %ebx,%esi
+ 1e0:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+ 1e2:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 1e5:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 1e8:	5b                   	pop    %ebx
+ 1e9:	5e                   	pop    %esi
+ 1ea:	5f                   	pop    %edi
+ 1eb:	5d                   	pop    %ebp
+ 1ec:	c3                   	ret    
+ 1ed:	8d 76 00             	lea    0x0(%esi),%esi
+
+000001f0 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 1f0:	f3 0f 1e fb          	endbr32 
+ 1f4:	55                   	push   %ebp
+ 1f5:	89 e5                	mov    %esp,%ebp
+ 1f7:	56                   	push   %esi
+ 1f8:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 1f9:	83 ec 08             	sub    $0x8,%esp
+ 1fc:	6a 00                	push   $0x0
+ 1fe:	ff 75 08             	pushl  0x8(%ebp)
+ 201:	e8 ed 00 00 00       	call   2f3 <open>
+  if(fd < 0)
+ 206:	83 c4 10             	add    $0x10,%esp
+ 209:	85 c0                	test   %eax,%eax
+ 20b:	78 2b                	js     238 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+ 20d:	83 ec 08             	sub    $0x8,%esp
+ 210:	ff 75 0c             	pushl  0xc(%ebp)
+ 213:	89 c3                	mov    %eax,%ebx
+ 215:	50                   	push   %eax
+ 216:	e8 f0 00 00 00       	call   30b <fstat>
+  close(fd);
+ 21b:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+ 21e:	89 c6                	mov    %eax,%esi
+  close(fd);
+ 220:	e8 b6 00 00 00       	call   2db <close>
+  return r;
+ 225:	83 c4 10             	add    $0x10,%esp
+}
+ 228:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 22b:	89 f0                	mov    %esi,%eax
+ 22d:	5b                   	pop    %ebx
+ 22e:	5e                   	pop    %esi
+ 22f:	5d                   	pop    %ebp
+ 230:	c3                   	ret    
+ 231:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+ 238:	be ff ff ff ff       	mov    $0xffffffff,%esi
+ 23d:	eb e9                	jmp    228 <stat+0x38>
+ 23f:	90                   	nop
+
+00000240 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 240:	f3 0f 1e fb          	endbr32 
+ 244:	55                   	push   %ebp
+ 245:	89 e5                	mov    %esp,%ebp
+ 247:	53                   	push   %ebx
+ 248:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 24b:	0f be 02             	movsbl (%edx),%eax
+ 24e:	8d 48 d0             	lea    -0x30(%eax),%ecx
+ 251:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+ 254:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+ 259:	77 1a                	ja     275 <atoi+0x35>
+ 25b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 25f:	90                   	nop
+    n = n*10 + *s++ - '0';
+ 260:	83 c2 01             	add    $0x1,%edx
+ 263:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+ 266:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+ 26a:	0f be 02             	movsbl (%edx),%eax
+ 26d:	8d 58 d0             	lea    -0x30(%eax),%ebx
+ 270:	80 fb 09             	cmp    $0x9,%bl
+ 273:	76 eb                	jbe    260 <atoi+0x20>
+  return n;
+}
+ 275:	89 c8                	mov    %ecx,%eax
+ 277:	5b                   	pop    %ebx
+ 278:	5d                   	pop    %ebp
+ 279:	c3                   	ret    
+ 27a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000280 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 280:	f3 0f 1e fb          	endbr32 
+ 284:	55                   	push   %ebp
+ 285:	89 e5                	mov    %esp,%ebp
+ 287:	57                   	push   %edi
+ 288:	8b 45 10             	mov    0x10(%ebp),%eax
+ 28b:	8b 55 08             	mov    0x8(%ebp),%edx
+ 28e:	56                   	push   %esi
+ 28f:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 292:	85 c0                	test   %eax,%eax
+ 294:	7e 0f                	jle    2a5 <memmove+0x25>
+ 296:	01 d0                	add    %edx,%eax
+  dst = vdst;
+ 298:	89 d7                	mov    %edx,%edi
+ 29a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+ 2a0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+ 2a1:	39 f8                	cmp    %edi,%eax
+ 2a3:	75 fb                	jne    2a0 <memmove+0x20>
+  return vdst;
+}
+ 2a5:	5e                   	pop    %esi
+ 2a6:	89 d0                	mov    %edx,%eax
+ 2a8:	5f                   	pop    %edi
+ 2a9:	5d                   	pop    %ebp
+ 2aa:	c3                   	ret    
+
+000002ab <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 2ab:	b8 01 00 00 00       	mov    $0x1,%eax
+ 2b0:	cd 40                	int    $0x40
+ 2b2:	c3                   	ret    
+
+000002b3 <exit>:
+SYSCALL(exit)
+ 2b3:	b8 02 00 00 00       	mov    $0x2,%eax
+ 2b8:	cd 40                	int    $0x40
+ 2ba:	c3                   	ret    
+
+000002bb <wait>:
+SYSCALL(wait)
+ 2bb:	b8 03 00 00 00       	mov    $0x3,%eax
+ 2c0:	cd 40                	int    $0x40
+ 2c2:	c3                   	ret    
+
+000002c3 <pipe>:
+SYSCALL(pipe)
+ 2c3:	b8 04 00 00 00       	mov    $0x4,%eax
+ 2c8:	cd 40                	int    $0x40
+ 2ca:	c3                   	ret    
+
+000002cb <read>:
+SYSCALL(read)
+ 2cb:	b8 05 00 00 00       	mov    $0x5,%eax
+ 2d0:	cd 40                	int    $0x40
+ 2d2:	c3                   	ret    
+
+000002d3 <write>:
+SYSCALL(write)
+ 2d3:	b8 10 00 00 00       	mov    $0x10,%eax
+ 2d8:	cd 40                	int    $0x40
+ 2da:	c3                   	ret    
+
+000002db <close>:
+SYSCALL(close)
+ 2db:	b8 15 00 00 00       	mov    $0x15,%eax
+ 2e0:	cd 40                	int    $0x40
+ 2e2:	c3                   	ret    
+
+000002e3 <kill>:
+SYSCALL(kill)
+ 2e3:	b8 06 00 00 00       	mov    $0x6,%eax
+ 2e8:	cd 40                	int    $0x40
+ 2ea:	c3                   	ret    
+
+000002eb <exec>:
+SYSCALL(exec)
+ 2eb:	b8 07 00 00 00       	mov    $0x7,%eax
+ 2f0:	cd 40                	int    $0x40
+ 2f2:	c3                   	ret    
+
+000002f3 <open>:
+SYSCALL(open)
+ 2f3:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 2f8:	cd 40                	int    $0x40
+ 2fa:	c3                   	ret    
+
+000002fb <mknod>:
+SYSCALL(mknod)
+ 2fb:	b8 11 00 00 00       	mov    $0x11,%eax
+ 300:	cd 40                	int    $0x40
+ 302:	c3                   	ret    
+
+00000303 <unlink>:
+SYSCALL(unlink)
+ 303:	b8 12 00 00 00       	mov    $0x12,%eax
+ 308:	cd 40                	int    $0x40
+ 30a:	c3                   	ret    
+
+0000030b <fstat>:
+SYSCALL(fstat)
+ 30b:	b8 08 00 00 00       	mov    $0x8,%eax
+ 310:	cd 40                	int    $0x40
+ 312:	c3                   	ret    
+
+00000313 <link>:
+SYSCALL(link)
+ 313:	b8 13 00 00 00       	mov    $0x13,%eax
+ 318:	cd 40                	int    $0x40
+ 31a:	c3                   	ret    
+
+0000031b <mkdir>:
+SYSCALL(mkdir)
+ 31b:	b8 14 00 00 00       	mov    $0x14,%eax
+ 320:	cd 40                	int    $0x40
+ 322:	c3                   	ret    
+
+00000323 <chdir>:
+SYSCALL(chdir)
+ 323:	b8 09 00 00 00       	mov    $0x9,%eax
+ 328:	cd 40                	int    $0x40
+ 32a:	c3                   	ret    
+
+0000032b <dup>:
+SYSCALL(dup)
+ 32b:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 330:	cd 40                	int    $0x40
+ 332:	c3                   	ret    
+
+00000333 <getpid>:
+SYSCALL(getpid)
+ 333:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 338:	cd 40                	int    $0x40
+ 33a:	c3                   	ret    
+
+0000033b <sbrk>:
+SYSCALL(sbrk)
+ 33b:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 340:	cd 40                	int    $0x40
+ 342:	c3                   	ret    
+
+00000343 <sleep>:
+SYSCALL(sleep)
+ 343:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 348:	cd 40                	int    $0x40
+ 34a:	c3                   	ret    
+
+0000034b <uptime>:
+SYSCALL(uptime)
+ 34b:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 350:	cd 40                	int    $0x40
+ 352:	c3                   	ret    
+
+00000353 <draw>:
+SYSCALL(draw)
+ 353:	b8 16 00 00 00       	mov    $0x16,%eax
+ 358:	cd 40                	int    $0x40
+ 35a:	c3                   	ret    
+
+0000035b <thread_create>:
+
+SYSCALL(thread_create)
+ 35b:	b8 17 00 00 00       	mov    $0x17,%eax
+ 360:	cd 40                	int    $0x40
+ 362:	c3                   	ret    
+
+00000363 <thread_join>:
+SYSCALL(thread_join)
+ 363:	b8 18 00 00 00       	mov    $0x18,%eax
+ 368:	cd 40                	int    $0x40
+ 36a:	c3                   	ret    
+
+0000036b <thread_exit>:
+SYSCALL(thread_exit)
+ 36b:	b8 19 00 00 00       	mov    $0x19,%eax
+ 370:	cd 40                	int    $0x40
+ 372:	c3                   	ret    
+ 373:	66 90                	xchg   %ax,%ax
+ 375:	66 90                	xchg   %ax,%ax
+ 377:	66 90                	xchg   %ax,%ax
+ 379:	66 90                	xchg   %ax,%ax
+ 37b:	66 90                	xchg   %ax,%ax
+ 37d:	66 90                	xchg   %ax,%ax
+ 37f:	90                   	nop
+
+00000380 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 380:	55                   	push   %ebp
+ 381:	89 e5                	mov    %esp,%ebp
+ 383:	57                   	push   %edi
+ 384:	56                   	push   %esi
+ 385:	53                   	push   %ebx
+ 386:	83 ec 3c             	sub    $0x3c,%esp
+ 389:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+ 38c:	89 d1                	mov    %edx,%ecx
+{
+ 38e:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  if(sgn && xx < 0){
+ 391:	85 d2                	test   %edx,%edx
+ 393:	0f 89 7f 00 00 00    	jns    418 <printint+0x98>
+ 399:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
+ 39d:	74 79                	je     418 <printint+0x98>
+    neg = 1;
+ 39f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+    x = -xx;
+ 3a6:	f7 d9                	neg    %ecx
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 3a8:	31 db                	xor    %ebx,%ebx
+ 3aa:	8d 75 d7             	lea    -0x29(%ebp),%esi
+ 3ad:	8d 76 00             	lea    0x0(%esi),%esi
+  do{
+    buf[i++] = digits[x % base];
+ 3b0:	89 c8                	mov    %ecx,%eax
+ 3b2:	31 d2                	xor    %edx,%edx
+ 3b4:	89 cf                	mov    %ecx,%edi
+ 3b6:	f7 75 c4             	divl   -0x3c(%ebp)
+ 3b9:	0f b6 92 bc 07 00 00 	movzbl 0x7bc(%edx),%edx
+ 3c0:	89 45 c0             	mov    %eax,-0x40(%ebp)
+ 3c3:	89 d8                	mov    %ebx,%eax
+ 3c5:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+ 3c8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+    buf[i++] = digits[x % base];
+ 3cb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
+  }while((x /= base) != 0);
+ 3ce:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
+ 3d1:	76 dd                	jbe    3b0 <printint+0x30>
+  if(neg)
+ 3d3:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+ 3d6:	85 c9                	test   %ecx,%ecx
+ 3d8:	74 0c                	je     3e6 <printint+0x66>
+    buf[i++] = '-';
+ 3da:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+ 3df:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+ 3e1:	ba 2d 00 00 00       	mov    $0x2d,%edx
+
+  while(--i >= 0)
+ 3e6:	8b 7d b8             	mov    -0x48(%ebp),%edi
+ 3e9:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+ 3ed:	eb 07                	jmp    3f6 <printint+0x76>
+ 3ef:	90                   	nop
+ 3f0:	0f b6 13             	movzbl (%ebx),%edx
+ 3f3:	83 eb 01             	sub    $0x1,%ebx
+  write(fd, &c, 1);
+ 3f6:	83 ec 04             	sub    $0x4,%esp
+ 3f9:	88 55 d7             	mov    %dl,-0x29(%ebp)
+ 3fc:	6a 01                	push   $0x1
+ 3fe:	56                   	push   %esi
+ 3ff:	57                   	push   %edi
+ 400:	e8 ce fe ff ff       	call   2d3 <write>
+  while(--i >= 0)
+ 405:	83 c4 10             	add    $0x10,%esp
+ 408:	39 de                	cmp    %ebx,%esi
+ 40a:	75 e4                	jne    3f0 <printint+0x70>
+    putc(fd, buf[i]);
+}
+ 40c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 40f:	5b                   	pop    %ebx
+ 410:	5e                   	pop    %esi
+ 411:	5f                   	pop    %edi
+ 412:	5d                   	pop    %ebp
+ 413:	c3                   	ret    
+ 414:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  neg = 0;
+ 418:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+ 41f:	eb 87                	jmp    3a8 <printint+0x28>
+ 421:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 428:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 42f:	90                   	nop
+
+00000430 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 430:	f3 0f 1e fb          	endbr32 
+ 434:	55                   	push   %ebp
+ 435:	89 e5                	mov    %esp,%ebp
+ 437:	57                   	push   %edi
+ 438:	56                   	push   %esi
+ 439:	53                   	push   %ebx
+ 43a:	83 ec 2c             	sub    $0x2c,%esp
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 43d:	8b 75 0c             	mov    0xc(%ebp),%esi
+ 440:	0f b6 1e             	movzbl (%esi),%ebx
+ 443:	84 db                	test   %bl,%bl
+ 445:	0f 84 b4 00 00 00    	je     4ff <printf+0xcf>
+  ap = (uint*)(void*)&fmt + 1;
+ 44b:	8d 45 10             	lea    0x10(%ebp),%eax
+ 44e:	83 c6 01             	add    $0x1,%esi
+  write(fd, &c, 1);
+ 451:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  state = 0;
+ 454:	31 d2                	xor    %edx,%edx
+  ap = (uint*)(void*)&fmt + 1;
+ 456:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 459:	eb 33                	jmp    48e <printf+0x5e>
+ 45b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 45f:	90                   	nop
+ 460:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+ 463:	ba 25 00 00 00       	mov    $0x25,%edx
+      if(c == '%'){
+ 468:	83 f8 25             	cmp    $0x25,%eax
+ 46b:	74 17                	je     484 <printf+0x54>
+  write(fd, &c, 1);
+ 46d:	83 ec 04             	sub    $0x4,%esp
+ 470:	88 5d e7             	mov    %bl,-0x19(%ebp)
+ 473:	6a 01                	push   $0x1
+ 475:	57                   	push   %edi
+ 476:	ff 75 08             	pushl  0x8(%ebp)
+ 479:	e8 55 fe ff ff       	call   2d3 <write>
+ 47e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+      } else {
+        putc(fd, c);
+ 481:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; fmt[i]; i++){
+ 484:	0f b6 1e             	movzbl (%esi),%ebx
+ 487:	83 c6 01             	add    $0x1,%esi
+ 48a:	84 db                	test   %bl,%bl
+ 48c:	74 71                	je     4ff <printf+0xcf>
+    c = fmt[i] & 0xff;
+ 48e:	0f be cb             	movsbl %bl,%ecx
+ 491:	0f b6 c3             	movzbl %bl,%eax
+    if(state == 0){
+ 494:	85 d2                	test   %edx,%edx
+ 496:	74 c8                	je     460 <printf+0x30>
+      }
+    } else if(state == '%'){
+ 498:	83 fa 25             	cmp    $0x25,%edx
+ 49b:	75 e7                	jne    484 <printf+0x54>
+      if(c == 'd'){
+ 49d:	83 f8 64             	cmp    $0x64,%eax
+ 4a0:	0f 84 9a 00 00 00    	je     540 <printf+0x110>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+ 4a6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
+ 4ac:	83 f9 70             	cmp    $0x70,%ecx
+ 4af:	74 5f                	je     510 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+ 4b1:	83 f8 73             	cmp    $0x73,%eax
+ 4b4:	0f 84 d6 00 00 00    	je     590 <printf+0x160>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 4ba:	83 f8 63             	cmp    $0x63,%eax
+ 4bd:	0f 84 8d 00 00 00    	je     550 <printf+0x120>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+ 4c3:	83 f8 25             	cmp    $0x25,%eax
+ 4c6:	0f 84 b4 00 00 00    	je     580 <printf+0x150>
+  write(fd, &c, 1);
+ 4cc:	83 ec 04             	sub    $0x4,%esp
+ 4cf:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
+ 4d3:	6a 01                	push   $0x1
+ 4d5:	57                   	push   %edi
+ 4d6:	ff 75 08             	pushl  0x8(%ebp)
+ 4d9:	e8 f5 fd ff ff       	call   2d3 <write>
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+ 4de:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 4e1:	83 c4 0c             	add    $0xc,%esp
+ 4e4:	6a 01                	push   $0x1
+ 4e6:	83 c6 01             	add    $0x1,%esi
+ 4e9:	57                   	push   %edi
+ 4ea:	ff 75 08             	pushl  0x8(%ebp)
+ 4ed:	e8 e1 fd ff ff       	call   2d3 <write>
+  for(i = 0; fmt[i]; i++){
+ 4f2:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
+        putc(fd, c);
+ 4f6:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 4f9:	31 d2                	xor    %edx,%edx
+  for(i = 0; fmt[i]; i++){
+ 4fb:	84 db                	test   %bl,%bl
+ 4fd:	75 8f                	jne    48e <printf+0x5e>
+    }
+  }
+}
+ 4ff:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 502:	5b                   	pop    %ebx
+ 503:	5e                   	pop    %esi
+ 504:	5f                   	pop    %edi
+ 505:	5d                   	pop    %ebp
+ 506:	c3                   	ret    
+ 507:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 50e:	66 90                	xchg   %ax,%ax
+        printint(fd, *ap, 16, 0);
+ 510:	83 ec 0c             	sub    $0xc,%esp
+ 513:	b9 10 00 00 00       	mov    $0x10,%ecx
+ 518:	6a 00                	push   $0x0
+ 51a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+ 51d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 520:	8b 13                	mov    (%ebx),%edx
+ 522:	e8 59 fe ff ff       	call   380 <printint>
+        ap++;
+ 527:	89 d8                	mov    %ebx,%eax
+ 529:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 52c:	31 d2                	xor    %edx,%edx
+        ap++;
+ 52e:	83 c0 04             	add    $0x4,%eax
+ 531:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 534:	e9 4b ff ff ff       	jmp    484 <printf+0x54>
+ 539:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        printint(fd, *ap, 10, 1);
+ 540:	83 ec 0c             	sub    $0xc,%esp
+ 543:	b9 0a 00 00 00       	mov    $0xa,%ecx
+ 548:	6a 01                	push   $0x1
+ 54a:	eb ce                	jmp    51a <printf+0xea>
+ 54c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        putc(fd, *ap);
+ 550:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+  write(fd, &c, 1);
+ 553:	83 ec 04             	sub    $0x4,%esp
+        putc(fd, *ap);
+ 556:	8b 03                	mov    (%ebx),%eax
+  write(fd, &c, 1);
+ 558:	6a 01                	push   $0x1
+        ap++;
+ 55a:	83 c3 04             	add    $0x4,%ebx
+  write(fd, &c, 1);
+ 55d:	57                   	push   %edi
+ 55e:	ff 75 08             	pushl  0x8(%ebp)
+        putc(fd, *ap);
+ 561:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 564:	e8 6a fd ff ff       	call   2d3 <write>
+        ap++;
+ 569:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+ 56c:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 56f:	31 d2                	xor    %edx,%edx
+ 571:	e9 0e ff ff ff       	jmp    484 <printf+0x54>
+ 576:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 57d:	8d 76 00             	lea    0x0(%esi),%esi
+        putc(fd, c);
+ 580:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 583:	83 ec 04             	sub    $0x4,%esp
+ 586:	e9 59 ff ff ff       	jmp    4e4 <printf+0xb4>
+ 58b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 58f:	90                   	nop
+        s = (char*)*ap;
+ 590:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 593:	8b 18                	mov    (%eax),%ebx
+        ap++;
+ 595:	83 c0 04             	add    $0x4,%eax
+ 598:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        if(s == 0)
+ 59b:	85 db                	test   %ebx,%ebx
+ 59d:	74 17                	je     5b6 <printf+0x186>
+        while(*s != 0){
+ 59f:	0f b6 03             	movzbl (%ebx),%eax
+      state = 0;
+ 5a2:	31 d2                	xor    %edx,%edx
+        while(*s != 0){
+ 5a4:	84 c0                	test   %al,%al
+ 5a6:	0f 84 d8 fe ff ff    	je     484 <printf+0x54>
+ 5ac:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 5af:	89 de                	mov    %ebx,%esi
+ 5b1:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 5b4:	eb 1a                	jmp    5d0 <printf+0x1a0>
+          s = "(null)";
+ 5b6:	bb b5 07 00 00       	mov    $0x7b5,%ebx
+        while(*s != 0){
+ 5bb:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 5be:	b8 28 00 00 00       	mov    $0x28,%eax
+ 5c3:	89 de                	mov    %ebx,%esi
+ 5c5:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 5c8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 5cf:	90                   	nop
+  write(fd, &c, 1);
+ 5d0:	83 ec 04             	sub    $0x4,%esp
+          s++;
+ 5d3:	83 c6 01             	add    $0x1,%esi
+ 5d6:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 5d9:	6a 01                	push   $0x1
+ 5db:	57                   	push   %edi
+ 5dc:	53                   	push   %ebx
+ 5dd:	e8 f1 fc ff ff       	call   2d3 <write>
+        while(*s != 0){
+ 5e2:	0f b6 06             	movzbl (%esi),%eax
+ 5e5:	83 c4 10             	add    $0x10,%esp
+ 5e8:	84 c0                	test   %al,%al
+ 5ea:	75 e4                	jne    5d0 <printf+0x1a0>
+ 5ec:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+      state = 0;
+ 5ef:	31 d2                	xor    %edx,%edx
+ 5f1:	e9 8e fe ff ff       	jmp    484 <printf+0x54>
+ 5f6:	66 90                	xchg   %ax,%ax
+ 5f8:	66 90                	xchg   %ax,%ax
+ 5fa:	66 90                	xchg   %ax,%ax
+ 5fc:	66 90                	xchg   %ax,%ax
+ 5fe:	66 90                	xchg   %ax,%ax
+
+00000600 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 600:	f3 0f 1e fb          	endbr32 
+ 604:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 605:	a1 50 12 00 00       	mov    0x1250,%eax
+{
+ 60a:	89 e5                	mov    %esp,%ebp
+ 60c:	57                   	push   %edi
+ 60d:	56                   	push   %esi
+ 60e:	53                   	push   %ebx
+ 60f:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 612:	8b 10                	mov    (%eax),%edx
+  bp = (Header*)ap - 1;
+ 614:	8d 4b f8             	lea    -0x8(%ebx),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 617:	39 c8                	cmp    %ecx,%eax
+ 619:	73 15                	jae    630 <free+0x30>
+ 61b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 61f:	90                   	nop
+ 620:	39 d1                	cmp    %edx,%ecx
+ 622:	72 14                	jb     638 <free+0x38>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 624:	39 d0                	cmp    %edx,%eax
+ 626:	73 10                	jae    638 <free+0x38>
+{
+ 628:	89 d0                	mov    %edx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 62a:	8b 10                	mov    (%eax),%edx
+ 62c:	39 c8                	cmp    %ecx,%eax
+ 62e:	72 f0                	jb     620 <free+0x20>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 630:	39 d0                	cmp    %edx,%eax
+ 632:	72 f4                	jb     628 <free+0x28>
+ 634:	39 d1                	cmp    %edx,%ecx
+ 636:	73 f0                	jae    628 <free+0x28>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 638:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ 63b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
+ 63e:	39 fa                	cmp    %edi,%edx
+ 640:	74 1e                	je     660 <free+0x60>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+ 642:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 645:	8b 50 04             	mov    0x4(%eax),%edx
+ 648:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 64b:	39 f1                	cmp    %esi,%ecx
+ 64d:	74 28                	je     677 <free+0x77>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+ 64f:	89 08                	mov    %ecx,(%eax)
+  freep = p;
+}
+ 651:	5b                   	pop    %ebx
+  freep = p;
+ 652:	a3 50 12 00 00       	mov    %eax,0x1250
+}
+ 657:	5e                   	pop    %esi
+ 658:	5f                   	pop    %edi
+ 659:	5d                   	pop    %ebp
+ 65a:	c3                   	ret    
+ 65b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 65f:	90                   	nop
+    bp->s.size += p->s.ptr->s.size;
+ 660:	03 72 04             	add    0x4(%edx),%esi
+ 663:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 666:	8b 10                	mov    (%eax),%edx
+ 668:	8b 12                	mov    (%edx),%edx
+ 66a:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 66d:	8b 50 04             	mov    0x4(%eax),%edx
+ 670:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 673:	39 f1                	cmp    %esi,%ecx
+ 675:	75 d8                	jne    64f <free+0x4f>
+    p->s.size += bp->s.size;
+ 677:	03 53 fc             	add    -0x4(%ebx),%edx
+  freep = p;
+ 67a:	a3 50 12 00 00       	mov    %eax,0x1250
+    p->s.size += bp->s.size;
+ 67f:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 682:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ 685:	89 10                	mov    %edx,(%eax)
+}
+ 687:	5b                   	pop    %ebx
+ 688:	5e                   	pop    %esi
+ 689:	5f                   	pop    %edi
+ 68a:	5d                   	pop    %ebp
+ 68b:	c3                   	ret    
+ 68c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000690 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 690:	f3 0f 1e fb          	endbr32 
+ 694:	55                   	push   %ebp
+ 695:	89 e5                	mov    %esp,%ebp
+ 697:	57                   	push   %edi
+ 698:	56                   	push   %esi
+ 699:	53                   	push   %ebx
+ 69a:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 69d:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+ 6a0:	8b 3d 50 12 00 00    	mov    0x1250,%edi
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 6a6:	8d 70 07             	lea    0x7(%eax),%esi
+ 6a9:	c1 ee 03             	shr    $0x3,%esi
+ 6ac:	83 c6 01             	add    $0x1,%esi
+  if((prevp = freep) == 0){
+ 6af:	85 ff                	test   %edi,%edi
+ 6b1:	0f 84 a9 00 00 00    	je     760 <malloc+0xd0>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 6b7:	8b 07                	mov    (%edi),%eax
+    if(p->s.size >= nunits){
+ 6b9:	8b 48 04             	mov    0x4(%eax),%ecx
+ 6bc:	39 f1                	cmp    %esi,%ecx
+ 6be:	73 6d                	jae    72d <malloc+0x9d>
+ 6c0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+ 6c6:	bb 00 10 00 00       	mov    $0x1000,%ebx
+ 6cb:	0f 43 de             	cmovae %esi,%ebx
+  p = sbrk(nu * sizeof(Header));
+ 6ce:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
+ 6d5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+ 6d8:	eb 17                	jmp    6f1 <malloc+0x61>
+ 6da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 6e0:	8b 10                	mov    (%eax),%edx
+    if(p->s.size >= nunits){
+ 6e2:	8b 4a 04             	mov    0x4(%edx),%ecx
+ 6e5:	39 f1                	cmp    %esi,%ecx
+ 6e7:	73 4f                	jae    738 <malloc+0xa8>
+ 6e9:	8b 3d 50 12 00 00    	mov    0x1250,%edi
+ 6ef:	89 d0                	mov    %edx,%eax
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 6f1:	39 c7                	cmp    %eax,%edi
+ 6f3:	75 eb                	jne    6e0 <malloc+0x50>
+  p = sbrk(nu * sizeof(Header));
+ 6f5:	83 ec 0c             	sub    $0xc,%esp
+ 6f8:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 6fb:	e8 3b fc ff ff       	call   33b <sbrk>
+  if(p == (char*)-1)
+ 700:	83 c4 10             	add    $0x10,%esp
+ 703:	83 f8 ff             	cmp    $0xffffffff,%eax
+ 706:	74 1b                	je     723 <malloc+0x93>
+  hp->s.size = nu;
+ 708:	89 58 04             	mov    %ebx,0x4(%eax)
+  free((void*)(hp + 1));
+ 70b:	83 ec 0c             	sub    $0xc,%esp
+ 70e:	83 c0 08             	add    $0x8,%eax
+ 711:	50                   	push   %eax
+ 712:	e8 e9 fe ff ff       	call   600 <free>
+  return freep;
+ 717:	a1 50 12 00 00       	mov    0x1250,%eax
+      if((p = morecore(nunits)) == 0)
+ 71c:	83 c4 10             	add    $0x10,%esp
+ 71f:	85 c0                	test   %eax,%eax
+ 721:	75 bd                	jne    6e0 <malloc+0x50>
+        return 0;
+  }
+}
+ 723:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return 0;
+ 726:	31 c0                	xor    %eax,%eax
+}
+ 728:	5b                   	pop    %ebx
+ 729:	5e                   	pop    %esi
+ 72a:	5f                   	pop    %edi
+ 72b:	5d                   	pop    %ebp
+ 72c:	c3                   	ret    
+    if(p->s.size >= nunits){
+ 72d:	89 c2                	mov    %eax,%edx
+ 72f:	89 f8                	mov    %edi,%eax
+ 731:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+ 738:	39 ce                	cmp    %ecx,%esi
+ 73a:	74 54                	je     790 <malloc+0x100>
+        p->s.size -= nunits;
+ 73c:	29 f1                	sub    %esi,%ecx
+ 73e:	89 4a 04             	mov    %ecx,0x4(%edx)
+        p += p->s.size;
+ 741:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
+        p->s.size = nunits;
+ 744:	89 72 04             	mov    %esi,0x4(%edx)
+      freep = prevp;
+ 747:	a3 50 12 00 00       	mov    %eax,0x1250
+}
+ 74c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return (void*)(p + 1);
+ 74f:	8d 42 08             	lea    0x8(%edx),%eax
+}
+ 752:	5b                   	pop    %ebx
+ 753:	5e                   	pop    %esi
+ 754:	5f                   	pop    %edi
+ 755:	5d                   	pop    %ebp
+ 756:	c3                   	ret    
+ 757:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 75e:	66 90                	xchg   %ax,%ax
+    base.s.ptr = freep = prevp = &base;
+ 760:	c7 05 50 12 00 00 54 	movl   $0x1254,0x1250
+ 767:	12 00 00 
+    base.s.size = 0;
+ 76a:	bf 54 12 00 00       	mov    $0x1254,%edi
+    base.s.ptr = freep = prevp = &base;
+ 76f:	c7 05 54 12 00 00 54 	movl   $0x1254,0x1254
+ 776:	12 00 00 
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 779:	89 f8                	mov    %edi,%eax
+    base.s.size = 0;
+ 77b:	c7 05 58 12 00 00 00 	movl   $0x0,0x1258
+ 782:	00 00 00 
+    if(p->s.size >= nunits){
+ 785:	e9 36 ff ff ff       	jmp    6c0 <malloc+0x30>
+ 78a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        prevp->s.ptr = p->s.ptr;
+ 790:	8b 0a                	mov    (%edx),%ecx
+ 792:	89 08                	mov    %ecx,(%eax)
+ 794:	eb b1                	jmp    747 <malloc+0xb7>
diff -ruN xv6-public/drawtest.c copy-xv6/drawtest.c
--- xv6-public/drawtest.c	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/drawtest.c	2022-08-12 13:29:22.767673000 +0530
@@ -0,0 +1,13 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(void)
+{
+	static char buf[2000];
+	printf(1,"draw sys call returns %d\n",draw((void*) buf,2000));
+
+	printf(1,"%s",buf);
+	exit();
+}
diff -ruN xv6-public/drawtest.d copy-xv6/drawtest.d
--- xv6-public/drawtest.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/drawtest.d	2022-09-05 23:26:12.584781079 +0530
@@ -0,0 +1 @@
+drawtest.o: drawtest.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/drawtest.o and copy-xv6/drawtest.o differ
diff -ruN xv6-public/drawtest.sym copy-xv6/drawtest.sym
--- xv6-public/drawtest.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/drawtest.sym	2022-09-05 23:26:12.596781079 +0530
@@ -0,0 +1,62 @@
+00000000 .text
+00000798 .rodata
+000007d0 .eh_frame
+00000a80 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 drawtest.c
+00000a80 buf.1090
+00000000 ulib.c
+00000000 printf.c
+00000380 printint
+000007bc digits.1097
+00000000 umalloc.c
+00001250 freep
+00001254 base
+00000050 strcpy
+00000430 printf
+0000036b thread_exit
+00000280 memmove
+000002fb mknod
+00000170 gets
+00000333 getpid
+00000690 malloc
+00000343 sleep
+000002c3 pipe
+000002d3 write
+0000030b fstat
+000002e3 kill
+00000323 chdir
+000002eb exec
+000002bb wait
+000002cb read
+00000303 unlink
+000002ab fork
+0000033b sbrk
+0000034b uptime
+00000a64 __bss_start
+00000110 memset
+00000000 main
+00000080 strcmp
+0000032b dup
+000001f0 stat
+00000a64 _edata
+0000125c _end
+00000313 link
+000002b3 exit
+00000240 atoi
+00000353 draw
+000000d0 strlen
+000002f3 open
+00000130 strchr
+0000035b thread_create
+0000031b mkdir
+000002db close
+00000363 thread_join
+00000600 free
Binary files xv6-public/_echo and copy-xv6/_echo differ
diff -ruN xv6-public/echo.asm copy-xv6/echo.asm
--- xv6-public/echo.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/echo.asm	2022-09-05 23:26:11.844781093 +0530
@@ -0,0 +1,1224 @@
+
+_echo:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	56                   	push   %esi
+  12:	53                   	push   %ebx
+  13:	51                   	push   %ecx
+  14:	83 ec 0c             	sub    $0xc,%esp
+  17:	8b 01                	mov    (%ecx),%eax
+  19:	8b 51 04             	mov    0x4(%ecx),%edx
+  int i;
+
+  for(i = 1; i < argc; i++)
+  1c:	83 f8 01             	cmp    $0x1,%eax
+  1f:	7e 4b                	jle    6c <main+0x6c>
+  21:	8d 5a 04             	lea    0x4(%edx),%ebx
+  24:	8d 34 82             	lea    (%edx,%eax,4),%esi
+    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+  27:	83 c3 04             	add    $0x4,%ebx
+  2a:	8b 43 fc             	mov    -0x4(%ebx),%eax
+  2d:	39 f3                	cmp    %esi,%ebx
+  2f:	74 26                	je     57 <main+0x57>
+  31:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  38:	68 c8 07 00 00       	push   $0x7c8
+  3d:	83 c3 04             	add    $0x4,%ebx
+  40:	50                   	push   %eax
+  41:	68 ca 07 00 00       	push   $0x7ca
+  46:	6a 01                	push   $0x1
+  48:	e8 13 04 00 00       	call   460 <printf>
+  for(i = 1; i < argc; i++)
+  4d:	8b 43 fc             	mov    -0x4(%ebx),%eax
+    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+  50:	83 c4 10             	add    $0x10,%esp
+  53:	39 f3                	cmp    %esi,%ebx
+  55:	75 e1                	jne    38 <main+0x38>
+  57:	68 cf 07 00 00       	push   $0x7cf
+  5c:	50                   	push   %eax
+  5d:	68 ca 07 00 00       	push   $0x7ca
+  62:	6a 01                	push   $0x1
+  64:	e8 f7 03 00 00       	call   460 <printf>
+  69:	83 c4 10             	add    $0x10,%esp
+  exit();
+  6c:	e8 72 02 00 00       	call   2e3 <exit>
+  71:	66 90                	xchg   %ax,%ax
+  73:	66 90                	xchg   %ax,%ax
+  75:	66 90                	xchg   %ax,%ax
+  77:	66 90                	xchg   %ax,%ax
+  79:	66 90                	xchg   %ax,%ax
+  7b:	66 90                	xchg   %ax,%ax
+  7d:	66 90                	xchg   %ax,%ax
+  7f:	90                   	nop
+
+00000080 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+  80:	f3 0f 1e fb          	endbr32 
+  84:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  85:	31 c0                	xor    %eax,%eax
+{
+  87:	89 e5                	mov    %esp,%ebp
+  89:	53                   	push   %ebx
+  8a:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  8d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+  90:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+  94:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+  97:	83 c0 01             	add    $0x1,%eax
+  9a:	84 d2                	test   %dl,%dl
+  9c:	75 f2                	jne    90 <strcpy+0x10>
+    ;
+  return os;
+}
+  9e:	89 c8                	mov    %ecx,%eax
+  a0:	5b                   	pop    %ebx
+  a1:	5d                   	pop    %ebp
+  a2:	c3                   	ret    
+  a3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000000b0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  b0:	f3 0f 1e fb          	endbr32 
+  b4:	55                   	push   %ebp
+  b5:	89 e5                	mov    %esp,%ebp
+  b7:	53                   	push   %ebx
+  b8:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  bb:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+  be:	0f b6 01             	movzbl (%ecx),%eax
+  c1:	0f b6 1a             	movzbl (%edx),%ebx
+  c4:	84 c0                	test   %al,%al
+  c6:	75 19                	jne    e1 <strcmp+0x31>
+  c8:	eb 26                	jmp    f0 <strcmp+0x40>
+  ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  d0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+  d4:	83 c1 01             	add    $0x1,%ecx
+  d7:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+  da:	0f b6 1a             	movzbl (%edx),%ebx
+  dd:	84 c0                	test   %al,%al
+  df:	74 0f                	je     f0 <strcmp+0x40>
+  e1:	38 d8                	cmp    %bl,%al
+  e3:	74 eb                	je     d0 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+  e5:	29 d8                	sub    %ebx,%eax
+}
+  e7:	5b                   	pop    %ebx
+  e8:	5d                   	pop    %ebp
+  e9:	c3                   	ret    
+  ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  f0:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+  f2:	29 d8                	sub    %ebx,%eax
+}
+  f4:	5b                   	pop    %ebx
+  f5:	5d                   	pop    %ebp
+  f6:	c3                   	ret    
+  f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  fe:	66 90                	xchg   %ax,%ax
+
+00000100 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 100:	f3 0f 1e fb          	endbr32 
+ 104:	55                   	push   %ebp
+ 105:	89 e5                	mov    %esp,%ebp
+ 107:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 10a:	80 3a 00             	cmpb   $0x0,(%edx)
+ 10d:	74 21                	je     130 <strlen+0x30>
+ 10f:	31 c0                	xor    %eax,%eax
+ 111:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 118:	83 c0 01             	add    $0x1,%eax
+ 11b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+ 11f:	89 c1                	mov    %eax,%ecx
+ 121:	75 f5                	jne    118 <strlen+0x18>
+    ;
+  return n;
+}
+ 123:	89 c8                	mov    %ecx,%eax
+ 125:	5d                   	pop    %ebp
+ 126:	c3                   	ret    
+ 127:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 12e:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+ 130:	31 c9                	xor    %ecx,%ecx
+}
+ 132:	5d                   	pop    %ebp
+ 133:	89 c8                	mov    %ecx,%eax
+ 135:	c3                   	ret    
+ 136:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 13d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000140 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 140:	f3 0f 1e fb          	endbr32 
+ 144:	55                   	push   %ebp
+ 145:	89 e5                	mov    %esp,%ebp
+ 147:	57                   	push   %edi
+ 148:	8b 55 08             	mov    0x8(%ebp),%edx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+ 14b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 14e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 151:	89 d7                	mov    %edx,%edi
+ 153:	fc                   	cld    
+ 154:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+ 156:	89 d0                	mov    %edx,%eax
+ 158:	5f                   	pop    %edi
+ 159:	5d                   	pop    %ebp
+ 15a:	c3                   	ret    
+ 15b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 15f:	90                   	nop
+
+00000160 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 160:	f3 0f 1e fb          	endbr32 
+ 164:	55                   	push   %ebp
+ 165:	89 e5                	mov    %esp,%ebp
+ 167:	8b 45 08             	mov    0x8(%ebp),%eax
+ 16a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+ 16e:	0f b6 10             	movzbl (%eax),%edx
+ 171:	84 d2                	test   %dl,%dl
+ 173:	75 16                	jne    18b <strchr+0x2b>
+ 175:	eb 21                	jmp    198 <strchr+0x38>
+ 177:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 17e:	66 90                	xchg   %ax,%ax
+ 180:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+ 184:	83 c0 01             	add    $0x1,%eax
+ 187:	84 d2                	test   %dl,%dl
+ 189:	74 0d                	je     198 <strchr+0x38>
+    if(*s == c)
+ 18b:	38 d1                	cmp    %dl,%cl
+ 18d:	75 f1                	jne    180 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+ 18f:	5d                   	pop    %ebp
+ 190:	c3                   	ret    
+ 191:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+ 198:	31 c0                	xor    %eax,%eax
+}
+ 19a:	5d                   	pop    %ebp
+ 19b:	c3                   	ret    
+ 19c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000001a0 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 1a0:	f3 0f 1e fb          	endbr32 
+ 1a4:	55                   	push   %ebp
+ 1a5:	89 e5                	mov    %esp,%ebp
+ 1a7:	57                   	push   %edi
+ 1a8:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1a9:	31 f6                	xor    %esi,%esi
+{
+ 1ab:	53                   	push   %ebx
+ 1ac:	89 f3                	mov    %esi,%ebx
+ 1ae:	83 ec 1c             	sub    $0x1c,%esp
+ 1b1:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+ 1b4:	eb 33                	jmp    1e9 <gets+0x49>
+ 1b6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1bd:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+ 1c0:	83 ec 04             	sub    $0x4,%esp
+ 1c3:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ 1c6:	6a 01                	push   $0x1
+ 1c8:	50                   	push   %eax
+ 1c9:	6a 00                	push   $0x0
+ 1cb:	e8 2b 01 00 00       	call   2fb <read>
+    if(cc < 1)
+ 1d0:	83 c4 10             	add    $0x10,%esp
+ 1d3:	85 c0                	test   %eax,%eax
+ 1d5:	7e 1c                	jle    1f3 <gets+0x53>
+      break;
+    buf[i++] = c;
+ 1d7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ 1db:	83 c7 01             	add    $0x1,%edi
+ 1de:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+ 1e1:	3c 0a                	cmp    $0xa,%al
+ 1e3:	74 23                	je     208 <gets+0x68>
+ 1e5:	3c 0d                	cmp    $0xd,%al
+ 1e7:	74 1f                	je     208 <gets+0x68>
+  for(i=0; i+1 < max; ){
+ 1e9:	83 c3 01             	add    $0x1,%ebx
+ 1ec:	89 fe                	mov    %edi,%esi
+ 1ee:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+ 1f1:	7c cd                	jl     1c0 <gets+0x20>
+ 1f3:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+ 1f5:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+ 1f8:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 1fb:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 1fe:	5b                   	pop    %ebx
+ 1ff:	5e                   	pop    %esi
+ 200:	5f                   	pop    %edi
+ 201:	5d                   	pop    %ebp
+ 202:	c3                   	ret    
+ 203:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 207:	90                   	nop
+ 208:	8b 75 08             	mov    0x8(%ebp),%esi
+ 20b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 20e:	01 de                	add    %ebx,%esi
+ 210:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+ 212:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 215:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 218:	5b                   	pop    %ebx
+ 219:	5e                   	pop    %esi
+ 21a:	5f                   	pop    %edi
+ 21b:	5d                   	pop    %ebp
+ 21c:	c3                   	ret    
+ 21d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000220 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 220:	f3 0f 1e fb          	endbr32 
+ 224:	55                   	push   %ebp
+ 225:	89 e5                	mov    %esp,%ebp
+ 227:	56                   	push   %esi
+ 228:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 229:	83 ec 08             	sub    $0x8,%esp
+ 22c:	6a 00                	push   $0x0
+ 22e:	ff 75 08             	pushl  0x8(%ebp)
+ 231:	e8 ed 00 00 00       	call   323 <open>
+  if(fd < 0)
+ 236:	83 c4 10             	add    $0x10,%esp
+ 239:	85 c0                	test   %eax,%eax
+ 23b:	78 2b                	js     268 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+ 23d:	83 ec 08             	sub    $0x8,%esp
+ 240:	ff 75 0c             	pushl  0xc(%ebp)
+ 243:	89 c3                	mov    %eax,%ebx
+ 245:	50                   	push   %eax
+ 246:	e8 f0 00 00 00       	call   33b <fstat>
+  close(fd);
+ 24b:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+ 24e:	89 c6                	mov    %eax,%esi
+  close(fd);
+ 250:	e8 b6 00 00 00       	call   30b <close>
+  return r;
+ 255:	83 c4 10             	add    $0x10,%esp
+}
+ 258:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 25b:	89 f0                	mov    %esi,%eax
+ 25d:	5b                   	pop    %ebx
+ 25e:	5e                   	pop    %esi
+ 25f:	5d                   	pop    %ebp
+ 260:	c3                   	ret    
+ 261:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+ 268:	be ff ff ff ff       	mov    $0xffffffff,%esi
+ 26d:	eb e9                	jmp    258 <stat+0x38>
+ 26f:	90                   	nop
+
+00000270 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 270:	f3 0f 1e fb          	endbr32 
+ 274:	55                   	push   %ebp
+ 275:	89 e5                	mov    %esp,%ebp
+ 277:	53                   	push   %ebx
+ 278:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 27b:	0f be 02             	movsbl (%edx),%eax
+ 27e:	8d 48 d0             	lea    -0x30(%eax),%ecx
+ 281:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+ 284:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+ 289:	77 1a                	ja     2a5 <atoi+0x35>
+ 28b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 28f:	90                   	nop
+    n = n*10 + *s++ - '0';
+ 290:	83 c2 01             	add    $0x1,%edx
+ 293:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+ 296:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+ 29a:	0f be 02             	movsbl (%edx),%eax
+ 29d:	8d 58 d0             	lea    -0x30(%eax),%ebx
+ 2a0:	80 fb 09             	cmp    $0x9,%bl
+ 2a3:	76 eb                	jbe    290 <atoi+0x20>
+  return n;
+}
+ 2a5:	89 c8                	mov    %ecx,%eax
+ 2a7:	5b                   	pop    %ebx
+ 2a8:	5d                   	pop    %ebp
+ 2a9:	c3                   	ret    
+ 2aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000002b0 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 2b0:	f3 0f 1e fb          	endbr32 
+ 2b4:	55                   	push   %ebp
+ 2b5:	89 e5                	mov    %esp,%ebp
+ 2b7:	57                   	push   %edi
+ 2b8:	8b 45 10             	mov    0x10(%ebp),%eax
+ 2bb:	8b 55 08             	mov    0x8(%ebp),%edx
+ 2be:	56                   	push   %esi
+ 2bf:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 2c2:	85 c0                	test   %eax,%eax
+ 2c4:	7e 0f                	jle    2d5 <memmove+0x25>
+ 2c6:	01 d0                	add    %edx,%eax
+  dst = vdst;
+ 2c8:	89 d7                	mov    %edx,%edi
+ 2ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+ 2d0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+ 2d1:	39 f8                	cmp    %edi,%eax
+ 2d3:	75 fb                	jne    2d0 <memmove+0x20>
+  return vdst;
+}
+ 2d5:	5e                   	pop    %esi
+ 2d6:	89 d0                	mov    %edx,%eax
+ 2d8:	5f                   	pop    %edi
+ 2d9:	5d                   	pop    %ebp
+ 2da:	c3                   	ret    
+
+000002db <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 2db:	b8 01 00 00 00       	mov    $0x1,%eax
+ 2e0:	cd 40                	int    $0x40
+ 2e2:	c3                   	ret    
+
+000002e3 <exit>:
+SYSCALL(exit)
+ 2e3:	b8 02 00 00 00       	mov    $0x2,%eax
+ 2e8:	cd 40                	int    $0x40
+ 2ea:	c3                   	ret    
+
+000002eb <wait>:
+SYSCALL(wait)
+ 2eb:	b8 03 00 00 00       	mov    $0x3,%eax
+ 2f0:	cd 40                	int    $0x40
+ 2f2:	c3                   	ret    
+
+000002f3 <pipe>:
+SYSCALL(pipe)
+ 2f3:	b8 04 00 00 00       	mov    $0x4,%eax
+ 2f8:	cd 40                	int    $0x40
+ 2fa:	c3                   	ret    
+
+000002fb <read>:
+SYSCALL(read)
+ 2fb:	b8 05 00 00 00       	mov    $0x5,%eax
+ 300:	cd 40                	int    $0x40
+ 302:	c3                   	ret    
+
+00000303 <write>:
+SYSCALL(write)
+ 303:	b8 10 00 00 00       	mov    $0x10,%eax
+ 308:	cd 40                	int    $0x40
+ 30a:	c3                   	ret    
+
+0000030b <close>:
+SYSCALL(close)
+ 30b:	b8 15 00 00 00       	mov    $0x15,%eax
+ 310:	cd 40                	int    $0x40
+ 312:	c3                   	ret    
+
+00000313 <kill>:
+SYSCALL(kill)
+ 313:	b8 06 00 00 00       	mov    $0x6,%eax
+ 318:	cd 40                	int    $0x40
+ 31a:	c3                   	ret    
+
+0000031b <exec>:
+SYSCALL(exec)
+ 31b:	b8 07 00 00 00       	mov    $0x7,%eax
+ 320:	cd 40                	int    $0x40
+ 322:	c3                   	ret    
+
+00000323 <open>:
+SYSCALL(open)
+ 323:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 328:	cd 40                	int    $0x40
+ 32a:	c3                   	ret    
+
+0000032b <mknod>:
+SYSCALL(mknod)
+ 32b:	b8 11 00 00 00       	mov    $0x11,%eax
+ 330:	cd 40                	int    $0x40
+ 332:	c3                   	ret    
+
+00000333 <unlink>:
+SYSCALL(unlink)
+ 333:	b8 12 00 00 00       	mov    $0x12,%eax
+ 338:	cd 40                	int    $0x40
+ 33a:	c3                   	ret    
+
+0000033b <fstat>:
+SYSCALL(fstat)
+ 33b:	b8 08 00 00 00       	mov    $0x8,%eax
+ 340:	cd 40                	int    $0x40
+ 342:	c3                   	ret    
+
+00000343 <link>:
+SYSCALL(link)
+ 343:	b8 13 00 00 00       	mov    $0x13,%eax
+ 348:	cd 40                	int    $0x40
+ 34a:	c3                   	ret    
+
+0000034b <mkdir>:
+SYSCALL(mkdir)
+ 34b:	b8 14 00 00 00       	mov    $0x14,%eax
+ 350:	cd 40                	int    $0x40
+ 352:	c3                   	ret    
+
+00000353 <chdir>:
+SYSCALL(chdir)
+ 353:	b8 09 00 00 00       	mov    $0x9,%eax
+ 358:	cd 40                	int    $0x40
+ 35a:	c3                   	ret    
+
+0000035b <dup>:
+SYSCALL(dup)
+ 35b:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 360:	cd 40                	int    $0x40
+ 362:	c3                   	ret    
+
+00000363 <getpid>:
+SYSCALL(getpid)
+ 363:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 368:	cd 40                	int    $0x40
+ 36a:	c3                   	ret    
+
+0000036b <sbrk>:
+SYSCALL(sbrk)
+ 36b:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 370:	cd 40                	int    $0x40
+ 372:	c3                   	ret    
+
+00000373 <sleep>:
+SYSCALL(sleep)
+ 373:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 378:	cd 40                	int    $0x40
+ 37a:	c3                   	ret    
+
+0000037b <uptime>:
+SYSCALL(uptime)
+ 37b:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 380:	cd 40                	int    $0x40
+ 382:	c3                   	ret    
+
+00000383 <draw>:
+SYSCALL(draw)
+ 383:	b8 16 00 00 00       	mov    $0x16,%eax
+ 388:	cd 40                	int    $0x40
+ 38a:	c3                   	ret    
+
+0000038b <thread_create>:
+
+SYSCALL(thread_create)
+ 38b:	b8 17 00 00 00       	mov    $0x17,%eax
+ 390:	cd 40                	int    $0x40
+ 392:	c3                   	ret    
+
+00000393 <thread_join>:
+SYSCALL(thread_join)
+ 393:	b8 18 00 00 00       	mov    $0x18,%eax
+ 398:	cd 40                	int    $0x40
+ 39a:	c3                   	ret    
+
+0000039b <thread_exit>:
+SYSCALL(thread_exit)
+ 39b:	b8 19 00 00 00       	mov    $0x19,%eax
+ 3a0:	cd 40                	int    $0x40
+ 3a2:	c3                   	ret    
+ 3a3:	66 90                	xchg   %ax,%ax
+ 3a5:	66 90                	xchg   %ax,%ax
+ 3a7:	66 90                	xchg   %ax,%ax
+ 3a9:	66 90                	xchg   %ax,%ax
+ 3ab:	66 90                	xchg   %ax,%ax
+ 3ad:	66 90                	xchg   %ax,%ax
+ 3af:	90                   	nop
+
+000003b0 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 3b0:	55                   	push   %ebp
+ 3b1:	89 e5                	mov    %esp,%ebp
+ 3b3:	57                   	push   %edi
+ 3b4:	56                   	push   %esi
+ 3b5:	53                   	push   %ebx
+ 3b6:	83 ec 3c             	sub    $0x3c,%esp
+ 3b9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+ 3bc:	89 d1                	mov    %edx,%ecx
+{
+ 3be:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  if(sgn && xx < 0){
+ 3c1:	85 d2                	test   %edx,%edx
+ 3c3:	0f 89 7f 00 00 00    	jns    448 <printint+0x98>
+ 3c9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
+ 3cd:	74 79                	je     448 <printint+0x98>
+    neg = 1;
+ 3cf:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+    x = -xx;
+ 3d6:	f7 d9                	neg    %ecx
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 3d8:	31 db                	xor    %ebx,%ebx
+ 3da:	8d 75 d7             	lea    -0x29(%ebp),%esi
+ 3dd:	8d 76 00             	lea    0x0(%esi),%esi
+  do{
+    buf[i++] = digits[x % base];
+ 3e0:	89 c8                	mov    %ecx,%eax
+ 3e2:	31 d2                	xor    %edx,%edx
+ 3e4:	89 cf                	mov    %ecx,%edi
+ 3e6:	f7 75 c4             	divl   -0x3c(%ebp)
+ 3e9:	0f b6 92 d8 07 00 00 	movzbl 0x7d8(%edx),%edx
+ 3f0:	89 45 c0             	mov    %eax,-0x40(%ebp)
+ 3f3:	89 d8                	mov    %ebx,%eax
+ 3f5:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+ 3f8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+    buf[i++] = digits[x % base];
+ 3fb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
+  }while((x /= base) != 0);
+ 3fe:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
+ 401:	76 dd                	jbe    3e0 <printint+0x30>
+  if(neg)
+ 403:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+ 406:	85 c9                	test   %ecx,%ecx
+ 408:	74 0c                	je     416 <printint+0x66>
+    buf[i++] = '-';
+ 40a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+ 40f:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+ 411:	ba 2d 00 00 00       	mov    $0x2d,%edx
+
+  while(--i >= 0)
+ 416:	8b 7d b8             	mov    -0x48(%ebp),%edi
+ 419:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+ 41d:	eb 07                	jmp    426 <printint+0x76>
+ 41f:	90                   	nop
+ 420:	0f b6 13             	movzbl (%ebx),%edx
+ 423:	83 eb 01             	sub    $0x1,%ebx
+  write(fd, &c, 1);
+ 426:	83 ec 04             	sub    $0x4,%esp
+ 429:	88 55 d7             	mov    %dl,-0x29(%ebp)
+ 42c:	6a 01                	push   $0x1
+ 42e:	56                   	push   %esi
+ 42f:	57                   	push   %edi
+ 430:	e8 ce fe ff ff       	call   303 <write>
+  while(--i >= 0)
+ 435:	83 c4 10             	add    $0x10,%esp
+ 438:	39 de                	cmp    %ebx,%esi
+ 43a:	75 e4                	jne    420 <printint+0x70>
+    putc(fd, buf[i]);
+}
+ 43c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 43f:	5b                   	pop    %ebx
+ 440:	5e                   	pop    %esi
+ 441:	5f                   	pop    %edi
+ 442:	5d                   	pop    %ebp
+ 443:	c3                   	ret    
+ 444:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  neg = 0;
+ 448:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+ 44f:	eb 87                	jmp    3d8 <printint+0x28>
+ 451:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 458:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 45f:	90                   	nop
+
+00000460 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 460:	f3 0f 1e fb          	endbr32 
+ 464:	55                   	push   %ebp
+ 465:	89 e5                	mov    %esp,%ebp
+ 467:	57                   	push   %edi
+ 468:	56                   	push   %esi
+ 469:	53                   	push   %ebx
+ 46a:	83 ec 2c             	sub    $0x2c,%esp
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 46d:	8b 75 0c             	mov    0xc(%ebp),%esi
+ 470:	0f b6 1e             	movzbl (%esi),%ebx
+ 473:	84 db                	test   %bl,%bl
+ 475:	0f 84 b4 00 00 00    	je     52f <printf+0xcf>
+  ap = (uint*)(void*)&fmt + 1;
+ 47b:	8d 45 10             	lea    0x10(%ebp),%eax
+ 47e:	83 c6 01             	add    $0x1,%esi
+  write(fd, &c, 1);
+ 481:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  state = 0;
+ 484:	31 d2                	xor    %edx,%edx
+  ap = (uint*)(void*)&fmt + 1;
+ 486:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 489:	eb 33                	jmp    4be <printf+0x5e>
+ 48b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 48f:	90                   	nop
+ 490:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+ 493:	ba 25 00 00 00       	mov    $0x25,%edx
+      if(c == '%'){
+ 498:	83 f8 25             	cmp    $0x25,%eax
+ 49b:	74 17                	je     4b4 <printf+0x54>
+  write(fd, &c, 1);
+ 49d:	83 ec 04             	sub    $0x4,%esp
+ 4a0:	88 5d e7             	mov    %bl,-0x19(%ebp)
+ 4a3:	6a 01                	push   $0x1
+ 4a5:	57                   	push   %edi
+ 4a6:	ff 75 08             	pushl  0x8(%ebp)
+ 4a9:	e8 55 fe ff ff       	call   303 <write>
+ 4ae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+      } else {
+        putc(fd, c);
+ 4b1:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; fmt[i]; i++){
+ 4b4:	0f b6 1e             	movzbl (%esi),%ebx
+ 4b7:	83 c6 01             	add    $0x1,%esi
+ 4ba:	84 db                	test   %bl,%bl
+ 4bc:	74 71                	je     52f <printf+0xcf>
+    c = fmt[i] & 0xff;
+ 4be:	0f be cb             	movsbl %bl,%ecx
+ 4c1:	0f b6 c3             	movzbl %bl,%eax
+    if(state == 0){
+ 4c4:	85 d2                	test   %edx,%edx
+ 4c6:	74 c8                	je     490 <printf+0x30>
+      }
+    } else if(state == '%'){
+ 4c8:	83 fa 25             	cmp    $0x25,%edx
+ 4cb:	75 e7                	jne    4b4 <printf+0x54>
+      if(c == 'd'){
+ 4cd:	83 f8 64             	cmp    $0x64,%eax
+ 4d0:	0f 84 9a 00 00 00    	je     570 <printf+0x110>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+ 4d6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
+ 4dc:	83 f9 70             	cmp    $0x70,%ecx
+ 4df:	74 5f                	je     540 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+ 4e1:	83 f8 73             	cmp    $0x73,%eax
+ 4e4:	0f 84 d6 00 00 00    	je     5c0 <printf+0x160>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 4ea:	83 f8 63             	cmp    $0x63,%eax
+ 4ed:	0f 84 8d 00 00 00    	je     580 <printf+0x120>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+ 4f3:	83 f8 25             	cmp    $0x25,%eax
+ 4f6:	0f 84 b4 00 00 00    	je     5b0 <printf+0x150>
+  write(fd, &c, 1);
+ 4fc:	83 ec 04             	sub    $0x4,%esp
+ 4ff:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
+ 503:	6a 01                	push   $0x1
+ 505:	57                   	push   %edi
+ 506:	ff 75 08             	pushl  0x8(%ebp)
+ 509:	e8 f5 fd ff ff       	call   303 <write>
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+ 50e:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 511:	83 c4 0c             	add    $0xc,%esp
+ 514:	6a 01                	push   $0x1
+ 516:	83 c6 01             	add    $0x1,%esi
+ 519:	57                   	push   %edi
+ 51a:	ff 75 08             	pushl  0x8(%ebp)
+ 51d:	e8 e1 fd ff ff       	call   303 <write>
+  for(i = 0; fmt[i]; i++){
+ 522:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
+        putc(fd, c);
+ 526:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 529:	31 d2                	xor    %edx,%edx
+  for(i = 0; fmt[i]; i++){
+ 52b:	84 db                	test   %bl,%bl
+ 52d:	75 8f                	jne    4be <printf+0x5e>
+    }
+  }
+}
+ 52f:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 532:	5b                   	pop    %ebx
+ 533:	5e                   	pop    %esi
+ 534:	5f                   	pop    %edi
+ 535:	5d                   	pop    %ebp
+ 536:	c3                   	ret    
+ 537:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 53e:	66 90                	xchg   %ax,%ax
+        printint(fd, *ap, 16, 0);
+ 540:	83 ec 0c             	sub    $0xc,%esp
+ 543:	b9 10 00 00 00       	mov    $0x10,%ecx
+ 548:	6a 00                	push   $0x0
+ 54a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+ 54d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 550:	8b 13                	mov    (%ebx),%edx
+ 552:	e8 59 fe ff ff       	call   3b0 <printint>
+        ap++;
+ 557:	89 d8                	mov    %ebx,%eax
+ 559:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 55c:	31 d2                	xor    %edx,%edx
+        ap++;
+ 55e:	83 c0 04             	add    $0x4,%eax
+ 561:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 564:	e9 4b ff ff ff       	jmp    4b4 <printf+0x54>
+ 569:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        printint(fd, *ap, 10, 1);
+ 570:	83 ec 0c             	sub    $0xc,%esp
+ 573:	b9 0a 00 00 00       	mov    $0xa,%ecx
+ 578:	6a 01                	push   $0x1
+ 57a:	eb ce                	jmp    54a <printf+0xea>
+ 57c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        putc(fd, *ap);
+ 580:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+  write(fd, &c, 1);
+ 583:	83 ec 04             	sub    $0x4,%esp
+        putc(fd, *ap);
+ 586:	8b 03                	mov    (%ebx),%eax
+  write(fd, &c, 1);
+ 588:	6a 01                	push   $0x1
+        ap++;
+ 58a:	83 c3 04             	add    $0x4,%ebx
+  write(fd, &c, 1);
+ 58d:	57                   	push   %edi
+ 58e:	ff 75 08             	pushl  0x8(%ebp)
+        putc(fd, *ap);
+ 591:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 594:	e8 6a fd ff ff       	call   303 <write>
+        ap++;
+ 599:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+ 59c:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 59f:	31 d2                	xor    %edx,%edx
+ 5a1:	e9 0e ff ff ff       	jmp    4b4 <printf+0x54>
+ 5a6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 5ad:	8d 76 00             	lea    0x0(%esi),%esi
+        putc(fd, c);
+ 5b0:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 5b3:	83 ec 04             	sub    $0x4,%esp
+ 5b6:	e9 59 ff ff ff       	jmp    514 <printf+0xb4>
+ 5bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 5bf:	90                   	nop
+        s = (char*)*ap;
+ 5c0:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 5c3:	8b 18                	mov    (%eax),%ebx
+        ap++;
+ 5c5:	83 c0 04             	add    $0x4,%eax
+ 5c8:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        if(s == 0)
+ 5cb:	85 db                	test   %ebx,%ebx
+ 5cd:	74 17                	je     5e6 <printf+0x186>
+        while(*s != 0){
+ 5cf:	0f b6 03             	movzbl (%ebx),%eax
+      state = 0;
+ 5d2:	31 d2                	xor    %edx,%edx
+        while(*s != 0){
+ 5d4:	84 c0                	test   %al,%al
+ 5d6:	0f 84 d8 fe ff ff    	je     4b4 <printf+0x54>
+ 5dc:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 5df:	89 de                	mov    %ebx,%esi
+ 5e1:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 5e4:	eb 1a                	jmp    600 <printf+0x1a0>
+          s = "(null)";
+ 5e6:	bb d1 07 00 00       	mov    $0x7d1,%ebx
+        while(*s != 0){
+ 5eb:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 5ee:	b8 28 00 00 00       	mov    $0x28,%eax
+ 5f3:	89 de                	mov    %ebx,%esi
+ 5f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 5f8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 5ff:	90                   	nop
+  write(fd, &c, 1);
+ 600:	83 ec 04             	sub    $0x4,%esp
+          s++;
+ 603:	83 c6 01             	add    $0x1,%esi
+ 606:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 609:	6a 01                	push   $0x1
+ 60b:	57                   	push   %edi
+ 60c:	53                   	push   %ebx
+ 60d:	e8 f1 fc ff ff       	call   303 <write>
+        while(*s != 0){
+ 612:	0f b6 06             	movzbl (%esi),%eax
+ 615:	83 c4 10             	add    $0x10,%esp
+ 618:	84 c0                	test   %al,%al
+ 61a:	75 e4                	jne    600 <printf+0x1a0>
+ 61c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+      state = 0;
+ 61f:	31 d2                	xor    %edx,%edx
+ 621:	e9 8e fe ff ff       	jmp    4b4 <printf+0x54>
+ 626:	66 90                	xchg   %ax,%ax
+ 628:	66 90                	xchg   %ax,%ax
+ 62a:	66 90                	xchg   %ax,%ax
+ 62c:	66 90                	xchg   %ax,%ax
+ 62e:	66 90                	xchg   %ax,%ax
+
+00000630 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 630:	f3 0f 1e fb          	endbr32 
+ 634:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 635:	a1 88 0a 00 00       	mov    0xa88,%eax
+{
+ 63a:	89 e5                	mov    %esp,%ebp
+ 63c:	57                   	push   %edi
+ 63d:	56                   	push   %esi
+ 63e:	53                   	push   %ebx
+ 63f:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 642:	8b 10                	mov    (%eax),%edx
+  bp = (Header*)ap - 1;
+ 644:	8d 4b f8             	lea    -0x8(%ebx),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 647:	39 c8                	cmp    %ecx,%eax
+ 649:	73 15                	jae    660 <free+0x30>
+ 64b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 64f:	90                   	nop
+ 650:	39 d1                	cmp    %edx,%ecx
+ 652:	72 14                	jb     668 <free+0x38>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 654:	39 d0                	cmp    %edx,%eax
+ 656:	73 10                	jae    668 <free+0x38>
+{
+ 658:	89 d0                	mov    %edx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 65a:	8b 10                	mov    (%eax),%edx
+ 65c:	39 c8                	cmp    %ecx,%eax
+ 65e:	72 f0                	jb     650 <free+0x20>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 660:	39 d0                	cmp    %edx,%eax
+ 662:	72 f4                	jb     658 <free+0x28>
+ 664:	39 d1                	cmp    %edx,%ecx
+ 666:	73 f0                	jae    658 <free+0x28>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 668:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ 66b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
+ 66e:	39 fa                	cmp    %edi,%edx
+ 670:	74 1e                	je     690 <free+0x60>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+ 672:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 675:	8b 50 04             	mov    0x4(%eax),%edx
+ 678:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 67b:	39 f1                	cmp    %esi,%ecx
+ 67d:	74 28                	je     6a7 <free+0x77>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+ 67f:	89 08                	mov    %ecx,(%eax)
+  freep = p;
+}
+ 681:	5b                   	pop    %ebx
+  freep = p;
+ 682:	a3 88 0a 00 00       	mov    %eax,0xa88
+}
+ 687:	5e                   	pop    %esi
+ 688:	5f                   	pop    %edi
+ 689:	5d                   	pop    %ebp
+ 68a:	c3                   	ret    
+ 68b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 68f:	90                   	nop
+    bp->s.size += p->s.ptr->s.size;
+ 690:	03 72 04             	add    0x4(%edx),%esi
+ 693:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 696:	8b 10                	mov    (%eax),%edx
+ 698:	8b 12                	mov    (%edx),%edx
+ 69a:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 69d:	8b 50 04             	mov    0x4(%eax),%edx
+ 6a0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 6a3:	39 f1                	cmp    %esi,%ecx
+ 6a5:	75 d8                	jne    67f <free+0x4f>
+    p->s.size += bp->s.size;
+ 6a7:	03 53 fc             	add    -0x4(%ebx),%edx
+  freep = p;
+ 6aa:	a3 88 0a 00 00       	mov    %eax,0xa88
+    p->s.size += bp->s.size;
+ 6af:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 6b2:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ 6b5:	89 10                	mov    %edx,(%eax)
+}
+ 6b7:	5b                   	pop    %ebx
+ 6b8:	5e                   	pop    %esi
+ 6b9:	5f                   	pop    %edi
+ 6ba:	5d                   	pop    %ebp
+ 6bb:	c3                   	ret    
+ 6bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000006c0 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 6c0:	f3 0f 1e fb          	endbr32 
+ 6c4:	55                   	push   %ebp
+ 6c5:	89 e5                	mov    %esp,%ebp
+ 6c7:	57                   	push   %edi
+ 6c8:	56                   	push   %esi
+ 6c9:	53                   	push   %ebx
+ 6ca:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 6cd:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+ 6d0:	8b 3d 88 0a 00 00    	mov    0xa88,%edi
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 6d6:	8d 70 07             	lea    0x7(%eax),%esi
+ 6d9:	c1 ee 03             	shr    $0x3,%esi
+ 6dc:	83 c6 01             	add    $0x1,%esi
+  if((prevp = freep) == 0){
+ 6df:	85 ff                	test   %edi,%edi
+ 6e1:	0f 84 a9 00 00 00    	je     790 <malloc+0xd0>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 6e7:	8b 07                	mov    (%edi),%eax
+    if(p->s.size >= nunits){
+ 6e9:	8b 48 04             	mov    0x4(%eax),%ecx
+ 6ec:	39 f1                	cmp    %esi,%ecx
+ 6ee:	73 6d                	jae    75d <malloc+0x9d>
+ 6f0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+ 6f6:	bb 00 10 00 00       	mov    $0x1000,%ebx
+ 6fb:	0f 43 de             	cmovae %esi,%ebx
+  p = sbrk(nu * sizeof(Header));
+ 6fe:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
+ 705:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+ 708:	eb 17                	jmp    721 <malloc+0x61>
+ 70a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 710:	8b 10                	mov    (%eax),%edx
+    if(p->s.size >= nunits){
+ 712:	8b 4a 04             	mov    0x4(%edx),%ecx
+ 715:	39 f1                	cmp    %esi,%ecx
+ 717:	73 4f                	jae    768 <malloc+0xa8>
+ 719:	8b 3d 88 0a 00 00    	mov    0xa88,%edi
+ 71f:	89 d0                	mov    %edx,%eax
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 721:	39 c7                	cmp    %eax,%edi
+ 723:	75 eb                	jne    710 <malloc+0x50>
+  p = sbrk(nu * sizeof(Header));
+ 725:	83 ec 0c             	sub    $0xc,%esp
+ 728:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 72b:	e8 3b fc ff ff       	call   36b <sbrk>
+  if(p == (char*)-1)
+ 730:	83 c4 10             	add    $0x10,%esp
+ 733:	83 f8 ff             	cmp    $0xffffffff,%eax
+ 736:	74 1b                	je     753 <malloc+0x93>
+  hp->s.size = nu;
+ 738:	89 58 04             	mov    %ebx,0x4(%eax)
+  free((void*)(hp + 1));
+ 73b:	83 ec 0c             	sub    $0xc,%esp
+ 73e:	83 c0 08             	add    $0x8,%eax
+ 741:	50                   	push   %eax
+ 742:	e8 e9 fe ff ff       	call   630 <free>
+  return freep;
+ 747:	a1 88 0a 00 00       	mov    0xa88,%eax
+      if((p = morecore(nunits)) == 0)
+ 74c:	83 c4 10             	add    $0x10,%esp
+ 74f:	85 c0                	test   %eax,%eax
+ 751:	75 bd                	jne    710 <malloc+0x50>
+        return 0;
+  }
+}
+ 753:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return 0;
+ 756:	31 c0                	xor    %eax,%eax
+}
+ 758:	5b                   	pop    %ebx
+ 759:	5e                   	pop    %esi
+ 75a:	5f                   	pop    %edi
+ 75b:	5d                   	pop    %ebp
+ 75c:	c3                   	ret    
+    if(p->s.size >= nunits){
+ 75d:	89 c2                	mov    %eax,%edx
+ 75f:	89 f8                	mov    %edi,%eax
+ 761:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+ 768:	39 ce                	cmp    %ecx,%esi
+ 76a:	74 54                	je     7c0 <malloc+0x100>
+        p->s.size -= nunits;
+ 76c:	29 f1                	sub    %esi,%ecx
+ 76e:	89 4a 04             	mov    %ecx,0x4(%edx)
+        p += p->s.size;
+ 771:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
+        p->s.size = nunits;
+ 774:	89 72 04             	mov    %esi,0x4(%edx)
+      freep = prevp;
+ 777:	a3 88 0a 00 00       	mov    %eax,0xa88
+}
+ 77c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return (void*)(p + 1);
+ 77f:	8d 42 08             	lea    0x8(%edx),%eax
+}
+ 782:	5b                   	pop    %ebx
+ 783:	5e                   	pop    %esi
+ 784:	5f                   	pop    %edi
+ 785:	5d                   	pop    %ebp
+ 786:	c3                   	ret    
+ 787:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 78e:	66 90                	xchg   %ax,%ax
+    base.s.ptr = freep = prevp = &base;
+ 790:	c7 05 88 0a 00 00 8c 	movl   $0xa8c,0xa88
+ 797:	0a 00 00 
+    base.s.size = 0;
+ 79a:	bf 8c 0a 00 00       	mov    $0xa8c,%edi
+    base.s.ptr = freep = prevp = &base;
+ 79f:	c7 05 8c 0a 00 00 8c 	movl   $0xa8c,0xa8c
+ 7a6:	0a 00 00 
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7a9:	89 f8                	mov    %edi,%eax
+    base.s.size = 0;
+ 7ab:	c7 05 90 0a 00 00 00 	movl   $0x0,0xa90
+ 7b2:	00 00 00 
+    if(p->s.size >= nunits){
+ 7b5:	e9 36 ff ff ff       	jmp    6f0 <malloc+0x30>
+ 7ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        prevp->s.ptr = p->s.ptr;
+ 7c0:	8b 0a                	mov    (%edx),%ecx
+ 7c2:	89 08                	mov    %ecx,(%eax)
+ 7c4:	eb b1                	jmp    777 <malloc+0xb7>
diff -ruN xv6-public/echo.d copy-xv6/echo.d
--- xv6-public/echo.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/echo.d	2022-09-05 23:26:11.836781093 +0530
@@ -0,0 +1 @@
+echo.o: echo.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/echo.o and copy-xv6/echo.o differ
diff -ruN xv6-public/echo.sym copy-xv6/echo.sym
--- xv6-public/echo.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/echo.sym	2022-09-05 23:26:11.848781093 +0530
@@ -0,0 +1,61 @@
+00000000 .text
+000007c8 .rodata
+000007ec .eh_frame
+00000a88 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 echo.c
+00000000 ulib.c
+00000000 printf.c
+000003b0 printint
+000007d8 digits.1097
+00000000 umalloc.c
+00000a88 freep
+00000a8c base
+00000080 strcpy
+00000460 printf
+0000039b thread_exit
+000002b0 memmove
+0000032b mknod
+000001a0 gets
+00000363 getpid
+000006c0 malloc
+00000373 sleep
+000002f3 pipe
+00000303 write
+0000033b fstat
+00000313 kill
+00000353 chdir
+0000031b exec
+000002eb wait
+000002fb read
+00000333 unlink
+000002db fork
+0000036b sbrk
+0000037b uptime
+00000a88 __bss_start
+00000140 memset
+00000000 main
+000000b0 strcmp
+0000035b dup
+00000220 stat
+00000a88 _edata
+00000a94 _end
+00000343 link
+000002e3 exit
+00000270 atoi
+00000383 draw
+00000100 strlen
+00000323 open
+00000160 strchr
+0000038b thread_create
+0000034b mkdir
+0000030b close
+00000393 thread_join
+00000630 free
Binary files xv6-public/entry.o and copy-xv6/entry.o differ
Binary files xv6-public/entryother and copy-xv6/entryother differ
diff -ruN xv6-public/entryother.asm copy-xv6/entryother.asm
--- xv6-public/entryother.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/entryother.asm	2022-09-05 23:26:13.852781049 +0530
@@ -0,0 +1,125 @@
+
+bootblockother.o:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00007000 <start>:
+# This code combines elements of bootasm.S and entry.S.
+
+.code16           
+.globl start
+start:
+  cli            
+    7000:	fa                   	cli    
+
+  # Zero data segment registers DS, ES, and SS.
+  xorw    %ax,%ax
+    7001:	31 c0                	xor    %eax,%eax
+  movw    %ax,%ds
+    7003:	8e d8                	mov    %eax,%ds
+  movw    %ax,%es
+    7005:	8e c0                	mov    %eax,%es
+  movw    %ax,%ss
+    7007:	8e d0                	mov    %eax,%ss
+
+  # Switch from real to protected mode.  Use a bootstrap GDT that makes
+  # virtual addresses map directly to physical addresses so that the
+  # effective memory map doesn't change during the transition.
+  lgdt    gdtdesc
+    7009:	0f 01 16             	lgdtl  (%esi)
+    700c:	84 70 0f             	test   %dh,0xf(%eax)
+  movl    %cr0, %eax
+    700f:	20 c0                	and    %al,%al
+  orl     $CR0_PE, %eax
+    7011:	66 83 c8 01          	or     $0x1,%ax
+  movl    %eax, %cr0
+    7015:	0f 22 c0             	mov    %eax,%cr0
+
+  # Complete the transition to 32-bit protected mode by using a long jmp
+  # to reload %cs and %eip.  The segment descriptors are set up with no
+  # translation, so that the mapping is still the identity mapping.
+  ljmpl    $(SEG_KCODE<<3), $(start32)
+    7018:	66 ea 20 70 00 00    	ljmpw  $0x0,$0x7020
+    701e:	08 00                	or     %al,(%eax)
+
+00007020 <start32>:
+
+//PAGEBREAK!
+.code32  # Tell assembler to generate 32-bit code now.
+start32:
+  # Set up the protected-mode data segment registers
+  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
+    7020:	66 b8 10 00          	mov    $0x10,%ax
+  movw    %ax, %ds                # -> DS: Data Segment
+    7024:	8e d8                	mov    %eax,%ds
+  movw    %ax, %es                # -> ES: Extra Segment
+    7026:	8e c0                	mov    %eax,%es
+  movw    %ax, %ss                # -> SS: Stack Segment
+    7028:	8e d0                	mov    %eax,%ss
+  movw    $0, %ax                 # Zero segments not ready for use
+    702a:	66 b8 00 00          	mov    $0x0,%ax
+  movw    %ax, %fs                # -> FS
+    702e:	8e e0                	mov    %eax,%fs
+  movw    %ax, %gs                # -> GS
+    7030:	8e e8                	mov    %eax,%gs
+
+  # Turn on page size extension for 4Mbyte pages
+  movl    %cr4, %eax
+    7032:	0f 20 e0             	mov    %cr4,%eax
+  orl     $(CR4_PSE), %eax
+    7035:	83 c8 10             	or     $0x10,%eax
+  movl    %eax, %cr4
+    7038:	0f 22 e0             	mov    %eax,%cr4
+  # Use entrypgdir as our initial page table
+  movl    (start-12), %eax
+    703b:	a1 f4 6f 00 00       	mov    0x6ff4,%eax
+  movl    %eax, %cr3
+    7040:	0f 22 d8             	mov    %eax,%cr3
+  # Turn on paging.
+  movl    %cr0, %eax
+    7043:	0f 20 c0             	mov    %cr0,%eax
+  orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
+    7046:	0d 01 00 01 80       	or     $0x80010001,%eax
+  movl    %eax, %cr0
+    704b:	0f 22 c0             	mov    %eax,%cr0
+
+  # Switch to the stack allocated by startothers()
+  movl    (start-4), %esp
+    704e:	8b 25 fc 6f 00 00    	mov    0x6ffc,%esp
+  # Call mpenter()
+  call	 *(start-8)
+    7054:	ff 15 f8 6f 00 00    	call   *0x6ff8
+
+  movw    $0x8a00, %ax
+    705a:	66 b8 00 8a          	mov    $0x8a00,%ax
+  movw    %ax, %dx
+    705e:	66 89 c2             	mov    %ax,%dx
+  outw    %ax, %dx
+    7061:	66 ef                	out    %ax,(%dx)
+  movw    $0x8ae0, %ax
+    7063:	66 b8 e0 8a          	mov    $0x8ae0,%ax
+  outw    %ax, %dx
+    7067:	66 ef                	out    %ax,(%dx)
+
+00007069 <spin>:
+spin:
+  jmp     spin
+    7069:	eb fe                	jmp    7069 <spin>
+    706b:	90                   	nop
+
+0000706c <gdt>:
+	...
+    7074:	ff                   	(bad)  
+    7075:	ff 00                	incl   (%eax)
+    7077:	00 00                	add    %al,(%eax)
+    7079:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
+    7080:	00                   	.byte 0x0
+    7081:	92                   	xchg   %eax,%edx
+    7082:	cf                   	iret   
+	...
+
+00007084 <gdtdesc>:
+    7084:	17                   	pop    %ss
+    7085:	00 6c 70 00          	add    %ch,0x0(%eax,%esi,2)
+	...
diff -ruN xv6-public/entryother.d copy-xv6/entryother.d
--- xv6-public/entryother.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/entryother.d	2022-09-05 23:26:13.844781049 +0530
@@ -0,0 +1 @@
+entryother.o: entryother.S asm.h memlayout.h mmu.h
Binary files xv6-public/entryother.o and copy-xv6/entryother.o differ
diff -ruN xv6-public/exec.d copy-xv6/exec.d
--- xv6-public/exec.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/exec.d	2022-09-05 23:26:12.852781074 +0530
@@ -0,0 +1,2 @@
+exec.o: exec.c /usr/include/stdc-predef.h types.h param.h memlayout.h \
+ mmu.h proc.h defs.h x86.h elf.h
Binary files xv6-public/exec.o and copy-xv6/exec.o differ
diff -ruN xv6-public/file.d copy-xv6/file.d
--- xv6-public/file.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/file.d	2022-09-05 23:26:12.888781073 +0530
@@ -0,0 +1,2 @@
+file.o: file.c /usr/include/stdc-predef.h types.h defs.h param.h fs.h \
+ spinlock.h sleeplock.h file.h
Binary files xv6-public/file.o and copy-xv6/file.o differ
Binary files xv6-public/_forktest and copy-xv6/_forktest differ
diff -ruN xv6-public/forktest.asm copy-xv6/forktest.asm
--- xv6-public/forktest.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/forktest.asm	2022-09-05 23:26:11.876781092 +0530
@@ -0,0 +1,704 @@
+
+_forktest:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+  printf(1, "fork test OK\n");
+}
+
+int
+main(void)
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	55                   	push   %ebp
+   5:	89 e5                	mov    %esp,%ebp
+   7:	83 e4 f0             	and    $0xfffffff0,%esp
+  forktest();
+   a:	e8 41 00 00 00       	call   50 <forktest>
+  exit();
+   f:	e8 9f 03 00 00       	call   3b3 <exit>
+  14:	66 90                	xchg   %ax,%ax
+  16:	66 90                	xchg   %ax,%ax
+  18:	66 90                	xchg   %ax,%ax
+  1a:	66 90                	xchg   %ax,%ax
+  1c:	66 90                	xchg   %ax,%ax
+  1e:	66 90                	xchg   %ax,%ax
+
+00000020 <printf>:
+{
+  20:	f3 0f 1e fb          	endbr32 
+  24:	55                   	push   %ebp
+  25:	89 e5                	mov    %esp,%ebp
+  27:	53                   	push   %ebx
+  28:	83 ec 10             	sub    $0x10,%esp
+  2b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  write(fd, s, strlen(s));
+  2e:	53                   	push   %ebx
+  2f:	e8 9c 01 00 00       	call   1d0 <strlen>
+  34:	83 c4 0c             	add    $0xc,%esp
+  37:	50                   	push   %eax
+  38:	53                   	push   %ebx
+  39:	ff 75 08             	pushl  0x8(%ebp)
+  3c:	e8 92 03 00 00       	call   3d3 <write>
+}
+  41:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+  44:	83 c4 10             	add    $0x10,%esp
+  47:	c9                   	leave  
+  48:	c3                   	ret    
+  49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00000050 <forktest>:
+{
+  50:	f3 0f 1e fb          	endbr32 
+  54:	55                   	push   %ebp
+  55:	89 e5                	mov    %esp,%ebp
+  57:	53                   	push   %ebx
+  for(n=0; n<N; n++){
+  58:	31 db                	xor    %ebx,%ebx
+{
+  5a:	83 ec 10             	sub    $0x10,%esp
+  write(fd, s, strlen(s));
+  5d:	68 74 04 00 00       	push   $0x474
+  62:	e8 69 01 00 00       	call   1d0 <strlen>
+  67:	83 c4 0c             	add    $0xc,%esp
+  6a:	50                   	push   %eax
+  6b:	68 74 04 00 00       	push   $0x474
+  70:	6a 01                	push   $0x1
+  72:	e8 5c 03 00 00       	call   3d3 <write>
+  77:	83 c4 10             	add    $0x10,%esp
+  7a:	eb 15                	jmp    91 <forktest+0x41>
+  7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    if(pid == 0)
+  80:	74 58                	je     da <forktest+0x8a>
+  for(n=0; n<N; n++){
+  82:	83 c3 01             	add    $0x1,%ebx
+  85:	81 fb e8 03 00 00    	cmp    $0x3e8,%ebx
+  8b:	0f 84 92 00 00 00    	je     123 <forktest+0xd3>
+    pid = fork();
+  91:	e8 15 03 00 00       	call   3ab <fork>
+    if(pid < 0)
+  96:	85 c0                	test   %eax,%eax
+  98:	79 e6                	jns    80 <forktest+0x30>
+  for(; n > 0; n--){
+  9a:	85 db                	test   %ebx,%ebx
+  9c:	74 10                	je     ae <forktest+0x5e>
+  9e:	66 90                	xchg   %ax,%ax
+    if(wait() < 0){
+  a0:	e8 16 03 00 00       	call   3bb <wait>
+  a5:	85 c0                	test   %eax,%eax
+  a7:	78 36                	js     df <forktest+0x8f>
+  for(; n > 0; n--){
+  a9:	83 eb 01             	sub    $0x1,%ebx
+  ac:	75 f2                	jne    a0 <forktest+0x50>
+  if(wait() != -1){
+  ae:	e8 08 03 00 00       	call   3bb <wait>
+  b3:	83 f8 ff             	cmp    $0xffffffff,%eax
+  b6:	75 49                	jne    101 <forktest+0xb1>
+  write(fd, s, strlen(s));
+  b8:	83 ec 0c             	sub    $0xc,%esp
+  bb:	68 a6 04 00 00       	push   $0x4a6
+  c0:	e8 0b 01 00 00       	call   1d0 <strlen>
+  c5:	83 c4 0c             	add    $0xc,%esp
+  c8:	50                   	push   %eax
+  c9:	68 a6 04 00 00       	push   $0x4a6
+  ce:	6a 01                	push   $0x1
+  d0:	e8 fe 02 00 00       	call   3d3 <write>
+}
+  d5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+  d8:	c9                   	leave  
+  d9:	c3                   	ret    
+      exit();
+  da:	e8 d4 02 00 00       	call   3b3 <exit>
+  write(fd, s, strlen(s));
+  df:	83 ec 0c             	sub    $0xc,%esp
+  e2:	68 7f 04 00 00       	push   $0x47f
+  e7:	e8 e4 00 00 00       	call   1d0 <strlen>
+  ec:	83 c4 0c             	add    $0xc,%esp
+  ef:	50                   	push   %eax
+  f0:	68 7f 04 00 00       	push   $0x47f
+  f5:	6a 01                	push   $0x1
+  f7:	e8 d7 02 00 00       	call   3d3 <write>
+      exit();
+  fc:	e8 b2 02 00 00       	call   3b3 <exit>
+  write(fd, s, strlen(s));
+ 101:	83 ec 0c             	sub    $0xc,%esp
+ 104:	68 93 04 00 00       	push   $0x493
+ 109:	e8 c2 00 00 00       	call   1d0 <strlen>
+ 10e:	83 c4 0c             	add    $0xc,%esp
+ 111:	50                   	push   %eax
+ 112:	68 93 04 00 00       	push   $0x493
+ 117:	6a 01                	push   $0x1
+ 119:	e8 b5 02 00 00       	call   3d3 <write>
+    exit();
+ 11e:	e8 90 02 00 00       	call   3b3 <exit>
+  write(fd, s, strlen(s));
+ 123:	83 ec 0c             	sub    $0xc,%esp
+ 126:	68 b4 04 00 00       	push   $0x4b4
+ 12b:	e8 a0 00 00 00       	call   1d0 <strlen>
+ 130:	83 c4 0c             	add    $0xc,%esp
+ 133:	50                   	push   %eax
+ 134:	68 b4 04 00 00       	push   $0x4b4
+ 139:	6a 01                	push   $0x1
+ 13b:	e8 93 02 00 00       	call   3d3 <write>
+    exit();
+ 140:	e8 6e 02 00 00       	call   3b3 <exit>
+ 145:	66 90                	xchg   %ax,%ax
+ 147:	66 90                	xchg   %ax,%ax
+ 149:	66 90                	xchg   %ax,%ax
+ 14b:	66 90                	xchg   %ax,%ax
+ 14d:	66 90                	xchg   %ax,%ax
+ 14f:	90                   	nop
+
+00000150 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 150:	f3 0f 1e fb          	endbr32 
+ 154:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+ 155:	31 c0                	xor    %eax,%eax
+{
+ 157:	89 e5                	mov    %esp,%ebp
+ 159:	53                   	push   %ebx
+ 15a:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 15d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+ 160:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+ 164:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+ 167:	83 c0 01             	add    $0x1,%eax
+ 16a:	84 d2                	test   %dl,%dl
+ 16c:	75 f2                	jne    160 <strcpy+0x10>
+    ;
+  return os;
+}
+ 16e:	89 c8                	mov    %ecx,%eax
+ 170:	5b                   	pop    %ebx
+ 171:	5d                   	pop    %ebp
+ 172:	c3                   	ret    
+ 173:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 17a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000180 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 180:	f3 0f 1e fb          	endbr32 
+ 184:	55                   	push   %ebp
+ 185:	89 e5                	mov    %esp,%ebp
+ 187:	53                   	push   %ebx
+ 188:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 18b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+ 18e:	0f b6 01             	movzbl (%ecx),%eax
+ 191:	0f b6 1a             	movzbl (%edx),%ebx
+ 194:	84 c0                	test   %al,%al
+ 196:	75 19                	jne    1b1 <strcmp+0x31>
+ 198:	eb 26                	jmp    1c0 <strcmp+0x40>
+ 19a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 1a0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+ 1a4:	83 c1 01             	add    $0x1,%ecx
+ 1a7:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+ 1aa:	0f b6 1a             	movzbl (%edx),%ebx
+ 1ad:	84 c0                	test   %al,%al
+ 1af:	74 0f                	je     1c0 <strcmp+0x40>
+ 1b1:	38 d8                	cmp    %bl,%al
+ 1b3:	74 eb                	je     1a0 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+ 1b5:	29 d8                	sub    %ebx,%eax
+}
+ 1b7:	5b                   	pop    %ebx
+ 1b8:	5d                   	pop    %ebp
+ 1b9:	c3                   	ret    
+ 1ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 1c0:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+ 1c2:	29 d8                	sub    %ebx,%eax
+}
+ 1c4:	5b                   	pop    %ebx
+ 1c5:	5d                   	pop    %ebp
+ 1c6:	c3                   	ret    
+ 1c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1ce:	66 90                	xchg   %ax,%ax
+
+000001d0 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 1d0:	f3 0f 1e fb          	endbr32 
+ 1d4:	55                   	push   %ebp
+ 1d5:	89 e5                	mov    %esp,%ebp
+ 1d7:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 1da:	80 3a 00             	cmpb   $0x0,(%edx)
+ 1dd:	74 21                	je     200 <strlen+0x30>
+ 1df:	31 c0                	xor    %eax,%eax
+ 1e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1e8:	83 c0 01             	add    $0x1,%eax
+ 1eb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+ 1ef:	89 c1                	mov    %eax,%ecx
+ 1f1:	75 f5                	jne    1e8 <strlen+0x18>
+    ;
+  return n;
+}
+ 1f3:	89 c8                	mov    %ecx,%eax
+ 1f5:	5d                   	pop    %ebp
+ 1f6:	c3                   	ret    
+ 1f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1fe:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+ 200:	31 c9                	xor    %ecx,%ecx
+}
+ 202:	5d                   	pop    %ebp
+ 203:	89 c8                	mov    %ecx,%eax
+ 205:	c3                   	ret    
+ 206:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 20d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000210 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 210:	f3 0f 1e fb          	endbr32 
+ 214:	55                   	push   %ebp
+ 215:	89 e5                	mov    %esp,%ebp
+ 217:	57                   	push   %edi
+ 218:	8b 55 08             	mov    0x8(%ebp),%edx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+ 21b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 21e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 221:	89 d7                	mov    %edx,%edi
+ 223:	fc                   	cld    
+ 224:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+ 226:	89 d0                	mov    %edx,%eax
+ 228:	5f                   	pop    %edi
+ 229:	5d                   	pop    %ebp
+ 22a:	c3                   	ret    
+ 22b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 22f:	90                   	nop
+
+00000230 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 230:	f3 0f 1e fb          	endbr32 
+ 234:	55                   	push   %ebp
+ 235:	89 e5                	mov    %esp,%ebp
+ 237:	8b 45 08             	mov    0x8(%ebp),%eax
+ 23a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+ 23e:	0f b6 10             	movzbl (%eax),%edx
+ 241:	84 d2                	test   %dl,%dl
+ 243:	75 16                	jne    25b <strchr+0x2b>
+ 245:	eb 21                	jmp    268 <strchr+0x38>
+ 247:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 24e:	66 90                	xchg   %ax,%ax
+ 250:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+ 254:	83 c0 01             	add    $0x1,%eax
+ 257:	84 d2                	test   %dl,%dl
+ 259:	74 0d                	je     268 <strchr+0x38>
+    if(*s == c)
+ 25b:	38 d1                	cmp    %dl,%cl
+ 25d:	75 f1                	jne    250 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+ 25f:	5d                   	pop    %ebp
+ 260:	c3                   	ret    
+ 261:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+ 268:	31 c0                	xor    %eax,%eax
+}
+ 26a:	5d                   	pop    %ebp
+ 26b:	c3                   	ret    
+ 26c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000270 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 270:	f3 0f 1e fb          	endbr32 
+ 274:	55                   	push   %ebp
+ 275:	89 e5                	mov    %esp,%ebp
+ 277:	57                   	push   %edi
+ 278:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 279:	31 f6                	xor    %esi,%esi
+{
+ 27b:	53                   	push   %ebx
+ 27c:	89 f3                	mov    %esi,%ebx
+ 27e:	83 ec 1c             	sub    $0x1c,%esp
+ 281:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+ 284:	eb 33                	jmp    2b9 <gets+0x49>
+ 286:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 28d:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+ 290:	83 ec 04             	sub    $0x4,%esp
+ 293:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ 296:	6a 01                	push   $0x1
+ 298:	50                   	push   %eax
+ 299:	6a 00                	push   $0x0
+ 29b:	e8 2b 01 00 00       	call   3cb <read>
+    if(cc < 1)
+ 2a0:	83 c4 10             	add    $0x10,%esp
+ 2a3:	85 c0                	test   %eax,%eax
+ 2a5:	7e 1c                	jle    2c3 <gets+0x53>
+      break;
+    buf[i++] = c;
+ 2a7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ 2ab:	83 c7 01             	add    $0x1,%edi
+ 2ae:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+ 2b1:	3c 0a                	cmp    $0xa,%al
+ 2b3:	74 23                	je     2d8 <gets+0x68>
+ 2b5:	3c 0d                	cmp    $0xd,%al
+ 2b7:	74 1f                	je     2d8 <gets+0x68>
+  for(i=0; i+1 < max; ){
+ 2b9:	83 c3 01             	add    $0x1,%ebx
+ 2bc:	89 fe                	mov    %edi,%esi
+ 2be:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+ 2c1:	7c cd                	jl     290 <gets+0x20>
+ 2c3:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+ 2c5:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+ 2c8:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 2cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 2ce:	5b                   	pop    %ebx
+ 2cf:	5e                   	pop    %esi
+ 2d0:	5f                   	pop    %edi
+ 2d1:	5d                   	pop    %ebp
+ 2d2:	c3                   	ret    
+ 2d3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 2d7:	90                   	nop
+ 2d8:	8b 75 08             	mov    0x8(%ebp),%esi
+ 2db:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2de:	01 de                	add    %ebx,%esi
+ 2e0:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+ 2e2:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 2e5:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 2e8:	5b                   	pop    %ebx
+ 2e9:	5e                   	pop    %esi
+ 2ea:	5f                   	pop    %edi
+ 2eb:	5d                   	pop    %ebp
+ 2ec:	c3                   	ret    
+ 2ed:	8d 76 00             	lea    0x0(%esi),%esi
+
+000002f0 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 2f0:	f3 0f 1e fb          	endbr32 
+ 2f4:	55                   	push   %ebp
+ 2f5:	89 e5                	mov    %esp,%ebp
+ 2f7:	56                   	push   %esi
+ 2f8:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 2f9:	83 ec 08             	sub    $0x8,%esp
+ 2fc:	6a 00                	push   $0x0
+ 2fe:	ff 75 08             	pushl  0x8(%ebp)
+ 301:	e8 ed 00 00 00       	call   3f3 <open>
+  if(fd < 0)
+ 306:	83 c4 10             	add    $0x10,%esp
+ 309:	85 c0                	test   %eax,%eax
+ 30b:	78 2b                	js     338 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+ 30d:	83 ec 08             	sub    $0x8,%esp
+ 310:	ff 75 0c             	pushl  0xc(%ebp)
+ 313:	89 c3                	mov    %eax,%ebx
+ 315:	50                   	push   %eax
+ 316:	e8 f0 00 00 00       	call   40b <fstat>
+  close(fd);
+ 31b:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+ 31e:	89 c6                	mov    %eax,%esi
+  close(fd);
+ 320:	e8 b6 00 00 00       	call   3db <close>
+  return r;
+ 325:	83 c4 10             	add    $0x10,%esp
+}
+ 328:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 32b:	89 f0                	mov    %esi,%eax
+ 32d:	5b                   	pop    %ebx
+ 32e:	5e                   	pop    %esi
+ 32f:	5d                   	pop    %ebp
+ 330:	c3                   	ret    
+ 331:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+ 338:	be ff ff ff ff       	mov    $0xffffffff,%esi
+ 33d:	eb e9                	jmp    328 <stat+0x38>
+ 33f:	90                   	nop
+
+00000340 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 340:	f3 0f 1e fb          	endbr32 
+ 344:	55                   	push   %ebp
+ 345:	89 e5                	mov    %esp,%ebp
+ 347:	53                   	push   %ebx
+ 348:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 34b:	0f be 02             	movsbl (%edx),%eax
+ 34e:	8d 48 d0             	lea    -0x30(%eax),%ecx
+ 351:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+ 354:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+ 359:	77 1a                	ja     375 <atoi+0x35>
+ 35b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 35f:	90                   	nop
+    n = n*10 + *s++ - '0';
+ 360:	83 c2 01             	add    $0x1,%edx
+ 363:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+ 366:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+ 36a:	0f be 02             	movsbl (%edx),%eax
+ 36d:	8d 58 d0             	lea    -0x30(%eax),%ebx
+ 370:	80 fb 09             	cmp    $0x9,%bl
+ 373:	76 eb                	jbe    360 <atoi+0x20>
+  return n;
+}
+ 375:	89 c8                	mov    %ecx,%eax
+ 377:	5b                   	pop    %ebx
+ 378:	5d                   	pop    %ebp
+ 379:	c3                   	ret    
+ 37a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000380 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 380:	f3 0f 1e fb          	endbr32 
+ 384:	55                   	push   %ebp
+ 385:	89 e5                	mov    %esp,%ebp
+ 387:	57                   	push   %edi
+ 388:	8b 45 10             	mov    0x10(%ebp),%eax
+ 38b:	8b 55 08             	mov    0x8(%ebp),%edx
+ 38e:	56                   	push   %esi
+ 38f:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 392:	85 c0                	test   %eax,%eax
+ 394:	7e 0f                	jle    3a5 <memmove+0x25>
+ 396:	01 d0                	add    %edx,%eax
+  dst = vdst;
+ 398:	89 d7                	mov    %edx,%edi
+ 39a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+ 3a0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+ 3a1:	39 f8                	cmp    %edi,%eax
+ 3a3:	75 fb                	jne    3a0 <memmove+0x20>
+  return vdst;
+}
+ 3a5:	5e                   	pop    %esi
+ 3a6:	89 d0                	mov    %edx,%eax
+ 3a8:	5f                   	pop    %edi
+ 3a9:	5d                   	pop    %ebp
+ 3aa:	c3                   	ret    
+
+000003ab <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 3ab:	b8 01 00 00 00       	mov    $0x1,%eax
+ 3b0:	cd 40                	int    $0x40
+ 3b2:	c3                   	ret    
+
+000003b3 <exit>:
+SYSCALL(exit)
+ 3b3:	b8 02 00 00 00       	mov    $0x2,%eax
+ 3b8:	cd 40                	int    $0x40
+ 3ba:	c3                   	ret    
+
+000003bb <wait>:
+SYSCALL(wait)
+ 3bb:	b8 03 00 00 00       	mov    $0x3,%eax
+ 3c0:	cd 40                	int    $0x40
+ 3c2:	c3                   	ret    
+
+000003c3 <pipe>:
+SYSCALL(pipe)
+ 3c3:	b8 04 00 00 00       	mov    $0x4,%eax
+ 3c8:	cd 40                	int    $0x40
+ 3ca:	c3                   	ret    
+
+000003cb <read>:
+SYSCALL(read)
+ 3cb:	b8 05 00 00 00       	mov    $0x5,%eax
+ 3d0:	cd 40                	int    $0x40
+ 3d2:	c3                   	ret    
+
+000003d3 <write>:
+SYSCALL(write)
+ 3d3:	b8 10 00 00 00       	mov    $0x10,%eax
+ 3d8:	cd 40                	int    $0x40
+ 3da:	c3                   	ret    
+
+000003db <close>:
+SYSCALL(close)
+ 3db:	b8 15 00 00 00       	mov    $0x15,%eax
+ 3e0:	cd 40                	int    $0x40
+ 3e2:	c3                   	ret    
+
+000003e3 <kill>:
+SYSCALL(kill)
+ 3e3:	b8 06 00 00 00       	mov    $0x6,%eax
+ 3e8:	cd 40                	int    $0x40
+ 3ea:	c3                   	ret    
+
+000003eb <exec>:
+SYSCALL(exec)
+ 3eb:	b8 07 00 00 00       	mov    $0x7,%eax
+ 3f0:	cd 40                	int    $0x40
+ 3f2:	c3                   	ret    
+
+000003f3 <open>:
+SYSCALL(open)
+ 3f3:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 3f8:	cd 40                	int    $0x40
+ 3fa:	c3                   	ret    
+
+000003fb <mknod>:
+SYSCALL(mknod)
+ 3fb:	b8 11 00 00 00       	mov    $0x11,%eax
+ 400:	cd 40                	int    $0x40
+ 402:	c3                   	ret    
+
+00000403 <unlink>:
+SYSCALL(unlink)
+ 403:	b8 12 00 00 00       	mov    $0x12,%eax
+ 408:	cd 40                	int    $0x40
+ 40a:	c3                   	ret    
+
+0000040b <fstat>:
+SYSCALL(fstat)
+ 40b:	b8 08 00 00 00       	mov    $0x8,%eax
+ 410:	cd 40                	int    $0x40
+ 412:	c3                   	ret    
+
+00000413 <link>:
+SYSCALL(link)
+ 413:	b8 13 00 00 00       	mov    $0x13,%eax
+ 418:	cd 40                	int    $0x40
+ 41a:	c3                   	ret    
+
+0000041b <mkdir>:
+SYSCALL(mkdir)
+ 41b:	b8 14 00 00 00       	mov    $0x14,%eax
+ 420:	cd 40                	int    $0x40
+ 422:	c3                   	ret    
+
+00000423 <chdir>:
+SYSCALL(chdir)
+ 423:	b8 09 00 00 00       	mov    $0x9,%eax
+ 428:	cd 40                	int    $0x40
+ 42a:	c3                   	ret    
+
+0000042b <dup>:
+SYSCALL(dup)
+ 42b:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 430:	cd 40                	int    $0x40
+ 432:	c3                   	ret    
+
+00000433 <getpid>:
+SYSCALL(getpid)
+ 433:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 438:	cd 40                	int    $0x40
+ 43a:	c3                   	ret    
+
+0000043b <sbrk>:
+SYSCALL(sbrk)
+ 43b:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 440:	cd 40                	int    $0x40
+ 442:	c3                   	ret    
+
+00000443 <sleep>:
+SYSCALL(sleep)
+ 443:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 448:	cd 40                	int    $0x40
+ 44a:	c3                   	ret    
+
+0000044b <uptime>:
+SYSCALL(uptime)
+ 44b:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 450:	cd 40                	int    $0x40
+ 452:	c3                   	ret    
+
+00000453 <draw>:
+SYSCALL(draw)
+ 453:	b8 16 00 00 00       	mov    $0x16,%eax
+ 458:	cd 40                	int    $0x40
+ 45a:	c3                   	ret    
+
+0000045b <thread_create>:
+
+SYSCALL(thread_create)
+ 45b:	b8 17 00 00 00       	mov    $0x17,%eax
+ 460:	cd 40                	int    $0x40
+ 462:	c3                   	ret    
+
+00000463 <thread_join>:
+SYSCALL(thread_join)
+ 463:	b8 18 00 00 00       	mov    $0x18,%eax
+ 468:	cd 40                	int    $0x40
+ 46a:	c3                   	ret    
+
+0000046b <thread_exit>:
+SYSCALL(thread_exit)
+ 46b:	b8 19 00 00 00       	mov    $0x19,%eax
+ 470:	cd 40                	int    $0x40
+ 472:	c3                   	ret    
diff -ruN xv6-public/forktest.d copy-xv6/forktest.d
--- xv6-public/forktest.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/forktest.d	2022-09-05 23:26:11.864781093 +0530
@@ -0,0 +1 @@
+forktest.o: forktest.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/forktest.o and copy-xv6/forktest.o differ
diff -ruN xv6-public/fs.d copy-xv6/fs.d
--- xv6-public/fs.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/fs.d	2022-09-05 23:26:13.000781071 +0530
@@ -0,0 +1,2 @@
+fs.o: fs.c /usr/include/stdc-predef.h types.h defs.h param.h stat.h mmu.h \
+ proc.h spinlock.h sleeplock.h fs.h buf.h file.h
Binary files xv6-public/fs.img and copy-xv6/fs.img differ
Binary files xv6-public/fs.o and copy-xv6/fs.o differ
diff -ruN xv6-public/.git/COMMIT_EDITMSG copy-xv6/.git/COMMIT_EDITMSG
--- xv6-public/.git/COMMIT_EDITMSG	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/.git/COMMIT_EDITMSG	2022-09-04 00:27:53.604875000 +0530
@@ -0,0 +1 @@
+git init threads working using for ref:https://github.com/bravadoops/cs238p_hw4
diff -ruN xv6-public/.git/config copy-xv6/.git/config
--- xv6-public/.git/config	2022-09-05 23:23:48.532715193 +0530
+++ copy-xv6/.git/config	2022-08-08 10:54:15.836938000 +0530
@@ -3,6 +3,8 @@
 	filemode = true
 	bare = false
 	logallrefupdates = true
+[submodule]
+	active = .
 [remote "origin"]
 	url = https://github.com/mit-pdos/xv6-public.git
 	fetch = +refs/heads/*:refs/remotes/origin/*
diff -ruN xv6-public/.git/hooks/fsmonitor-watchman.sample copy-xv6/.git/hooks/fsmonitor-watchman.sample
--- xv6-public/.git/hooks/fsmonitor-watchman.sample	2022-09-05 23:23:36.148702407 +0530
+++ copy-xv6/.git/hooks/fsmonitor-watchman.sample	2022-08-08 10:54:07.225025000 +0530
@@ -8,102 +8,166 @@
 # (https://facebook.github.io/watchman/) with git to speed up detecting
 # new and modified files.
 #
-# The hook is passed a version (currently 1) and a time in nanoseconds
-# formatted as a string and outputs to stdout all files that have been
-# modified since the given time. Paths must be relative to the root of
-# the working tree and separated by a single NUL.
+# The hook is passed a version (currently 2) and last update token
+# formatted as a string and outputs to stdout a new update token and
+# all files that have been modified since the update token. Paths must
+# be relative to the root of the working tree and separated by a single NUL.
 #
 # To enable this hook, rename this file to "query-watchman" and set
 # 'git config core.fsmonitor .git/hooks/query-watchman'
 #
-my ($version, $time) = @ARGV;
+my ($version, $last_update_token) = @ARGV;
 
-# Check the hook interface version
+# Uncomment for debugging
+# print STDERR "$0 $version $last_update_token\n";
 
-if ($version == 1) {
-	# convert nanoseconds to seconds
-	# subtract one second to make sure watchman will return all changes
-	$time = int ($time / 1000000000) - 1;
-} else {
+# Check the hook interface version
+if ($version ne 2) {
 	die "Unsupported query-fsmonitor hook version '$version'.\n" .
 	    "Falling back to scanning...\n";
 }
 
-my $git_work_tree;
-if ($^O =~ 'msys' || $^O =~ 'cygwin') {
-	$git_work_tree = Win32::GetCwd();
-	$git_work_tree =~ tr/\\/\//;
-} else {
-	require Cwd;
-	$git_work_tree = Cwd::cwd();
-}
+my $git_work_tree = get_working_dir();
 
 my $retry = 1;
 
+my $json_pkg;
+eval {
+	require JSON::XS;
+	$json_pkg = "JSON::XS";
+	1;
+} or do {
+	require JSON::PP;
+	$json_pkg = "JSON::PP";
+};
+
 launch_watchman();
 
 sub launch_watchman {
+	my $o = watchman_query();
+	if (is_work_tree_watched($o)) {
+		output_result($o->{clock}, @{$o->{files}});
+	}
+}
+
+sub output_result {
+	my ($clockid, @files) = @_;
+
+	# Uncomment for debugging watchman output
+	# open (my $fh, ">", ".git/watchman-output.out");
+	# binmode $fh, ":utf8";
+	# print $fh "$clockid\n@files\n";
+	# close $fh;
 
+	binmode STDOUT, ":utf8";
+	print $clockid;
+	print "\0";
+	local $, = "\0";
+	print @files;
+}
+
+sub watchman_clock {
+	my $response = qx/watchman clock "$git_work_tree"/;
+	die "Failed to get clock id on '$git_work_tree'.\n" .
+		"Falling back to scanning...\n" if $? != 0;
+
+	return $json_pkg->new->utf8->decode($response);
+}
+
+sub watchman_query {
 	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
-	    or die "open2() failed: $!\n" .
-	    "Falling back to scanning...\n";
+	or die "open2() failed: $!\n" .
+	"Falling back to scanning...\n";
 
 	# In the query expression below we're asking for names of files that
-	# changed since $time but were not transient (ie created after
-	# $time but no longer exist).
+	# changed since $last_update_token but not from the .git folder.
 	#
 	# To accomplish this, we're using the "since" generator to use the
 	# recency index to select candidate nodes and "fields" to limit the
-	# output to file names only.
-
+	# output to file names only. Then we're using the "expression" term to
+	# further constrain the results.
+	if (substr($last_update_token, 0, 1) eq "c") {
+		$last_update_token = "\"$last_update_token\"";
+	}
 	my $query = <<"	END";
 		["query", "$git_work_tree", {
-			"since": $time,
-			"fields": ["name"]
+			"since": $last_update_token,
+			"fields": ["name"],
+			"expression": ["not", ["dirname", ".git"]]
 		}]
 	END
 
+	# Uncomment for debugging the watchman query
+	# open (my $fh, ">", ".git/watchman-query.json");
+	# print $fh $query;
+	# close $fh;
+
 	print CHLD_IN $query;
 	close CHLD_IN;
 	my $response = do {local $/; <CHLD_OUT>};
 
+	# Uncomment for debugging the watch response
+	# open ($fh, ">", ".git/watchman-response.json");
+	# print $fh $response;
+	# close $fh;
+
 	die "Watchman: command returned no output.\n" .
-	    "Falling back to scanning...\n" if $response eq "";
+	"Falling back to scanning...\n" if $response eq "";
 	die "Watchman: command returned invalid output: $response\n" .
-	    "Falling back to scanning...\n" unless $response =~ /^\{/;
+	"Falling back to scanning...\n" unless $response =~ /^\{/;
 
-	my $json_pkg;
-	eval {
-		require JSON::XS;
-		$json_pkg = "JSON::XS";
-		1;
-	} or do {
-		require JSON::PP;
-		$json_pkg = "JSON::PP";
-	};
-
-	my $o = $json_pkg->new->utf8->decode($response);
+	return $json_pkg->new->utf8->decode($response);
+}
 
-	if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
-		print STDERR "Adding '$git_work_tree' to watchman's watch list.\n";
+sub is_work_tree_watched {
+	my ($output) = @_;
+	my $error = $output->{error};
+	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
 		$retry--;
-		qx/watchman watch "$git_work_tree"/;
+		my $response = qx/watchman watch "$git_work_tree"/;
 		die "Failed to make watchman watch '$git_work_tree'.\n" .
 		    "Falling back to scanning...\n" if $? != 0;
+		$output = $json_pkg->new->utf8->decode($response);
+		$error = $output->{error};
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		# Uncomment for debugging watchman output
+		# open (my $fh, ">", ".git/watchman-output.out");
+		# close $fh;
 
 		# Watchman will always return all files on the first query so
 		# return the fast "everything is dirty" flag to git and do the
 		# Watchman query just to get it over with now so we won't pay
 		# the cost in git to look up each individual file.
-		print "/\0";
+		my $o = watchman_clock();
+		$error = $output->{error};
+
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		output_result($o->{clock}, ("/"));
+		$last_update_token = $o->{clock};
+
 		eval { launch_watchman() };
-		exit 0;
+		return 0;
 	}
 
-	die "Watchman: $o->{error}.\n" .
-	    "Falling back to scanning...\n" if $o->{error};
+	die "Watchman: $error.\n" .
+	"Falling back to scanning...\n" if $error;
 
-	binmode STDOUT, ":utf8";
-	local $, = "\0";
-	print @{$o->{files}};
+	return 1;
+}
+
+sub get_working_dir {
+	my $working_dir;
+	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
+		$working_dir = Win32::GetCwd();
+		$working_dir =~ tr/\\/\//;
+	} else {
+		require Cwd;
+		$working_dir = Cwd::cwd();
+	}
+
+	return $working_dir;
 }
diff -ruN xv6-public/.git/hooks/pre-commit.sample copy-xv6/.git/hooks/pre-commit.sample
--- xv6-public/.git/hooks/pre-commit.sample	2022-09-05 23:23:36.148702407 +0530
+++ copy-xv6/.git/hooks/pre-commit.sample	2022-08-08 10:54:07.225025000 +0530
@@ -16,7 +16,7 @@
 fi
 
 # If you want to allow non-ASCII filenames set this variable to true.
-allownonascii=$(git config --bool hooks.allownonascii)
+allownonascii=$(git config --type=bool hooks.allownonascii)
 
 # Redirect output to stderr.
 exec 1>&2
diff -ruN xv6-public/.git/hooks/pre-push.sample copy-xv6/.git/hooks/pre-push.sample
--- xv6-public/.git/hooks/pre-push.sample	2022-09-05 23:23:36.148702407 +0530
+++ copy-xv6/.git/hooks/pre-push.sample	2022-08-08 10:54:07.225025000 +0530
@@ -14,7 +14,7 @@
 # Information about the commits which are being pushed is supplied as lines to
 # the standard input in the form:
 #
-#   <local ref> <local sha1> <remote ref> <remote sha1>
+#   <local ref> <local oid> <remote ref> <remote oid>
 #
 # This sample shows how to prevent push of commits where the log message starts
 # with "WIP" (work in progress).
@@ -22,27 +22,27 @@
 remote="$1"
 url="$2"
 
-z40=0000000000000000000000000000000000000000
+zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
 
-while read local_ref local_sha remote_ref remote_sha
+while read local_ref local_oid remote_ref remote_oid
 do
-	if [ "$local_sha" = $z40 ]
+	if test "$local_oid" = "$zero"
 	then
 		# Handle delete
 		:
 	else
-		if [ "$remote_sha" = $z40 ]
+		if test "$remote_oid" = "$zero"
 		then
 			# New branch, examine all commits
-			range="$local_sha"
+			range="$local_oid"
 		else
 			# Update to existing branch, examine new commits
-			range="$remote_sha..$local_sha"
+			range="$remote_oid..$local_oid"
 		fi
 
 		# Check for WIP commit
-		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
-		if [ -n "$commit" ]
+		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
+		if test -n "$commit"
 		then
 			echo >&2 "Found WIP commit in $local_ref, not pushing"
 			exit 1
diff -ruN xv6-public/.git/hooks/update.sample copy-xv6/.git/hooks/update.sample
--- xv6-public/.git/hooks/update.sample	2022-09-05 23:23:36.148702407 +0530
+++ copy-xv6/.git/hooks/update.sample	2022-08-08 10:54:07.225025000 +0530
@@ -43,11 +43,11 @@
 fi
 
 # --- Config
-allowunannotated=$(git config --bool hooks.allowunannotated)
-allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
-denycreatebranch=$(git config --bool hooks.denycreatebranch)
-allowdeletetag=$(git config --bool hooks.allowdeletetag)
-allowmodifytag=$(git config --bool hooks.allowmodifytag)
+allowunannotated=$(git config --type=bool hooks.allowunannotated)
+allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
+allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
+allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
 
 # check for no description
 projectdesc=$(sed -e '1q' "$GIT_DIR/description")
@@ -60,7 +60,7 @@
 
 # --- Check types
 # if $newrev is 0000...0000, it's a commit to delete a ref.
-zero="0000000000000000000000000000000000000000"
+zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
 if [ "$newrev" = "$zero" ]; then
 	newrev_type=delete
 else
Binary files xv6-public/.git/index and copy-xv6/.git/index differ
diff -ruN xv6-public/.git/logs/HEAD copy-xv6/.git/logs/HEAD
--- xv6-public/.git/logs/HEAD	2022-09-05 23:23:48.532715193 +0530
+++ copy-xv6/.git/logs/HEAD	2022-09-04 00:27:53.604875000 +0530
@@ -1 +1,2 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Vatsal Gupta <vatsal.gupta0804@gmail.com> 1662400428 +0530	clone: from https://github.com/mit-pdos/xv6-public.git
+0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Vatsal Gupta <vatsal.gupta0804@gmail.com> 1659936255 +0530	clone: from https://github.com/mit-pdos/xv6-public.git
+eeb7b415dbcb12cc362d0783e41c3d1f44066b17 f97b076fcabb46d190485c251fccb7dc0c2217ca Vatsal Gupta <vatsal.gupta0804@gmail.com> 1662231473 +0530	commit: git init threads working using for ref:https://github.com/bravadoops/cs238p_hw4
diff -ruN xv6-public/.git/logs/refs/heads/master copy-xv6/.git/logs/refs/heads/master
--- xv6-public/.git/logs/refs/heads/master	2022-09-05 23:23:48.532715193 +0530
+++ copy-xv6/.git/logs/refs/heads/master	2022-09-04 00:27:53.604875000 +0530
@@ -1 +1,2 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Vatsal Gupta <vatsal.gupta0804@gmail.com> 1662400428 +0530	clone: from https://github.com/mit-pdos/xv6-public.git
+0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Vatsal Gupta <vatsal.gupta0804@gmail.com> 1659936255 +0530	clone: from https://github.com/mit-pdos/xv6-public.git
+eeb7b415dbcb12cc362d0783e41c3d1f44066b17 f97b076fcabb46d190485c251fccb7dc0c2217ca Vatsal Gupta <vatsal.gupta0804@gmail.com> 1662231473 +0530	commit: git init threads working using for ref:https://github.com/bravadoops/cs238p_hw4
diff -ruN xv6-public/.git/logs/refs/remotes/origin/HEAD copy-xv6/.git/logs/refs/remotes/origin/HEAD
--- xv6-public/.git/logs/refs/remotes/origin/HEAD	2022-09-05 23:23:48.532715193 +0530
+++ copy-xv6/.git/logs/refs/remotes/origin/HEAD	2022-08-08 10:54:15.836938000 +0530
@@ -1 +1 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Vatsal Gupta <vatsal.gupta0804@gmail.com> 1662400428 +0530	clone: from https://github.com/mit-pdos/xv6-public.git
+0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Vatsal Gupta <vatsal.gupta0804@gmail.com> 1659936255 +0530	clone: from https://github.com/mit-pdos/xv6-public.git
Binary files xv6-public/.git/objects/1a/cb6f05476de3744863a3572425ae361586e68e and copy-xv6/.git/objects/1a/cb6f05476de3744863a3572425ae361586e68e differ
Binary files xv6-public/.git/objects/23/cbdcbea155a075b3dd31457598be5672986dde and copy-xv6/.git/objects/23/cbdcbea155a075b3dd31457598be5672986dde differ
Binary files xv6-public/.git/objects/25/e8ecfd3732f1f267085214c7d4c085c4c0e4bf and copy-xv6/.git/objects/25/e8ecfd3732f1f267085214c7d4c085c4c0e4bf differ
Binary files xv6-public/.git/objects/27/9f50e14553e616301204339745ecc758d5bb81 and copy-xv6/.git/objects/27/9f50e14553e616301204339745ecc758d5bb81 differ
Binary files xv6-public/.git/objects/2d/be283ed2b0df3b7e0160eecbe2d0dd7b9a800d and copy-xv6/.git/objects/2d/be283ed2b0df3b7e0160eecbe2d0dd7b9a800d differ
diff -ruN xv6-public/.git/objects/47/cce1643f83247ab8fa8657dc4918ef8eb49157 copy-xv6/.git/objects/47/cce1643f83247ab8fa8657dc4918ef8eb49157
--- xv6-public/.git/objects/47/cce1643f83247ab8fa8657dc4918ef8eb49157	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/.git/objects/47/cce1643f83247ab8fa8657dc4918ef8eb49157	2022-09-04 00:27:53.596874000 +0530
@@ -0,0 +1,2 @@
+xU
+0D~%RH$H+H?E]IJ1-yEw7n8sf;8iH|Q"/pl'TE6$<i<P->#m9Q^1:;KG?g;V.J?L9}=
\ No newline at end of file
Binary files xv6-public/.git/objects/4f/e132994e237a457431fb3aaa3626fcb7e9b40e and copy-xv6/.git/objects/4f/e132994e237a457431fb3aaa3626fcb7e9b40e differ
Binary files xv6-public/.git/objects/64/d98bb239dd9b694f2ec18b3f45def7bae16f6c and copy-xv6/.git/objects/64/d98bb239dd9b694f2ec18b3f45def7bae16f6c differ
Binary files xv6-public/.git/objects/7e/edffcf88489350a4caca0e4412e957f1e7934b and copy-xv6/.git/objects/7e/edffcf88489350a4caca0e4412e957f1e7934b differ
Binary files xv6-public/.git/objects/8e/ce9aaf67d03b0e1674f58777e31e9623b64b56 and copy-xv6/.git/objects/8e/ce9aaf67d03b0e1674f58777e31e9623b64b56 differ
Binary files xv6-public/.git/objects/9b/7f7322fef3614fdf9056dfd8cfd1aae48324ae and copy-xv6/.git/objects/9b/7f7322fef3614fdf9056dfd8cfd1aae48324ae differ
Binary files xv6-public/.git/objects/9f/2b138d3362c6331ccce0ac0eaf4403b098dec9 and copy-xv6/.git/objects/9f/2b138d3362c6331ccce0ac0eaf4403b098dec9 differ
Binary files xv6-public/.git/objects/9f/91a8df935a89f558900d285fa1bba85236b7a1 and copy-xv6/.git/objects/9f/91a8df935a89f558900d285fa1bba85236b7a1 differ
Binary files xv6-public/.git/objects/a2/186092b864a1842c7441c01817d853c87b5486 and copy-xv6/.git/objects/a2/186092b864a1842c7441c01817d853c87b5486 differ
Binary files xv6-public/.git/objects/a8/578c69d7cc421d3a4a08d2996bd3f90685105c and copy-xv6/.git/objects/a8/578c69d7cc421d3a4a08d2996bd3f90685105c differ
Binary files xv6-public/.git/objects/b3/96187a2bde18cf0b537d0e15e2ed537f2e239c and copy-xv6/.git/objects/b3/96187a2bde18cf0b537d0e15e2ed537f2e239c differ
Binary files xv6-public/.git/objects/cc/37d9cba4f7ebf4c98ea6361458539c5000992c and copy-xv6/.git/objects/cc/37d9cba4f7ebf4c98ea6361458539c5000992c differ
Binary files xv6-public/.git/objects/ec/93cf5bf8d39ce6174ce807083a505519622022 and copy-xv6/.git/objects/ec/93cf5bf8d39ce6174ce807083a505519622022 differ
diff -ruN xv6-public/.git/objects/f9/7b076fcabb46d190485c251fccb7dc0c2217ca copy-xv6/.git/objects/f9/7b076fcabb46d190485c251fccb7dc0c2217ca
--- xv6-public/.git/objects/f9/7b076fcabb46d190485c251fccb7dc0c2217ca	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/.git/objects/f9/7b076fcabb46d190485c251fccb7dc0c2217ca	2022-09-04 00:27:53.604875000 +0530
@@ -0,0 +1,2 @@
+xn {SpgQ7Zp}^F[LT!*F%5(#59GZ:EZ
+"jvp9e}{stq1<;H]xF}lM	BambG956L6[|RKE*/eA
\ No newline at end of file
diff -ruN xv6-public/.git/ORIG_HEAD copy-xv6/.git/ORIG_HEAD
--- xv6-public/.git/ORIG_HEAD	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/.git/ORIG_HEAD	2022-09-04 00:27:55.556880000 +0530
@@ -0,0 +1 @@
+f97b076fcabb46d190485c251fccb7dc0c2217ca
diff -ruN xv6-public/.git/refs/heads/master copy-xv6/.git/refs/heads/master
--- xv6-public/.git/refs/heads/master	2022-09-05 23:23:48.532715193 +0530
+++ copy-xv6/.git/refs/heads/master	2022-09-04 00:27:53.604875000 +0530
@@ -1 +1 @@
-eeb7b415dbcb12cc362d0783e41c3d1f44066b17
+f97b076fcabb46d190485c251fccb7dc0c2217ca
Binary files xv6-public/_grep and copy-xv6/_grep differ
diff -ruN xv6-public/grep.asm copy-xv6/grep.asm
--- xv6-public/grep.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/grep.asm	2022-09-05 23:26:11.920781092 +0530
@@ -0,0 +1,1590 @@
+
+_grep:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+  }
+}
+
+int
+main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	57                   	push   %edi
+  12:	56                   	push   %esi
+  13:	53                   	push   %ebx
+  14:	51                   	push   %ecx
+  15:	83 ec 18             	sub    $0x18,%esp
+  18:	8b 01                	mov    (%ecx),%eax
+  1a:	8b 59 04             	mov    0x4(%ecx),%ebx
+  1d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  int fd, i;
+  char *pattern;
+
+  if(argc <= 1){
+  20:	83 f8 01             	cmp    $0x1,%eax
+  23:	7e 6b                	jle    90 <main+0x90>
+    printf(2, "usage: grep pattern [file ...]\n");
+    exit();
+  }
+  pattern = argv[1];
+  25:	8b 43 04             	mov    0x4(%ebx),%eax
+  28:	83 c3 08             	add    $0x8,%ebx
+
+  if(argc <= 2){
+  2b:	83 7d e4 02          	cmpl   $0x2,-0x1c(%ebp)
+    grep(pattern, 0);
+    exit();
+  }
+
+  for(i = 2; i < argc; i++){
+  2f:	be 02 00 00 00       	mov    $0x2,%esi
+  pattern = argv[1];
+  34:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  if(argc <= 2){
+  37:	75 29                	jne    62 <main+0x62>
+  39:	eb 68                	jmp    a3 <main+0xa3>
+  3b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  3f:	90                   	nop
+    if((fd = open(argv[i], 0)) < 0){
+      printf(1, "grep: cannot open %s\n", argv[i]);
+      exit();
+    }
+    grep(pattern, fd);
+  40:	83 ec 08             	sub    $0x8,%esp
+  for(i = 2; i < argc; i++){
+  43:	83 c6 01             	add    $0x1,%esi
+  46:	83 c3 04             	add    $0x4,%ebx
+    grep(pattern, fd);
+  49:	50                   	push   %eax
+  4a:	ff 75 e0             	pushl  -0x20(%ebp)
+  4d:	e8 de 01 00 00       	call   230 <grep>
+    close(fd);
+  52:	89 3c 24             	mov    %edi,(%esp)
+  55:	e8 71 05 00 00       	call   5cb <close>
+  for(i = 2; i < argc; i++){
+  5a:	83 c4 10             	add    $0x10,%esp
+  5d:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
+  60:	7e 29                	jle    8b <main+0x8b>
+    if((fd = open(argv[i], 0)) < 0){
+  62:	83 ec 08             	sub    $0x8,%esp
+  65:	6a 00                	push   $0x0
+  67:	ff 33                	pushl  (%ebx)
+  69:	e8 75 05 00 00       	call   5e3 <open>
+  6e:	83 c4 10             	add    $0x10,%esp
+  71:	89 c7                	mov    %eax,%edi
+  73:	85 c0                	test   %eax,%eax
+  75:	79 c9                	jns    40 <main+0x40>
+      printf(1, "grep: cannot open %s\n", argv[i]);
+  77:	50                   	push   %eax
+  78:	ff 33                	pushl  (%ebx)
+  7a:	68 a8 0a 00 00       	push   $0xaa8
+  7f:	6a 01                	push   $0x1
+  81:	e8 9a 06 00 00       	call   720 <printf>
+      exit();
+  86:	e8 18 05 00 00       	call   5a3 <exit>
+  }
+  exit();
+  8b:	e8 13 05 00 00       	call   5a3 <exit>
+    printf(2, "usage: grep pattern [file ...]\n");
+  90:	51                   	push   %ecx
+  91:	51                   	push   %ecx
+  92:	68 88 0a 00 00       	push   $0xa88
+  97:	6a 02                	push   $0x2
+  99:	e8 82 06 00 00       	call   720 <printf>
+    exit();
+  9e:	e8 00 05 00 00       	call   5a3 <exit>
+    grep(pattern, 0);
+  a3:	52                   	push   %edx
+  a4:	52                   	push   %edx
+  a5:	6a 00                	push   $0x0
+  a7:	50                   	push   %eax
+  a8:	e8 83 01 00 00       	call   230 <grep>
+    exit();
+  ad:	e8 f1 04 00 00       	call   5a3 <exit>
+  b2:	66 90                	xchg   %ax,%ax
+  b4:	66 90                	xchg   %ax,%ax
+  b6:	66 90                	xchg   %ax,%ax
+  b8:	66 90                	xchg   %ax,%ax
+  ba:	66 90                	xchg   %ax,%ax
+  bc:	66 90                	xchg   %ax,%ax
+  be:	66 90                	xchg   %ax,%ax
+
+000000c0 <matchstar>:
+  return 0;
+}
+
+// matchstar: search for c*re at beginning of text
+int matchstar(int c, char *re, char *text)
+{
+  c0:	f3 0f 1e fb          	endbr32 
+  c4:	55                   	push   %ebp
+  c5:	89 e5                	mov    %esp,%ebp
+  c7:	57                   	push   %edi
+  c8:	56                   	push   %esi
+  c9:	53                   	push   %ebx
+  ca:	83 ec 0c             	sub    $0xc,%esp
+  cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  d0:	8b 75 0c             	mov    0xc(%ebp),%esi
+  d3:	8b 7d 10             	mov    0x10(%ebp),%edi
+  d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  dd:	8d 76 00             	lea    0x0(%esi),%esi
+  do{  // a * matches zero or more instances
+    if(matchhere(re, text))
+  e0:	83 ec 08             	sub    $0x8,%esp
+  e3:	57                   	push   %edi
+  e4:	56                   	push   %esi
+  e5:	e8 36 00 00 00       	call   120 <matchhere>
+  ea:	83 c4 10             	add    $0x10,%esp
+  ed:	85 c0                	test   %eax,%eax
+  ef:	75 1f                	jne    110 <matchstar+0x50>
+      return 1;
+  }while(*text!='\0' && (*text++==c || c=='.'));
+  f1:	0f be 17             	movsbl (%edi),%edx
+  f4:	84 d2                	test   %dl,%dl
+  f6:	74 0c                	je     104 <matchstar+0x44>
+  f8:	83 c7 01             	add    $0x1,%edi
+  fb:	39 da                	cmp    %ebx,%edx
+  fd:	74 e1                	je     e0 <matchstar+0x20>
+  ff:	83 fb 2e             	cmp    $0x2e,%ebx
+ 102:	74 dc                	je     e0 <matchstar+0x20>
+  return 0;
+}
+ 104:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 107:	5b                   	pop    %ebx
+ 108:	5e                   	pop    %esi
+ 109:	5f                   	pop    %edi
+ 10a:	5d                   	pop    %ebp
+ 10b:	c3                   	ret    
+ 10c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 110:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return 1;
+ 113:	b8 01 00 00 00       	mov    $0x1,%eax
+}
+ 118:	5b                   	pop    %ebx
+ 119:	5e                   	pop    %esi
+ 11a:	5f                   	pop    %edi
+ 11b:	5d                   	pop    %ebp
+ 11c:	c3                   	ret    
+ 11d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000120 <matchhere>:
+{
+ 120:	f3 0f 1e fb          	endbr32 
+ 124:	55                   	push   %ebp
+ 125:	89 e5                	mov    %esp,%ebp
+ 127:	57                   	push   %edi
+ 128:	56                   	push   %esi
+ 129:	53                   	push   %ebx
+ 12a:	83 ec 0c             	sub    $0xc,%esp
+ 12d:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 130:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  if(re[0] == '\0')
+ 133:	0f b6 01             	movzbl (%ecx),%eax
+ 136:	84 c0                	test   %al,%al
+ 138:	75 2b                	jne    165 <matchhere+0x45>
+ 13a:	eb 64                	jmp    1a0 <matchhere+0x80>
+ 13c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  if(re[0] == '$' && re[1] == '\0')
+ 140:	0f b6 37             	movzbl (%edi),%esi
+ 143:	80 fa 24             	cmp    $0x24,%dl
+ 146:	75 04                	jne    14c <matchhere+0x2c>
+ 148:	84 c0                	test   %al,%al
+ 14a:	74 61                	je     1ad <matchhere+0x8d>
+  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
+ 14c:	89 f3                	mov    %esi,%ebx
+ 14e:	84 db                	test   %bl,%bl
+ 150:	74 3e                	je     190 <matchhere+0x70>
+ 152:	80 fa 2e             	cmp    $0x2e,%dl
+ 155:	74 04                	je     15b <matchhere+0x3b>
+ 157:	38 d3                	cmp    %dl,%bl
+ 159:	75 35                	jne    190 <matchhere+0x70>
+    return matchhere(re+1, text+1);
+ 15b:	83 c7 01             	add    $0x1,%edi
+ 15e:	83 c1 01             	add    $0x1,%ecx
+  if(re[0] == '\0')
+ 161:	84 c0                	test   %al,%al
+ 163:	74 3b                	je     1a0 <matchhere+0x80>
+  if(re[1] == '*')
+ 165:	0f be d0             	movsbl %al,%edx
+ 168:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+ 16c:	3c 2a                	cmp    $0x2a,%al
+ 16e:	75 d0                	jne    140 <matchhere+0x20>
+    return matchstar(re[0], re+2, text);
+ 170:	83 ec 04             	sub    $0x4,%esp
+ 173:	83 c1 02             	add    $0x2,%ecx
+ 176:	57                   	push   %edi
+ 177:	51                   	push   %ecx
+ 178:	52                   	push   %edx
+ 179:	e8 42 ff ff ff       	call   c0 <matchstar>
+ 17e:	83 c4 10             	add    $0x10,%esp
+}
+ 181:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 184:	5b                   	pop    %ebx
+ 185:	5e                   	pop    %esi
+ 186:	5f                   	pop    %edi
+ 187:	5d                   	pop    %ebp
+ 188:	c3                   	ret    
+ 189:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 190:	8d 65 f4             	lea    -0xc(%ebp),%esp
+  return 0;
+ 193:	31 c0                	xor    %eax,%eax
+}
+ 195:	5b                   	pop    %ebx
+ 196:	5e                   	pop    %esi
+ 197:	5f                   	pop    %edi
+ 198:	5d                   	pop    %ebp
+ 199:	c3                   	ret    
+ 19a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 1a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    return 1;
+ 1a3:	b8 01 00 00 00       	mov    $0x1,%eax
+}
+ 1a8:	5b                   	pop    %ebx
+ 1a9:	5e                   	pop    %esi
+ 1aa:	5f                   	pop    %edi
+ 1ab:	5d                   	pop    %ebp
+ 1ac:	c3                   	ret    
+    return *text == '\0';
+ 1ad:	89 f0                	mov    %esi,%eax
+ 1af:	84 c0                	test   %al,%al
+ 1b1:	0f 94 c0             	sete   %al
+ 1b4:	0f b6 c0             	movzbl %al,%eax
+ 1b7:	eb c8                	jmp    181 <matchhere+0x61>
+ 1b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+000001c0 <match>:
+{
+ 1c0:	f3 0f 1e fb          	endbr32 
+ 1c4:	55                   	push   %ebp
+ 1c5:	89 e5                	mov    %esp,%ebp
+ 1c7:	56                   	push   %esi
+ 1c8:	53                   	push   %ebx
+ 1c9:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 1cc:	8b 75 0c             	mov    0xc(%ebp),%esi
+  if(re[0] == '^')
+ 1cf:	80 3b 5e             	cmpb   $0x5e,(%ebx)
+ 1d2:	75 15                	jne    1e9 <match+0x29>
+ 1d4:	eb 3a                	jmp    210 <match+0x50>
+ 1d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1dd:	8d 76 00             	lea    0x0(%esi),%esi
+  }while(*text++ != '\0');
+ 1e0:	83 c6 01             	add    $0x1,%esi
+ 1e3:	80 7e ff 00          	cmpb   $0x0,-0x1(%esi)
+ 1e7:	74 16                	je     1ff <match+0x3f>
+    if(matchhere(re, text))
+ 1e9:	83 ec 08             	sub    $0x8,%esp
+ 1ec:	56                   	push   %esi
+ 1ed:	53                   	push   %ebx
+ 1ee:	e8 2d ff ff ff       	call   120 <matchhere>
+ 1f3:	83 c4 10             	add    $0x10,%esp
+ 1f6:	85 c0                	test   %eax,%eax
+ 1f8:	74 e6                	je     1e0 <match+0x20>
+      return 1;
+ 1fa:	b8 01 00 00 00       	mov    $0x1,%eax
+}
+ 1ff:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 202:	5b                   	pop    %ebx
+ 203:	5e                   	pop    %esi
+ 204:	5d                   	pop    %ebp
+ 205:	c3                   	ret    
+ 206:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 20d:	8d 76 00             	lea    0x0(%esi),%esi
+    return matchhere(re+1, text);
+ 210:	83 c3 01             	add    $0x1,%ebx
+ 213:	89 5d 08             	mov    %ebx,0x8(%ebp)
+}
+ 216:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 219:	5b                   	pop    %ebx
+ 21a:	5e                   	pop    %esi
+ 21b:	5d                   	pop    %ebp
+    return matchhere(re+1, text);
+ 21c:	e9 ff fe ff ff       	jmp    120 <matchhere>
+ 221:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 228:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 22f:	90                   	nop
+
+00000230 <grep>:
+{
+ 230:	f3 0f 1e fb          	endbr32 
+ 234:	55                   	push   %ebp
+ 235:	89 e5                	mov    %esp,%ebp
+ 237:	57                   	push   %edi
+ 238:	56                   	push   %esi
+ 239:	53                   	push   %ebx
+ 23a:	83 ec 1c             	sub    $0x1c,%esp
+  m = 0;
+ 23d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+{
+ 244:	8b 75 08             	mov    0x8(%ebp),%esi
+ 247:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 24e:	66 90                	xchg   %ax,%ax
+  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
+ 250:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+ 253:	b8 ff 03 00 00       	mov    $0x3ff,%eax
+ 258:	83 ec 04             	sub    $0x4,%esp
+ 25b:	29 c8                	sub    %ecx,%eax
+ 25d:	50                   	push   %eax
+ 25e:	8d 81 a0 0e 00 00    	lea    0xea0(%ecx),%eax
+ 264:	50                   	push   %eax
+ 265:	ff 75 0c             	pushl  0xc(%ebp)
+ 268:	e8 4e 03 00 00       	call   5bb <read>
+ 26d:	83 c4 10             	add    $0x10,%esp
+ 270:	85 c0                	test   %eax,%eax
+ 272:	0f 8e b8 00 00 00    	jle    330 <grep+0x100>
+    m += n;
+ 278:	01 45 e4             	add    %eax,-0x1c(%ebp)
+ 27b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+    p = buf;
+ 27e:	bb a0 0e 00 00       	mov    $0xea0,%ebx
+    buf[m] = '\0';
+ 283:	c6 81 a0 0e 00 00 00 	movb   $0x0,0xea0(%ecx)
+    while((q = strchr(p, '\n')) != 0){
+ 28a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 290:	83 ec 08             	sub    $0x8,%esp
+ 293:	6a 0a                	push   $0xa
+ 295:	53                   	push   %ebx
+ 296:	e8 85 01 00 00       	call   420 <strchr>
+ 29b:	83 c4 10             	add    $0x10,%esp
+ 29e:	89 c7                	mov    %eax,%edi
+ 2a0:	85 c0                	test   %eax,%eax
+ 2a2:	74 3c                	je     2e0 <grep+0xb0>
+      if(match(pattern, p)){
+ 2a4:	83 ec 08             	sub    $0x8,%esp
+      *q = 0;
+ 2a7:	c6 07 00             	movb   $0x0,(%edi)
+      if(match(pattern, p)){
+ 2aa:	53                   	push   %ebx
+ 2ab:	56                   	push   %esi
+ 2ac:	e8 0f ff ff ff       	call   1c0 <match>
+ 2b1:	83 c4 10             	add    $0x10,%esp
+ 2b4:	8d 57 01             	lea    0x1(%edi),%edx
+ 2b7:	85 c0                	test   %eax,%eax
+ 2b9:	75 05                	jne    2c0 <grep+0x90>
+      p = q+1;
+ 2bb:	89 d3                	mov    %edx,%ebx
+ 2bd:	eb d1                	jmp    290 <grep+0x60>
+ 2bf:	90                   	nop
+        write(1, p, q+1 - p);
+ 2c0:	89 d0                	mov    %edx,%eax
+ 2c2:	83 ec 04             	sub    $0x4,%esp
+        *q = '\n';
+ 2c5:	c6 07 0a             	movb   $0xa,(%edi)
+        write(1, p, q+1 - p);
+ 2c8:	29 d8                	sub    %ebx,%eax
+ 2ca:	89 55 e0             	mov    %edx,-0x20(%ebp)
+ 2cd:	50                   	push   %eax
+ 2ce:	53                   	push   %ebx
+ 2cf:	6a 01                	push   $0x1
+ 2d1:	e8 ed 02 00 00       	call   5c3 <write>
+ 2d6:	8b 55 e0             	mov    -0x20(%ebp),%edx
+ 2d9:	83 c4 10             	add    $0x10,%esp
+      p = q+1;
+ 2dc:	89 d3                	mov    %edx,%ebx
+ 2de:	eb b0                	jmp    290 <grep+0x60>
+    if(p == buf)
+ 2e0:	81 fb a0 0e 00 00    	cmp    $0xea0,%ebx
+ 2e6:	74 38                	je     320 <grep+0xf0>
+    if(m > 0){
+ 2e8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+ 2eb:	85 c9                	test   %ecx,%ecx
+ 2ed:	0f 8e 5d ff ff ff    	jle    250 <grep+0x20>
+      m -= p - buf;
+ 2f3:	89 d8                	mov    %ebx,%eax
+      memmove(buf, p, m);
+ 2f5:	83 ec 04             	sub    $0x4,%esp
+      m -= p - buf;
+ 2f8:	2d a0 0e 00 00       	sub    $0xea0,%eax
+ 2fd:	29 c1                	sub    %eax,%ecx
+      memmove(buf, p, m);
+ 2ff:	51                   	push   %ecx
+ 300:	53                   	push   %ebx
+ 301:	68 a0 0e 00 00       	push   $0xea0
+      m -= p - buf;
+ 306:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+      memmove(buf, p, m);
+ 309:	e8 62 02 00 00       	call   570 <memmove>
+ 30e:	83 c4 10             	add    $0x10,%esp
+ 311:	e9 3a ff ff ff       	jmp    250 <grep+0x20>
+ 316:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 31d:	8d 76 00             	lea    0x0(%esi),%esi
+      m = 0;
+ 320:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+ 327:	e9 24 ff ff ff       	jmp    250 <grep+0x20>
+ 32c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+}
+ 330:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 333:	5b                   	pop    %ebx
+ 334:	5e                   	pop    %esi
+ 335:	5f                   	pop    %edi
+ 336:	5d                   	pop    %ebp
+ 337:	c3                   	ret    
+ 338:	66 90                	xchg   %ax,%ax
+ 33a:	66 90                	xchg   %ax,%ax
+ 33c:	66 90                	xchg   %ax,%ax
+ 33e:	66 90                	xchg   %ax,%ax
+
+00000340 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 340:	f3 0f 1e fb          	endbr32 
+ 344:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+ 345:	31 c0                	xor    %eax,%eax
+{
+ 347:	89 e5                	mov    %esp,%ebp
+ 349:	53                   	push   %ebx
+ 34a:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 34d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+ 350:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+ 354:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+ 357:	83 c0 01             	add    $0x1,%eax
+ 35a:	84 d2                	test   %dl,%dl
+ 35c:	75 f2                	jne    350 <strcpy+0x10>
+    ;
+  return os;
+}
+ 35e:	89 c8                	mov    %ecx,%eax
+ 360:	5b                   	pop    %ebx
+ 361:	5d                   	pop    %ebp
+ 362:	c3                   	ret    
+ 363:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 36a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000370 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 370:	f3 0f 1e fb          	endbr32 
+ 374:	55                   	push   %ebp
+ 375:	89 e5                	mov    %esp,%ebp
+ 377:	53                   	push   %ebx
+ 378:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 37b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+ 37e:	0f b6 01             	movzbl (%ecx),%eax
+ 381:	0f b6 1a             	movzbl (%edx),%ebx
+ 384:	84 c0                	test   %al,%al
+ 386:	75 19                	jne    3a1 <strcmp+0x31>
+ 388:	eb 26                	jmp    3b0 <strcmp+0x40>
+ 38a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 390:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+ 394:	83 c1 01             	add    $0x1,%ecx
+ 397:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+ 39a:	0f b6 1a             	movzbl (%edx),%ebx
+ 39d:	84 c0                	test   %al,%al
+ 39f:	74 0f                	je     3b0 <strcmp+0x40>
+ 3a1:	38 d8                	cmp    %bl,%al
+ 3a3:	74 eb                	je     390 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+ 3a5:	29 d8                	sub    %ebx,%eax
+}
+ 3a7:	5b                   	pop    %ebx
+ 3a8:	5d                   	pop    %ebp
+ 3a9:	c3                   	ret    
+ 3aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 3b0:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+ 3b2:	29 d8                	sub    %ebx,%eax
+}
+ 3b4:	5b                   	pop    %ebx
+ 3b5:	5d                   	pop    %ebp
+ 3b6:	c3                   	ret    
+ 3b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 3be:	66 90                	xchg   %ax,%ax
+
+000003c0 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 3c0:	f3 0f 1e fb          	endbr32 
+ 3c4:	55                   	push   %ebp
+ 3c5:	89 e5                	mov    %esp,%ebp
+ 3c7:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 3ca:	80 3a 00             	cmpb   $0x0,(%edx)
+ 3cd:	74 21                	je     3f0 <strlen+0x30>
+ 3cf:	31 c0                	xor    %eax,%eax
+ 3d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 3d8:	83 c0 01             	add    $0x1,%eax
+ 3db:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+ 3df:	89 c1                	mov    %eax,%ecx
+ 3e1:	75 f5                	jne    3d8 <strlen+0x18>
+    ;
+  return n;
+}
+ 3e3:	89 c8                	mov    %ecx,%eax
+ 3e5:	5d                   	pop    %ebp
+ 3e6:	c3                   	ret    
+ 3e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 3ee:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+ 3f0:	31 c9                	xor    %ecx,%ecx
+}
+ 3f2:	5d                   	pop    %ebp
+ 3f3:	89 c8                	mov    %ecx,%eax
+ 3f5:	c3                   	ret    
+ 3f6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 3fd:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000400 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 400:	f3 0f 1e fb          	endbr32 
+ 404:	55                   	push   %ebp
+ 405:	89 e5                	mov    %esp,%ebp
+ 407:	57                   	push   %edi
+ 408:	8b 55 08             	mov    0x8(%ebp),%edx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+ 40b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 40e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 411:	89 d7                	mov    %edx,%edi
+ 413:	fc                   	cld    
+ 414:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+ 416:	89 d0                	mov    %edx,%eax
+ 418:	5f                   	pop    %edi
+ 419:	5d                   	pop    %ebp
+ 41a:	c3                   	ret    
+ 41b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 41f:	90                   	nop
+
+00000420 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 420:	f3 0f 1e fb          	endbr32 
+ 424:	55                   	push   %ebp
+ 425:	89 e5                	mov    %esp,%ebp
+ 427:	8b 45 08             	mov    0x8(%ebp),%eax
+ 42a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+ 42e:	0f b6 10             	movzbl (%eax),%edx
+ 431:	84 d2                	test   %dl,%dl
+ 433:	75 16                	jne    44b <strchr+0x2b>
+ 435:	eb 21                	jmp    458 <strchr+0x38>
+ 437:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 43e:	66 90                	xchg   %ax,%ax
+ 440:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+ 444:	83 c0 01             	add    $0x1,%eax
+ 447:	84 d2                	test   %dl,%dl
+ 449:	74 0d                	je     458 <strchr+0x38>
+    if(*s == c)
+ 44b:	38 d1                	cmp    %dl,%cl
+ 44d:	75 f1                	jne    440 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+ 44f:	5d                   	pop    %ebp
+ 450:	c3                   	ret    
+ 451:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+ 458:	31 c0                	xor    %eax,%eax
+}
+ 45a:	5d                   	pop    %ebp
+ 45b:	c3                   	ret    
+ 45c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000460 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 460:	f3 0f 1e fb          	endbr32 
+ 464:	55                   	push   %ebp
+ 465:	89 e5                	mov    %esp,%ebp
+ 467:	57                   	push   %edi
+ 468:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 469:	31 f6                	xor    %esi,%esi
+{
+ 46b:	53                   	push   %ebx
+ 46c:	89 f3                	mov    %esi,%ebx
+ 46e:	83 ec 1c             	sub    $0x1c,%esp
+ 471:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+ 474:	eb 33                	jmp    4a9 <gets+0x49>
+ 476:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 47d:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+ 480:	83 ec 04             	sub    $0x4,%esp
+ 483:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ 486:	6a 01                	push   $0x1
+ 488:	50                   	push   %eax
+ 489:	6a 00                	push   $0x0
+ 48b:	e8 2b 01 00 00       	call   5bb <read>
+    if(cc < 1)
+ 490:	83 c4 10             	add    $0x10,%esp
+ 493:	85 c0                	test   %eax,%eax
+ 495:	7e 1c                	jle    4b3 <gets+0x53>
+      break;
+    buf[i++] = c;
+ 497:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ 49b:	83 c7 01             	add    $0x1,%edi
+ 49e:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+ 4a1:	3c 0a                	cmp    $0xa,%al
+ 4a3:	74 23                	je     4c8 <gets+0x68>
+ 4a5:	3c 0d                	cmp    $0xd,%al
+ 4a7:	74 1f                	je     4c8 <gets+0x68>
+  for(i=0; i+1 < max; ){
+ 4a9:	83 c3 01             	add    $0x1,%ebx
+ 4ac:	89 fe                	mov    %edi,%esi
+ 4ae:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+ 4b1:	7c cd                	jl     480 <gets+0x20>
+ 4b3:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+ 4b5:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+ 4b8:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 4bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 4be:	5b                   	pop    %ebx
+ 4bf:	5e                   	pop    %esi
+ 4c0:	5f                   	pop    %edi
+ 4c1:	5d                   	pop    %ebp
+ 4c2:	c3                   	ret    
+ 4c3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 4c7:	90                   	nop
+ 4c8:	8b 75 08             	mov    0x8(%ebp),%esi
+ 4cb:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4ce:	01 de                	add    %ebx,%esi
+ 4d0:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+ 4d2:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 4d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 4d8:	5b                   	pop    %ebx
+ 4d9:	5e                   	pop    %esi
+ 4da:	5f                   	pop    %edi
+ 4db:	5d                   	pop    %ebp
+ 4dc:	c3                   	ret    
+ 4dd:	8d 76 00             	lea    0x0(%esi),%esi
+
+000004e0 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 4e0:	f3 0f 1e fb          	endbr32 
+ 4e4:	55                   	push   %ebp
+ 4e5:	89 e5                	mov    %esp,%ebp
+ 4e7:	56                   	push   %esi
+ 4e8:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 4e9:	83 ec 08             	sub    $0x8,%esp
+ 4ec:	6a 00                	push   $0x0
+ 4ee:	ff 75 08             	pushl  0x8(%ebp)
+ 4f1:	e8 ed 00 00 00       	call   5e3 <open>
+  if(fd < 0)
+ 4f6:	83 c4 10             	add    $0x10,%esp
+ 4f9:	85 c0                	test   %eax,%eax
+ 4fb:	78 2b                	js     528 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+ 4fd:	83 ec 08             	sub    $0x8,%esp
+ 500:	ff 75 0c             	pushl  0xc(%ebp)
+ 503:	89 c3                	mov    %eax,%ebx
+ 505:	50                   	push   %eax
+ 506:	e8 f0 00 00 00       	call   5fb <fstat>
+  close(fd);
+ 50b:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+ 50e:	89 c6                	mov    %eax,%esi
+  close(fd);
+ 510:	e8 b6 00 00 00       	call   5cb <close>
+  return r;
+ 515:	83 c4 10             	add    $0x10,%esp
+}
+ 518:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 51b:	89 f0                	mov    %esi,%eax
+ 51d:	5b                   	pop    %ebx
+ 51e:	5e                   	pop    %esi
+ 51f:	5d                   	pop    %ebp
+ 520:	c3                   	ret    
+ 521:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+ 528:	be ff ff ff ff       	mov    $0xffffffff,%esi
+ 52d:	eb e9                	jmp    518 <stat+0x38>
+ 52f:	90                   	nop
+
+00000530 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 530:	f3 0f 1e fb          	endbr32 
+ 534:	55                   	push   %ebp
+ 535:	89 e5                	mov    %esp,%ebp
+ 537:	53                   	push   %ebx
+ 538:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 53b:	0f be 02             	movsbl (%edx),%eax
+ 53e:	8d 48 d0             	lea    -0x30(%eax),%ecx
+ 541:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+ 544:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+ 549:	77 1a                	ja     565 <atoi+0x35>
+ 54b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 54f:	90                   	nop
+    n = n*10 + *s++ - '0';
+ 550:	83 c2 01             	add    $0x1,%edx
+ 553:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+ 556:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+ 55a:	0f be 02             	movsbl (%edx),%eax
+ 55d:	8d 58 d0             	lea    -0x30(%eax),%ebx
+ 560:	80 fb 09             	cmp    $0x9,%bl
+ 563:	76 eb                	jbe    550 <atoi+0x20>
+  return n;
+}
+ 565:	89 c8                	mov    %ecx,%eax
+ 567:	5b                   	pop    %ebx
+ 568:	5d                   	pop    %ebp
+ 569:	c3                   	ret    
+ 56a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000570 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 570:	f3 0f 1e fb          	endbr32 
+ 574:	55                   	push   %ebp
+ 575:	89 e5                	mov    %esp,%ebp
+ 577:	57                   	push   %edi
+ 578:	8b 45 10             	mov    0x10(%ebp),%eax
+ 57b:	8b 55 08             	mov    0x8(%ebp),%edx
+ 57e:	56                   	push   %esi
+ 57f:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 582:	85 c0                	test   %eax,%eax
+ 584:	7e 0f                	jle    595 <memmove+0x25>
+ 586:	01 d0                	add    %edx,%eax
+  dst = vdst;
+ 588:	89 d7                	mov    %edx,%edi
+ 58a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+ 590:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+ 591:	39 f8                	cmp    %edi,%eax
+ 593:	75 fb                	jne    590 <memmove+0x20>
+  return vdst;
+}
+ 595:	5e                   	pop    %esi
+ 596:	89 d0                	mov    %edx,%eax
+ 598:	5f                   	pop    %edi
+ 599:	5d                   	pop    %ebp
+ 59a:	c3                   	ret    
+
+0000059b <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 59b:	b8 01 00 00 00       	mov    $0x1,%eax
+ 5a0:	cd 40                	int    $0x40
+ 5a2:	c3                   	ret    
+
+000005a3 <exit>:
+SYSCALL(exit)
+ 5a3:	b8 02 00 00 00       	mov    $0x2,%eax
+ 5a8:	cd 40                	int    $0x40
+ 5aa:	c3                   	ret    
+
+000005ab <wait>:
+SYSCALL(wait)
+ 5ab:	b8 03 00 00 00       	mov    $0x3,%eax
+ 5b0:	cd 40                	int    $0x40
+ 5b2:	c3                   	ret    
+
+000005b3 <pipe>:
+SYSCALL(pipe)
+ 5b3:	b8 04 00 00 00       	mov    $0x4,%eax
+ 5b8:	cd 40                	int    $0x40
+ 5ba:	c3                   	ret    
+
+000005bb <read>:
+SYSCALL(read)
+ 5bb:	b8 05 00 00 00       	mov    $0x5,%eax
+ 5c0:	cd 40                	int    $0x40
+ 5c2:	c3                   	ret    
+
+000005c3 <write>:
+SYSCALL(write)
+ 5c3:	b8 10 00 00 00       	mov    $0x10,%eax
+ 5c8:	cd 40                	int    $0x40
+ 5ca:	c3                   	ret    
+
+000005cb <close>:
+SYSCALL(close)
+ 5cb:	b8 15 00 00 00       	mov    $0x15,%eax
+ 5d0:	cd 40                	int    $0x40
+ 5d2:	c3                   	ret    
+
+000005d3 <kill>:
+SYSCALL(kill)
+ 5d3:	b8 06 00 00 00       	mov    $0x6,%eax
+ 5d8:	cd 40                	int    $0x40
+ 5da:	c3                   	ret    
+
+000005db <exec>:
+SYSCALL(exec)
+ 5db:	b8 07 00 00 00       	mov    $0x7,%eax
+ 5e0:	cd 40                	int    $0x40
+ 5e2:	c3                   	ret    
+
+000005e3 <open>:
+SYSCALL(open)
+ 5e3:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 5e8:	cd 40                	int    $0x40
+ 5ea:	c3                   	ret    
+
+000005eb <mknod>:
+SYSCALL(mknod)
+ 5eb:	b8 11 00 00 00       	mov    $0x11,%eax
+ 5f0:	cd 40                	int    $0x40
+ 5f2:	c3                   	ret    
+
+000005f3 <unlink>:
+SYSCALL(unlink)
+ 5f3:	b8 12 00 00 00       	mov    $0x12,%eax
+ 5f8:	cd 40                	int    $0x40
+ 5fa:	c3                   	ret    
+
+000005fb <fstat>:
+SYSCALL(fstat)
+ 5fb:	b8 08 00 00 00       	mov    $0x8,%eax
+ 600:	cd 40                	int    $0x40
+ 602:	c3                   	ret    
+
+00000603 <link>:
+SYSCALL(link)
+ 603:	b8 13 00 00 00       	mov    $0x13,%eax
+ 608:	cd 40                	int    $0x40
+ 60a:	c3                   	ret    
+
+0000060b <mkdir>:
+SYSCALL(mkdir)
+ 60b:	b8 14 00 00 00       	mov    $0x14,%eax
+ 610:	cd 40                	int    $0x40
+ 612:	c3                   	ret    
+
+00000613 <chdir>:
+SYSCALL(chdir)
+ 613:	b8 09 00 00 00       	mov    $0x9,%eax
+ 618:	cd 40                	int    $0x40
+ 61a:	c3                   	ret    
+
+0000061b <dup>:
+SYSCALL(dup)
+ 61b:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 620:	cd 40                	int    $0x40
+ 622:	c3                   	ret    
+
+00000623 <getpid>:
+SYSCALL(getpid)
+ 623:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 628:	cd 40                	int    $0x40
+ 62a:	c3                   	ret    
+
+0000062b <sbrk>:
+SYSCALL(sbrk)
+ 62b:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 630:	cd 40                	int    $0x40
+ 632:	c3                   	ret    
+
+00000633 <sleep>:
+SYSCALL(sleep)
+ 633:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 638:	cd 40                	int    $0x40
+ 63a:	c3                   	ret    
+
+0000063b <uptime>:
+SYSCALL(uptime)
+ 63b:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 640:	cd 40                	int    $0x40
+ 642:	c3                   	ret    
+
+00000643 <draw>:
+SYSCALL(draw)
+ 643:	b8 16 00 00 00       	mov    $0x16,%eax
+ 648:	cd 40                	int    $0x40
+ 64a:	c3                   	ret    
+
+0000064b <thread_create>:
+
+SYSCALL(thread_create)
+ 64b:	b8 17 00 00 00       	mov    $0x17,%eax
+ 650:	cd 40                	int    $0x40
+ 652:	c3                   	ret    
+
+00000653 <thread_join>:
+SYSCALL(thread_join)
+ 653:	b8 18 00 00 00       	mov    $0x18,%eax
+ 658:	cd 40                	int    $0x40
+ 65a:	c3                   	ret    
+
+0000065b <thread_exit>:
+SYSCALL(thread_exit)
+ 65b:	b8 19 00 00 00       	mov    $0x19,%eax
+ 660:	cd 40                	int    $0x40
+ 662:	c3                   	ret    
+ 663:	66 90                	xchg   %ax,%ax
+ 665:	66 90                	xchg   %ax,%ax
+ 667:	66 90                	xchg   %ax,%ax
+ 669:	66 90                	xchg   %ax,%ax
+ 66b:	66 90                	xchg   %ax,%ax
+ 66d:	66 90                	xchg   %ax,%ax
+ 66f:	90                   	nop
+
+00000670 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 670:	55                   	push   %ebp
+ 671:	89 e5                	mov    %esp,%ebp
+ 673:	57                   	push   %edi
+ 674:	56                   	push   %esi
+ 675:	53                   	push   %ebx
+ 676:	83 ec 3c             	sub    $0x3c,%esp
+ 679:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+ 67c:	89 d1                	mov    %edx,%ecx
+{
+ 67e:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  if(sgn && xx < 0){
+ 681:	85 d2                	test   %edx,%edx
+ 683:	0f 89 7f 00 00 00    	jns    708 <printint+0x98>
+ 689:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
+ 68d:	74 79                	je     708 <printint+0x98>
+    neg = 1;
+ 68f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+    x = -xx;
+ 696:	f7 d9                	neg    %ecx
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 698:	31 db                	xor    %ebx,%ebx
+ 69a:	8d 75 d7             	lea    -0x29(%ebp),%esi
+ 69d:	8d 76 00             	lea    0x0(%esi),%esi
+  do{
+    buf[i++] = digits[x % base];
+ 6a0:	89 c8                	mov    %ecx,%eax
+ 6a2:	31 d2                	xor    %edx,%edx
+ 6a4:	89 cf                	mov    %ecx,%edi
+ 6a6:	f7 75 c4             	divl   -0x3c(%ebp)
+ 6a9:	0f b6 92 c8 0a 00 00 	movzbl 0xac8(%edx),%edx
+ 6b0:	89 45 c0             	mov    %eax,-0x40(%ebp)
+ 6b3:	89 d8                	mov    %ebx,%eax
+ 6b5:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+ 6b8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+    buf[i++] = digits[x % base];
+ 6bb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
+  }while((x /= base) != 0);
+ 6be:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
+ 6c1:	76 dd                	jbe    6a0 <printint+0x30>
+  if(neg)
+ 6c3:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+ 6c6:	85 c9                	test   %ecx,%ecx
+ 6c8:	74 0c                	je     6d6 <printint+0x66>
+    buf[i++] = '-';
+ 6ca:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+ 6cf:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+ 6d1:	ba 2d 00 00 00       	mov    $0x2d,%edx
+
+  while(--i >= 0)
+ 6d6:	8b 7d b8             	mov    -0x48(%ebp),%edi
+ 6d9:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+ 6dd:	eb 07                	jmp    6e6 <printint+0x76>
+ 6df:	90                   	nop
+ 6e0:	0f b6 13             	movzbl (%ebx),%edx
+ 6e3:	83 eb 01             	sub    $0x1,%ebx
+  write(fd, &c, 1);
+ 6e6:	83 ec 04             	sub    $0x4,%esp
+ 6e9:	88 55 d7             	mov    %dl,-0x29(%ebp)
+ 6ec:	6a 01                	push   $0x1
+ 6ee:	56                   	push   %esi
+ 6ef:	57                   	push   %edi
+ 6f0:	e8 ce fe ff ff       	call   5c3 <write>
+  while(--i >= 0)
+ 6f5:	83 c4 10             	add    $0x10,%esp
+ 6f8:	39 de                	cmp    %ebx,%esi
+ 6fa:	75 e4                	jne    6e0 <printint+0x70>
+    putc(fd, buf[i]);
+}
+ 6fc:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 6ff:	5b                   	pop    %ebx
+ 700:	5e                   	pop    %esi
+ 701:	5f                   	pop    %edi
+ 702:	5d                   	pop    %ebp
+ 703:	c3                   	ret    
+ 704:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  neg = 0;
+ 708:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+ 70f:	eb 87                	jmp    698 <printint+0x28>
+ 711:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 718:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 71f:	90                   	nop
+
+00000720 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 720:	f3 0f 1e fb          	endbr32 
+ 724:	55                   	push   %ebp
+ 725:	89 e5                	mov    %esp,%ebp
+ 727:	57                   	push   %edi
+ 728:	56                   	push   %esi
+ 729:	53                   	push   %ebx
+ 72a:	83 ec 2c             	sub    $0x2c,%esp
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 72d:	8b 75 0c             	mov    0xc(%ebp),%esi
+ 730:	0f b6 1e             	movzbl (%esi),%ebx
+ 733:	84 db                	test   %bl,%bl
+ 735:	0f 84 b4 00 00 00    	je     7ef <printf+0xcf>
+  ap = (uint*)(void*)&fmt + 1;
+ 73b:	8d 45 10             	lea    0x10(%ebp),%eax
+ 73e:	83 c6 01             	add    $0x1,%esi
+  write(fd, &c, 1);
+ 741:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  state = 0;
+ 744:	31 d2                	xor    %edx,%edx
+  ap = (uint*)(void*)&fmt + 1;
+ 746:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 749:	eb 33                	jmp    77e <printf+0x5e>
+ 74b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 74f:	90                   	nop
+ 750:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+ 753:	ba 25 00 00 00       	mov    $0x25,%edx
+      if(c == '%'){
+ 758:	83 f8 25             	cmp    $0x25,%eax
+ 75b:	74 17                	je     774 <printf+0x54>
+  write(fd, &c, 1);
+ 75d:	83 ec 04             	sub    $0x4,%esp
+ 760:	88 5d e7             	mov    %bl,-0x19(%ebp)
+ 763:	6a 01                	push   $0x1
+ 765:	57                   	push   %edi
+ 766:	ff 75 08             	pushl  0x8(%ebp)
+ 769:	e8 55 fe ff ff       	call   5c3 <write>
+ 76e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+      } else {
+        putc(fd, c);
+ 771:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; fmt[i]; i++){
+ 774:	0f b6 1e             	movzbl (%esi),%ebx
+ 777:	83 c6 01             	add    $0x1,%esi
+ 77a:	84 db                	test   %bl,%bl
+ 77c:	74 71                	je     7ef <printf+0xcf>
+    c = fmt[i] & 0xff;
+ 77e:	0f be cb             	movsbl %bl,%ecx
+ 781:	0f b6 c3             	movzbl %bl,%eax
+    if(state == 0){
+ 784:	85 d2                	test   %edx,%edx
+ 786:	74 c8                	je     750 <printf+0x30>
+      }
+    } else if(state == '%'){
+ 788:	83 fa 25             	cmp    $0x25,%edx
+ 78b:	75 e7                	jne    774 <printf+0x54>
+      if(c == 'd'){
+ 78d:	83 f8 64             	cmp    $0x64,%eax
+ 790:	0f 84 9a 00 00 00    	je     830 <printf+0x110>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+ 796:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
+ 79c:	83 f9 70             	cmp    $0x70,%ecx
+ 79f:	74 5f                	je     800 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+ 7a1:	83 f8 73             	cmp    $0x73,%eax
+ 7a4:	0f 84 d6 00 00 00    	je     880 <printf+0x160>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 7aa:	83 f8 63             	cmp    $0x63,%eax
+ 7ad:	0f 84 8d 00 00 00    	je     840 <printf+0x120>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+ 7b3:	83 f8 25             	cmp    $0x25,%eax
+ 7b6:	0f 84 b4 00 00 00    	je     870 <printf+0x150>
+  write(fd, &c, 1);
+ 7bc:	83 ec 04             	sub    $0x4,%esp
+ 7bf:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
+ 7c3:	6a 01                	push   $0x1
+ 7c5:	57                   	push   %edi
+ 7c6:	ff 75 08             	pushl  0x8(%ebp)
+ 7c9:	e8 f5 fd ff ff       	call   5c3 <write>
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+ 7ce:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 7d1:	83 c4 0c             	add    $0xc,%esp
+ 7d4:	6a 01                	push   $0x1
+ 7d6:	83 c6 01             	add    $0x1,%esi
+ 7d9:	57                   	push   %edi
+ 7da:	ff 75 08             	pushl  0x8(%ebp)
+ 7dd:	e8 e1 fd ff ff       	call   5c3 <write>
+  for(i = 0; fmt[i]; i++){
+ 7e2:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
+        putc(fd, c);
+ 7e6:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 7e9:	31 d2                	xor    %edx,%edx
+  for(i = 0; fmt[i]; i++){
+ 7eb:	84 db                	test   %bl,%bl
+ 7ed:	75 8f                	jne    77e <printf+0x5e>
+    }
+  }
+}
+ 7ef:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 7f2:	5b                   	pop    %ebx
+ 7f3:	5e                   	pop    %esi
+ 7f4:	5f                   	pop    %edi
+ 7f5:	5d                   	pop    %ebp
+ 7f6:	c3                   	ret    
+ 7f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 7fe:	66 90                	xchg   %ax,%ax
+        printint(fd, *ap, 16, 0);
+ 800:	83 ec 0c             	sub    $0xc,%esp
+ 803:	b9 10 00 00 00       	mov    $0x10,%ecx
+ 808:	6a 00                	push   $0x0
+ 80a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+ 80d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 810:	8b 13                	mov    (%ebx),%edx
+ 812:	e8 59 fe ff ff       	call   670 <printint>
+        ap++;
+ 817:	89 d8                	mov    %ebx,%eax
+ 819:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 81c:	31 d2                	xor    %edx,%edx
+        ap++;
+ 81e:	83 c0 04             	add    $0x4,%eax
+ 821:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 824:	e9 4b ff ff ff       	jmp    774 <printf+0x54>
+ 829:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        printint(fd, *ap, 10, 1);
+ 830:	83 ec 0c             	sub    $0xc,%esp
+ 833:	b9 0a 00 00 00       	mov    $0xa,%ecx
+ 838:	6a 01                	push   $0x1
+ 83a:	eb ce                	jmp    80a <printf+0xea>
+ 83c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        putc(fd, *ap);
+ 840:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+  write(fd, &c, 1);
+ 843:	83 ec 04             	sub    $0x4,%esp
+        putc(fd, *ap);
+ 846:	8b 03                	mov    (%ebx),%eax
+  write(fd, &c, 1);
+ 848:	6a 01                	push   $0x1
+        ap++;
+ 84a:	83 c3 04             	add    $0x4,%ebx
+  write(fd, &c, 1);
+ 84d:	57                   	push   %edi
+ 84e:	ff 75 08             	pushl  0x8(%ebp)
+        putc(fd, *ap);
+ 851:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 854:	e8 6a fd ff ff       	call   5c3 <write>
+        ap++;
+ 859:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+ 85c:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 85f:	31 d2                	xor    %edx,%edx
+ 861:	e9 0e ff ff ff       	jmp    774 <printf+0x54>
+ 866:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 86d:	8d 76 00             	lea    0x0(%esi),%esi
+        putc(fd, c);
+ 870:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 873:	83 ec 04             	sub    $0x4,%esp
+ 876:	e9 59 ff ff ff       	jmp    7d4 <printf+0xb4>
+ 87b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 87f:	90                   	nop
+        s = (char*)*ap;
+ 880:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 883:	8b 18                	mov    (%eax),%ebx
+        ap++;
+ 885:	83 c0 04             	add    $0x4,%eax
+ 888:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        if(s == 0)
+ 88b:	85 db                	test   %ebx,%ebx
+ 88d:	74 17                	je     8a6 <printf+0x186>
+        while(*s != 0){
+ 88f:	0f b6 03             	movzbl (%ebx),%eax
+      state = 0;
+ 892:	31 d2                	xor    %edx,%edx
+        while(*s != 0){
+ 894:	84 c0                	test   %al,%al
+ 896:	0f 84 d8 fe ff ff    	je     774 <printf+0x54>
+ 89c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 89f:	89 de                	mov    %ebx,%esi
+ 8a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 8a4:	eb 1a                	jmp    8c0 <printf+0x1a0>
+          s = "(null)";
+ 8a6:	bb be 0a 00 00       	mov    $0xabe,%ebx
+        while(*s != 0){
+ 8ab:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 8ae:	b8 28 00 00 00       	mov    $0x28,%eax
+ 8b3:	89 de                	mov    %ebx,%esi
+ 8b5:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 8b8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 8bf:	90                   	nop
+  write(fd, &c, 1);
+ 8c0:	83 ec 04             	sub    $0x4,%esp
+          s++;
+ 8c3:	83 c6 01             	add    $0x1,%esi
+ 8c6:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 8c9:	6a 01                	push   $0x1
+ 8cb:	57                   	push   %edi
+ 8cc:	53                   	push   %ebx
+ 8cd:	e8 f1 fc ff ff       	call   5c3 <write>
+        while(*s != 0){
+ 8d2:	0f b6 06             	movzbl (%esi),%eax
+ 8d5:	83 c4 10             	add    $0x10,%esp
+ 8d8:	84 c0                	test   %al,%al
+ 8da:	75 e4                	jne    8c0 <printf+0x1a0>
+ 8dc:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+      state = 0;
+ 8df:	31 d2                	xor    %edx,%edx
+ 8e1:	e9 8e fe ff ff       	jmp    774 <printf+0x54>
+ 8e6:	66 90                	xchg   %ax,%ax
+ 8e8:	66 90                	xchg   %ax,%ax
+ 8ea:	66 90                	xchg   %ax,%ax
+ 8ec:	66 90                	xchg   %ax,%ax
+ 8ee:	66 90                	xchg   %ax,%ax
+
+000008f0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 8f0:	f3 0f 1e fb          	endbr32 
+ 8f4:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 8f5:	a1 80 0e 00 00       	mov    0xe80,%eax
+{
+ 8fa:	89 e5                	mov    %esp,%ebp
+ 8fc:	57                   	push   %edi
+ 8fd:	56                   	push   %esi
+ 8fe:	53                   	push   %ebx
+ 8ff:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 902:	8b 10                	mov    (%eax),%edx
+  bp = (Header*)ap - 1;
+ 904:	8d 4b f8             	lea    -0x8(%ebx),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 907:	39 c8                	cmp    %ecx,%eax
+ 909:	73 15                	jae    920 <free+0x30>
+ 90b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 90f:	90                   	nop
+ 910:	39 d1                	cmp    %edx,%ecx
+ 912:	72 14                	jb     928 <free+0x38>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 914:	39 d0                	cmp    %edx,%eax
+ 916:	73 10                	jae    928 <free+0x38>
+{
+ 918:	89 d0                	mov    %edx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 91a:	8b 10                	mov    (%eax),%edx
+ 91c:	39 c8                	cmp    %ecx,%eax
+ 91e:	72 f0                	jb     910 <free+0x20>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 920:	39 d0                	cmp    %edx,%eax
+ 922:	72 f4                	jb     918 <free+0x28>
+ 924:	39 d1                	cmp    %edx,%ecx
+ 926:	73 f0                	jae    918 <free+0x28>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 928:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ 92b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
+ 92e:	39 fa                	cmp    %edi,%edx
+ 930:	74 1e                	je     950 <free+0x60>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+ 932:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 935:	8b 50 04             	mov    0x4(%eax),%edx
+ 938:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 93b:	39 f1                	cmp    %esi,%ecx
+ 93d:	74 28                	je     967 <free+0x77>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+ 93f:	89 08                	mov    %ecx,(%eax)
+  freep = p;
+}
+ 941:	5b                   	pop    %ebx
+  freep = p;
+ 942:	a3 80 0e 00 00       	mov    %eax,0xe80
+}
+ 947:	5e                   	pop    %esi
+ 948:	5f                   	pop    %edi
+ 949:	5d                   	pop    %ebp
+ 94a:	c3                   	ret    
+ 94b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 94f:	90                   	nop
+    bp->s.size += p->s.ptr->s.size;
+ 950:	03 72 04             	add    0x4(%edx),%esi
+ 953:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 956:	8b 10                	mov    (%eax),%edx
+ 958:	8b 12                	mov    (%edx),%edx
+ 95a:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 95d:	8b 50 04             	mov    0x4(%eax),%edx
+ 960:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 963:	39 f1                	cmp    %esi,%ecx
+ 965:	75 d8                	jne    93f <free+0x4f>
+    p->s.size += bp->s.size;
+ 967:	03 53 fc             	add    -0x4(%ebx),%edx
+  freep = p;
+ 96a:	a3 80 0e 00 00       	mov    %eax,0xe80
+    p->s.size += bp->s.size;
+ 96f:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 972:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ 975:	89 10                	mov    %edx,(%eax)
+}
+ 977:	5b                   	pop    %ebx
+ 978:	5e                   	pop    %esi
+ 979:	5f                   	pop    %edi
+ 97a:	5d                   	pop    %ebp
+ 97b:	c3                   	ret    
+ 97c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000980 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 980:	f3 0f 1e fb          	endbr32 
+ 984:	55                   	push   %ebp
+ 985:	89 e5                	mov    %esp,%ebp
+ 987:	57                   	push   %edi
+ 988:	56                   	push   %esi
+ 989:	53                   	push   %ebx
+ 98a:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 98d:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+ 990:	8b 3d 80 0e 00 00    	mov    0xe80,%edi
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 996:	8d 70 07             	lea    0x7(%eax),%esi
+ 999:	c1 ee 03             	shr    $0x3,%esi
+ 99c:	83 c6 01             	add    $0x1,%esi
+  if((prevp = freep) == 0){
+ 99f:	85 ff                	test   %edi,%edi
+ 9a1:	0f 84 a9 00 00 00    	je     a50 <malloc+0xd0>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 9a7:	8b 07                	mov    (%edi),%eax
+    if(p->s.size >= nunits){
+ 9a9:	8b 48 04             	mov    0x4(%eax),%ecx
+ 9ac:	39 f1                	cmp    %esi,%ecx
+ 9ae:	73 6d                	jae    a1d <malloc+0x9d>
+ 9b0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+ 9b6:	bb 00 10 00 00       	mov    $0x1000,%ebx
+ 9bb:	0f 43 de             	cmovae %esi,%ebx
+  p = sbrk(nu * sizeof(Header));
+ 9be:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
+ 9c5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+ 9c8:	eb 17                	jmp    9e1 <malloc+0x61>
+ 9ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 9d0:	8b 10                	mov    (%eax),%edx
+    if(p->s.size >= nunits){
+ 9d2:	8b 4a 04             	mov    0x4(%edx),%ecx
+ 9d5:	39 f1                	cmp    %esi,%ecx
+ 9d7:	73 4f                	jae    a28 <malloc+0xa8>
+ 9d9:	8b 3d 80 0e 00 00    	mov    0xe80,%edi
+ 9df:	89 d0                	mov    %edx,%eax
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 9e1:	39 c7                	cmp    %eax,%edi
+ 9e3:	75 eb                	jne    9d0 <malloc+0x50>
+  p = sbrk(nu * sizeof(Header));
+ 9e5:	83 ec 0c             	sub    $0xc,%esp
+ 9e8:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 9eb:	e8 3b fc ff ff       	call   62b <sbrk>
+  if(p == (char*)-1)
+ 9f0:	83 c4 10             	add    $0x10,%esp
+ 9f3:	83 f8 ff             	cmp    $0xffffffff,%eax
+ 9f6:	74 1b                	je     a13 <malloc+0x93>
+  hp->s.size = nu;
+ 9f8:	89 58 04             	mov    %ebx,0x4(%eax)
+  free((void*)(hp + 1));
+ 9fb:	83 ec 0c             	sub    $0xc,%esp
+ 9fe:	83 c0 08             	add    $0x8,%eax
+ a01:	50                   	push   %eax
+ a02:	e8 e9 fe ff ff       	call   8f0 <free>
+  return freep;
+ a07:	a1 80 0e 00 00       	mov    0xe80,%eax
+      if((p = morecore(nunits)) == 0)
+ a0c:	83 c4 10             	add    $0x10,%esp
+ a0f:	85 c0                	test   %eax,%eax
+ a11:	75 bd                	jne    9d0 <malloc+0x50>
+        return 0;
+  }
+}
+ a13:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return 0;
+ a16:	31 c0                	xor    %eax,%eax
+}
+ a18:	5b                   	pop    %ebx
+ a19:	5e                   	pop    %esi
+ a1a:	5f                   	pop    %edi
+ a1b:	5d                   	pop    %ebp
+ a1c:	c3                   	ret    
+    if(p->s.size >= nunits){
+ a1d:	89 c2                	mov    %eax,%edx
+ a1f:	89 f8                	mov    %edi,%eax
+ a21:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+ a28:	39 ce                	cmp    %ecx,%esi
+ a2a:	74 54                	je     a80 <malloc+0x100>
+        p->s.size -= nunits;
+ a2c:	29 f1                	sub    %esi,%ecx
+ a2e:	89 4a 04             	mov    %ecx,0x4(%edx)
+        p += p->s.size;
+ a31:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
+        p->s.size = nunits;
+ a34:	89 72 04             	mov    %esi,0x4(%edx)
+      freep = prevp;
+ a37:	a3 80 0e 00 00       	mov    %eax,0xe80
+}
+ a3c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return (void*)(p + 1);
+ a3f:	8d 42 08             	lea    0x8(%edx),%eax
+}
+ a42:	5b                   	pop    %ebx
+ a43:	5e                   	pop    %esi
+ a44:	5f                   	pop    %edi
+ a45:	5d                   	pop    %ebp
+ a46:	c3                   	ret    
+ a47:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ a4e:	66 90                	xchg   %ax,%ax
+    base.s.ptr = freep = prevp = &base;
+ a50:	c7 05 80 0e 00 00 84 	movl   $0xe84,0xe80
+ a57:	0e 00 00 
+    base.s.size = 0;
+ a5a:	bf 84 0e 00 00       	mov    $0xe84,%edi
+    base.s.ptr = freep = prevp = &base;
+ a5f:	c7 05 84 0e 00 00 84 	movl   $0xe84,0xe84
+ a66:	0e 00 00 
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ a69:	89 f8                	mov    %edi,%eax
+    base.s.size = 0;
+ a6b:	c7 05 88 0e 00 00 00 	movl   $0x0,0xe88
+ a72:	00 00 00 
+    if(p->s.size >= nunits){
+ a75:	e9 36 ff ff ff       	jmp    9b0 <malloc+0x30>
+ a7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        prevp->s.ptr = p->s.ptr;
+ a80:	8b 0a                	mov    (%edx),%ecx
+ a82:	89 08                	mov    %ecx,(%eax)
+ a84:	eb b1                	jmp    a37 <malloc+0xb7>
diff -ruN xv6-public/grep.d copy-xv6/grep.d
--- xv6-public/grep.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/grep.d	2022-09-05 23:26:11.908781092 +0530
@@ -0,0 +1 @@
+grep.o: grep.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/grep.o and copy-xv6/grep.o differ
diff -ruN xv6-public/grep.sym copy-xv6/grep.sym
--- xv6-public/grep.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/grep.sym	2022-09-05 23:26:11.920781092 +0530
@@ -0,0 +1,66 @@
+00000000 .text
+00000a88 .rodata
+00000adc .eh_frame
+00000e80 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 grep.c
+00000000 ulib.c
+00000000 printf.c
+00000670 printint
+00000ac8 digits.1097
+00000000 umalloc.c
+00000e80 freep
+00000e84 base
+00000340 strcpy
+00000720 printf
+0000065b thread_exit
+00000570 memmove
+00000120 matchhere
+000005eb mknod
+00000460 gets
+00000623 getpid
+00000230 grep
+00000980 malloc
+00000633 sleep
+000005b3 pipe
+000005c3 write
+000005fb fstat
+000005d3 kill
+00000613 chdir
+000005db exec
+000005ab wait
+000005bb read
+000005f3 unlink
+0000059b fork
+0000062b sbrk
+0000063b uptime
+00000e64 __bss_start
+00000400 memset
+00000000 main
+000000c0 matchstar
+00000370 strcmp
+0000061b dup
+00000ea0 buf
+000004e0 stat
+00000e64 _edata
+000012a0 _end
+000001c0 match
+00000603 link
+000005a3 exit
+00000530 atoi
+00000643 draw
+000003c0 strlen
+000005e3 open
+00000420 strchr
+0000064b thread_create
+0000060b mkdir
+000005cb close
+00000653 thread_join
+000008f0 free
diff -ruN xv6-public/ide.d copy-xv6/ide.d
--- xv6-public/ide.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/ide.d	2022-09-05 23:26:13.044781070 +0530
@@ -0,0 +1,2 @@
+ide.o: ide.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h proc.h x86.h traps.h spinlock.h sleeplock.h fs.h buf.h
Binary files xv6-public/ide.o and copy-xv6/ide.o differ
Binary files xv6-public/_init and copy-xv6/_init differ
diff -ruN xv6-public/init.asm copy-xv6/init.asm
--- xv6-public/init.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/init.asm	2022-09-05 23:26:11.944781092 +0530
@@ -0,0 +1,1279 @@
+
+_init:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+
+char *argv[] = { "sh", 0 };
+
+int
+main(void)
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	53                   	push   %ebx
+  12:	51                   	push   %ecx
+  int pid, wpid;
+
+  if(open("console", O_RDWR) < 0){
+  13:	83 ec 08             	sub    $0x8,%esp
+  16:	6a 02                	push   $0x2
+  18:	68 38 08 00 00       	push   $0x838
+  1d:	e8 71 03 00 00       	call   393 <open>
+  22:	83 c4 10             	add    $0x10,%esp
+  25:	85 c0                	test   %eax,%eax
+  27:	0f 88 9b 00 00 00    	js     c8 <main+0xc8>
+    mknod("console", 1, 1);
+    open("console", O_RDWR);
+  }
+  dup(0);  // stdout
+  2d:	83 ec 0c             	sub    $0xc,%esp
+  30:	6a 00                	push   $0x0
+  32:	e8 94 03 00 00       	call   3cb <dup>
+  dup(0);  // stderr
+  37:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  3e:	e8 88 03 00 00       	call   3cb <dup>
+  43:	83 c4 10             	add    $0x10,%esp
+  46:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  4d:	8d 76 00             	lea    0x0(%esi),%esi
+
+  for(;;){
+    printf(1, "init: starting sh\n");
+  50:	83 ec 08             	sub    $0x8,%esp
+  53:	68 40 08 00 00       	push   $0x840
+  58:	6a 01                	push   $0x1
+  5a:	e8 71 04 00 00       	call   4d0 <printf>
+    pid = fork();
+  5f:	e8 e7 02 00 00       	call   34b <fork>
+    if(pid < 0){
+  64:	83 c4 10             	add    $0x10,%esp
+    pid = fork();
+  67:	89 c3                	mov    %eax,%ebx
+    if(pid < 0){
+  69:	85 c0                	test   %eax,%eax
+  6b:	78 24                	js     91 <main+0x91>
+      printf(1, "init: fork failed\n");
+      exit();
+    }
+    if(pid == 0){
+  6d:	74 35                	je     a4 <main+0xa4>
+  6f:	90                   	nop
+      exec("sh", argv);
+      printf(1, "init: exec sh failed\n");
+      exit();
+    }
+    while((wpid=wait()) >= 0 && wpid != pid)
+  70:	e8 e6 02 00 00       	call   35b <wait>
+  75:	85 c0                	test   %eax,%eax
+  77:	78 d7                	js     50 <main+0x50>
+  79:	39 c3                	cmp    %eax,%ebx
+  7b:	74 d3                	je     50 <main+0x50>
+      printf(1, "zombie!\n");
+  7d:	83 ec 08             	sub    $0x8,%esp
+  80:	68 7f 08 00 00       	push   $0x87f
+  85:	6a 01                	push   $0x1
+  87:	e8 44 04 00 00       	call   4d0 <printf>
+  8c:	83 c4 10             	add    $0x10,%esp
+  8f:	eb df                	jmp    70 <main+0x70>
+      printf(1, "init: fork failed\n");
+  91:	53                   	push   %ebx
+  92:	53                   	push   %ebx
+  93:	68 53 08 00 00       	push   $0x853
+  98:	6a 01                	push   $0x1
+  9a:	e8 31 04 00 00       	call   4d0 <printf>
+      exit();
+  9f:	e8 af 02 00 00       	call   353 <exit>
+      exec("sh", argv);
+  a4:	50                   	push   %eax
+  a5:	50                   	push   %eax
+  a6:	68 3c 0b 00 00       	push   $0xb3c
+  ab:	68 66 08 00 00       	push   $0x866
+  b0:	e8 d6 02 00 00       	call   38b <exec>
+      printf(1, "init: exec sh failed\n");
+  b5:	5a                   	pop    %edx
+  b6:	59                   	pop    %ecx
+  b7:	68 69 08 00 00       	push   $0x869
+  bc:	6a 01                	push   $0x1
+  be:	e8 0d 04 00 00       	call   4d0 <printf>
+      exit();
+  c3:	e8 8b 02 00 00       	call   353 <exit>
+    mknod("console", 1, 1);
+  c8:	50                   	push   %eax
+  c9:	6a 01                	push   $0x1
+  cb:	6a 01                	push   $0x1
+  cd:	68 38 08 00 00       	push   $0x838
+  d2:	e8 c4 02 00 00       	call   39b <mknod>
+    open("console", O_RDWR);
+  d7:	58                   	pop    %eax
+  d8:	5a                   	pop    %edx
+  d9:	6a 02                	push   $0x2
+  db:	68 38 08 00 00       	push   $0x838
+  e0:	e8 ae 02 00 00       	call   393 <open>
+  e5:	83 c4 10             	add    $0x10,%esp
+  e8:	e9 40 ff ff ff       	jmp    2d <main+0x2d>
+  ed:	66 90                	xchg   %ax,%ax
+  ef:	90                   	nop
+
+000000f0 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+  f0:	f3 0f 1e fb          	endbr32 
+  f4:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  f5:	31 c0                	xor    %eax,%eax
+{
+  f7:	89 e5                	mov    %esp,%ebp
+  f9:	53                   	push   %ebx
+  fa:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  fd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+ 100:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+ 104:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+ 107:	83 c0 01             	add    $0x1,%eax
+ 10a:	84 d2                	test   %dl,%dl
+ 10c:	75 f2                	jne    100 <strcpy+0x10>
+    ;
+  return os;
+}
+ 10e:	89 c8                	mov    %ecx,%eax
+ 110:	5b                   	pop    %ebx
+ 111:	5d                   	pop    %ebp
+ 112:	c3                   	ret    
+ 113:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 11a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000120 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 120:	f3 0f 1e fb          	endbr32 
+ 124:	55                   	push   %ebp
+ 125:	89 e5                	mov    %esp,%ebp
+ 127:	53                   	push   %ebx
+ 128:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 12b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+ 12e:	0f b6 01             	movzbl (%ecx),%eax
+ 131:	0f b6 1a             	movzbl (%edx),%ebx
+ 134:	84 c0                	test   %al,%al
+ 136:	75 19                	jne    151 <strcmp+0x31>
+ 138:	eb 26                	jmp    160 <strcmp+0x40>
+ 13a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 140:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+ 144:	83 c1 01             	add    $0x1,%ecx
+ 147:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+ 14a:	0f b6 1a             	movzbl (%edx),%ebx
+ 14d:	84 c0                	test   %al,%al
+ 14f:	74 0f                	je     160 <strcmp+0x40>
+ 151:	38 d8                	cmp    %bl,%al
+ 153:	74 eb                	je     140 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+ 155:	29 d8                	sub    %ebx,%eax
+}
+ 157:	5b                   	pop    %ebx
+ 158:	5d                   	pop    %ebp
+ 159:	c3                   	ret    
+ 15a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 160:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+ 162:	29 d8                	sub    %ebx,%eax
+}
+ 164:	5b                   	pop    %ebx
+ 165:	5d                   	pop    %ebp
+ 166:	c3                   	ret    
+ 167:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 16e:	66 90                	xchg   %ax,%ax
+
+00000170 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 170:	f3 0f 1e fb          	endbr32 
+ 174:	55                   	push   %ebp
+ 175:	89 e5                	mov    %esp,%ebp
+ 177:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 17a:	80 3a 00             	cmpb   $0x0,(%edx)
+ 17d:	74 21                	je     1a0 <strlen+0x30>
+ 17f:	31 c0                	xor    %eax,%eax
+ 181:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 188:	83 c0 01             	add    $0x1,%eax
+ 18b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+ 18f:	89 c1                	mov    %eax,%ecx
+ 191:	75 f5                	jne    188 <strlen+0x18>
+    ;
+  return n;
+}
+ 193:	89 c8                	mov    %ecx,%eax
+ 195:	5d                   	pop    %ebp
+ 196:	c3                   	ret    
+ 197:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 19e:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+ 1a0:	31 c9                	xor    %ecx,%ecx
+}
+ 1a2:	5d                   	pop    %ebp
+ 1a3:	89 c8                	mov    %ecx,%eax
+ 1a5:	c3                   	ret    
+ 1a6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1ad:	8d 76 00             	lea    0x0(%esi),%esi
+
+000001b0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 1b0:	f3 0f 1e fb          	endbr32 
+ 1b4:	55                   	push   %ebp
+ 1b5:	89 e5                	mov    %esp,%ebp
+ 1b7:	57                   	push   %edi
+ 1b8:	8b 55 08             	mov    0x8(%ebp),%edx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+ 1bb:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 1be:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1c1:	89 d7                	mov    %edx,%edi
+ 1c3:	fc                   	cld    
+ 1c4:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+ 1c6:	89 d0                	mov    %edx,%eax
+ 1c8:	5f                   	pop    %edi
+ 1c9:	5d                   	pop    %ebp
+ 1ca:	c3                   	ret    
+ 1cb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 1cf:	90                   	nop
+
+000001d0 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 1d0:	f3 0f 1e fb          	endbr32 
+ 1d4:	55                   	push   %ebp
+ 1d5:	89 e5                	mov    %esp,%ebp
+ 1d7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1da:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+ 1de:	0f b6 10             	movzbl (%eax),%edx
+ 1e1:	84 d2                	test   %dl,%dl
+ 1e3:	75 16                	jne    1fb <strchr+0x2b>
+ 1e5:	eb 21                	jmp    208 <strchr+0x38>
+ 1e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1ee:	66 90                	xchg   %ax,%ax
+ 1f0:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+ 1f4:	83 c0 01             	add    $0x1,%eax
+ 1f7:	84 d2                	test   %dl,%dl
+ 1f9:	74 0d                	je     208 <strchr+0x38>
+    if(*s == c)
+ 1fb:	38 d1                	cmp    %dl,%cl
+ 1fd:	75 f1                	jne    1f0 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+ 1ff:	5d                   	pop    %ebp
+ 200:	c3                   	ret    
+ 201:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+ 208:	31 c0                	xor    %eax,%eax
+}
+ 20a:	5d                   	pop    %ebp
+ 20b:	c3                   	ret    
+ 20c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000210 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 210:	f3 0f 1e fb          	endbr32 
+ 214:	55                   	push   %ebp
+ 215:	89 e5                	mov    %esp,%ebp
+ 217:	57                   	push   %edi
+ 218:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 219:	31 f6                	xor    %esi,%esi
+{
+ 21b:	53                   	push   %ebx
+ 21c:	89 f3                	mov    %esi,%ebx
+ 21e:	83 ec 1c             	sub    $0x1c,%esp
+ 221:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+ 224:	eb 33                	jmp    259 <gets+0x49>
+ 226:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 22d:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+ 230:	83 ec 04             	sub    $0x4,%esp
+ 233:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ 236:	6a 01                	push   $0x1
+ 238:	50                   	push   %eax
+ 239:	6a 00                	push   $0x0
+ 23b:	e8 2b 01 00 00       	call   36b <read>
+    if(cc < 1)
+ 240:	83 c4 10             	add    $0x10,%esp
+ 243:	85 c0                	test   %eax,%eax
+ 245:	7e 1c                	jle    263 <gets+0x53>
+      break;
+    buf[i++] = c;
+ 247:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ 24b:	83 c7 01             	add    $0x1,%edi
+ 24e:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+ 251:	3c 0a                	cmp    $0xa,%al
+ 253:	74 23                	je     278 <gets+0x68>
+ 255:	3c 0d                	cmp    $0xd,%al
+ 257:	74 1f                	je     278 <gets+0x68>
+  for(i=0; i+1 < max; ){
+ 259:	83 c3 01             	add    $0x1,%ebx
+ 25c:	89 fe                	mov    %edi,%esi
+ 25e:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+ 261:	7c cd                	jl     230 <gets+0x20>
+ 263:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+ 265:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+ 268:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 26b:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 26e:	5b                   	pop    %ebx
+ 26f:	5e                   	pop    %esi
+ 270:	5f                   	pop    %edi
+ 271:	5d                   	pop    %ebp
+ 272:	c3                   	ret    
+ 273:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 277:	90                   	nop
+ 278:	8b 75 08             	mov    0x8(%ebp),%esi
+ 27b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 27e:	01 de                	add    %ebx,%esi
+ 280:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+ 282:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 285:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 288:	5b                   	pop    %ebx
+ 289:	5e                   	pop    %esi
+ 28a:	5f                   	pop    %edi
+ 28b:	5d                   	pop    %ebp
+ 28c:	c3                   	ret    
+ 28d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000290 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 290:	f3 0f 1e fb          	endbr32 
+ 294:	55                   	push   %ebp
+ 295:	89 e5                	mov    %esp,%ebp
+ 297:	56                   	push   %esi
+ 298:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 299:	83 ec 08             	sub    $0x8,%esp
+ 29c:	6a 00                	push   $0x0
+ 29e:	ff 75 08             	pushl  0x8(%ebp)
+ 2a1:	e8 ed 00 00 00       	call   393 <open>
+  if(fd < 0)
+ 2a6:	83 c4 10             	add    $0x10,%esp
+ 2a9:	85 c0                	test   %eax,%eax
+ 2ab:	78 2b                	js     2d8 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+ 2ad:	83 ec 08             	sub    $0x8,%esp
+ 2b0:	ff 75 0c             	pushl  0xc(%ebp)
+ 2b3:	89 c3                	mov    %eax,%ebx
+ 2b5:	50                   	push   %eax
+ 2b6:	e8 f0 00 00 00       	call   3ab <fstat>
+  close(fd);
+ 2bb:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+ 2be:	89 c6                	mov    %eax,%esi
+  close(fd);
+ 2c0:	e8 b6 00 00 00       	call   37b <close>
+  return r;
+ 2c5:	83 c4 10             	add    $0x10,%esp
+}
+ 2c8:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 2cb:	89 f0                	mov    %esi,%eax
+ 2cd:	5b                   	pop    %ebx
+ 2ce:	5e                   	pop    %esi
+ 2cf:	5d                   	pop    %ebp
+ 2d0:	c3                   	ret    
+ 2d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+ 2d8:	be ff ff ff ff       	mov    $0xffffffff,%esi
+ 2dd:	eb e9                	jmp    2c8 <stat+0x38>
+ 2df:	90                   	nop
+
+000002e0 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 2e0:	f3 0f 1e fb          	endbr32 
+ 2e4:	55                   	push   %ebp
+ 2e5:	89 e5                	mov    %esp,%ebp
+ 2e7:	53                   	push   %ebx
+ 2e8:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 2eb:	0f be 02             	movsbl (%edx),%eax
+ 2ee:	8d 48 d0             	lea    -0x30(%eax),%ecx
+ 2f1:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+ 2f4:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+ 2f9:	77 1a                	ja     315 <atoi+0x35>
+ 2fb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 2ff:	90                   	nop
+    n = n*10 + *s++ - '0';
+ 300:	83 c2 01             	add    $0x1,%edx
+ 303:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+ 306:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+ 30a:	0f be 02             	movsbl (%edx),%eax
+ 30d:	8d 58 d0             	lea    -0x30(%eax),%ebx
+ 310:	80 fb 09             	cmp    $0x9,%bl
+ 313:	76 eb                	jbe    300 <atoi+0x20>
+  return n;
+}
+ 315:	89 c8                	mov    %ecx,%eax
+ 317:	5b                   	pop    %ebx
+ 318:	5d                   	pop    %ebp
+ 319:	c3                   	ret    
+ 31a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000320 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 320:	f3 0f 1e fb          	endbr32 
+ 324:	55                   	push   %ebp
+ 325:	89 e5                	mov    %esp,%ebp
+ 327:	57                   	push   %edi
+ 328:	8b 45 10             	mov    0x10(%ebp),%eax
+ 32b:	8b 55 08             	mov    0x8(%ebp),%edx
+ 32e:	56                   	push   %esi
+ 32f:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 332:	85 c0                	test   %eax,%eax
+ 334:	7e 0f                	jle    345 <memmove+0x25>
+ 336:	01 d0                	add    %edx,%eax
+  dst = vdst;
+ 338:	89 d7                	mov    %edx,%edi
+ 33a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+ 340:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+ 341:	39 f8                	cmp    %edi,%eax
+ 343:	75 fb                	jne    340 <memmove+0x20>
+  return vdst;
+}
+ 345:	5e                   	pop    %esi
+ 346:	89 d0                	mov    %edx,%eax
+ 348:	5f                   	pop    %edi
+ 349:	5d                   	pop    %ebp
+ 34a:	c3                   	ret    
+
+0000034b <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 34b:	b8 01 00 00 00       	mov    $0x1,%eax
+ 350:	cd 40                	int    $0x40
+ 352:	c3                   	ret    
+
+00000353 <exit>:
+SYSCALL(exit)
+ 353:	b8 02 00 00 00       	mov    $0x2,%eax
+ 358:	cd 40                	int    $0x40
+ 35a:	c3                   	ret    
+
+0000035b <wait>:
+SYSCALL(wait)
+ 35b:	b8 03 00 00 00       	mov    $0x3,%eax
+ 360:	cd 40                	int    $0x40
+ 362:	c3                   	ret    
+
+00000363 <pipe>:
+SYSCALL(pipe)
+ 363:	b8 04 00 00 00       	mov    $0x4,%eax
+ 368:	cd 40                	int    $0x40
+ 36a:	c3                   	ret    
+
+0000036b <read>:
+SYSCALL(read)
+ 36b:	b8 05 00 00 00       	mov    $0x5,%eax
+ 370:	cd 40                	int    $0x40
+ 372:	c3                   	ret    
+
+00000373 <write>:
+SYSCALL(write)
+ 373:	b8 10 00 00 00       	mov    $0x10,%eax
+ 378:	cd 40                	int    $0x40
+ 37a:	c3                   	ret    
+
+0000037b <close>:
+SYSCALL(close)
+ 37b:	b8 15 00 00 00       	mov    $0x15,%eax
+ 380:	cd 40                	int    $0x40
+ 382:	c3                   	ret    
+
+00000383 <kill>:
+SYSCALL(kill)
+ 383:	b8 06 00 00 00       	mov    $0x6,%eax
+ 388:	cd 40                	int    $0x40
+ 38a:	c3                   	ret    
+
+0000038b <exec>:
+SYSCALL(exec)
+ 38b:	b8 07 00 00 00       	mov    $0x7,%eax
+ 390:	cd 40                	int    $0x40
+ 392:	c3                   	ret    
+
+00000393 <open>:
+SYSCALL(open)
+ 393:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 398:	cd 40                	int    $0x40
+ 39a:	c3                   	ret    
+
+0000039b <mknod>:
+SYSCALL(mknod)
+ 39b:	b8 11 00 00 00       	mov    $0x11,%eax
+ 3a0:	cd 40                	int    $0x40
+ 3a2:	c3                   	ret    
+
+000003a3 <unlink>:
+SYSCALL(unlink)
+ 3a3:	b8 12 00 00 00       	mov    $0x12,%eax
+ 3a8:	cd 40                	int    $0x40
+ 3aa:	c3                   	ret    
+
+000003ab <fstat>:
+SYSCALL(fstat)
+ 3ab:	b8 08 00 00 00       	mov    $0x8,%eax
+ 3b0:	cd 40                	int    $0x40
+ 3b2:	c3                   	ret    
+
+000003b3 <link>:
+SYSCALL(link)
+ 3b3:	b8 13 00 00 00       	mov    $0x13,%eax
+ 3b8:	cd 40                	int    $0x40
+ 3ba:	c3                   	ret    
+
+000003bb <mkdir>:
+SYSCALL(mkdir)
+ 3bb:	b8 14 00 00 00       	mov    $0x14,%eax
+ 3c0:	cd 40                	int    $0x40
+ 3c2:	c3                   	ret    
+
+000003c3 <chdir>:
+SYSCALL(chdir)
+ 3c3:	b8 09 00 00 00       	mov    $0x9,%eax
+ 3c8:	cd 40                	int    $0x40
+ 3ca:	c3                   	ret    
+
+000003cb <dup>:
+SYSCALL(dup)
+ 3cb:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 3d0:	cd 40                	int    $0x40
+ 3d2:	c3                   	ret    
+
+000003d3 <getpid>:
+SYSCALL(getpid)
+ 3d3:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 3d8:	cd 40                	int    $0x40
+ 3da:	c3                   	ret    
+
+000003db <sbrk>:
+SYSCALL(sbrk)
+ 3db:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 3e0:	cd 40                	int    $0x40
+ 3e2:	c3                   	ret    
+
+000003e3 <sleep>:
+SYSCALL(sleep)
+ 3e3:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 3e8:	cd 40                	int    $0x40
+ 3ea:	c3                   	ret    
+
+000003eb <uptime>:
+SYSCALL(uptime)
+ 3eb:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 3f0:	cd 40                	int    $0x40
+ 3f2:	c3                   	ret    
+
+000003f3 <draw>:
+SYSCALL(draw)
+ 3f3:	b8 16 00 00 00       	mov    $0x16,%eax
+ 3f8:	cd 40                	int    $0x40
+ 3fa:	c3                   	ret    
+
+000003fb <thread_create>:
+
+SYSCALL(thread_create)
+ 3fb:	b8 17 00 00 00       	mov    $0x17,%eax
+ 400:	cd 40                	int    $0x40
+ 402:	c3                   	ret    
+
+00000403 <thread_join>:
+SYSCALL(thread_join)
+ 403:	b8 18 00 00 00       	mov    $0x18,%eax
+ 408:	cd 40                	int    $0x40
+ 40a:	c3                   	ret    
+
+0000040b <thread_exit>:
+SYSCALL(thread_exit)
+ 40b:	b8 19 00 00 00       	mov    $0x19,%eax
+ 410:	cd 40                	int    $0x40
+ 412:	c3                   	ret    
+ 413:	66 90                	xchg   %ax,%ax
+ 415:	66 90                	xchg   %ax,%ax
+ 417:	66 90                	xchg   %ax,%ax
+ 419:	66 90                	xchg   %ax,%ax
+ 41b:	66 90                	xchg   %ax,%ax
+ 41d:	66 90                	xchg   %ax,%ax
+ 41f:	90                   	nop
+
+00000420 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 420:	55                   	push   %ebp
+ 421:	89 e5                	mov    %esp,%ebp
+ 423:	57                   	push   %edi
+ 424:	56                   	push   %esi
+ 425:	53                   	push   %ebx
+ 426:	83 ec 3c             	sub    $0x3c,%esp
+ 429:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+ 42c:	89 d1                	mov    %edx,%ecx
+{
+ 42e:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  if(sgn && xx < 0){
+ 431:	85 d2                	test   %edx,%edx
+ 433:	0f 89 7f 00 00 00    	jns    4b8 <printint+0x98>
+ 439:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
+ 43d:	74 79                	je     4b8 <printint+0x98>
+    neg = 1;
+ 43f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+    x = -xx;
+ 446:	f7 d9                	neg    %ecx
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 448:	31 db                	xor    %ebx,%ebx
+ 44a:	8d 75 d7             	lea    -0x29(%ebp),%esi
+ 44d:	8d 76 00             	lea    0x0(%esi),%esi
+  do{
+    buf[i++] = digits[x % base];
+ 450:	89 c8                	mov    %ecx,%eax
+ 452:	31 d2                	xor    %edx,%edx
+ 454:	89 cf                	mov    %ecx,%edi
+ 456:	f7 75 c4             	divl   -0x3c(%ebp)
+ 459:	0f b6 92 90 08 00 00 	movzbl 0x890(%edx),%edx
+ 460:	89 45 c0             	mov    %eax,-0x40(%ebp)
+ 463:	89 d8                	mov    %ebx,%eax
+ 465:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+ 468:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+    buf[i++] = digits[x % base];
+ 46b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
+  }while((x /= base) != 0);
+ 46e:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
+ 471:	76 dd                	jbe    450 <printint+0x30>
+  if(neg)
+ 473:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+ 476:	85 c9                	test   %ecx,%ecx
+ 478:	74 0c                	je     486 <printint+0x66>
+    buf[i++] = '-';
+ 47a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+ 47f:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+ 481:	ba 2d 00 00 00       	mov    $0x2d,%edx
+
+  while(--i >= 0)
+ 486:	8b 7d b8             	mov    -0x48(%ebp),%edi
+ 489:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+ 48d:	eb 07                	jmp    496 <printint+0x76>
+ 48f:	90                   	nop
+ 490:	0f b6 13             	movzbl (%ebx),%edx
+ 493:	83 eb 01             	sub    $0x1,%ebx
+  write(fd, &c, 1);
+ 496:	83 ec 04             	sub    $0x4,%esp
+ 499:	88 55 d7             	mov    %dl,-0x29(%ebp)
+ 49c:	6a 01                	push   $0x1
+ 49e:	56                   	push   %esi
+ 49f:	57                   	push   %edi
+ 4a0:	e8 ce fe ff ff       	call   373 <write>
+  while(--i >= 0)
+ 4a5:	83 c4 10             	add    $0x10,%esp
+ 4a8:	39 de                	cmp    %ebx,%esi
+ 4aa:	75 e4                	jne    490 <printint+0x70>
+    putc(fd, buf[i]);
+}
+ 4ac:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 4af:	5b                   	pop    %ebx
+ 4b0:	5e                   	pop    %esi
+ 4b1:	5f                   	pop    %edi
+ 4b2:	5d                   	pop    %ebp
+ 4b3:	c3                   	ret    
+ 4b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  neg = 0;
+ 4b8:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+ 4bf:	eb 87                	jmp    448 <printint+0x28>
+ 4c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 4c8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 4cf:	90                   	nop
+
+000004d0 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 4d0:	f3 0f 1e fb          	endbr32 
+ 4d4:	55                   	push   %ebp
+ 4d5:	89 e5                	mov    %esp,%ebp
+ 4d7:	57                   	push   %edi
+ 4d8:	56                   	push   %esi
+ 4d9:	53                   	push   %ebx
+ 4da:	83 ec 2c             	sub    $0x2c,%esp
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 4dd:	8b 75 0c             	mov    0xc(%ebp),%esi
+ 4e0:	0f b6 1e             	movzbl (%esi),%ebx
+ 4e3:	84 db                	test   %bl,%bl
+ 4e5:	0f 84 b4 00 00 00    	je     59f <printf+0xcf>
+  ap = (uint*)(void*)&fmt + 1;
+ 4eb:	8d 45 10             	lea    0x10(%ebp),%eax
+ 4ee:	83 c6 01             	add    $0x1,%esi
+  write(fd, &c, 1);
+ 4f1:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  state = 0;
+ 4f4:	31 d2                	xor    %edx,%edx
+  ap = (uint*)(void*)&fmt + 1;
+ 4f6:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 4f9:	eb 33                	jmp    52e <printf+0x5e>
+ 4fb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 4ff:	90                   	nop
+ 500:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+ 503:	ba 25 00 00 00       	mov    $0x25,%edx
+      if(c == '%'){
+ 508:	83 f8 25             	cmp    $0x25,%eax
+ 50b:	74 17                	je     524 <printf+0x54>
+  write(fd, &c, 1);
+ 50d:	83 ec 04             	sub    $0x4,%esp
+ 510:	88 5d e7             	mov    %bl,-0x19(%ebp)
+ 513:	6a 01                	push   $0x1
+ 515:	57                   	push   %edi
+ 516:	ff 75 08             	pushl  0x8(%ebp)
+ 519:	e8 55 fe ff ff       	call   373 <write>
+ 51e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+      } else {
+        putc(fd, c);
+ 521:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; fmt[i]; i++){
+ 524:	0f b6 1e             	movzbl (%esi),%ebx
+ 527:	83 c6 01             	add    $0x1,%esi
+ 52a:	84 db                	test   %bl,%bl
+ 52c:	74 71                	je     59f <printf+0xcf>
+    c = fmt[i] & 0xff;
+ 52e:	0f be cb             	movsbl %bl,%ecx
+ 531:	0f b6 c3             	movzbl %bl,%eax
+    if(state == 0){
+ 534:	85 d2                	test   %edx,%edx
+ 536:	74 c8                	je     500 <printf+0x30>
+      }
+    } else if(state == '%'){
+ 538:	83 fa 25             	cmp    $0x25,%edx
+ 53b:	75 e7                	jne    524 <printf+0x54>
+      if(c == 'd'){
+ 53d:	83 f8 64             	cmp    $0x64,%eax
+ 540:	0f 84 9a 00 00 00    	je     5e0 <printf+0x110>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+ 546:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
+ 54c:	83 f9 70             	cmp    $0x70,%ecx
+ 54f:	74 5f                	je     5b0 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+ 551:	83 f8 73             	cmp    $0x73,%eax
+ 554:	0f 84 d6 00 00 00    	je     630 <printf+0x160>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 55a:	83 f8 63             	cmp    $0x63,%eax
+ 55d:	0f 84 8d 00 00 00    	je     5f0 <printf+0x120>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+ 563:	83 f8 25             	cmp    $0x25,%eax
+ 566:	0f 84 b4 00 00 00    	je     620 <printf+0x150>
+  write(fd, &c, 1);
+ 56c:	83 ec 04             	sub    $0x4,%esp
+ 56f:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
+ 573:	6a 01                	push   $0x1
+ 575:	57                   	push   %edi
+ 576:	ff 75 08             	pushl  0x8(%ebp)
+ 579:	e8 f5 fd ff ff       	call   373 <write>
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+ 57e:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 581:	83 c4 0c             	add    $0xc,%esp
+ 584:	6a 01                	push   $0x1
+ 586:	83 c6 01             	add    $0x1,%esi
+ 589:	57                   	push   %edi
+ 58a:	ff 75 08             	pushl  0x8(%ebp)
+ 58d:	e8 e1 fd ff ff       	call   373 <write>
+  for(i = 0; fmt[i]; i++){
+ 592:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
+        putc(fd, c);
+ 596:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 599:	31 d2                	xor    %edx,%edx
+  for(i = 0; fmt[i]; i++){
+ 59b:	84 db                	test   %bl,%bl
+ 59d:	75 8f                	jne    52e <printf+0x5e>
+    }
+  }
+}
+ 59f:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 5a2:	5b                   	pop    %ebx
+ 5a3:	5e                   	pop    %esi
+ 5a4:	5f                   	pop    %edi
+ 5a5:	5d                   	pop    %ebp
+ 5a6:	c3                   	ret    
+ 5a7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 5ae:	66 90                	xchg   %ax,%ax
+        printint(fd, *ap, 16, 0);
+ 5b0:	83 ec 0c             	sub    $0xc,%esp
+ 5b3:	b9 10 00 00 00       	mov    $0x10,%ecx
+ 5b8:	6a 00                	push   $0x0
+ 5ba:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+ 5bd:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5c0:	8b 13                	mov    (%ebx),%edx
+ 5c2:	e8 59 fe ff ff       	call   420 <printint>
+        ap++;
+ 5c7:	89 d8                	mov    %ebx,%eax
+ 5c9:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 5cc:	31 d2                	xor    %edx,%edx
+        ap++;
+ 5ce:	83 c0 04             	add    $0x4,%eax
+ 5d1:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 5d4:	e9 4b ff ff ff       	jmp    524 <printf+0x54>
+ 5d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        printint(fd, *ap, 10, 1);
+ 5e0:	83 ec 0c             	sub    $0xc,%esp
+ 5e3:	b9 0a 00 00 00       	mov    $0xa,%ecx
+ 5e8:	6a 01                	push   $0x1
+ 5ea:	eb ce                	jmp    5ba <printf+0xea>
+ 5ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        putc(fd, *ap);
+ 5f0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+  write(fd, &c, 1);
+ 5f3:	83 ec 04             	sub    $0x4,%esp
+        putc(fd, *ap);
+ 5f6:	8b 03                	mov    (%ebx),%eax
+  write(fd, &c, 1);
+ 5f8:	6a 01                	push   $0x1
+        ap++;
+ 5fa:	83 c3 04             	add    $0x4,%ebx
+  write(fd, &c, 1);
+ 5fd:	57                   	push   %edi
+ 5fe:	ff 75 08             	pushl  0x8(%ebp)
+        putc(fd, *ap);
+ 601:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 604:	e8 6a fd ff ff       	call   373 <write>
+        ap++;
+ 609:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+ 60c:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 60f:	31 d2                	xor    %edx,%edx
+ 611:	e9 0e ff ff ff       	jmp    524 <printf+0x54>
+ 616:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 61d:	8d 76 00             	lea    0x0(%esi),%esi
+        putc(fd, c);
+ 620:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 623:	83 ec 04             	sub    $0x4,%esp
+ 626:	e9 59 ff ff ff       	jmp    584 <printf+0xb4>
+ 62b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 62f:	90                   	nop
+        s = (char*)*ap;
+ 630:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 633:	8b 18                	mov    (%eax),%ebx
+        ap++;
+ 635:	83 c0 04             	add    $0x4,%eax
+ 638:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        if(s == 0)
+ 63b:	85 db                	test   %ebx,%ebx
+ 63d:	74 17                	je     656 <printf+0x186>
+        while(*s != 0){
+ 63f:	0f b6 03             	movzbl (%ebx),%eax
+      state = 0;
+ 642:	31 d2                	xor    %edx,%edx
+        while(*s != 0){
+ 644:	84 c0                	test   %al,%al
+ 646:	0f 84 d8 fe ff ff    	je     524 <printf+0x54>
+ 64c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 64f:	89 de                	mov    %ebx,%esi
+ 651:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 654:	eb 1a                	jmp    670 <printf+0x1a0>
+          s = "(null)";
+ 656:	bb 88 08 00 00       	mov    $0x888,%ebx
+        while(*s != 0){
+ 65b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 65e:	b8 28 00 00 00       	mov    $0x28,%eax
+ 663:	89 de                	mov    %ebx,%esi
+ 665:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 668:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 66f:	90                   	nop
+  write(fd, &c, 1);
+ 670:	83 ec 04             	sub    $0x4,%esp
+          s++;
+ 673:	83 c6 01             	add    $0x1,%esi
+ 676:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 679:	6a 01                	push   $0x1
+ 67b:	57                   	push   %edi
+ 67c:	53                   	push   %ebx
+ 67d:	e8 f1 fc ff ff       	call   373 <write>
+        while(*s != 0){
+ 682:	0f b6 06             	movzbl (%esi),%eax
+ 685:	83 c4 10             	add    $0x10,%esp
+ 688:	84 c0                	test   %al,%al
+ 68a:	75 e4                	jne    670 <printf+0x1a0>
+ 68c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+      state = 0;
+ 68f:	31 d2                	xor    %edx,%edx
+ 691:	e9 8e fe ff ff       	jmp    524 <printf+0x54>
+ 696:	66 90                	xchg   %ax,%ax
+ 698:	66 90                	xchg   %ax,%ax
+ 69a:	66 90                	xchg   %ax,%ax
+ 69c:	66 90                	xchg   %ax,%ax
+ 69e:	66 90                	xchg   %ax,%ax
+
+000006a0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 6a0:	f3 0f 1e fb          	endbr32 
+ 6a4:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 6a5:	a1 44 0b 00 00       	mov    0xb44,%eax
+{
+ 6aa:	89 e5                	mov    %esp,%ebp
+ 6ac:	57                   	push   %edi
+ 6ad:	56                   	push   %esi
+ 6ae:	53                   	push   %ebx
+ 6af:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 6b2:	8b 10                	mov    (%eax),%edx
+  bp = (Header*)ap - 1;
+ 6b4:	8d 4b f8             	lea    -0x8(%ebx),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 6b7:	39 c8                	cmp    %ecx,%eax
+ 6b9:	73 15                	jae    6d0 <free+0x30>
+ 6bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 6bf:	90                   	nop
+ 6c0:	39 d1                	cmp    %edx,%ecx
+ 6c2:	72 14                	jb     6d8 <free+0x38>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 6c4:	39 d0                	cmp    %edx,%eax
+ 6c6:	73 10                	jae    6d8 <free+0x38>
+{
+ 6c8:	89 d0                	mov    %edx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 6ca:	8b 10                	mov    (%eax),%edx
+ 6cc:	39 c8                	cmp    %ecx,%eax
+ 6ce:	72 f0                	jb     6c0 <free+0x20>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 6d0:	39 d0                	cmp    %edx,%eax
+ 6d2:	72 f4                	jb     6c8 <free+0x28>
+ 6d4:	39 d1                	cmp    %edx,%ecx
+ 6d6:	73 f0                	jae    6c8 <free+0x28>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 6d8:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ 6db:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
+ 6de:	39 fa                	cmp    %edi,%edx
+ 6e0:	74 1e                	je     700 <free+0x60>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+ 6e2:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 6e5:	8b 50 04             	mov    0x4(%eax),%edx
+ 6e8:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 6eb:	39 f1                	cmp    %esi,%ecx
+ 6ed:	74 28                	je     717 <free+0x77>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+ 6ef:	89 08                	mov    %ecx,(%eax)
+  freep = p;
+}
+ 6f1:	5b                   	pop    %ebx
+  freep = p;
+ 6f2:	a3 44 0b 00 00       	mov    %eax,0xb44
+}
+ 6f7:	5e                   	pop    %esi
+ 6f8:	5f                   	pop    %edi
+ 6f9:	5d                   	pop    %ebp
+ 6fa:	c3                   	ret    
+ 6fb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 6ff:	90                   	nop
+    bp->s.size += p->s.ptr->s.size;
+ 700:	03 72 04             	add    0x4(%edx),%esi
+ 703:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 706:	8b 10                	mov    (%eax),%edx
+ 708:	8b 12                	mov    (%edx),%edx
+ 70a:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 70d:	8b 50 04             	mov    0x4(%eax),%edx
+ 710:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 713:	39 f1                	cmp    %esi,%ecx
+ 715:	75 d8                	jne    6ef <free+0x4f>
+    p->s.size += bp->s.size;
+ 717:	03 53 fc             	add    -0x4(%ebx),%edx
+  freep = p;
+ 71a:	a3 44 0b 00 00       	mov    %eax,0xb44
+    p->s.size += bp->s.size;
+ 71f:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 722:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ 725:	89 10                	mov    %edx,(%eax)
+}
+ 727:	5b                   	pop    %ebx
+ 728:	5e                   	pop    %esi
+ 729:	5f                   	pop    %edi
+ 72a:	5d                   	pop    %ebp
+ 72b:	c3                   	ret    
+ 72c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000730 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 730:	f3 0f 1e fb          	endbr32 
+ 734:	55                   	push   %ebp
+ 735:	89 e5                	mov    %esp,%ebp
+ 737:	57                   	push   %edi
+ 738:	56                   	push   %esi
+ 739:	53                   	push   %ebx
+ 73a:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 73d:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+ 740:	8b 3d 44 0b 00 00    	mov    0xb44,%edi
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 746:	8d 70 07             	lea    0x7(%eax),%esi
+ 749:	c1 ee 03             	shr    $0x3,%esi
+ 74c:	83 c6 01             	add    $0x1,%esi
+  if((prevp = freep) == 0){
+ 74f:	85 ff                	test   %edi,%edi
+ 751:	0f 84 a9 00 00 00    	je     800 <malloc+0xd0>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 757:	8b 07                	mov    (%edi),%eax
+    if(p->s.size >= nunits){
+ 759:	8b 48 04             	mov    0x4(%eax),%ecx
+ 75c:	39 f1                	cmp    %esi,%ecx
+ 75e:	73 6d                	jae    7cd <malloc+0x9d>
+ 760:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+ 766:	bb 00 10 00 00       	mov    $0x1000,%ebx
+ 76b:	0f 43 de             	cmovae %esi,%ebx
+  p = sbrk(nu * sizeof(Header));
+ 76e:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
+ 775:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+ 778:	eb 17                	jmp    791 <malloc+0x61>
+ 77a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 780:	8b 10                	mov    (%eax),%edx
+    if(p->s.size >= nunits){
+ 782:	8b 4a 04             	mov    0x4(%edx),%ecx
+ 785:	39 f1                	cmp    %esi,%ecx
+ 787:	73 4f                	jae    7d8 <malloc+0xa8>
+ 789:	8b 3d 44 0b 00 00    	mov    0xb44,%edi
+ 78f:	89 d0                	mov    %edx,%eax
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 791:	39 c7                	cmp    %eax,%edi
+ 793:	75 eb                	jne    780 <malloc+0x50>
+  p = sbrk(nu * sizeof(Header));
+ 795:	83 ec 0c             	sub    $0xc,%esp
+ 798:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 79b:	e8 3b fc ff ff       	call   3db <sbrk>
+  if(p == (char*)-1)
+ 7a0:	83 c4 10             	add    $0x10,%esp
+ 7a3:	83 f8 ff             	cmp    $0xffffffff,%eax
+ 7a6:	74 1b                	je     7c3 <malloc+0x93>
+  hp->s.size = nu;
+ 7a8:	89 58 04             	mov    %ebx,0x4(%eax)
+  free((void*)(hp + 1));
+ 7ab:	83 ec 0c             	sub    $0xc,%esp
+ 7ae:	83 c0 08             	add    $0x8,%eax
+ 7b1:	50                   	push   %eax
+ 7b2:	e8 e9 fe ff ff       	call   6a0 <free>
+  return freep;
+ 7b7:	a1 44 0b 00 00       	mov    0xb44,%eax
+      if((p = morecore(nunits)) == 0)
+ 7bc:	83 c4 10             	add    $0x10,%esp
+ 7bf:	85 c0                	test   %eax,%eax
+ 7c1:	75 bd                	jne    780 <malloc+0x50>
+        return 0;
+  }
+}
+ 7c3:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return 0;
+ 7c6:	31 c0                	xor    %eax,%eax
+}
+ 7c8:	5b                   	pop    %ebx
+ 7c9:	5e                   	pop    %esi
+ 7ca:	5f                   	pop    %edi
+ 7cb:	5d                   	pop    %ebp
+ 7cc:	c3                   	ret    
+    if(p->s.size >= nunits){
+ 7cd:	89 c2                	mov    %eax,%edx
+ 7cf:	89 f8                	mov    %edi,%eax
+ 7d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+ 7d8:	39 ce                	cmp    %ecx,%esi
+ 7da:	74 54                	je     830 <malloc+0x100>
+        p->s.size -= nunits;
+ 7dc:	29 f1                	sub    %esi,%ecx
+ 7de:	89 4a 04             	mov    %ecx,0x4(%edx)
+        p += p->s.size;
+ 7e1:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
+        p->s.size = nunits;
+ 7e4:	89 72 04             	mov    %esi,0x4(%edx)
+      freep = prevp;
+ 7e7:	a3 44 0b 00 00       	mov    %eax,0xb44
+}
+ 7ec:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return (void*)(p + 1);
+ 7ef:	8d 42 08             	lea    0x8(%edx),%eax
+}
+ 7f2:	5b                   	pop    %ebx
+ 7f3:	5e                   	pop    %esi
+ 7f4:	5f                   	pop    %edi
+ 7f5:	5d                   	pop    %ebp
+ 7f6:	c3                   	ret    
+ 7f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 7fe:	66 90                	xchg   %ax,%ax
+    base.s.ptr = freep = prevp = &base;
+ 800:	c7 05 44 0b 00 00 48 	movl   $0xb48,0xb44
+ 807:	0b 00 00 
+    base.s.size = 0;
+ 80a:	bf 48 0b 00 00       	mov    $0xb48,%edi
+    base.s.ptr = freep = prevp = &base;
+ 80f:	c7 05 48 0b 00 00 48 	movl   $0xb48,0xb48
+ 816:	0b 00 00 
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 819:	89 f8                	mov    %edi,%eax
+    base.s.size = 0;
+ 81b:	c7 05 4c 0b 00 00 00 	movl   $0x0,0xb4c
+ 822:	00 00 00 
+    if(p->s.size >= nunits){
+ 825:	e9 36 ff ff ff       	jmp    760 <malloc+0x30>
+ 82a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        prevp->s.ptr = p->s.ptr;
+ 830:	8b 0a                	mov    (%edx),%ecx
+ 832:	89 08                	mov    %ecx,(%eax)
+ 834:	eb b1                	jmp    7e7 <malloc+0xb7>
Binary files xv6-public/initcode and copy-xv6/initcode differ
diff -ruN xv6-public/initcode.asm copy-xv6/initcode.asm
--- xv6-public/initcode.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/initcode.asm	2022-09-05 23:26:13.864781049 +0530
@@ -0,0 +1,43 @@
+
+initcode.o:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <start>:
+
+
+# exec(init, argv)
+.globl start
+start:
+  pushl $argv
+   0:	68 24 00 00 00       	push   $0x24
+  pushl $init
+   5:	68 1c 00 00 00       	push   $0x1c
+  pushl $0  // where caller pc would be
+   a:	6a 00                	push   $0x0
+  movl $SYS_exec, %eax
+   c:	b8 07 00 00 00       	mov    $0x7,%eax
+  int $T_SYSCALL
+  11:	cd 40                	int    $0x40
+
+00000013 <exit>:
+
+# for(;;) exit();
+exit:
+  movl $SYS_exit, %eax
+  13:	b8 02 00 00 00       	mov    $0x2,%eax
+  int $T_SYSCALL
+  18:	cd 40                	int    $0x40
+  jmp exit
+  1a:	eb f7                	jmp    13 <exit>
+
+0000001c <init>:
+  1c:	2f                   	das    
+  1d:	69 6e 69 74 00 00 90 	imul   $0x90000074,0x69(%esi),%ebp
+
+00000024 <argv>:
+  24:	1c 00                	sbb    $0x0,%al
+  26:	00 00                	add    %al,(%eax)
+  28:	00 00                	add    %al,(%eax)
+	...
diff -ruN xv6-public/initcode.d copy-xv6/initcode.d
--- xv6-public/initcode.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/initcode.d	2022-09-05 23:26:13.860781049 +0530
@@ -0,0 +1 @@
+initcode.o: initcode.S syscall.h traps.h
Binary files xv6-public/initcode.o and copy-xv6/initcode.o differ
Binary files xv6-public/initcode.out and copy-xv6/initcode.out differ
diff -ruN xv6-public/init.d copy-xv6/init.d
--- xv6-public/init.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/init.d	2022-09-05 23:26:11.936781091 +0530
@@ -0,0 +1 @@
+init.o: init.c /usr/include/stdc-predef.h types.h stat.h user.h fcntl.h
Binary files xv6-public/init.o and copy-xv6/init.o differ
diff -ruN xv6-public/init.sym copy-xv6/init.sym
--- xv6-public/init.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/init.sym	2022-09-05 23:26:11.948781092 +0530
@@ -0,0 +1,63 @@
+00000000 .text
+00000838 .rodata
+000008a4 .eh_frame
+00000b3c .data
+00000b44 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 init.c
+00000000 ulib.c
+00000000 printf.c
+00000420 printint
+00000890 digits.1097
+00000000 umalloc.c
+00000b44 freep
+00000b48 base
+000000f0 strcpy
+000004d0 printf
+0000040b thread_exit
+00000b3c argv
+00000320 memmove
+0000039b mknod
+00000210 gets
+000003d3 getpid
+00000730 malloc
+000003e3 sleep
+00000363 pipe
+00000373 write
+000003ab fstat
+00000383 kill
+000003c3 chdir
+0000038b exec
+0000035b wait
+0000036b read
+000003a3 unlink
+0000034b fork
+000003db sbrk
+000003eb uptime
+00000b44 __bss_start
+000001b0 memset
+00000000 main
+00000120 strcmp
+000003cb dup
+00000290 stat
+00000b44 _edata
+00000b50 _end
+000003b3 link
+00000353 exit
+000002e0 atoi
+000003f3 draw
+00000170 strlen
+00000393 open
+000001d0 strchr
+000003fb thread_create
+000003bb mkdir
+0000037b close
+00000403 thread_join
+000006a0 free
diff -ruN xv6-public/ioapic.d copy-xv6/ioapic.d
--- xv6-public/ioapic.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/ioapic.d	2022-09-05 23:26:13.064781069 +0530
@@ -0,0 +1 @@
+ioapic.o: ioapic.c /usr/include/stdc-predef.h types.h defs.h traps.h
Binary files xv6-public/ioapic.o and copy-xv6/ioapic.o differ
diff -ruN xv6-public/kalloc.d copy-xv6/kalloc.d
--- xv6-public/kalloc.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/kalloc.d	2022-09-05 23:26:13.096781069 +0530
@@ -0,0 +1,2 @@
+kalloc.o: kalloc.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h spinlock.h
Binary files xv6-public/kalloc.o and copy-xv6/kalloc.o differ
diff -ruN xv6-public/kbd.d copy-xv6/kbd.d
--- xv6-public/kbd.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/kbd.d	2022-09-05 23:26:13.116781068 +0530
@@ -0,0 +1 @@
+kbd.o: kbd.c /usr/include/stdc-predef.h types.h x86.h defs.h kbd.h
Binary files xv6-public/kbd.o and copy-xv6/kbd.o differ
Binary files xv6-public/kernel and copy-xv6/kernel differ
diff -ruN xv6-public/kernel.asm copy-xv6/kernel.asm
--- xv6-public/kernel.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/kernel.asm	2022-09-05 23:26:13.888781048 +0530
@@ -0,0 +1,16098 @@
+
+kernel:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+80100000 <multiboot_header>:
+80100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
+80100006:	00 00                	add    %al,(%eax)
+80100008:	fe 4f 52             	decb   0x52(%edi)
+8010000b:	e4                   	.byte 0xe4
+
+8010000c <entry>:
+
+# Entering xv6 on boot processor, with paging off.
+.globl entry
+entry:
+  # Turn on page size extension for 4Mbyte pages
+  movl    %cr4, %eax
+8010000c:	0f 20 e0             	mov    %cr4,%eax
+  orl     $(CR4_PSE), %eax
+8010000f:	83 c8 10             	or     $0x10,%eax
+  movl    %eax, %cr4
+80100012:	0f 22 e0             	mov    %eax,%cr4
+  # Set page directory
+  movl    $(V2P_WO(entrypgdir)), %eax
+80100015:	b8 00 90 10 00       	mov    $0x109000,%eax
+  movl    %eax, %cr3
+8010001a:	0f 22 d8             	mov    %eax,%cr3
+  # Turn on paging.
+  movl    %cr0, %eax
+8010001d:	0f 20 c0             	mov    %cr0,%eax
+  orl     $(CR0_PG|CR0_WP), %eax
+80100020:	0d 00 00 01 80       	or     $0x80010000,%eax
+  movl    %eax, %cr0
+80100025:	0f 22 c0             	mov    %eax,%cr0
+
+  # Set up the stack pointer.
+  movl $(stack + KSTACKSIZE), %esp
+80100028:	bc c0 b5 10 80       	mov    $0x8010b5c0,%esp
+
+  # Jump to main(), and switch to executing at
+  # high addresses. The indirect call is needed because
+  # the assembler produces a PC-relative instruction
+  # for a direct jump.
+  mov $main, %eax
+8010002d:	b8 40 30 10 80       	mov    $0x80103040,%eax
+  jmp *%eax
+80100032:	ff e0                	jmp    *%eax
+80100034:	66 90                	xchg   %ax,%ax
+80100036:	66 90                	xchg   %ax,%ax
+80100038:	66 90                	xchg   %ax,%ax
+8010003a:	66 90                	xchg   %ax,%ax
+8010003c:	66 90                	xchg   %ax,%ax
+8010003e:	66 90                	xchg   %ax,%ax
+
+80100040 <binit>:
+  struct buf head;
+} bcache;
+
+void
+binit(void)
+{
+80100040:	f3 0f 1e fb          	endbr32 
+80100044:	55                   	push   %ebp
+80100045:	89 e5                	mov    %esp,%ebp
+80100047:	53                   	push   %ebx
+
+//PAGEBREAK!
+  // Create linked list of buffers
+  bcache.head.prev = &bcache.head;
+  bcache.head.next = &bcache.head;
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+80100048:	bb f4 b5 10 80       	mov    $0x8010b5f4,%ebx
+{
+8010004d:	83 ec 0c             	sub    $0xc,%esp
+  initlock(&bcache.lock, "bcache");
+80100050:	68 c0 74 10 80       	push   $0x801074c0
+80100055:	68 c0 b5 10 80       	push   $0x8010b5c0
+8010005a:	e8 01 46 00 00       	call   80104660 <initlock>
+  bcache.head.next = &bcache.head;
+8010005f:	83 c4 10             	add    $0x10,%esp
+80100062:	b8 bc fc 10 80       	mov    $0x8010fcbc,%eax
+  bcache.head.prev = &bcache.head;
+80100067:	c7 05 0c fd 10 80 bc 	movl   $0x8010fcbc,0x8010fd0c
+8010006e:	fc 10 80 
+  bcache.head.next = &bcache.head;
+80100071:	c7 05 10 fd 10 80 bc 	movl   $0x8010fcbc,0x8010fd10
+80100078:	fc 10 80 
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+8010007b:	eb 05                	jmp    80100082 <binit+0x42>
+8010007d:	8d 76 00             	lea    0x0(%esi),%esi
+80100080:	89 d3                	mov    %edx,%ebx
+    b->next = bcache.head.next;
+80100082:	89 43 54             	mov    %eax,0x54(%ebx)
+    b->prev = &bcache.head;
+    initsleeplock(&b->lock, "buffer");
+80100085:	83 ec 08             	sub    $0x8,%esp
+80100088:	8d 43 0c             	lea    0xc(%ebx),%eax
+    b->prev = &bcache.head;
+8010008b:	c7 43 50 bc fc 10 80 	movl   $0x8010fcbc,0x50(%ebx)
+    initsleeplock(&b->lock, "buffer");
+80100092:	68 c7 74 10 80       	push   $0x801074c7
+80100097:	50                   	push   %eax
+80100098:	e8 83 44 00 00       	call   80104520 <initsleeplock>
+    bcache.head.next->prev = b;
+8010009d:	a1 10 fd 10 80       	mov    0x8010fd10,%eax
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+801000a2:	8d 93 5c 02 00 00    	lea    0x25c(%ebx),%edx
+801000a8:	83 c4 10             	add    $0x10,%esp
+    bcache.head.next->prev = b;
+801000ab:	89 58 50             	mov    %ebx,0x50(%eax)
+    bcache.head.next = b;
+801000ae:	89 d8                	mov    %ebx,%eax
+801000b0:	89 1d 10 fd 10 80    	mov    %ebx,0x8010fd10
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+801000b6:	81 fb 60 fa 10 80    	cmp    $0x8010fa60,%ebx
+801000bc:	75 c2                	jne    80100080 <binit+0x40>
+  }
+}
+801000be:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+801000c1:	c9                   	leave  
+801000c2:	c3                   	ret    
+801000c3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801000ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+801000d0 <bread>:
+}
+
+// Return a locked buf with the contents of the indicated block.
+struct buf*
+bread(uint dev, uint blockno)
+{
+801000d0:	f3 0f 1e fb          	endbr32 
+801000d4:	55                   	push   %ebp
+801000d5:	89 e5                	mov    %esp,%ebp
+801000d7:	57                   	push   %edi
+801000d8:	56                   	push   %esi
+801000d9:	53                   	push   %ebx
+801000da:	83 ec 18             	sub    $0x18,%esp
+801000dd:	8b 7d 08             	mov    0x8(%ebp),%edi
+801000e0:	8b 75 0c             	mov    0xc(%ebp),%esi
+  acquire(&bcache.lock);
+801000e3:	68 c0 b5 10 80       	push   $0x8010b5c0
+801000e8:	e8 f3 46 00 00       	call   801047e0 <acquire>
+  for(b = bcache.head.next; b != &bcache.head; b = b->next){
+801000ed:	8b 1d 10 fd 10 80    	mov    0x8010fd10,%ebx
+801000f3:	83 c4 10             	add    $0x10,%esp
+801000f6:	81 fb bc fc 10 80    	cmp    $0x8010fcbc,%ebx
+801000fc:	75 0d                	jne    8010010b <bread+0x3b>
+801000fe:	eb 20                	jmp    80100120 <bread+0x50>
+80100100:	8b 5b 54             	mov    0x54(%ebx),%ebx
+80100103:	81 fb bc fc 10 80    	cmp    $0x8010fcbc,%ebx
+80100109:	74 15                	je     80100120 <bread+0x50>
+    if(b->dev == dev && b->blockno == blockno){
+8010010b:	3b 7b 04             	cmp    0x4(%ebx),%edi
+8010010e:	75 f0                	jne    80100100 <bread+0x30>
+80100110:	3b 73 08             	cmp    0x8(%ebx),%esi
+80100113:	75 eb                	jne    80100100 <bread+0x30>
+      b->refcnt++;
+80100115:	83 43 4c 01          	addl   $0x1,0x4c(%ebx)
+      release(&bcache.lock);
+80100119:	eb 3f                	jmp    8010015a <bread+0x8a>
+8010011b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010011f:	90                   	nop
+  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+80100120:	8b 1d 0c fd 10 80    	mov    0x8010fd0c,%ebx
+80100126:	81 fb bc fc 10 80    	cmp    $0x8010fcbc,%ebx
+8010012c:	75 0d                	jne    8010013b <bread+0x6b>
+8010012e:	eb 70                	jmp    801001a0 <bread+0xd0>
+80100130:	8b 5b 50             	mov    0x50(%ebx),%ebx
+80100133:	81 fb bc fc 10 80    	cmp    $0x8010fcbc,%ebx
+80100139:	74 65                	je     801001a0 <bread+0xd0>
+    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
+8010013b:	8b 43 4c             	mov    0x4c(%ebx),%eax
+8010013e:	85 c0                	test   %eax,%eax
+80100140:	75 ee                	jne    80100130 <bread+0x60>
+80100142:	f6 03 04             	testb  $0x4,(%ebx)
+80100145:	75 e9                	jne    80100130 <bread+0x60>
+      b->dev = dev;
+80100147:	89 7b 04             	mov    %edi,0x4(%ebx)
+      b->blockno = blockno;
+8010014a:	89 73 08             	mov    %esi,0x8(%ebx)
+      b->flags = 0;
+8010014d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
+      b->refcnt = 1;
+80100153:	c7 43 4c 01 00 00 00 	movl   $0x1,0x4c(%ebx)
+      release(&bcache.lock);
+8010015a:	83 ec 0c             	sub    $0xc,%esp
+8010015d:	68 c0 b5 10 80       	push   $0x8010b5c0
+80100162:	e8 39 47 00 00       	call   801048a0 <release>
+      acquiresleep(&b->lock);
+80100167:	8d 43 0c             	lea    0xc(%ebx),%eax
+8010016a:	89 04 24             	mov    %eax,(%esp)
+8010016d:	e8 ee 43 00 00       	call   80104560 <acquiresleep>
+      return b;
+80100172:	83 c4 10             	add    $0x10,%esp
+  struct buf *b;
+
+  b = bget(dev, blockno);
+  if((b->flags & B_VALID) == 0) {
+80100175:	f6 03 02             	testb  $0x2,(%ebx)
+80100178:	74 0e                	je     80100188 <bread+0xb8>
+    iderw(b);
+  }
+  return b;
+}
+8010017a:	8d 65 f4             	lea    -0xc(%ebp),%esp
+8010017d:	89 d8                	mov    %ebx,%eax
+8010017f:	5b                   	pop    %ebx
+80100180:	5e                   	pop    %esi
+80100181:	5f                   	pop    %edi
+80100182:	5d                   	pop    %ebp
+80100183:	c3                   	ret    
+80100184:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    iderw(b);
+80100188:	83 ec 0c             	sub    $0xc,%esp
+8010018b:	53                   	push   %ebx
+8010018c:	e8 ef 20 00 00       	call   80102280 <iderw>
+80100191:	83 c4 10             	add    $0x10,%esp
+}
+80100194:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80100197:	89 d8                	mov    %ebx,%eax
+80100199:	5b                   	pop    %ebx
+8010019a:	5e                   	pop    %esi
+8010019b:	5f                   	pop    %edi
+8010019c:	5d                   	pop    %ebp
+8010019d:	c3                   	ret    
+8010019e:	66 90                	xchg   %ax,%ax
+  panic("bget: no buffers");
+801001a0:	83 ec 0c             	sub    $0xc,%esp
+801001a3:	68 ce 74 10 80       	push   $0x801074ce
+801001a8:	e8 e3 01 00 00       	call   80100390 <panic>
+801001ad:	8d 76 00             	lea    0x0(%esi),%esi
+
+801001b0 <bwrite>:
+
+// Write b's contents to disk.  Must be locked.
+void
+bwrite(struct buf *b)
+{
+801001b0:	f3 0f 1e fb          	endbr32 
+801001b4:	55                   	push   %ebp
+801001b5:	89 e5                	mov    %esp,%ebp
+801001b7:	53                   	push   %ebx
+801001b8:	83 ec 10             	sub    $0x10,%esp
+801001bb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(!holdingsleep(&b->lock))
+801001be:	8d 43 0c             	lea    0xc(%ebx),%eax
+801001c1:	50                   	push   %eax
+801001c2:	e8 39 44 00 00       	call   80104600 <holdingsleep>
+801001c7:	83 c4 10             	add    $0x10,%esp
+801001ca:	85 c0                	test   %eax,%eax
+801001cc:	74 0f                	je     801001dd <bwrite+0x2d>
+    panic("bwrite");
+  b->flags |= B_DIRTY;
+801001ce:	83 0b 04             	orl    $0x4,(%ebx)
+  iderw(b);
+801001d1:	89 5d 08             	mov    %ebx,0x8(%ebp)
+}
+801001d4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+801001d7:	c9                   	leave  
+  iderw(b);
+801001d8:	e9 a3 20 00 00       	jmp    80102280 <iderw>
+    panic("bwrite");
+801001dd:	83 ec 0c             	sub    $0xc,%esp
+801001e0:	68 df 74 10 80       	push   $0x801074df
+801001e5:	e8 a6 01 00 00       	call   80100390 <panic>
+801001ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+801001f0 <brelse>:
+
+// Release a locked buffer.
+// Move to the head of the MRU list.
+void
+brelse(struct buf *b)
+{
+801001f0:	f3 0f 1e fb          	endbr32 
+801001f4:	55                   	push   %ebp
+801001f5:	89 e5                	mov    %esp,%ebp
+801001f7:	56                   	push   %esi
+801001f8:	53                   	push   %ebx
+801001f9:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(!holdingsleep(&b->lock))
+801001fc:	8d 73 0c             	lea    0xc(%ebx),%esi
+801001ff:	83 ec 0c             	sub    $0xc,%esp
+80100202:	56                   	push   %esi
+80100203:	e8 f8 43 00 00       	call   80104600 <holdingsleep>
+80100208:	83 c4 10             	add    $0x10,%esp
+8010020b:	85 c0                	test   %eax,%eax
+8010020d:	74 66                	je     80100275 <brelse+0x85>
+    panic("brelse");
+
+  releasesleep(&b->lock);
+8010020f:	83 ec 0c             	sub    $0xc,%esp
+80100212:	56                   	push   %esi
+80100213:	e8 a8 43 00 00       	call   801045c0 <releasesleep>
+
+  acquire(&bcache.lock);
+80100218:	c7 04 24 c0 b5 10 80 	movl   $0x8010b5c0,(%esp)
+8010021f:	e8 bc 45 00 00       	call   801047e0 <acquire>
+  b->refcnt--;
+80100224:	8b 43 4c             	mov    0x4c(%ebx),%eax
+  if (b->refcnt == 0) {
+80100227:	83 c4 10             	add    $0x10,%esp
+  b->refcnt--;
+8010022a:	83 e8 01             	sub    $0x1,%eax
+8010022d:	89 43 4c             	mov    %eax,0x4c(%ebx)
+  if (b->refcnt == 0) {
+80100230:	85 c0                	test   %eax,%eax
+80100232:	75 2f                	jne    80100263 <brelse+0x73>
+    // no one is waiting for it.
+    b->next->prev = b->prev;
+80100234:	8b 43 54             	mov    0x54(%ebx),%eax
+80100237:	8b 53 50             	mov    0x50(%ebx),%edx
+8010023a:	89 50 50             	mov    %edx,0x50(%eax)
+    b->prev->next = b->next;
+8010023d:	8b 43 50             	mov    0x50(%ebx),%eax
+80100240:	8b 53 54             	mov    0x54(%ebx),%edx
+80100243:	89 50 54             	mov    %edx,0x54(%eax)
+    b->next = bcache.head.next;
+80100246:	a1 10 fd 10 80       	mov    0x8010fd10,%eax
+    b->prev = &bcache.head;
+8010024b:	c7 43 50 bc fc 10 80 	movl   $0x8010fcbc,0x50(%ebx)
+    b->next = bcache.head.next;
+80100252:	89 43 54             	mov    %eax,0x54(%ebx)
+    bcache.head.next->prev = b;
+80100255:	a1 10 fd 10 80       	mov    0x8010fd10,%eax
+8010025a:	89 58 50             	mov    %ebx,0x50(%eax)
+    bcache.head.next = b;
+8010025d:	89 1d 10 fd 10 80    	mov    %ebx,0x8010fd10
+  }
+  
+  release(&bcache.lock);
+80100263:	c7 45 08 c0 b5 10 80 	movl   $0x8010b5c0,0x8(%ebp)
+}
+8010026a:	8d 65 f8             	lea    -0x8(%ebp),%esp
+8010026d:	5b                   	pop    %ebx
+8010026e:	5e                   	pop    %esi
+8010026f:	5d                   	pop    %ebp
+  release(&bcache.lock);
+80100270:	e9 2b 46 00 00       	jmp    801048a0 <release>
+    panic("brelse");
+80100275:	83 ec 0c             	sub    $0xc,%esp
+80100278:	68 e6 74 10 80       	push   $0x801074e6
+8010027d:	e8 0e 01 00 00       	call   80100390 <panic>
+80100282:	66 90                	xchg   %ax,%ax
+80100284:	66 90                	xchg   %ax,%ax
+80100286:	66 90                	xchg   %ax,%ax
+80100288:	66 90                	xchg   %ax,%ax
+8010028a:	66 90                	xchg   %ax,%ax
+8010028c:	66 90                	xchg   %ax,%ax
+8010028e:	66 90                	xchg   %ax,%ax
+
+80100290 <consoleread>:
+  }
+}
+
+int
+consoleread(struct inode *ip, char *dst, int n)
+{
+80100290:	f3 0f 1e fb          	endbr32 
+80100294:	55                   	push   %ebp
+80100295:	89 e5                	mov    %esp,%ebp
+80100297:	57                   	push   %edi
+80100298:	56                   	push   %esi
+80100299:	53                   	push   %ebx
+8010029a:	83 ec 18             	sub    $0x18,%esp
+  uint target;
+  int c;
+
+  iunlock(ip);
+8010029d:	ff 75 08             	pushl  0x8(%ebp)
+{
+801002a0:	8b 5d 10             	mov    0x10(%ebp),%ebx
+  target = n;
+801002a3:	89 de                	mov    %ebx,%esi
+  iunlock(ip);
+801002a5:	e8 96 15 00 00       	call   80101840 <iunlock>
+  acquire(&cons.lock);
+801002aa:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+801002b1:	e8 2a 45 00 00       	call   801047e0 <acquire>
+        // caller gets a 0-byte result.
+        input.r--;
+      }
+      break;
+    }
+    *dst++ = c;
+801002b6:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  while(n > 0){
+801002b9:	83 c4 10             	add    $0x10,%esp
+    *dst++ = c;
+801002bc:	01 df                	add    %ebx,%edi
+  while(n > 0){
+801002be:	85 db                	test   %ebx,%ebx
+801002c0:	0f 8e 97 00 00 00    	jle    8010035d <consoleread+0xcd>
+    while(input.r == input.w){
+801002c6:	a1 a0 ff 10 80       	mov    0x8010ffa0,%eax
+801002cb:	3b 05 a4 ff 10 80    	cmp    0x8010ffa4,%eax
+801002d1:	74 27                	je     801002fa <consoleread+0x6a>
+801002d3:	eb 5b                	jmp    80100330 <consoleread+0xa0>
+801002d5:	8d 76 00             	lea    0x0(%esi),%esi
+      sleep(&input.r, &cons.lock);
+801002d8:	83 ec 08             	sub    $0x8,%esp
+801002db:	68 20 a5 10 80       	push   $0x8010a520
+801002e0:	68 a0 ff 10 80       	push   $0x8010ffa0
+801002e5:	e8 36 3c 00 00       	call   80103f20 <sleep>
+    while(input.r == input.w){
+801002ea:	a1 a0 ff 10 80       	mov    0x8010ffa0,%eax
+801002ef:	83 c4 10             	add    $0x10,%esp
+801002f2:	3b 05 a4 ff 10 80    	cmp    0x8010ffa4,%eax
+801002f8:	75 36                	jne    80100330 <consoleread+0xa0>
+      if(myproc()->killed){
+801002fa:	e8 61 36 00 00       	call   80103960 <myproc>
+801002ff:	8b 48 24             	mov    0x24(%eax),%ecx
+80100302:	85 c9                	test   %ecx,%ecx
+80100304:	74 d2                	je     801002d8 <consoleread+0x48>
+        release(&cons.lock);
+80100306:	83 ec 0c             	sub    $0xc,%esp
+80100309:	68 20 a5 10 80       	push   $0x8010a520
+8010030e:	e8 8d 45 00 00       	call   801048a0 <release>
+        ilock(ip);
+80100313:	5a                   	pop    %edx
+80100314:	ff 75 08             	pushl  0x8(%ebp)
+80100317:	e8 44 14 00 00       	call   80101760 <ilock>
+        return -1;
+8010031c:	83 c4 10             	add    $0x10,%esp
+  }
+  release(&cons.lock);
+  ilock(ip);
+
+  return target - n;
+}
+8010031f:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return -1;
+80100322:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80100327:	5b                   	pop    %ebx
+80100328:	5e                   	pop    %esi
+80100329:	5f                   	pop    %edi
+8010032a:	5d                   	pop    %ebp
+8010032b:	c3                   	ret    
+8010032c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    c = input.buf[input.r++ % INPUT_BUF];
+80100330:	8d 50 01             	lea    0x1(%eax),%edx
+80100333:	89 15 a0 ff 10 80    	mov    %edx,0x8010ffa0
+80100339:	89 c2                	mov    %eax,%edx
+8010033b:	83 e2 7f             	and    $0x7f,%edx
+8010033e:	0f be 8a 20 ff 10 80 	movsbl -0x7fef00e0(%edx),%ecx
+    if(c == C('D')){  // EOF
+80100345:	80 f9 04             	cmp    $0x4,%cl
+80100348:	74 38                	je     80100382 <consoleread+0xf2>
+    *dst++ = c;
+8010034a:	89 d8                	mov    %ebx,%eax
+    --n;
+8010034c:	83 eb 01             	sub    $0x1,%ebx
+    *dst++ = c;
+8010034f:	f7 d8                	neg    %eax
+80100351:	88 0c 07             	mov    %cl,(%edi,%eax,1)
+    if(c == '\n')
+80100354:	83 f9 0a             	cmp    $0xa,%ecx
+80100357:	0f 85 61 ff ff ff    	jne    801002be <consoleread+0x2e>
+  release(&cons.lock);
+8010035d:	83 ec 0c             	sub    $0xc,%esp
+80100360:	68 20 a5 10 80       	push   $0x8010a520
+80100365:	e8 36 45 00 00       	call   801048a0 <release>
+  ilock(ip);
+8010036a:	58                   	pop    %eax
+8010036b:	ff 75 08             	pushl  0x8(%ebp)
+8010036e:	e8 ed 13 00 00       	call   80101760 <ilock>
+  return target - n;
+80100373:	89 f0                	mov    %esi,%eax
+80100375:	83 c4 10             	add    $0x10,%esp
+}
+80100378:	8d 65 f4             	lea    -0xc(%ebp),%esp
+  return target - n;
+8010037b:	29 d8                	sub    %ebx,%eax
+}
+8010037d:	5b                   	pop    %ebx
+8010037e:	5e                   	pop    %esi
+8010037f:	5f                   	pop    %edi
+80100380:	5d                   	pop    %ebp
+80100381:	c3                   	ret    
+      if(n < target){
+80100382:	39 f3                	cmp    %esi,%ebx
+80100384:	73 d7                	jae    8010035d <consoleread+0xcd>
+        input.r--;
+80100386:	a3 a0 ff 10 80       	mov    %eax,0x8010ffa0
+8010038b:	eb d0                	jmp    8010035d <consoleread+0xcd>
+8010038d:	8d 76 00             	lea    0x0(%esi),%esi
+
+80100390 <panic>:
+{
+80100390:	f3 0f 1e fb          	endbr32 
+80100394:	55                   	push   %ebp
+80100395:	89 e5                	mov    %esp,%ebp
+80100397:	56                   	push   %esi
+80100398:	53                   	push   %ebx
+80100399:	83 ec 30             	sub    $0x30,%esp
+}
+
+static inline void
+cli(void)
+{
+  asm volatile("cli");
+8010039c:	fa                   	cli    
+  cons.locking = 0;
+8010039d:	c7 05 54 a5 10 80 00 	movl   $0x0,0x8010a554
+801003a4:	00 00 00 
+  getcallerpcs(&s, pcs);
+801003a7:	8d 5d d0             	lea    -0x30(%ebp),%ebx
+801003aa:	8d 75 f8             	lea    -0x8(%ebp),%esi
+  cprintf("lapicid %d: panic: ", lapicid());
+801003ad:	e8 ee 24 00 00       	call   801028a0 <lapicid>
+801003b2:	83 ec 08             	sub    $0x8,%esp
+801003b5:	50                   	push   %eax
+801003b6:	68 ed 74 10 80       	push   $0x801074ed
+801003bb:	e8 f0 02 00 00       	call   801006b0 <cprintf>
+  cprintf(s);
+801003c0:	58                   	pop    %eax
+801003c1:	ff 75 08             	pushl  0x8(%ebp)
+801003c4:	e8 e7 02 00 00       	call   801006b0 <cprintf>
+  cprintf("\n");
+801003c9:	c7 04 24 27 7e 10 80 	movl   $0x80107e27,(%esp)
+801003d0:	e8 db 02 00 00       	call   801006b0 <cprintf>
+  getcallerpcs(&s, pcs);
+801003d5:	8d 45 08             	lea    0x8(%ebp),%eax
+801003d8:	5a                   	pop    %edx
+801003d9:	59                   	pop    %ecx
+801003da:	53                   	push   %ebx
+801003db:	50                   	push   %eax
+801003dc:	e8 9f 42 00 00       	call   80104680 <getcallerpcs>
+  for(i=0; i<10; i++)
+801003e1:	83 c4 10             	add    $0x10,%esp
+    cprintf(" %p", pcs[i]);
+801003e4:	83 ec 08             	sub    $0x8,%esp
+801003e7:	ff 33                	pushl  (%ebx)
+801003e9:	83 c3 04             	add    $0x4,%ebx
+801003ec:	68 01 75 10 80       	push   $0x80107501
+801003f1:	e8 ba 02 00 00       	call   801006b0 <cprintf>
+  for(i=0; i<10; i++)
+801003f6:	83 c4 10             	add    $0x10,%esp
+801003f9:	39 f3                	cmp    %esi,%ebx
+801003fb:	75 e7                	jne    801003e4 <panic+0x54>
+  panicked = 1; // freeze other CPU
+801003fd:	c7 05 58 a5 10 80 01 	movl   $0x1,0x8010a558
+80100404:	00 00 00 
+  for(;;)
+80100407:	eb fe                	jmp    80100407 <panic+0x77>
+80100409:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80100410 <consputc.part.0>:
+consputc(int c)
+80100410:	55                   	push   %ebp
+80100411:	89 e5                	mov    %esp,%ebp
+80100413:	57                   	push   %edi
+80100414:	56                   	push   %esi
+80100415:	53                   	push   %ebx
+80100416:	89 c3                	mov    %eax,%ebx
+80100418:	83 ec 1c             	sub    $0x1c,%esp
+  if(c == BACKSPACE){
+8010041b:	3d 00 01 00 00       	cmp    $0x100,%eax
+80100420:	0f 84 ea 00 00 00    	je     80100510 <consputc.part.0+0x100>
+    uartputc(c);
+80100426:	83 ec 0c             	sub    $0xc,%esp
+80100429:	50                   	push   %eax
+8010042a:	e8 91 5c 00 00       	call   801060c0 <uartputc>
+8010042f:	83 c4 10             	add    $0x10,%esp
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80100432:	bf d4 03 00 00       	mov    $0x3d4,%edi
+80100437:	b8 0e 00 00 00       	mov    $0xe,%eax
+8010043c:	89 fa                	mov    %edi,%edx
+8010043e:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+8010043f:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
+80100444:	89 ca                	mov    %ecx,%edx
+80100446:	ec                   	in     (%dx),%al
+  pos = inb(CRTPORT+1) << 8;
+80100447:	0f b6 c0             	movzbl %al,%eax
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+8010044a:	89 fa                	mov    %edi,%edx
+8010044c:	c1 e0 08             	shl    $0x8,%eax
+8010044f:	89 c6                	mov    %eax,%esi
+80100451:	b8 0f 00 00 00       	mov    $0xf,%eax
+80100456:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80100457:	89 ca                	mov    %ecx,%edx
+80100459:	ec                   	in     (%dx),%al
+  pos |= inb(CRTPORT+1);
+8010045a:	0f b6 c0             	movzbl %al,%eax
+8010045d:	09 f0                	or     %esi,%eax
+  if(c == '\n')
+8010045f:	83 fb 0a             	cmp    $0xa,%ebx
+80100462:	0f 84 90 00 00 00    	je     801004f8 <consputc.part.0+0xe8>
+  else if(c == BACKSPACE){
+80100468:	81 fb 00 01 00 00    	cmp    $0x100,%ebx
+8010046e:	74 70                	je     801004e0 <consputc.part.0+0xd0>
+    crt[pos++] = (c&0xff) | 0x0700;  // black on white
+80100470:	0f b6 db             	movzbl %bl,%ebx
+80100473:	8d 70 01             	lea    0x1(%eax),%esi
+80100476:	80 cf 07             	or     $0x7,%bh
+80100479:	66 89 9c 00 00 80 0b 	mov    %bx,-0x7ff48000(%eax,%eax,1)
+80100480:	80 
+  if(pos < 0 || pos > 25*80)
+80100481:	81 fe d0 07 00 00    	cmp    $0x7d0,%esi
+80100487:	0f 8f f9 00 00 00    	jg     80100586 <consputc.part.0+0x176>
+  if((pos/80) >= 24){  // Scroll up.
+8010048d:	81 fe 7f 07 00 00    	cmp    $0x77f,%esi
+80100493:	0f 8f a7 00 00 00    	jg     80100540 <consputc.part.0+0x130>
+80100499:	89 f0                	mov    %esi,%eax
+8010049b:	8d b4 36 00 80 0b 80 	lea    -0x7ff48000(%esi,%esi,1),%esi
+801004a2:	88 45 e7             	mov    %al,-0x19(%ebp)
+801004a5:	0f b6 fc             	movzbl %ah,%edi
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801004a8:	bb d4 03 00 00       	mov    $0x3d4,%ebx
+801004ad:	b8 0e 00 00 00       	mov    $0xe,%eax
+801004b2:	89 da                	mov    %ebx,%edx
+801004b4:	ee                   	out    %al,(%dx)
+801004b5:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
+801004ba:	89 f8                	mov    %edi,%eax
+801004bc:	89 ca                	mov    %ecx,%edx
+801004be:	ee                   	out    %al,(%dx)
+801004bf:	b8 0f 00 00 00       	mov    $0xf,%eax
+801004c4:	89 da                	mov    %ebx,%edx
+801004c6:	ee                   	out    %al,(%dx)
+801004c7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+801004cb:	89 ca                	mov    %ecx,%edx
+801004cd:	ee                   	out    %al,(%dx)
+  crt[pos] = ' ' | 0x0700;
+801004ce:	b8 20 07 00 00       	mov    $0x720,%eax
+801004d3:	66 89 06             	mov    %ax,(%esi)
+}
+801004d6:	8d 65 f4             	lea    -0xc(%ebp),%esp
+801004d9:	5b                   	pop    %ebx
+801004da:	5e                   	pop    %esi
+801004db:	5f                   	pop    %edi
+801004dc:	5d                   	pop    %ebp
+801004dd:	c3                   	ret    
+801004de:	66 90                	xchg   %ax,%ax
+    if(pos > 0) --pos;
+801004e0:	8d 70 ff             	lea    -0x1(%eax),%esi
+801004e3:	85 c0                	test   %eax,%eax
+801004e5:	75 9a                	jne    80100481 <consputc.part.0+0x71>
+801004e7:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
+801004eb:	be 00 80 0b 80       	mov    $0x800b8000,%esi
+801004f0:	31 ff                	xor    %edi,%edi
+801004f2:	eb b4                	jmp    801004a8 <consputc.part.0+0x98>
+801004f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    pos += 80 - pos%80;
+801004f8:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
+801004fd:	f7 e2                	mul    %edx
+801004ff:	c1 ea 06             	shr    $0x6,%edx
+80100502:	8d 04 92             	lea    (%edx,%edx,4),%eax
+80100505:	c1 e0 04             	shl    $0x4,%eax
+80100508:	8d 70 50             	lea    0x50(%eax),%esi
+8010050b:	e9 71 ff ff ff       	jmp    80100481 <consputc.part.0+0x71>
+    uartputc('\b'); uartputc(' '); uartputc('\b');
+80100510:	83 ec 0c             	sub    $0xc,%esp
+80100513:	6a 08                	push   $0x8
+80100515:	e8 a6 5b 00 00       	call   801060c0 <uartputc>
+8010051a:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+80100521:	e8 9a 5b 00 00       	call   801060c0 <uartputc>
+80100526:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+8010052d:	e8 8e 5b 00 00       	call   801060c0 <uartputc>
+80100532:	83 c4 10             	add    $0x10,%esp
+80100535:	e9 f8 fe ff ff       	jmp    80100432 <consputc.part.0+0x22>
+8010053a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    memmove(crt, crt+80, sizeof(crt[0])*23*80);
+80100540:	83 ec 04             	sub    $0x4,%esp
+    pos -= 80;
+80100543:	8d 5e b0             	lea    -0x50(%esi),%ebx
+    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+80100546:	8d b4 36 60 7f 0b 80 	lea    -0x7ff480a0(%esi,%esi,1),%esi
+8010054d:	bf 07 00 00 00       	mov    $0x7,%edi
+    memmove(crt, crt+80, sizeof(crt[0])*23*80);
+80100552:	68 60 0e 00 00       	push   $0xe60
+80100557:	68 a0 80 0b 80       	push   $0x800b80a0
+8010055c:	68 00 80 0b 80       	push   $0x800b8000
+80100561:	e8 2a 44 00 00       	call   80104990 <memmove>
+    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+80100566:	b8 80 07 00 00       	mov    $0x780,%eax
+8010056b:	83 c4 0c             	add    $0xc,%esp
+8010056e:	29 d8                	sub    %ebx,%eax
+80100570:	01 c0                	add    %eax,%eax
+80100572:	50                   	push   %eax
+80100573:	6a 00                	push   $0x0
+80100575:	56                   	push   %esi
+80100576:	e8 75 43 00 00       	call   801048f0 <memset>
+8010057b:	88 5d e7             	mov    %bl,-0x19(%ebp)
+8010057e:	83 c4 10             	add    $0x10,%esp
+80100581:	e9 22 ff ff ff       	jmp    801004a8 <consputc.part.0+0x98>
+    panic("pos under/overflow");
+80100586:	83 ec 0c             	sub    $0xc,%esp
+80100589:	68 05 75 10 80       	push   $0x80107505
+8010058e:	e8 fd fd ff ff       	call   80100390 <panic>
+80100593:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010059a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+801005a0 <printint>:
+{
+801005a0:	55                   	push   %ebp
+801005a1:	89 e5                	mov    %esp,%ebp
+801005a3:	57                   	push   %edi
+801005a4:	56                   	push   %esi
+801005a5:	53                   	push   %ebx
+801005a6:	83 ec 2c             	sub    $0x2c,%esp
+801005a9:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  if(sign && (sign = xx < 0))
+801005ac:	85 c9                	test   %ecx,%ecx
+801005ae:	74 04                	je     801005b4 <printint+0x14>
+801005b0:	85 c0                	test   %eax,%eax
+801005b2:	78 6d                	js     80100621 <printint+0x81>
+    x = xx;
+801005b4:	89 c1                	mov    %eax,%ecx
+801005b6:	31 f6                	xor    %esi,%esi
+  i = 0;
+801005b8:	89 75 cc             	mov    %esi,-0x34(%ebp)
+801005bb:	31 db                	xor    %ebx,%ebx
+801005bd:	8d 7d d7             	lea    -0x29(%ebp),%edi
+    buf[i++] = digits[x % base];
+801005c0:	89 c8                	mov    %ecx,%eax
+801005c2:	31 d2                	xor    %edx,%edx
+801005c4:	89 ce                	mov    %ecx,%esi
+801005c6:	f7 75 d4             	divl   -0x2c(%ebp)
+801005c9:	0f b6 92 30 75 10 80 	movzbl -0x7fef8ad0(%edx),%edx
+801005d0:	89 45 d0             	mov    %eax,-0x30(%ebp)
+801005d3:	89 d8                	mov    %ebx,%eax
+801005d5:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+801005d8:	8b 4d d0             	mov    -0x30(%ebp),%ecx
+801005db:	89 75 d0             	mov    %esi,-0x30(%ebp)
+    buf[i++] = digits[x % base];
+801005de:	88 14 1f             	mov    %dl,(%edi,%ebx,1)
+  }while((x /= base) != 0);
+801005e1:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+801005e4:	39 75 d0             	cmp    %esi,-0x30(%ebp)
+801005e7:	73 d7                	jae    801005c0 <printint+0x20>
+801005e9:	8b 75 cc             	mov    -0x34(%ebp),%esi
+  if(sign)
+801005ec:	85 f6                	test   %esi,%esi
+801005ee:	74 0c                	je     801005fc <printint+0x5c>
+    buf[i++] = '-';
+801005f0:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+801005f5:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+801005f7:	ba 2d 00 00 00       	mov    $0x2d,%edx
+  while(--i >= 0)
+801005fc:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+80100600:	0f be c2             	movsbl %dl,%eax
+  if(panicked){
+80100603:	8b 15 58 a5 10 80    	mov    0x8010a558,%edx
+80100609:	85 d2                	test   %edx,%edx
+8010060b:	74 03                	je     80100610 <printint+0x70>
+  asm volatile("cli");
+8010060d:	fa                   	cli    
+    for(;;)
+8010060e:	eb fe                	jmp    8010060e <printint+0x6e>
+80100610:	e8 fb fd ff ff       	call   80100410 <consputc.part.0>
+  while(--i >= 0)
+80100615:	39 fb                	cmp    %edi,%ebx
+80100617:	74 10                	je     80100629 <printint+0x89>
+80100619:	0f be 03             	movsbl (%ebx),%eax
+8010061c:	83 eb 01             	sub    $0x1,%ebx
+8010061f:	eb e2                	jmp    80100603 <printint+0x63>
+    x = -xx;
+80100621:	f7 d8                	neg    %eax
+80100623:	89 ce                	mov    %ecx,%esi
+80100625:	89 c1                	mov    %eax,%ecx
+80100627:	eb 8f                	jmp    801005b8 <printint+0x18>
+}
+80100629:	83 c4 2c             	add    $0x2c,%esp
+8010062c:	5b                   	pop    %ebx
+8010062d:	5e                   	pop    %esi
+8010062e:	5f                   	pop    %edi
+8010062f:	5d                   	pop    %ebp
+80100630:	c3                   	ret    
+80100631:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80100638:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010063f:	90                   	nop
+
+80100640 <consolewrite>:
+
+int
+consolewrite(struct inode *ip, char *buf, int n)
+{
+80100640:	f3 0f 1e fb          	endbr32 
+80100644:	55                   	push   %ebp
+80100645:	89 e5                	mov    %esp,%ebp
+80100647:	57                   	push   %edi
+80100648:	56                   	push   %esi
+80100649:	53                   	push   %ebx
+8010064a:	83 ec 18             	sub    $0x18,%esp
+  int i;
+
+  iunlock(ip);
+8010064d:	ff 75 08             	pushl  0x8(%ebp)
+{
+80100650:	8b 5d 10             	mov    0x10(%ebp),%ebx
+  iunlock(ip);
+80100653:	e8 e8 11 00 00       	call   80101840 <iunlock>
+  acquire(&cons.lock);
+80100658:	c7 04 24 20 a5 10 80 	movl   $0x8010a520,(%esp)
+8010065f:	e8 7c 41 00 00       	call   801047e0 <acquire>
+  for(i = 0; i < n; i++)
+80100664:	83 c4 10             	add    $0x10,%esp
+80100667:	85 db                	test   %ebx,%ebx
+80100669:	7e 24                	jle    8010068f <consolewrite+0x4f>
+8010066b:	8b 7d 0c             	mov    0xc(%ebp),%edi
+8010066e:	8d 34 1f             	lea    (%edi,%ebx,1),%esi
+  if(panicked){
+80100671:	8b 15 58 a5 10 80    	mov    0x8010a558,%edx
+80100677:	85 d2                	test   %edx,%edx
+80100679:	74 05                	je     80100680 <consolewrite+0x40>
+8010067b:	fa                   	cli    
+    for(;;)
+8010067c:	eb fe                	jmp    8010067c <consolewrite+0x3c>
+8010067e:	66 90                	xchg   %ax,%ax
+    consputc(buf[i] & 0xff);
+80100680:	0f b6 07             	movzbl (%edi),%eax
+80100683:	83 c7 01             	add    $0x1,%edi
+80100686:	e8 85 fd ff ff       	call   80100410 <consputc.part.0>
+  for(i = 0; i < n; i++)
+8010068b:	39 fe                	cmp    %edi,%esi
+8010068d:	75 e2                	jne    80100671 <consolewrite+0x31>
+  release(&cons.lock);
+8010068f:	83 ec 0c             	sub    $0xc,%esp
+80100692:	68 20 a5 10 80       	push   $0x8010a520
+80100697:	e8 04 42 00 00       	call   801048a0 <release>
+  ilock(ip);
+8010069c:	58                   	pop    %eax
+8010069d:	ff 75 08             	pushl  0x8(%ebp)
+801006a0:	e8 bb 10 00 00       	call   80101760 <ilock>
+
+  return n;
+}
+801006a5:	8d 65 f4             	lea    -0xc(%ebp),%esp
+801006a8:	89 d8                	mov    %ebx,%eax
+801006aa:	5b                   	pop    %ebx
+801006ab:	5e                   	pop    %esi
+801006ac:	5f                   	pop    %edi
+801006ad:	5d                   	pop    %ebp
+801006ae:	c3                   	ret    
+801006af:	90                   	nop
+
+801006b0 <cprintf>:
+{
+801006b0:	f3 0f 1e fb          	endbr32 
+801006b4:	55                   	push   %ebp
+801006b5:	89 e5                	mov    %esp,%ebp
+801006b7:	57                   	push   %edi
+801006b8:	56                   	push   %esi
+801006b9:	53                   	push   %ebx
+801006ba:	83 ec 1c             	sub    $0x1c,%esp
+  locking = cons.locking;
+801006bd:	a1 54 a5 10 80       	mov    0x8010a554,%eax
+801006c2:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  if(locking)
+801006c5:	85 c0                	test   %eax,%eax
+801006c7:	0f 85 e8 00 00 00    	jne    801007b5 <cprintf+0x105>
+  if (fmt == 0)
+801006cd:	8b 45 08             	mov    0x8(%ebp),%eax
+801006d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+801006d3:	85 c0                	test   %eax,%eax
+801006d5:	0f 84 5a 01 00 00    	je     80100835 <cprintf+0x185>
+  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
+801006db:	0f b6 00             	movzbl (%eax),%eax
+801006de:	85 c0                	test   %eax,%eax
+801006e0:	74 36                	je     80100718 <cprintf+0x68>
+  argp = (uint*)(void*)(&fmt + 1);
+801006e2:	8d 5d 0c             	lea    0xc(%ebp),%ebx
+  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
+801006e5:	31 f6                	xor    %esi,%esi
+    if(c != '%'){
+801006e7:	83 f8 25             	cmp    $0x25,%eax
+801006ea:	74 44                	je     80100730 <cprintf+0x80>
+  if(panicked){
+801006ec:	8b 0d 58 a5 10 80    	mov    0x8010a558,%ecx
+801006f2:	85 c9                	test   %ecx,%ecx
+801006f4:	74 0f                	je     80100705 <cprintf+0x55>
+801006f6:	fa                   	cli    
+    for(;;)
+801006f7:	eb fe                	jmp    801006f7 <cprintf+0x47>
+801006f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80100700:	b8 25 00 00 00       	mov    $0x25,%eax
+80100705:	e8 06 fd ff ff       	call   80100410 <consputc.part.0>
+  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
+8010070a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+8010070d:	83 c6 01             	add    $0x1,%esi
+80100710:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
+80100714:	85 c0                	test   %eax,%eax
+80100716:	75 cf                	jne    801006e7 <cprintf+0x37>
+  if(locking)
+80100718:	8b 45 e0             	mov    -0x20(%ebp),%eax
+8010071b:	85 c0                	test   %eax,%eax
+8010071d:	0f 85 fd 00 00 00    	jne    80100820 <cprintf+0x170>
+}
+80100723:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80100726:	5b                   	pop    %ebx
+80100727:	5e                   	pop    %esi
+80100728:	5f                   	pop    %edi
+80100729:	5d                   	pop    %ebp
+8010072a:	c3                   	ret    
+8010072b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010072f:	90                   	nop
+    c = fmt[++i] & 0xff;
+80100730:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100733:	83 c6 01             	add    $0x1,%esi
+80100736:	0f b6 3c 30          	movzbl (%eax,%esi,1),%edi
+    if(c == 0)
+8010073a:	85 ff                	test   %edi,%edi
+8010073c:	74 da                	je     80100718 <cprintf+0x68>
+    switch(c){
+8010073e:	83 ff 70             	cmp    $0x70,%edi
+80100741:	74 5a                	je     8010079d <cprintf+0xed>
+80100743:	7f 2a                	jg     8010076f <cprintf+0xbf>
+80100745:	83 ff 25             	cmp    $0x25,%edi
+80100748:	0f 84 92 00 00 00    	je     801007e0 <cprintf+0x130>
+8010074e:	83 ff 64             	cmp    $0x64,%edi
+80100751:	0f 85 a1 00 00 00    	jne    801007f8 <cprintf+0x148>
+      printint(*argp++, 10, 1);
+80100757:	8b 03                	mov    (%ebx),%eax
+80100759:	8d 7b 04             	lea    0x4(%ebx),%edi
+8010075c:	b9 01 00 00 00       	mov    $0x1,%ecx
+80100761:	ba 0a 00 00 00       	mov    $0xa,%edx
+80100766:	89 fb                	mov    %edi,%ebx
+80100768:	e8 33 fe ff ff       	call   801005a0 <printint>
+      break;
+8010076d:	eb 9b                	jmp    8010070a <cprintf+0x5a>
+    switch(c){
+8010076f:	83 ff 73             	cmp    $0x73,%edi
+80100772:	75 24                	jne    80100798 <cprintf+0xe8>
+      if((s = (char*)*argp++) == 0)
+80100774:	8d 7b 04             	lea    0x4(%ebx),%edi
+80100777:	8b 1b                	mov    (%ebx),%ebx
+80100779:	85 db                	test   %ebx,%ebx
+8010077b:	75 55                	jne    801007d2 <cprintf+0x122>
+        s = "(null)";
+8010077d:	bb 18 75 10 80       	mov    $0x80107518,%ebx
+      for(; *s; s++)
+80100782:	b8 28 00 00 00       	mov    $0x28,%eax
+  if(panicked){
+80100787:	8b 15 58 a5 10 80    	mov    0x8010a558,%edx
+8010078d:	85 d2                	test   %edx,%edx
+8010078f:	74 39                	je     801007ca <cprintf+0x11a>
+80100791:	fa                   	cli    
+    for(;;)
+80100792:	eb fe                	jmp    80100792 <cprintf+0xe2>
+80100794:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    switch(c){
+80100798:	83 ff 78             	cmp    $0x78,%edi
+8010079b:	75 5b                	jne    801007f8 <cprintf+0x148>
+      printint(*argp++, 16, 0);
+8010079d:	8b 03                	mov    (%ebx),%eax
+8010079f:	8d 7b 04             	lea    0x4(%ebx),%edi
+801007a2:	31 c9                	xor    %ecx,%ecx
+801007a4:	ba 10 00 00 00       	mov    $0x10,%edx
+801007a9:	89 fb                	mov    %edi,%ebx
+801007ab:	e8 f0 fd ff ff       	call   801005a0 <printint>
+      break;
+801007b0:	e9 55 ff ff ff       	jmp    8010070a <cprintf+0x5a>
+    acquire(&cons.lock);
+801007b5:	83 ec 0c             	sub    $0xc,%esp
+801007b8:	68 20 a5 10 80       	push   $0x8010a520
+801007bd:	e8 1e 40 00 00       	call   801047e0 <acquire>
+801007c2:	83 c4 10             	add    $0x10,%esp
+801007c5:	e9 03 ff ff ff       	jmp    801006cd <cprintf+0x1d>
+801007ca:	e8 41 fc ff ff       	call   80100410 <consputc.part.0>
+      for(; *s; s++)
+801007cf:	83 c3 01             	add    $0x1,%ebx
+801007d2:	0f be 03             	movsbl (%ebx),%eax
+801007d5:	84 c0                	test   %al,%al
+801007d7:	75 ae                	jne    80100787 <cprintf+0xd7>
+      if((s = (char*)*argp++) == 0)
+801007d9:	89 fb                	mov    %edi,%ebx
+801007db:	e9 2a ff ff ff       	jmp    8010070a <cprintf+0x5a>
+  if(panicked){
+801007e0:	8b 3d 58 a5 10 80    	mov    0x8010a558,%edi
+801007e6:	85 ff                	test   %edi,%edi
+801007e8:	0f 84 12 ff ff ff    	je     80100700 <cprintf+0x50>
+801007ee:	fa                   	cli    
+    for(;;)
+801007ef:	eb fe                	jmp    801007ef <cprintf+0x13f>
+801007f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  if(panicked){
+801007f8:	8b 0d 58 a5 10 80    	mov    0x8010a558,%ecx
+801007fe:	85 c9                	test   %ecx,%ecx
+80100800:	74 06                	je     80100808 <cprintf+0x158>
+80100802:	fa                   	cli    
+    for(;;)
+80100803:	eb fe                	jmp    80100803 <cprintf+0x153>
+80100805:	8d 76 00             	lea    0x0(%esi),%esi
+80100808:	b8 25 00 00 00       	mov    $0x25,%eax
+8010080d:	e8 fe fb ff ff       	call   80100410 <consputc.part.0>
+  if(panicked){
+80100812:	8b 15 58 a5 10 80    	mov    0x8010a558,%edx
+80100818:	85 d2                	test   %edx,%edx
+8010081a:	74 2c                	je     80100848 <cprintf+0x198>
+8010081c:	fa                   	cli    
+    for(;;)
+8010081d:	eb fe                	jmp    8010081d <cprintf+0x16d>
+8010081f:	90                   	nop
+    release(&cons.lock);
+80100820:	83 ec 0c             	sub    $0xc,%esp
+80100823:	68 20 a5 10 80       	push   $0x8010a520
+80100828:	e8 73 40 00 00       	call   801048a0 <release>
+8010082d:	83 c4 10             	add    $0x10,%esp
+}
+80100830:	e9 ee fe ff ff       	jmp    80100723 <cprintf+0x73>
+    panic("null fmt");
+80100835:	83 ec 0c             	sub    $0xc,%esp
+80100838:	68 1f 75 10 80       	push   $0x8010751f
+8010083d:	e8 4e fb ff ff       	call   80100390 <panic>
+80100842:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80100848:	89 f8                	mov    %edi,%eax
+8010084a:	e8 c1 fb ff ff       	call   80100410 <consputc.part.0>
+8010084f:	e9 b6 fe ff ff       	jmp    8010070a <cprintf+0x5a>
+80100854:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010085b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010085f:	90                   	nop
+
+80100860 <consoleintr>:
+{
+80100860:	f3 0f 1e fb          	endbr32 
+80100864:	55                   	push   %ebp
+80100865:	89 e5                	mov    %esp,%ebp
+80100867:	57                   	push   %edi
+80100868:	56                   	push   %esi
+  int c, doprocdump = 0;
+80100869:	31 f6                	xor    %esi,%esi
+{
+8010086b:	53                   	push   %ebx
+8010086c:	83 ec 18             	sub    $0x18,%esp
+8010086f:	8b 7d 08             	mov    0x8(%ebp),%edi
+  acquire(&cons.lock);
+80100872:	68 20 a5 10 80       	push   $0x8010a520
+80100877:	e8 64 3f 00 00       	call   801047e0 <acquire>
+  while((c = getc()) >= 0){
+8010087c:	83 c4 10             	add    $0x10,%esp
+8010087f:	eb 17                	jmp    80100898 <consoleintr+0x38>
+    switch(c){
+80100881:	83 fb 08             	cmp    $0x8,%ebx
+80100884:	0f 84 f6 00 00 00    	je     80100980 <consoleintr+0x120>
+8010088a:	83 fb 10             	cmp    $0x10,%ebx
+8010088d:	0f 85 15 01 00 00    	jne    801009a8 <consoleintr+0x148>
+80100893:	be 01 00 00 00       	mov    $0x1,%esi
+  while((c = getc()) >= 0){
+80100898:	ff d7                	call   *%edi
+8010089a:	89 c3                	mov    %eax,%ebx
+8010089c:	85 c0                	test   %eax,%eax
+8010089e:	0f 88 23 01 00 00    	js     801009c7 <consoleintr+0x167>
+    switch(c){
+801008a4:	83 fb 15             	cmp    $0x15,%ebx
+801008a7:	74 77                	je     80100920 <consoleintr+0xc0>
+801008a9:	7e d6                	jle    80100881 <consoleintr+0x21>
+801008ab:	83 fb 7f             	cmp    $0x7f,%ebx
+801008ae:	0f 84 cc 00 00 00    	je     80100980 <consoleintr+0x120>
+      if(c != 0 && input.e-input.r < INPUT_BUF){
+801008b4:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
+801008b9:	89 c2                	mov    %eax,%edx
+801008bb:	2b 15 a0 ff 10 80    	sub    0x8010ffa0,%edx
+801008c1:	83 fa 7f             	cmp    $0x7f,%edx
+801008c4:	77 d2                	ja     80100898 <consoleintr+0x38>
+        c = (c == '\r') ? '\n' : c;
+801008c6:	8d 48 01             	lea    0x1(%eax),%ecx
+801008c9:	8b 15 58 a5 10 80    	mov    0x8010a558,%edx
+801008cf:	83 e0 7f             	and    $0x7f,%eax
+        input.buf[input.e++ % INPUT_BUF] = c;
+801008d2:	89 0d a8 ff 10 80    	mov    %ecx,0x8010ffa8
+        c = (c == '\r') ? '\n' : c;
+801008d8:	83 fb 0d             	cmp    $0xd,%ebx
+801008db:	0f 84 02 01 00 00    	je     801009e3 <consoleintr+0x183>
+        input.buf[input.e++ % INPUT_BUF] = c;
+801008e1:	88 98 20 ff 10 80    	mov    %bl,-0x7fef00e0(%eax)
+  if(panicked){
+801008e7:	85 d2                	test   %edx,%edx
+801008e9:	0f 85 ff 00 00 00    	jne    801009ee <consoleintr+0x18e>
+801008ef:	89 d8                	mov    %ebx,%eax
+801008f1:	e8 1a fb ff ff       	call   80100410 <consputc.part.0>
+        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
+801008f6:	83 fb 0a             	cmp    $0xa,%ebx
+801008f9:	0f 84 0f 01 00 00    	je     80100a0e <consoleintr+0x1ae>
+801008ff:	83 fb 04             	cmp    $0x4,%ebx
+80100902:	0f 84 06 01 00 00    	je     80100a0e <consoleintr+0x1ae>
+80100908:	a1 a0 ff 10 80       	mov    0x8010ffa0,%eax
+8010090d:	83 e8 80             	sub    $0xffffff80,%eax
+80100910:	39 05 a8 ff 10 80    	cmp    %eax,0x8010ffa8
+80100916:	75 80                	jne    80100898 <consoleintr+0x38>
+80100918:	e9 f6 00 00 00       	jmp    80100a13 <consoleintr+0x1b3>
+8010091d:	8d 76 00             	lea    0x0(%esi),%esi
+      while(input.e != input.w &&
+80100920:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
+80100925:	39 05 a4 ff 10 80    	cmp    %eax,0x8010ffa4
+8010092b:	0f 84 67 ff ff ff    	je     80100898 <consoleintr+0x38>
+            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+80100931:	83 e8 01             	sub    $0x1,%eax
+80100934:	89 c2                	mov    %eax,%edx
+80100936:	83 e2 7f             	and    $0x7f,%edx
+      while(input.e != input.w &&
+80100939:	80 ba 20 ff 10 80 0a 	cmpb   $0xa,-0x7fef00e0(%edx)
+80100940:	0f 84 52 ff ff ff    	je     80100898 <consoleintr+0x38>
+  if(panicked){
+80100946:	8b 15 58 a5 10 80    	mov    0x8010a558,%edx
+        input.e--;
+8010094c:	a3 a8 ff 10 80       	mov    %eax,0x8010ffa8
+  if(panicked){
+80100951:	85 d2                	test   %edx,%edx
+80100953:	74 0b                	je     80100960 <consoleintr+0x100>
+80100955:	fa                   	cli    
+    for(;;)
+80100956:	eb fe                	jmp    80100956 <consoleintr+0xf6>
+80100958:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010095f:	90                   	nop
+80100960:	b8 00 01 00 00       	mov    $0x100,%eax
+80100965:	e8 a6 fa ff ff       	call   80100410 <consputc.part.0>
+      while(input.e != input.w &&
+8010096a:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
+8010096f:	3b 05 a4 ff 10 80    	cmp    0x8010ffa4,%eax
+80100975:	75 ba                	jne    80100931 <consoleintr+0xd1>
+80100977:	e9 1c ff ff ff       	jmp    80100898 <consoleintr+0x38>
+8010097c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      if(input.e != input.w){
+80100980:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
+80100985:	3b 05 a4 ff 10 80    	cmp    0x8010ffa4,%eax
+8010098b:	0f 84 07 ff ff ff    	je     80100898 <consoleintr+0x38>
+        input.e--;
+80100991:	83 e8 01             	sub    $0x1,%eax
+80100994:	a3 a8 ff 10 80       	mov    %eax,0x8010ffa8
+  if(panicked){
+80100999:	a1 58 a5 10 80       	mov    0x8010a558,%eax
+8010099e:	85 c0                	test   %eax,%eax
+801009a0:	74 16                	je     801009b8 <consoleintr+0x158>
+801009a2:	fa                   	cli    
+    for(;;)
+801009a3:	eb fe                	jmp    801009a3 <consoleintr+0x143>
+801009a5:	8d 76 00             	lea    0x0(%esi),%esi
+      if(c != 0 && input.e-input.r < INPUT_BUF){
+801009a8:	85 db                	test   %ebx,%ebx
+801009aa:	0f 84 e8 fe ff ff    	je     80100898 <consoleintr+0x38>
+801009b0:	e9 ff fe ff ff       	jmp    801008b4 <consoleintr+0x54>
+801009b5:	8d 76 00             	lea    0x0(%esi),%esi
+801009b8:	b8 00 01 00 00       	mov    $0x100,%eax
+801009bd:	e8 4e fa ff ff       	call   80100410 <consputc.part.0>
+801009c2:	e9 d1 fe ff ff       	jmp    80100898 <consoleintr+0x38>
+  release(&cons.lock);
+801009c7:	83 ec 0c             	sub    $0xc,%esp
+801009ca:	68 20 a5 10 80       	push   $0x8010a520
+801009cf:	e8 cc 3e 00 00       	call   801048a0 <release>
+  if(doprocdump) {
+801009d4:	83 c4 10             	add    $0x10,%esp
+801009d7:	85 f6                	test   %esi,%esi
+801009d9:	75 1d                	jne    801009f8 <consoleintr+0x198>
+}
+801009db:	8d 65 f4             	lea    -0xc(%ebp),%esp
+801009de:	5b                   	pop    %ebx
+801009df:	5e                   	pop    %esi
+801009e0:	5f                   	pop    %edi
+801009e1:	5d                   	pop    %ebp
+801009e2:	c3                   	ret    
+        input.buf[input.e++ % INPUT_BUF] = c;
+801009e3:	c6 80 20 ff 10 80 0a 	movb   $0xa,-0x7fef00e0(%eax)
+  if(panicked){
+801009ea:	85 d2                	test   %edx,%edx
+801009ec:	74 16                	je     80100a04 <consoleintr+0x1a4>
+801009ee:	fa                   	cli    
+    for(;;)
+801009ef:	eb fe                	jmp    801009ef <consoleintr+0x18f>
+801009f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+}
+801009f8:	8d 65 f4             	lea    -0xc(%ebp),%esp
+801009fb:	5b                   	pop    %ebx
+801009fc:	5e                   	pop    %esi
+801009fd:	5f                   	pop    %edi
+801009fe:	5d                   	pop    %ebp
+    procdump();  // now call procdump() wo. cons.lock held
+801009ff:	e9 cc 37 00 00       	jmp    801041d0 <procdump>
+80100a04:	b8 0a 00 00 00       	mov    $0xa,%eax
+80100a09:	e8 02 fa ff ff       	call   80100410 <consputc.part.0>
+        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
+80100a0e:	a1 a8 ff 10 80       	mov    0x8010ffa8,%eax
+          wakeup(&input.r);
+80100a13:	83 ec 0c             	sub    $0xc,%esp
+          input.w = input.e;
+80100a16:	a3 a4 ff 10 80       	mov    %eax,0x8010ffa4
+          wakeup(&input.r);
+80100a1b:	68 a0 ff 10 80       	push   $0x8010ffa0
+80100a20:	e8 bb 36 00 00       	call   801040e0 <wakeup>
+80100a25:	83 c4 10             	add    $0x10,%esp
+80100a28:	e9 6b fe ff ff       	jmp    80100898 <consoleintr+0x38>
+80100a2d:	8d 76 00             	lea    0x0(%esi),%esi
+
+80100a30 <consoleinit>:
+
+void
+consoleinit(void)
+{
+80100a30:	f3 0f 1e fb          	endbr32 
+80100a34:	55                   	push   %ebp
+80100a35:	89 e5                	mov    %esp,%ebp
+80100a37:	83 ec 10             	sub    $0x10,%esp
+  initlock(&cons.lock, "console");
+80100a3a:	68 28 75 10 80       	push   $0x80107528
+80100a3f:	68 20 a5 10 80       	push   $0x8010a520
+80100a44:	e8 17 3c 00 00       	call   80104660 <initlock>
+
+  devsw[CONSOLE].write = consolewrite;
+  devsw[CONSOLE].read = consoleread;
+  cons.locking = 1;
+
+  ioapicenable(IRQ_KBD, 0);
+80100a49:	58                   	pop    %eax
+80100a4a:	5a                   	pop    %edx
+80100a4b:	6a 00                	push   $0x0
+80100a4d:	6a 01                	push   $0x1
+  devsw[CONSOLE].write = consolewrite;
+80100a4f:	c7 05 6c 09 11 80 40 	movl   $0x80100640,0x8011096c
+80100a56:	06 10 80 
+  devsw[CONSOLE].read = consoleread;
+80100a59:	c7 05 68 09 11 80 90 	movl   $0x80100290,0x80110968
+80100a60:	02 10 80 
+  cons.locking = 1;
+80100a63:	c7 05 54 a5 10 80 01 	movl   $0x1,0x8010a554
+80100a6a:	00 00 00 
+  ioapicenable(IRQ_KBD, 0);
+80100a6d:	e8 be 19 00 00       	call   80102430 <ioapicenable>
+}
+80100a72:	83 c4 10             	add    $0x10,%esp
+80100a75:	c9                   	leave  
+80100a76:	c3                   	ret    
+80100a77:	66 90                	xchg   %ax,%ax
+80100a79:	66 90                	xchg   %ax,%ax
+80100a7b:	66 90                	xchg   %ax,%ax
+80100a7d:	66 90                	xchg   %ax,%ax
+80100a7f:	90                   	nop
+
+80100a80 <exec>:
+#include "x86.h"
+#include "elf.h"
+
+int
+exec(char *path, char **argv)
+{
+80100a80:	f3 0f 1e fb          	endbr32 
+80100a84:	55                   	push   %ebp
+80100a85:	89 e5                	mov    %esp,%ebp
+80100a87:	57                   	push   %edi
+80100a88:	56                   	push   %esi
+80100a89:	53                   	push   %ebx
+80100a8a:	81 ec 0c 01 00 00    	sub    $0x10c,%esp
+  uint argc, sz, sp, ustack[3+MAXARG+1];
+  struct elfhdr elf;
+  struct inode *ip;
+  struct proghdr ph;
+  pde_t *pgdir, *oldpgdir;
+  struct proc *curproc = myproc();
+80100a90:	e8 cb 2e 00 00       	call   80103960 <myproc>
+80100a95:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
+
+  begin_op();
+80100a9b:	e8 90 22 00 00       	call   80102d30 <begin_op>
+
+  if((ip = namei(path)) == 0){
+80100aa0:	83 ec 0c             	sub    $0xc,%esp
+80100aa3:	ff 75 08             	pushl  0x8(%ebp)
+80100aa6:	e8 85 15 00 00       	call   80102030 <namei>
+80100aab:	83 c4 10             	add    $0x10,%esp
+80100aae:	85 c0                	test   %eax,%eax
+80100ab0:	0f 84 fe 02 00 00    	je     80100db4 <exec+0x334>
+    end_op();
+    cprintf("exec: fail\n");
+    return -1;
+  }
+  ilock(ip);
+80100ab6:	83 ec 0c             	sub    $0xc,%esp
+80100ab9:	89 c3                	mov    %eax,%ebx
+80100abb:	50                   	push   %eax
+80100abc:	e8 9f 0c 00 00       	call   80101760 <ilock>
+  pgdir = 0;
+
+  // Check ELF header
+  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
+80100ac1:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
+80100ac7:	6a 34                	push   $0x34
+80100ac9:	6a 00                	push   $0x0
+80100acb:	50                   	push   %eax
+80100acc:	53                   	push   %ebx
+80100acd:	e8 8e 0f 00 00       	call   80101a60 <readi>
+80100ad2:	83 c4 20             	add    $0x20,%esp
+80100ad5:	83 f8 34             	cmp    $0x34,%eax
+80100ad8:	74 26                	je     80100b00 <exec+0x80>
+
+ bad:
+  if(pgdir)
+    freevm(pgdir);
+  if(ip){
+    iunlockput(ip);
+80100ada:	83 ec 0c             	sub    $0xc,%esp
+80100add:	53                   	push   %ebx
+80100ade:	e8 1d 0f 00 00       	call   80101a00 <iunlockput>
+    end_op();
+80100ae3:	e8 b8 22 00 00       	call   80102da0 <end_op>
+80100ae8:	83 c4 10             	add    $0x10,%esp
+  }
+  return -1;
+80100aeb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80100af0:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80100af3:	5b                   	pop    %ebx
+80100af4:	5e                   	pop    %esi
+80100af5:	5f                   	pop    %edi
+80100af6:	5d                   	pop    %ebp
+80100af7:	c3                   	ret    
+80100af8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80100aff:	90                   	nop
+  if(elf.magic != ELF_MAGIC)
+80100b00:	81 bd 24 ff ff ff 7f 	cmpl   $0x464c457f,-0xdc(%ebp)
+80100b07:	45 4c 46 
+80100b0a:	75 ce                	jne    80100ada <exec+0x5a>
+  if((pgdir = setupkvm()) == 0)
+80100b0c:	e8 1f 67 00 00       	call   80107230 <setupkvm>
+80100b11:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
+80100b17:	85 c0                	test   %eax,%eax
+80100b19:	74 bf                	je     80100ada <exec+0x5a>
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+80100b1b:	66 83 bd 50 ff ff ff 	cmpw   $0x0,-0xb0(%ebp)
+80100b22:	00 
+80100b23:	8b b5 40 ff ff ff    	mov    -0xc0(%ebp),%esi
+80100b29:	0f 84 a4 02 00 00    	je     80100dd3 <exec+0x353>
+  sz = 0;
+80100b2f:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
+80100b36:	00 00 00 
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+80100b39:	31 ff                	xor    %edi,%edi
+80100b3b:	e9 86 00 00 00       	jmp    80100bc6 <exec+0x146>
+    if(ph.type != ELF_PROG_LOAD)
+80100b40:	83 bd 04 ff ff ff 01 	cmpl   $0x1,-0xfc(%ebp)
+80100b47:	75 6c                	jne    80100bb5 <exec+0x135>
+    if(ph.memsz < ph.filesz)
+80100b49:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
+80100b4f:	3b 85 14 ff ff ff    	cmp    -0xec(%ebp),%eax
+80100b55:	0f 82 87 00 00 00    	jb     80100be2 <exec+0x162>
+    if(ph.vaddr + ph.memsz < ph.vaddr)
+80100b5b:	03 85 0c ff ff ff    	add    -0xf4(%ebp),%eax
+80100b61:	72 7f                	jb     80100be2 <exec+0x162>
+    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+80100b63:	83 ec 04             	sub    $0x4,%esp
+80100b66:	50                   	push   %eax
+80100b67:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
+80100b6d:	ff b5 f4 fe ff ff    	pushl  -0x10c(%ebp)
+80100b73:	e8 d8 64 00 00       	call   80107050 <allocuvm>
+80100b78:	83 c4 10             	add    $0x10,%esp
+80100b7b:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
+80100b81:	85 c0                	test   %eax,%eax
+80100b83:	74 5d                	je     80100be2 <exec+0x162>
+    if(ph.vaddr % PGSIZE != 0)
+80100b85:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
+80100b8b:	a9 ff 0f 00 00       	test   $0xfff,%eax
+80100b90:	75 50                	jne    80100be2 <exec+0x162>
+    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
+80100b92:	83 ec 0c             	sub    $0xc,%esp
+80100b95:	ff b5 14 ff ff ff    	pushl  -0xec(%ebp)
+80100b9b:	ff b5 08 ff ff ff    	pushl  -0xf8(%ebp)
+80100ba1:	53                   	push   %ebx
+80100ba2:	50                   	push   %eax
+80100ba3:	ff b5 f4 fe ff ff    	pushl  -0x10c(%ebp)
+80100ba9:	e8 d2 63 00 00       	call   80106f80 <loaduvm>
+80100bae:	83 c4 20             	add    $0x20,%esp
+80100bb1:	85 c0                	test   %eax,%eax
+80100bb3:	78 2d                	js     80100be2 <exec+0x162>
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+80100bb5:	0f b7 85 50 ff ff ff 	movzwl -0xb0(%ebp),%eax
+80100bbc:	83 c7 01             	add    $0x1,%edi
+80100bbf:	83 c6 20             	add    $0x20,%esi
+80100bc2:	39 f8                	cmp    %edi,%eax
+80100bc4:	7e 3a                	jle    80100c00 <exec+0x180>
+    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
+80100bc6:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
+80100bcc:	6a 20                	push   $0x20
+80100bce:	56                   	push   %esi
+80100bcf:	50                   	push   %eax
+80100bd0:	53                   	push   %ebx
+80100bd1:	e8 8a 0e 00 00       	call   80101a60 <readi>
+80100bd6:	83 c4 10             	add    $0x10,%esp
+80100bd9:	83 f8 20             	cmp    $0x20,%eax
+80100bdc:	0f 84 5e ff ff ff    	je     80100b40 <exec+0xc0>
+    freevm(pgdir);
+80100be2:	83 ec 0c             	sub    $0xc,%esp
+80100be5:	ff b5 f4 fe ff ff    	pushl  -0x10c(%ebp)
+80100beb:	e8 c0 65 00 00       	call   801071b0 <freevm>
+  if(ip){
+80100bf0:	83 c4 10             	add    $0x10,%esp
+80100bf3:	e9 e2 fe ff ff       	jmp    80100ada <exec+0x5a>
+80100bf8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80100bff:	90                   	nop
+80100c00:	8b bd f0 fe ff ff    	mov    -0x110(%ebp),%edi
+80100c06:	81 c7 ff 0f 00 00    	add    $0xfff,%edi
+80100c0c:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
+80100c12:	8d b7 00 20 00 00    	lea    0x2000(%edi),%esi
+  iunlockput(ip);
+80100c18:	83 ec 0c             	sub    $0xc,%esp
+80100c1b:	53                   	push   %ebx
+80100c1c:	e8 df 0d 00 00       	call   80101a00 <iunlockput>
+  end_op();
+80100c21:	e8 7a 21 00 00       	call   80102da0 <end_op>
+  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
+80100c26:	83 c4 0c             	add    $0xc,%esp
+80100c29:	56                   	push   %esi
+80100c2a:	57                   	push   %edi
+80100c2b:	8b bd f4 fe ff ff    	mov    -0x10c(%ebp),%edi
+80100c31:	57                   	push   %edi
+80100c32:	e8 19 64 00 00       	call   80107050 <allocuvm>
+80100c37:	83 c4 10             	add    $0x10,%esp
+80100c3a:	89 c6                	mov    %eax,%esi
+80100c3c:	85 c0                	test   %eax,%eax
+80100c3e:	0f 84 94 00 00 00    	je     80100cd8 <exec+0x258>
+  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+80100c44:	83 ec 08             	sub    $0x8,%esp
+80100c47:	8d 80 00 e0 ff ff    	lea    -0x2000(%eax),%eax
+  for(argc = 0; argv[argc]; argc++) {
+80100c4d:	89 f3                	mov    %esi,%ebx
+  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+80100c4f:	50                   	push   %eax
+80100c50:	57                   	push   %edi
+  for(argc = 0; argv[argc]; argc++) {
+80100c51:	31 ff                	xor    %edi,%edi
+  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+80100c53:	e8 78 66 00 00       	call   801072d0 <clearpteu>
+  for(argc = 0; argv[argc]; argc++) {
+80100c58:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100c5b:	83 c4 10             	add    $0x10,%esp
+80100c5e:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
+80100c64:	8b 00                	mov    (%eax),%eax
+80100c66:	85 c0                	test   %eax,%eax
+80100c68:	0f 84 8b 00 00 00    	je     80100cf9 <exec+0x279>
+80100c6e:	89 b5 f0 fe ff ff    	mov    %esi,-0x110(%ebp)
+80100c74:	8b b5 f4 fe ff ff    	mov    -0x10c(%ebp),%esi
+80100c7a:	eb 23                	jmp    80100c9f <exec+0x21f>
+80100c7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80100c80:	8b 45 0c             	mov    0xc(%ebp),%eax
+    ustack[3+argc] = sp;
+80100c83:	89 9c bd 64 ff ff ff 	mov    %ebx,-0x9c(%ebp,%edi,4)
+  for(argc = 0; argv[argc]; argc++) {
+80100c8a:	83 c7 01             	add    $0x1,%edi
+    ustack[3+argc] = sp;
+80100c8d:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
+  for(argc = 0; argv[argc]; argc++) {
+80100c93:	8b 04 b8             	mov    (%eax,%edi,4),%eax
+80100c96:	85 c0                	test   %eax,%eax
+80100c98:	74 59                	je     80100cf3 <exec+0x273>
+    if(argc >= MAXARG)
+80100c9a:	83 ff 20             	cmp    $0x20,%edi
+80100c9d:	74 39                	je     80100cd8 <exec+0x258>
+    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+80100c9f:	83 ec 0c             	sub    $0xc,%esp
+80100ca2:	50                   	push   %eax
+80100ca3:	e8 48 3e 00 00       	call   80104af0 <strlen>
+80100ca8:	f7 d0                	not    %eax
+80100caa:	01 c3                	add    %eax,%ebx
+    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+80100cac:	58                   	pop    %eax
+80100cad:	8b 45 0c             	mov    0xc(%ebp),%eax
+    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+80100cb0:	83 e3 fc             	and    $0xfffffffc,%ebx
+    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+80100cb3:	ff 34 b8             	pushl  (%eax,%edi,4)
+80100cb6:	e8 35 3e 00 00       	call   80104af0 <strlen>
+80100cbb:	83 c0 01             	add    $0x1,%eax
+80100cbe:	50                   	push   %eax
+80100cbf:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100cc2:	ff 34 b8             	pushl  (%eax,%edi,4)
+80100cc5:	53                   	push   %ebx
+80100cc6:	56                   	push   %esi
+80100cc7:	e8 64 67 00 00       	call   80107430 <copyout>
+80100ccc:	83 c4 20             	add    $0x20,%esp
+80100ccf:	85 c0                	test   %eax,%eax
+80100cd1:	79 ad                	jns    80100c80 <exec+0x200>
+80100cd3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80100cd7:	90                   	nop
+    freevm(pgdir);
+80100cd8:	83 ec 0c             	sub    $0xc,%esp
+80100cdb:	ff b5 f4 fe ff ff    	pushl  -0x10c(%ebp)
+80100ce1:	e8 ca 64 00 00       	call   801071b0 <freevm>
+80100ce6:	83 c4 10             	add    $0x10,%esp
+  return -1;
+80100ce9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80100cee:	e9 fd fd ff ff       	jmp    80100af0 <exec+0x70>
+80100cf3:	8b b5 f0 fe ff ff    	mov    -0x110(%ebp),%esi
+  ustack[2] = sp - (argc+1)*4;  // argv pointer
+80100cf9:	8d 04 bd 04 00 00 00 	lea    0x4(,%edi,4),%eax
+80100d00:	89 d9                	mov    %ebx,%ecx
+  ustack[3+argc] = 0;
+80100d02:	c7 84 bd 64 ff ff ff 	movl   $0x0,-0x9c(%ebp,%edi,4)
+80100d09:	00 00 00 00 
+  ustack[2] = sp - (argc+1)*4;  // argv pointer
+80100d0d:	29 c1                	sub    %eax,%ecx
+  sp -= (3+argc+1) * 4;
+80100d0f:	83 c0 0c             	add    $0xc,%eax
+  ustack[1] = argc;
+80100d12:	89 bd 5c ff ff ff    	mov    %edi,-0xa4(%ebp)
+  sp -= (3+argc+1) * 4;
+80100d18:	29 c3                	sub    %eax,%ebx
+  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
+80100d1a:	50                   	push   %eax
+80100d1b:	52                   	push   %edx
+80100d1c:	53                   	push   %ebx
+80100d1d:	ff b5 f4 fe ff ff    	pushl  -0x10c(%ebp)
+  ustack[0] = 0xffffffff;  // fake return PC
+80100d23:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
+80100d2a:	ff ff ff 
+  ustack[2] = sp - (argc+1)*4;  // argv pointer
+80100d2d:	89 8d 60 ff ff ff    	mov    %ecx,-0xa0(%ebp)
+  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
+80100d33:	e8 f8 66 00 00       	call   80107430 <copyout>
+80100d38:	83 c4 10             	add    $0x10,%esp
+80100d3b:	85 c0                	test   %eax,%eax
+80100d3d:	78 99                	js     80100cd8 <exec+0x258>
+  for(last=s=path; *s; s++)
+80100d3f:	8b 45 08             	mov    0x8(%ebp),%eax
+80100d42:	8b 55 08             	mov    0x8(%ebp),%edx
+80100d45:	0f b6 00             	movzbl (%eax),%eax
+80100d48:	84 c0                	test   %al,%al
+80100d4a:	74 13                	je     80100d5f <exec+0x2df>
+80100d4c:	89 d1                	mov    %edx,%ecx
+80100d4e:	66 90                	xchg   %ax,%ax
+    if(*s == '/')
+80100d50:	83 c1 01             	add    $0x1,%ecx
+80100d53:	3c 2f                	cmp    $0x2f,%al
+  for(last=s=path; *s; s++)
+80100d55:	0f b6 01             	movzbl (%ecx),%eax
+    if(*s == '/')
+80100d58:	0f 44 d1             	cmove  %ecx,%edx
+  for(last=s=path; *s; s++)
+80100d5b:	84 c0                	test   %al,%al
+80100d5d:	75 f1                	jne    80100d50 <exec+0x2d0>
+  safestrcpy(curproc->name, last, sizeof(curproc->name));
+80100d5f:	8b bd ec fe ff ff    	mov    -0x114(%ebp),%edi
+80100d65:	83 ec 04             	sub    $0x4,%esp
+80100d68:	6a 10                	push   $0x10
+80100d6a:	89 f8                	mov    %edi,%eax
+80100d6c:	52                   	push   %edx
+80100d6d:	83 c0 6c             	add    $0x6c,%eax
+80100d70:	50                   	push   %eax
+80100d71:	e8 3a 3d 00 00       	call   80104ab0 <safestrcpy>
+  curproc->pgdir = pgdir;
+80100d76:	8b 8d f4 fe ff ff    	mov    -0x10c(%ebp),%ecx
+  oldpgdir = curproc->pgdir;
+80100d7c:	89 f8                	mov    %edi,%eax
+80100d7e:	8b 7f 04             	mov    0x4(%edi),%edi
+  curproc->sz = sz;
+80100d81:	89 30                	mov    %esi,(%eax)
+  curproc->pgdir = pgdir;
+80100d83:	89 48 04             	mov    %ecx,0x4(%eax)
+  curproc->tf->eip = elf.entry;  // main
+80100d86:	89 c1                	mov    %eax,%ecx
+80100d88:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
+80100d8e:	8b 40 18             	mov    0x18(%eax),%eax
+80100d91:	89 50 38             	mov    %edx,0x38(%eax)
+  curproc->tf->esp = sp;
+80100d94:	8b 41 18             	mov    0x18(%ecx),%eax
+80100d97:	89 58 44             	mov    %ebx,0x44(%eax)
+  switchuvm(curproc);
+80100d9a:	89 0c 24             	mov    %ecx,(%esp)
+80100d9d:	e8 4e 60 00 00       	call   80106df0 <switchuvm>
+  freevm(oldpgdir);
+80100da2:	89 3c 24             	mov    %edi,(%esp)
+80100da5:	e8 06 64 00 00       	call   801071b0 <freevm>
+  return 0;
+80100daa:	83 c4 10             	add    $0x10,%esp
+80100dad:	31 c0                	xor    %eax,%eax
+80100daf:	e9 3c fd ff ff       	jmp    80100af0 <exec+0x70>
+    end_op();
+80100db4:	e8 e7 1f 00 00       	call   80102da0 <end_op>
+    cprintf("exec: fail\n");
+80100db9:	83 ec 0c             	sub    $0xc,%esp
+80100dbc:	68 41 75 10 80       	push   $0x80107541
+80100dc1:	e8 ea f8 ff ff       	call   801006b0 <cprintf>
+    return -1;
+80100dc6:	83 c4 10             	add    $0x10,%esp
+80100dc9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80100dce:	e9 1d fd ff ff       	jmp    80100af0 <exec+0x70>
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+80100dd3:	31 ff                	xor    %edi,%edi
+80100dd5:	be 00 20 00 00       	mov    $0x2000,%esi
+80100dda:	e9 39 fe ff ff       	jmp    80100c18 <exec+0x198>
+80100ddf:	90                   	nop
+
+80100de0 <fileinit>:
+  struct file file[NFILE];
+} ftable;
+
+void
+fileinit(void)
+{
+80100de0:	f3 0f 1e fb          	endbr32 
+80100de4:	55                   	push   %ebp
+80100de5:	89 e5                	mov    %esp,%ebp
+80100de7:	83 ec 10             	sub    $0x10,%esp
+  initlock(&ftable.lock, "ftable");
+80100dea:	68 4d 75 10 80       	push   $0x8010754d
+80100def:	68 c0 ff 10 80       	push   $0x8010ffc0
+80100df4:	e8 67 38 00 00       	call   80104660 <initlock>
+}
+80100df9:	83 c4 10             	add    $0x10,%esp
+80100dfc:	c9                   	leave  
+80100dfd:	c3                   	ret    
+80100dfe:	66 90                	xchg   %ax,%ax
+
+80100e00 <filealloc>:
+
+// Allocate a file structure.
+struct file*
+filealloc(void)
+{
+80100e00:	f3 0f 1e fb          	endbr32 
+80100e04:	55                   	push   %ebp
+80100e05:	89 e5                	mov    %esp,%ebp
+80100e07:	53                   	push   %ebx
+  struct file *f;
+
+  acquire(&ftable.lock);
+  for(f = ftable.file; f < ftable.file + NFILE; f++){
+80100e08:	bb f4 ff 10 80       	mov    $0x8010fff4,%ebx
+{
+80100e0d:	83 ec 10             	sub    $0x10,%esp
+  acquire(&ftable.lock);
+80100e10:	68 c0 ff 10 80       	push   $0x8010ffc0
+80100e15:	e8 c6 39 00 00       	call   801047e0 <acquire>
+80100e1a:	83 c4 10             	add    $0x10,%esp
+80100e1d:	eb 0c                	jmp    80100e2b <filealloc+0x2b>
+80100e1f:	90                   	nop
+  for(f = ftable.file; f < ftable.file + NFILE; f++){
+80100e20:	83 c3 18             	add    $0x18,%ebx
+80100e23:	81 fb 54 09 11 80    	cmp    $0x80110954,%ebx
+80100e29:	74 25                	je     80100e50 <filealloc+0x50>
+    if(f->ref == 0){
+80100e2b:	8b 43 04             	mov    0x4(%ebx),%eax
+80100e2e:	85 c0                	test   %eax,%eax
+80100e30:	75 ee                	jne    80100e20 <filealloc+0x20>
+      f->ref = 1;
+      release(&ftable.lock);
+80100e32:	83 ec 0c             	sub    $0xc,%esp
+      f->ref = 1;
+80100e35:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)
+      release(&ftable.lock);
+80100e3c:	68 c0 ff 10 80       	push   $0x8010ffc0
+80100e41:	e8 5a 3a 00 00       	call   801048a0 <release>
+      return f;
+    }
+  }
+  release(&ftable.lock);
+  return 0;
+}
+80100e46:	89 d8                	mov    %ebx,%eax
+      return f;
+80100e48:	83 c4 10             	add    $0x10,%esp
+}
+80100e4b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80100e4e:	c9                   	leave  
+80100e4f:	c3                   	ret    
+  release(&ftable.lock);
+80100e50:	83 ec 0c             	sub    $0xc,%esp
+  return 0;
+80100e53:	31 db                	xor    %ebx,%ebx
+  release(&ftable.lock);
+80100e55:	68 c0 ff 10 80       	push   $0x8010ffc0
+80100e5a:	e8 41 3a 00 00       	call   801048a0 <release>
+}
+80100e5f:	89 d8                	mov    %ebx,%eax
+  return 0;
+80100e61:	83 c4 10             	add    $0x10,%esp
+}
+80100e64:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80100e67:	c9                   	leave  
+80100e68:	c3                   	ret    
+80100e69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80100e70 <filedup>:
+
+// Increment ref count for file f.
+struct file*
+filedup(struct file *f)
+{
+80100e70:	f3 0f 1e fb          	endbr32 
+80100e74:	55                   	push   %ebp
+80100e75:	89 e5                	mov    %esp,%ebp
+80100e77:	53                   	push   %ebx
+80100e78:	83 ec 10             	sub    $0x10,%esp
+80100e7b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  acquire(&ftable.lock);
+80100e7e:	68 c0 ff 10 80       	push   $0x8010ffc0
+80100e83:	e8 58 39 00 00       	call   801047e0 <acquire>
+  if(f->ref < 1)
+80100e88:	8b 43 04             	mov    0x4(%ebx),%eax
+80100e8b:	83 c4 10             	add    $0x10,%esp
+80100e8e:	85 c0                	test   %eax,%eax
+80100e90:	7e 1a                	jle    80100eac <filedup+0x3c>
+    panic("filedup");
+  f->ref++;
+80100e92:	83 c0 01             	add    $0x1,%eax
+  release(&ftable.lock);
+80100e95:	83 ec 0c             	sub    $0xc,%esp
+  f->ref++;
+80100e98:	89 43 04             	mov    %eax,0x4(%ebx)
+  release(&ftable.lock);
+80100e9b:	68 c0 ff 10 80       	push   $0x8010ffc0
+80100ea0:	e8 fb 39 00 00       	call   801048a0 <release>
+  return f;
+}
+80100ea5:	89 d8                	mov    %ebx,%eax
+80100ea7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80100eaa:	c9                   	leave  
+80100eab:	c3                   	ret    
+    panic("filedup");
+80100eac:	83 ec 0c             	sub    $0xc,%esp
+80100eaf:	68 54 75 10 80       	push   $0x80107554
+80100eb4:	e8 d7 f4 ff ff       	call   80100390 <panic>
+80100eb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80100ec0 <fileclose>:
+
+// Close file f.  (Decrement ref count, close when reaches 0.)
+void
+fileclose(struct file *f)
+{
+80100ec0:	f3 0f 1e fb          	endbr32 
+80100ec4:	55                   	push   %ebp
+80100ec5:	89 e5                	mov    %esp,%ebp
+80100ec7:	57                   	push   %edi
+80100ec8:	56                   	push   %esi
+80100ec9:	53                   	push   %ebx
+80100eca:	83 ec 28             	sub    $0x28,%esp
+80100ecd:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  struct file ff;
+
+  acquire(&ftable.lock);
+80100ed0:	68 c0 ff 10 80       	push   $0x8010ffc0
+80100ed5:	e8 06 39 00 00       	call   801047e0 <acquire>
+  if(f->ref < 1)
+80100eda:	8b 53 04             	mov    0x4(%ebx),%edx
+80100edd:	83 c4 10             	add    $0x10,%esp
+80100ee0:	85 d2                	test   %edx,%edx
+80100ee2:	0f 8e a1 00 00 00    	jle    80100f89 <fileclose+0xc9>
+    panic("fileclose");
+  if(--f->ref > 0){
+80100ee8:	83 ea 01             	sub    $0x1,%edx
+80100eeb:	89 53 04             	mov    %edx,0x4(%ebx)
+80100eee:	75 40                	jne    80100f30 <fileclose+0x70>
+    release(&ftable.lock);
+    return;
+  }
+  ff = *f;
+80100ef0:	0f b6 43 09          	movzbl 0x9(%ebx),%eax
+  f->ref = 0;
+  f->type = FD_NONE;
+  release(&ftable.lock);
+80100ef4:	83 ec 0c             	sub    $0xc,%esp
+  ff = *f;
+80100ef7:	8b 3b                	mov    (%ebx),%edi
+  f->type = FD_NONE;
+80100ef9:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
+  ff = *f;
+80100eff:	8b 73 0c             	mov    0xc(%ebx),%esi
+80100f02:	88 45 e7             	mov    %al,-0x19(%ebp)
+80100f05:	8b 43 10             	mov    0x10(%ebx),%eax
+  release(&ftable.lock);
+80100f08:	68 c0 ff 10 80       	push   $0x8010ffc0
+  ff = *f;
+80100f0d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  release(&ftable.lock);
+80100f10:	e8 8b 39 00 00       	call   801048a0 <release>
+
+  if(ff.type == FD_PIPE)
+80100f15:	83 c4 10             	add    $0x10,%esp
+80100f18:	83 ff 01             	cmp    $0x1,%edi
+80100f1b:	74 53                	je     80100f70 <fileclose+0xb0>
+    pipeclose(ff.pipe, ff.writable);
+  else if(ff.type == FD_INODE){
+80100f1d:	83 ff 02             	cmp    $0x2,%edi
+80100f20:	74 26                	je     80100f48 <fileclose+0x88>
+    begin_op();
+    iput(ff.ip);
+    end_op();
+  }
+}
+80100f22:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80100f25:	5b                   	pop    %ebx
+80100f26:	5e                   	pop    %esi
+80100f27:	5f                   	pop    %edi
+80100f28:	5d                   	pop    %ebp
+80100f29:	c3                   	ret    
+80100f2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    release(&ftable.lock);
+80100f30:	c7 45 08 c0 ff 10 80 	movl   $0x8010ffc0,0x8(%ebp)
+}
+80100f37:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80100f3a:	5b                   	pop    %ebx
+80100f3b:	5e                   	pop    %esi
+80100f3c:	5f                   	pop    %edi
+80100f3d:	5d                   	pop    %ebp
+    release(&ftable.lock);
+80100f3e:	e9 5d 39 00 00       	jmp    801048a0 <release>
+80100f43:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80100f47:	90                   	nop
+    begin_op();
+80100f48:	e8 e3 1d 00 00       	call   80102d30 <begin_op>
+    iput(ff.ip);
+80100f4d:	83 ec 0c             	sub    $0xc,%esp
+80100f50:	ff 75 e0             	pushl  -0x20(%ebp)
+80100f53:	e8 38 09 00 00       	call   80101890 <iput>
+    end_op();
+80100f58:	83 c4 10             	add    $0x10,%esp
+}
+80100f5b:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80100f5e:	5b                   	pop    %ebx
+80100f5f:	5e                   	pop    %esi
+80100f60:	5f                   	pop    %edi
+80100f61:	5d                   	pop    %ebp
+    end_op();
+80100f62:	e9 39 1e 00 00       	jmp    80102da0 <end_op>
+80100f67:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80100f6e:	66 90                	xchg   %ax,%ax
+    pipeclose(ff.pipe, ff.writable);
+80100f70:	0f be 5d e7          	movsbl -0x19(%ebp),%ebx
+80100f74:	83 ec 08             	sub    $0x8,%esp
+80100f77:	53                   	push   %ebx
+80100f78:	56                   	push   %esi
+80100f79:	e8 82 25 00 00       	call   80103500 <pipeclose>
+80100f7e:	83 c4 10             	add    $0x10,%esp
+}
+80100f81:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80100f84:	5b                   	pop    %ebx
+80100f85:	5e                   	pop    %esi
+80100f86:	5f                   	pop    %edi
+80100f87:	5d                   	pop    %ebp
+80100f88:	c3                   	ret    
+    panic("fileclose");
+80100f89:	83 ec 0c             	sub    $0xc,%esp
+80100f8c:	68 5c 75 10 80       	push   $0x8010755c
+80100f91:	e8 fa f3 ff ff       	call   80100390 <panic>
+80100f96:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80100f9d:	8d 76 00             	lea    0x0(%esi),%esi
+
+80100fa0 <filestat>:
+
+// Get metadata about file f.
+int
+filestat(struct file *f, struct stat *st)
+{
+80100fa0:	f3 0f 1e fb          	endbr32 
+80100fa4:	55                   	push   %ebp
+80100fa5:	89 e5                	mov    %esp,%ebp
+80100fa7:	53                   	push   %ebx
+80100fa8:	83 ec 04             	sub    $0x4,%esp
+80100fab:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(f->type == FD_INODE){
+80100fae:	83 3b 02             	cmpl   $0x2,(%ebx)
+80100fb1:	75 2d                	jne    80100fe0 <filestat+0x40>
+    ilock(f->ip);
+80100fb3:	83 ec 0c             	sub    $0xc,%esp
+80100fb6:	ff 73 10             	pushl  0x10(%ebx)
+80100fb9:	e8 a2 07 00 00       	call   80101760 <ilock>
+    stati(f->ip, st);
+80100fbe:	58                   	pop    %eax
+80100fbf:	5a                   	pop    %edx
+80100fc0:	ff 75 0c             	pushl  0xc(%ebp)
+80100fc3:	ff 73 10             	pushl  0x10(%ebx)
+80100fc6:	e8 65 0a 00 00       	call   80101a30 <stati>
+    iunlock(f->ip);
+80100fcb:	59                   	pop    %ecx
+80100fcc:	ff 73 10             	pushl  0x10(%ebx)
+80100fcf:	e8 6c 08 00 00       	call   80101840 <iunlock>
+    return 0;
+  }
+  return -1;
+}
+80100fd4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+    return 0;
+80100fd7:	83 c4 10             	add    $0x10,%esp
+80100fda:	31 c0                	xor    %eax,%eax
+}
+80100fdc:	c9                   	leave  
+80100fdd:	c3                   	ret    
+80100fde:	66 90                	xchg   %ax,%ax
+80100fe0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+  return -1;
+80100fe3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80100fe8:	c9                   	leave  
+80100fe9:	c3                   	ret    
+80100fea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80100ff0 <fileread>:
+
+// Read from file f.
+int
+fileread(struct file *f, char *addr, int n)
+{
+80100ff0:	f3 0f 1e fb          	endbr32 
+80100ff4:	55                   	push   %ebp
+80100ff5:	89 e5                	mov    %esp,%ebp
+80100ff7:	57                   	push   %edi
+80100ff8:	56                   	push   %esi
+80100ff9:	53                   	push   %ebx
+80100ffa:	83 ec 0c             	sub    $0xc,%esp
+80100ffd:	8b 5d 08             	mov    0x8(%ebp),%ebx
+80101000:	8b 75 0c             	mov    0xc(%ebp),%esi
+80101003:	8b 7d 10             	mov    0x10(%ebp),%edi
+  int r;
+
+  if(f->readable == 0)
+80101006:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
+8010100a:	74 64                	je     80101070 <fileread+0x80>
+    return -1;
+  if(f->type == FD_PIPE)
+8010100c:	8b 03                	mov    (%ebx),%eax
+8010100e:	83 f8 01             	cmp    $0x1,%eax
+80101011:	74 45                	je     80101058 <fileread+0x68>
+    return piperead(f->pipe, addr, n);
+  if(f->type == FD_INODE){
+80101013:	83 f8 02             	cmp    $0x2,%eax
+80101016:	75 5f                	jne    80101077 <fileread+0x87>
+    ilock(f->ip);
+80101018:	83 ec 0c             	sub    $0xc,%esp
+8010101b:	ff 73 10             	pushl  0x10(%ebx)
+8010101e:	e8 3d 07 00 00       	call   80101760 <ilock>
+    if((r = readi(f->ip, addr, f->off, n)) > 0)
+80101023:	57                   	push   %edi
+80101024:	ff 73 14             	pushl  0x14(%ebx)
+80101027:	56                   	push   %esi
+80101028:	ff 73 10             	pushl  0x10(%ebx)
+8010102b:	e8 30 0a 00 00       	call   80101a60 <readi>
+80101030:	83 c4 20             	add    $0x20,%esp
+80101033:	89 c6                	mov    %eax,%esi
+80101035:	85 c0                	test   %eax,%eax
+80101037:	7e 03                	jle    8010103c <fileread+0x4c>
+      f->off += r;
+80101039:	01 43 14             	add    %eax,0x14(%ebx)
+    iunlock(f->ip);
+8010103c:	83 ec 0c             	sub    $0xc,%esp
+8010103f:	ff 73 10             	pushl  0x10(%ebx)
+80101042:	e8 f9 07 00 00       	call   80101840 <iunlock>
+    return r;
+80101047:	83 c4 10             	add    $0x10,%esp
+  }
+  panic("fileread");
+}
+8010104a:	8d 65 f4             	lea    -0xc(%ebp),%esp
+8010104d:	89 f0                	mov    %esi,%eax
+8010104f:	5b                   	pop    %ebx
+80101050:	5e                   	pop    %esi
+80101051:	5f                   	pop    %edi
+80101052:	5d                   	pop    %ebp
+80101053:	c3                   	ret    
+80101054:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return piperead(f->pipe, addr, n);
+80101058:	8b 43 0c             	mov    0xc(%ebx),%eax
+8010105b:	89 45 08             	mov    %eax,0x8(%ebp)
+}
+8010105e:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80101061:	5b                   	pop    %ebx
+80101062:	5e                   	pop    %esi
+80101063:	5f                   	pop    %edi
+80101064:	5d                   	pop    %ebp
+    return piperead(f->pipe, addr, n);
+80101065:	e9 36 26 00 00       	jmp    801036a0 <piperead>
+8010106a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    return -1;
+80101070:	be ff ff ff ff       	mov    $0xffffffff,%esi
+80101075:	eb d3                	jmp    8010104a <fileread+0x5a>
+  panic("fileread");
+80101077:	83 ec 0c             	sub    $0xc,%esp
+8010107a:	68 66 75 10 80       	push   $0x80107566
+8010107f:	e8 0c f3 ff ff       	call   80100390 <panic>
+80101084:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010108b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010108f:	90                   	nop
+
+80101090 <filewrite>:
+
+//PAGEBREAK!
+// Write to file f.
+int
+filewrite(struct file *f, char *addr, int n)
+{
+80101090:	f3 0f 1e fb          	endbr32 
+80101094:	55                   	push   %ebp
+80101095:	89 e5                	mov    %esp,%ebp
+80101097:	57                   	push   %edi
+80101098:	56                   	push   %esi
+80101099:	53                   	push   %ebx
+8010109a:	83 ec 1c             	sub    $0x1c,%esp
+8010109d:	8b 45 0c             	mov    0xc(%ebp),%eax
+801010a0:	8b 75 08             	mov    0x8(%ebp),%esi
+801010a3:	89 45 dc             	mov    %eax,-0x24(%ebp)
+801010a6:	8b 45 10             	mov    0x10(%ebp),%eax
+  int r;
+
+  if(f->writable == 0)
+801010a9:	80 7e 09 00          	cmpb   $0x0,0x9(%esi)
+{
+801010ad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  if(f->writable == 0)
+801010b0:	0f 84 c1 00 00 00    	je     80101177 <filewrite+0xe7>
+    return -1;
+  if(f->type == FD_PIPE)
+801010b6:	8b 06                	mov    (%esi),%eax
+801010b8:	83 f8 01             	cmp    $0x1,%eax
+801010bb:	0f 84 c3 00 00 00    	je     80101184 <filewrite+0xf4>
+    return pipewrite(f->pipe, addr, n);
+  if(f->type == FD_INODE){
+801010c1:	83 f8 02             	cmp    $0x2,%eax
+801010c4:	0f 85 cc 00 00 00    	jne    80101196 <filewrite+0x106>
+    // and 2 blocks of slop for non-aligned writes.
+    // this really belongs lower down, since writei()
+    // might be writing a device like the console.
+    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
+    int i = 0;
+    while(i < n){
+801010ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    int i = 0;
+801010cd:	31 ff                	xor    %edi,%edi
+    while(i < n){
+801010cf:	85 c0                	test   %eax,%eax
+801010d1:	7f 34                	jg     80101107 <filewrite+0x77>
+801010d3:	e9 98 00 00 00       	jmp    80101170 <filewrite+0xe0>
+801010d8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801010df:	90                   	nop
+        n1 = max;
+
+      begin_op();
+      ilock(f->ip);
+      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
+        f->off += r;
+801010e0:	01 46 14             	add    %eax,0x14(%esi)
+      iunlock(f->ip);
+801010e3:	83 ec 0c             	sub    $0xc,%esp
+801010e6:	ff 76 10             	pushl  0x10(%esi)
+        f->off += r;
+801010e9:	89 45 e0             	mov    %eax,-0x20(%ebp)
+      iunlock(f->ip);
+801010ec:	e8 4f 07 00 00       	call   80101840 <iunlock>
+      end_op();
+801010f1:	e8 aa 1c 00 00       	call   80102da0 <end_op>
+
+      if(r < 0)
+        break;
+      if(r != n1)
+801010f6:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801010f9:	83 c4 10             	add    $0x10,%esp
+801010fc:	39 c3                	cmp    %eax,%ebx
+801010fe:	75 60                	jne    80101160 <filewrite+0xd0>
+        panic("short filewrite");
+      i += r;
+80101100:	01 df                	add    %ebx,%edi
+    while(i < n){
+80101102:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
+80101105:	7e 69                	jle    80101170 <filewrite+0xe0>
+      int n1 = n - i;
+80101107:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
+8010110a:	b8 00 06 00 00       	mov    $0x600,%eax
+8010110f:	29 fb                	sub    %edi,%ebx
+      if(n1 > max)
+80101111:	81 fb 00 06 00 00    	cmp    $0x600,%ebx
+80101117:	0f 4f d8             	cmovg  %eax,%ebx
+      begin_op();
+8010111a:	e8 11 1c 00 00       	call   80102d30 <begin_op>
+      ilock(f->ip);
+8010111f:	83 ec 0c             	sub    $0xc,%esp
+80101122:	ff 76 10             	pushl  0x10(%esi)
+80101125:	e8 36 06 00 00       	call   80101760 <ilock>
+      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
+8010112a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+8010112d:	53                   	push   %ebx
+8010112e:	ff 76 14             	pushl  0x14(%esi)
+80101131:	01 f8                	add    %edi,%eax
+80101133:	50                   	push   %eax
+80101134:	ff 76 10             	pushl  0x10(%esi)
+80101137:	e8 24 0a 00 00       	call   80101b60 <writei>
+8010113c:	83 c4 20             	add    $0x20,%esp
+8010113f:	85 c0                	test   %eax,%eax
+80101141:	7f 9d                	jg     801010e0 <filewrite+0x50>
+      iunlock(f->ip);
+80101143:	83 ec 0c             	sub    $0xc,%esp
+80101146:	ff 76 10             	pushl  0x10(%esi)
+80101149:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+8010114c:	e8 ef 06 00 00       	call   80101840 <iunlock>
+      end_op();
+80101151:	e8 4a 1c 00 00       	call   80102da0 <end_op>
+      if(r < 0)
+80101156:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80101159:	83 c4 10             	add    $0x10,%esp
+8010115c:	85 c0                	test   %eax,%eax
+8010115e:	75 17                	jne    80101177 <filewrite+0xe7>
+        panic("short filewrite");
+80101160:	83 ec 0c             	sub    $0xc,%esp
+80101163:	68 6f 75 10 80       	push   $0x8010756f
+80101168:	e8 23 f2 ff ff       	call   80100390 <panic>
+8010116d:	8d 76 00             	lea    0x0(%esi),%esi
+    }
+    return i == n ? n : -1;
+80101170:	89 f8                	mov    %edi,%eax
+80101172:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
+80101175:	74 05                	je     8010117c <filewrite+0xec>
+80101177:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  }
+  panic("filewrite");
+}
+8010117c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+8010117f:	5b                   	pop    %ebx
+80101180:	5e                   	pop    %esi
+80101181:	5f                   	pop    %edi
+80101182:	5d                   	pop    %ebp
+80101183:	c3                   	ret    
+    return pipewrite(f->pipe, addr, n);
+80101184:	8b 46 0c             	mov    0xc(%esi),%eax
+80101187:	89 45 08             	mov    %eax,0x8(%ebp)
+}
+8010118a:	8d 65 f4             	lea    -0xc(%ebp),%esp
+8010118d:	5b                   	pop    %ebx
+8010118e:	5e                   	pop    %esi
+8010118f:	5f                   	pop    %edi
+80101190:	5d                   	pop    %ebp
+    return pipewrite(f->pipe, addr, n);
+80101191:	e9 0a 24 00 00       	jmp    801035a0 <pipewrite>
+  panic("filewrite");
+80101196:	83 ec 0c             	sub    $0xc,%esp
+80101199:	68 75 75 10 80       	push   $0x80107575
+8010119e:	e8 ed f1 ff ff       	call   80100390 <panic>
+801011a3:	66 90                	xchg   %ax,%ax
+801011a5:	66 90                	xchg   %ax,%ax
+801011a7:	66 90                	xchg   %ax,%ax
+801011a9:	66 90                	xchg   %ax,%ax
+801011ab:	66 90                	xchg   %ax,%ax
+801011ad:	66 90                	xchg   %ax,%ax
+801011af:	90                   	nop
+
+801011b0 <bfree>:
+}
+
+// Free a disk block.
+static void
+bfree(int dev, uint b)
+{
+801011b0:	55                   	push   %ebp
+801011b1:	89 c1                	mov    %eax,%ecx
+  struct buf *bp;
+  int bi, m;
+
+  bp = bread(dev, BBLOCK(b, sb));
+801011b3:	89 d0                	mov    %edx,%eax
+801011b5:	c1 e8 0c             	shr    $0xc,%eax
+801011b8:	03 05 d8 09 11 80    	add    0x801109d8,%eax
+{
+801011be:	89 e5                	mov    %esp,%ebp
+801011c0:	56                   	push   %esi
+801011c1:	53                   	push   %ebx
+801011c2:	89 d3                	mov    %edx,%ebx
+  bp = bread(dev, BBLOCK(b, sb));
+801011c4:	83 ec 08             	sub    $0x8,%esp
+801011c7:	50                   	push   %eax
+801011c8:	51                   	push   %ecx
+801011c9:	e8 02 ef ff ff       	call   801000d0 <bread>
+  bi = b % BPB;
+  m = 1 << (bi % 8);
+801011ce:	89 d9                	mov    %ebx,%ecx
+  if((bp->data[bi/8] & m) == 0)
+801011d0:	c1 fb 03             	sar    $0x3,%ebx
+  m = 1 << (bi % 8);
+801011d3:	ba 01 00 00 00       	mov    $0x1,%edx
+801011d8:	83 e1 07             	and    $0x7,%ecx
+  if((bp->data[bi/8] & m) == 0)
+801011db:	81 e3 ff 01 00 00    	and    $0x1ff,%ebx
+801011e1:	83 c4 10             	add    $0x10,%esp
+  m = 1 << (bi % 8);
+801011e4:	d3 e2                	shl    %cl,%edx
+  if((bp->data[bi/8] & m) == 0)
+801011e6:	0f b6 4c 18 5c       	movzbl 0x5c(%eax,%ebx,1),%ecx
+801011eb:	85 d1                	test   %edx,%ecx
+801011ed:	74 25                	je     80101214 <bfree+0x64>
+    panic("freeing free block");
+  bp->data[bi/8] &= ~m;
+801011ef:	f7 d2                	not    %edx
+  log_write(bp);
+801011f1:	83 ec 0c             	sub    $0xc,%esp
+801011f4:	89 c6                	mov    %eax,%esi
+  bp->data[bi/8] &= ~m;
+801011f6:	21 ca                	and    %ecx,%edx
+801011f8:	88 54 18 5c          	mov    %dl,0x5c(%eax,%ebx,1)
+  log_write(bp);
+801011fc:	50                   	push   %eax
+801011fd:	e8 0e 1d 00 00       	call   80102f10 <log_write>
+  brelse(bp);
+80101202:	89 34 24             	mov    %esi,(%esp)
+80101205:	e8 e6 ef ff ff       	call   801001f0 <brelse>
+}
+8010120a:	83 c4 10             	add    $0x10,%esp
+8010120d:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80101210:	5b                   	pop    %ebx
+80101211:	5e                   	pop    %esi
+80101212:	5d                   	pop    %ebp
+80101213:	c3                   	ret    
+    panic("freeing free block");
+80101214:	83 ec 0c             	sub    $0xc,%esp
+80101217:	68 7f 75 10 80       	push   $0x8010757f
+8010121c:	e8 6f f1 ff ff       	call   80100390 <panic>
+80101221:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101228:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010122f:	90                   	nop
+
+80101230 <balloc>:
+{
+80101230:	55                   	push   %ebp
+80101231:	89 e5                	mov    %esp,%ebp
+80101233:	57                   	push   %edi
+80101234:	56                   	push   %esi
+80101235:	53                   	push   %ebx
+80101236:	83 ec 1c             	sub    $0x1c,%esp
+  for(b = 0; b < sb.size; b += BPB){
+80101239:	8b 0d c0 09 11 80    	mov    0x801109c0,%ecx
+{
+8010123f:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  for(b = 0; b < sb.size; b += BPB){
+80101242:	85 c9                	test   %ecx,%ecx
+80101244:	0f 84 87 00 00 00    	je     801012d1 <balloc+0xa1>
+8010124a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+    bp = bread(dev, BBLOCK(b, sb));
+80101251:	8b 75 dc             	mov    -0x24(%ebp),%esi
+80101254:	83 ec 08             	sub    $0x8,%esp
+80101257:	89 f0                	mov    %esi,%eax
+80101259:	c1 f8 0c             	sar    $0xc,%eax
+8010125c:	03 05 d8 09 11 80    	add    0x801109d8,%eax
+80101262:	50                   	push   %eax
+80101263:	ff 75 d8             	pushl  -0x28(%ebp)
+80101266:	e8 65 ee ff ff       	call   801000d0 <bread>
+8010126b:	83 c4 10             	add    $0x10,%esp
+8010126e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+80101271:	a1 c0 09 11 80       	mov    0x801109c0,%eax
+80101276:	89 45 e0             	mov    %eax,-0x20(%ebp)
+80101279:	31 c0                	xor    %eax,%eax
+8010127b:	eb 2f                	jmp    801012ac <balloc+0x7c>
+8010127d:	8d 76 00             	lea    0x0(%esi),%esi
+      m = 1 << (bi % 8);
+80101280:	89 c1                	mov    %eax,%ecx
+80101282:	bb 01 00 00 00       	mov    $0x1,%ebx
+      if((bp->data[bi/8] & m) == 0){  // Is block free?
+80101287:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+      m = 1 << (bi % 8);
+8010128a:	83 e1 07             	and    $0x7,%ecx
+8010128d:	d3 e3                	shl    %cl,%ebx
+      if((bp->data[bi/8] & m) == 0){  // Is block free?
+8010128f:	89 c1                	mov    %eax,%ecx
+80101291:	c1 f9 03             	sar    $0x3,%ecx
+80101294:	0f b6 7c 0a 5c       	movzbl 0x5c(%edx,%ecx,1),%edi
+80101299:	89 fa                	mov    %edi,%edx
+8010129b:	85 df                	test   %ebx,%edi
+8010129d:	74 41                	je     801012e0 <balloc+0xb0>
+    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+8010129f:	83 c0 01             	add    $0x1,%eax
+801012a2:	83 c6 01             	add    $0x1,%esi
+801012a5:	3d 00 10 00 00       	cmp    $0x1000,%eax
+801012aa:	74 05                	je     801012b1 <balloc+0x81>
+801012ac:	39 75 e0             	cmp    %esi,-0x20(%ebp)
+801012af:	77 cf                	ja     80101280 <balloc+0x50>
+    brelse(bp);
+801012b1:	83 ec 0c             	sub    $0xc,%esp
+801012b4:	ff 75 e4             	pushl  -0x1c(%ebp)
+801012b7:	e8 34 ef ff ff       	call   801001f0 <brelse>
+  for(b = 0; b < sb.size; b += BPB){
+801012bc:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
+801012c3:	83 c4 10             	add    $0x10,%esp
+801012c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
+801012c9:	39 05 c0 09 11 80    	cmp    %eax,0x801109c0
+801012cf:	77 80                	ja     80101251 <balloc+0x21>
+  panic("balloc: out of blocks");
+801012d1:	83 ec 0c             	sub    $0xc,%esp
+801012d4:	68 92 75 10 80       	push   $0x80107592
+801012d9:	e8 b2 f0 ff ff       	call   80100390 <panic>
+801012de:	66 90                	xchg   %ax,%ax
+        bp->data[bi/8] |= m;  // Mark block in use.
+801012e0:	8b 7d e4             	mov    -0x1c(%ebp),%edi
+        log_write(bp);
+801012e3:	83 ec 0c             	sub    $0xc,%esp
+        bp->data[bi/8] |= m;  // Mark block in use.
+801012e6:	09 da                	or     %ebx,%edx
+801012e8:	88 54 0f 5c          	mov    %dl,0x5c(%edi,%ecx,1)
+        log_write(bp);
+801012ec:	57                   	push   %edi
+801012ed:	e8 1e 1c 00 00       	call   80102f10 <log_write>
+        brelse(bp);
+801012f2:	89 3c 24             	mov    %edi,(%esp)
+801012f5:	e8 f6 ee ff ff       	call   801001f0 <brelse>
+  bp = bread(dev, bno);
+801012fa:	58                   	pop    %eax
+801012fb:	5a                   	pop    %edx
+801012fc:	56                   	push   %esi
+801012fd:	ff 75 d8             	pushl  -0x28(%ebp)
+80101300:	e8 cb ed ff ff       	call   801000d0 <bread>
+  memset(bp->data, 0, BSIZE);
+80101305:	83 c4 0c             	add    $0xc,%esp
+  bp = bread(dev, bno);
+80101308:	89 c3                	mov    %eax,%ebx
+  memset(bp->data, 0, BSIZE);
+8010130a:	8d 40 5c             	lea    0x5c(%eax),%eax
+8010130d:	68 00 02 00 00       	push   $0x200
+80101312:	6a 00                	push   $0x0
+80101314:	50                   	push   %eax
+80101315:	e8 d6 35 00 00       	call   801048f0 <memset>
+  log_write(bp);
+8010131a:	89 1c 24             	mov    %ebx,(%esp)
+8010131d:	e8 ee 1b 00 00       	call   80102f10 <log_write>
+  brelse(bp);
+80101322:	89 1c 24             	mov    %ebx,(%esp)
+80101325:	e8 c6 ee ff ff       	call   801001f0 <brelse>
+}
+8010132a:	8d 65 f4             	lea    -0xc(%ebp),%esp
+8010132d:	89 f0                	mov    %esi,%eax
+8010132f:	5b                   	pop    %ebx
+80101330:	5e                   	pop    %esi
+80101331:	5f                   	pop    %edi
+80101332:	5d                   	pop    %ebp
+80101333:	c3                   	ret    
+80101334:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010133b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010133f:	90                   	nop
+
+80101340 <iget>:
+// Find the inode with number inum on device dev
+// and return the in-memory copy. Does not lock
+// the inode and does not read it from disk.
+static struct inode*
+iget(uint dev, uint inum)
+{
+80101340:	55                   	push   %ebp
+80101341:	89 e5                	mov    %esp,%ebp
+80101343:	57                   	push   %edi
+80101344:	89 c7                	mov    %eax,%edi
+80101346:	56                   	push   %esi
+  struct inode *ip, *empty;
+
+  acquire(&icache.lock);
+
+  // Is the inode already cached?
+  empty = 0;
+80101347:	31 f6                	xor    %esi,%esi
+{
+80101349:	53                   	push   %ebx
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+8010134a:	bb 14 0a 11 80       	mov    $0x80110a14,%ebx
+{
+8010134f:	83 ec 28             	sub    $0x28,%esp
+80101352:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  acquire(&icache.lock);
+80101355:	68 e0 09 11 80       	push   $0x801109e0
+8010135a:	e8 81 34 00 00       	call   801047e0 <acquire>
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+8010135f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  acquire(&icache.lock);
+80101362:	83 c4 10             	add    $0x10,%esp
+80101365:	eb 1b                	jmp    80101382 <iget+0x42>
+80101367:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010136e:	66 90                	xchg   %ax,%ax
+    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+80101370:	39 3b                	cmp    %edi,(%ebx)
+80101372:	74 6c                	je     801013e0 <iget+0xa0>
+80101374:	81 c3 90 00 00 00    	add    $0x90,%ebx
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+8010137a:	81 fb 34 26 11 80    	cmp    $0x80112634,%ebx
+80101380:	73 26                	jae    801013a8 <iget+0x68>
+    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+80101382:	8b 4b 08             	mov    0x8(%ebx),%ecx
+80101385:	85 c9                	test   %ecx,%ecx
+80101387:	7f e7                	jg     80101370 <iget+0x30>
+      ip->ref++;
+      release(&icache.lock);
+      return ip;
+    }
+    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+80101389:	85 f6                	test   %esi,%esi
+8010138b:	75 e7                	jne    80101374 <iget+0x34>
+8010138d:	89 d8                	mov    %ebx,%eax
+8010138f:	81 c3 90 00 00 00    	add    $0x90,%ebx
+80101395:	85 c9                	test   %ecx,%ecx
+80101397:	75 6e                	jne    80101407 <iget+0xc7>
+80101399:	89 c6                	mov    %eax,%esi
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+8010139b:	81 fb 34 26 11 80    	cmp    $0x80112634,%ebx
+801013a1:	72 df                	jb     80101382 <iget+0x42>
+801013a3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801013a7:	90                   	nop
+      empty = ip;
+  }
+
+  // Recycle an inode cache entry.
+  if(empty == 0)
+801013a8:	85 f6                	test   %esi,%esi
+801013aa:	74 73                	je     8010141f <iget+0xdf>
+  ip = empty;
+  ip->dev = dev;
+  ip->inum = inum;
+  ip->ref = 1;
+  ip->valid = 0;
+  release(&icache.lock);
+801013ac:	83 ec 0c             	sub    $0xc,%esp
+  ip->dev = dev;
+801013af:	89 3e                	mov    %edi,(%esi)
+  ip->inum = inum;
+801013b1:	89 56 04             	mov    %edx,0x4(%esi)
+  ip->ref = 1;
+801013b4:	c7 46 08 01 00 00 00 	movl   $0x1,0x8(%esi)
+  ip->valid = 0;
+801013bb:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
+  release(&icache.lock);
+801013c2:	68 e0 09 11 80       	push   $0x801109e0
+801013c7:	e8 d4 34 00 00       	call   801048a0 <release>
+
+  return ip;
+801013cc:	83 c4 10             	add    $0x10,%esp
+}
+801013cf:	8d 65 f4             	lea    -0xc(%ebp),%esp
+801013d2:	89 f0                	mov    %esi,%eax
+801013d4:	5b                   	pop    %ebx
+801013d5:	5e                   	pop    %esi
+801013d6:	5f                   	pop    %edi
+801013d7:	5d                   	pop    %ebp
+801013d8:	c3                   	ret    
+801013d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+801013e0:	39 53 04             	cmp    %edx,0x4(%ebx)
+801013e3:	75 8f                	jne    80101374 <iget+0x34>
+      release(&icache.lock);
+801013e5:	83 ec 0c             	sub    $0xc,%esp
+      ip->ref++;
+801013e8:	83 c1 01             	add    $0x1,%ecx
+      return ip;
+801013eb:	89 de                	mov    %ebx,%esi
+      release(&icache.lock);
+801013ed:	68 e0 09 11 80       	push   $0x801109e0
+      ip->ref++;
+801013f2:	89 4b 08             	mov    %ecx,0x8(%ebx)
+      release(&icache.lock);
+801013f5:	e8 a6 34 00 00       	call   801048a0 <release>
+      return ip;
+801013fa:	83 c4 10             	add    $0x10,%esp
+}
+801013fd:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80101400:	89 f0                	mov    %esi,%eax
+80101402:	5b                   	pop    %ebx
+80101403:	5e                   	pop    %esi
+80101404:	5f                   	pop    %edi
+80101405:	5d                   	pop    %ebp
+80101406:	c3                   	ret    
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+80101407:	81 fb 34 26 11 80    	cmp    $0x80112634,%ebx
+8010140d:	73 10                	jae    8010141f <iget+0xdf>
+    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+8010140f:	8b 4b 08             	mov    0x8(%ebx),%ecx
+80101412:	85 c9                	test   %ecx,%ecx
+80101414:	0f 8f 56 ff ff ff    	jg     80101370 <iget+0x30>
+8010141a:	e9 6e ff ff ff       	jmp    8010138d <iget+0x4d>
+    panic("iget: no inodes");
+8010141f:	83 ec 0c             	sub    $0xc,%esp
+80101422:	68 a8 75 10 80       	push   $0x801075a8
+80101427:	e8 64 ef ff ff       	call   80100390 <panic>
+8010142c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80101430 <bmap>:
+
+// Return the disk block address of the nth block in inode ip.
+// If there is no such block, bmap allocates one.
+static uint
+bmap(struct inode *ip, uint bn)
+{
+80101430:	55                   	push   %ebp
+80101431:	89 e5                	mov    %esp,%ebp
+80101433:	57                   	push   %edi
+80101434:	56                   	push   %esi
+80101435:	89 c6                	mov    %eax,%esi
+80101437:	53                   	push   %ebx
+80101438:	83 ec 1c             	sub    $0x1c,%esp
+  uint addr, *a;
+  struct buf *bp;
+
+  if(bn < NDIRECT){
+8010143b:	83 fa 0b             	cmp    $0xb,%edx
+8010143e:	0f 86 84 00 00 00    	jbe    801014c8 <bmap+0x98>
+    if((addr = ip->addrs[bn]) == 0)
+      ip->addrs[bn] = addr = balloc(ip->dev);
+    return addr;
+  }
+  bn -= NDIRECT;
+80101444:	8d 5a f4             	lea    -0xc(%edx),%ebx
+
+  if(bn < NINDIRECT){
+80101447:	83 fb 7f             	cmp    $0x7f,%ebx
+8010144a:	0f 87 98 00 00 00    	ja     801014e8 <bmap+0xb8>
+    // Load indirect block, allocating if necessary.
+    if((addr = ip->addrs[NDIRECT]) == 0)
+80101450:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
+80101456:	8b 16                	mov    (%esi),%edx
+80101458:	85 c0                	test   %eax,%eax
+8010145a:	74 54                	je     801014b0 <bmap+0x80>
+      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+    bp = bread(ip->dev, addr);
+8010145c:	83 ec 08             	sub    $0x8,%esp
+8010145f:	50                   	push   %eax
+80101460:	52                   	push   %edx
+80101461:	e8 6a ec ff ff       	call   801000d0 <bread>
+    a = (uint*)bp->data;
+    if((addr = a[bn]) == 0){
+80101466:	83 c4 10             	add    $0x10,%esp
+80101469:	8d 54 98 5c          	lea    0x5c(%eax,%ebx,4),%edx
+    bp = bread(ip->dev, addr);
+8010146d:	89 c7                	mov    %eax,%edi
+    if((addr = a[bn]) == 0){
+8010146f:	8b 1a                	mov    (%edx),%ebx
+80101471:	85 db                	test   %ebx,%ebx
+80101473:	74 1b                	je     80101490 <bmap+0x60>
+      a[bn] = addr = balloc(ip->dev);
+      log_write(bp);
+    }
+    brelse(bp);
+80101475:	83 ec 0c             	sub    $0xc,%esp
+80101478:	57                   	push   %edi
+80101479:	e8 72 ed ff ff       	call   801001f0 <brelse>
+    return addr;
+8010147e:	83 c4 10             	add    $0x10,%esp
+  }
+
+  panic("bmap: out of range");
+}
+80101481:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80101484:	89 d8                	mov    %ebx,%eax
+80101486:	5b                   	pop    %ebx
+80101487:	5e                   	pop    %esi
+80101488:	5f                   	pop    %edi
+80101489:	5d                   	pop    %ebp
+8010148a:	c3                   	ret    
+8010148b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010148f:	90                   	nop
+      a[bn] = addr = balloc(ip->dev);
+80101490:	8b 06                	mov    (%esi),%eax
+80101492:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+80101495:	e8 96 fd ff ff       	call   80101230 <balloc>
+8010149a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+      log_write(bp);
+8010149d:	83 ec 0c             	sub    $0xc,%esp
+      a[bn] = addr = balloc(ip->dev);
+801014a0:	89 c3                	mov    %eax,%ebx
+801014a2:	89 02                	mov    %eax,(%edx)
+      log_write(bp);
+801014a4:	57                   	push   %edi
+801014a5:	e8 66 1a 00 00       	call   80102f10 <log_write>
+801014aa:	83 c4 10             	add    $0x10,%esp
+801014ad:	eb c6                	jmp    80101475 <bmap+0x45>
+801014af:	90                   	nop
+      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+801014b0:	89 d0                	mov    %edx,%eax
+801014b2:	e8 79 fd ff ff       	call   80101230 <balloc>
+801014b7:	8b 16                	mov    (%esi),%edx
+801014b9:	89 86 8c 00 00 00    	mov    %eax,0x8c(%esi)
+801014bf:	eb 9b                	jmp    8010145c <bmap+0x2c>
+801014c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    if((addr = ip->addrs[bn]) == 0)
+801014c8:	8d 3c 90             	lea    (%eax,%edx,4),%edi
+801014cb:	8b 5f 5c             	mov    0x5c(%edi),%ebx
+801014ce:	85 db                	test   %ebx,%ebx
+801014d0:	75 af                	jne    80101481 <bmap+0x51>
+      ip->addrs[bn] = addr = balloc(ip->dev);
+801014d2:	8b 00                	mov    (%eax),%eax
+801014d4:	e8 57 fd ff ff       	call   80101230 <balloc>
+801014d9:	89 47 5c             	mov    %eax,0x5c(%edi)
+801014dc:	89 c3                	mov    %eax,%ebx
+}
+801014de:	8d 65 f4             	lea    -0xc(%ebp),%esp
+801014e1:	89 d8                	mov    %ebx,%eax
+801014e3:	5b                   	pop    %ebx
+801014e4:	5e                   	pop    %esi
+801014e5:	5f                   	pop    %edi
+801014e6:	5d                   	pop    %ebp
+801014e7:	c3                   	ret    
+  panic("bmap: out of range");
+801014e8:	83 ec 0c             	sub    $0xc,%esp
+801014eb:	68 b8 75 10 80       	push   $0x801075b8
+801014f0:	e8 9b ee ff ff       	call   80100390 <panic>
+801014f5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801014fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80101500 <readsb>:
+{
+80101500:	f3 0f 1e fb          	endbr32 
+80101504:	55                   	push   %ebp
+80101505:	89 e5                	mov    %esp,%ebp
+80101507:	56                   	push   %esi
+80101508:	53                   	push   %ebx
+80101509:	8b 75 0c             	mov    0xc(%ebp),%esi
+  bp = bread(dev, 1);
+8010150c:	83 ec 08             	sub    $0x8,%esp
+8010150f:	6a 01                	push   $0x1
+80101511:	ff 75 08             	pushl  0x8(%ebp)
+80101514:	e8 b7 eb ff ff       	call   801000d0 <bread>
+  memmove(sb, bp->data, sizeof(*sb));
+80101519:	83 c4 0c             	add    $0xc,%esp
+  bp = bread(dev, 1);
+8010151c:	89 c3                	mov    %eax,%ebx
+  memmove(sb, bp->data, sizeof(*sb));
+8010151e:	8d 40 5c             	lea    0x5c(%eax),%eax
+80101521:	6a 1c                	push   $0x1c
+80101523:	50                   	push   %eax
+80101524:	56                   	push   %esi
+80101525:	e8 66 34 00 00       	call   80104990 <memmove>
+  brelse(bp);
+8010152a:	89 5d 08             	mov    %ebx,0x8(%ebp)
+8010152d:	83 c4 10             	add    $0x10,%esp
+}
+80101530:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80101533:	5b                   	pop    %ebx
+80101534:	5e                   	pop    %esi
+80101535:	5d                   	pop    %ebp
+  brelse(bp);
+80101536:	e9 b5 ec ff ff       	jmp    801001f0 <brelse>
+8010153b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010153f:	90                   	nop
+
+80101540 <iinit>:
+{
+80101540:	f3 0f 1e fb          	endbr32 
+80101544:	55                   	push   %ebp
+80101545:	89 e5                	mov    %esp,%ebp
+80101547:	53                   	push   %ebx
+80101548:	bb 20 0a 11 80       	mov    $0x80110a20,%ebx
+8010154d:	83 ec 0c             	sub    $0xc,%esp
+  initlock(&icache.lock, "icache");
+80101550:	68 cb 75 10 80       	push   $0x801075cb
+80101555:	68 e0 09 11 80       	push   $0x801109e0
+8010155a:	e8 01 31 00 00       	call   80104660 <initlock>
+  for(i = 0; i < NINODE; i++) {
+8010155f:	83 c4 10             	add    $0x10,%esp
+80101562:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    initsleeplock(&icache.inode[i].lock, "inode");
+80101568:	83 ec 08             	sub    $0x8,%esp
+8010156b:	68 d2 75 10 80       	push   $0x801075d2
+80101570:	53                   	push   %ebx
+80101571:	81 c3 90 00 00 00    	add    $0x90,%ebx
+80101577:	e8 a4 2f 00 00       	call   80104520 <initsleeplock>
+  for(i = 0; i < NINODE; i++) {
+8010157c:	83 c4 10             	add    $0x10,%esp
+8010157f:	81 fb 40 26 11 80    	cmp    $0x80112640,%ebx
+80101585:	75 e1                	jne    80101568 <iinit+0x28>
+  readsb(dev, &sb);
+80101587:	83 ec 08             	sub    $0x8,%esp
+8010158a:	68 c0 09 11 80       	push   $0x801109c0
+8010158f:	ff 75 08             	pushl  0x8(%ebp)
+80101592:	e8 69 ff ff ff       	call   80101500 <readsb>
+  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
+80101597:	ff 35 d8 09 11 80    	pushl  0x801109d8
+8010159d:	ff 35 d4 09 11 80    	pushl  0x801109d4
+801015a3:	ff 35 d0 09 11 80    	pushl  0x801109d0
+801015a9:	ff 35 cc 09 11 80    	pushl  0x801109cc
+801015af:	ff 35 c8 09 11 80    	pushl  0x801109c8
+801015b5:	ff 35 c4 09 11 80    	pushl  0x801109c4
+801015bb:	ff 35 c0 09 11 80    	pushl  0x801109c0
+801015c1:	68 38 76 10 80       	push   $0x80107638
+801015c6:	e8 e5 f0 ff ff       	call   801006b0 <cprintf>
+}
+801015cb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+801015ce:	83 c4 30             	add    $0x30,%esp
+801015d1:	c9                   	leave  
+801015d2:	c3                   	ret    
+801015d3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801015da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+801015e0 <ialloc>:
+{
+801015e0:	f3 0f 1e fb          	endbr32 
+801015e4:	55                   	push   %ebp
+801015e5:	89 e5                	mov    %esp,%ebp
+801015e7:	57                   	push   %edi
+801015e8:	56                   	push   %esi
+801015e9:	53                   	push   %ebx
+801015ea:	83 ec 1c             	sub    $0x1c,%esp
+801015ed:	8b 45 0c             	mov    0xc(%ebp),%eax
+  for(inum = 1; inum < sb.ninodes; inum++){
+801015f0:	83 3d c8 09 11 80 01 	cmpl   $0x1,0x801109c8
+{
+801015f7:	8b 75 08             	mov    0x8(%ebp),%esi
+801015fa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  for(inum = 1; inum < sb.ninodes; inum++){
+801015fd:	0f 86 8d 00 00 00    	jbe    80101690 <ialloc+0xb0>
+80101603:	bf 01 00 00 00       	mov    $0x1,%edi
+80101608:	eb 1d                	jmp    80101627 <ialloc+0x47>
+8010160a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    brelse(bp);
+80101610:	83 ec 0c             	sub    $0xc,%esp
+  for(inum = 1; inum < sb.ninodes; inum++){
+80101613:	83 c7 01             	add    $0x1,%edi
+    brelse(bp);
+80101616:	53                   	push   %ebx
+80101617:	e8 d4 eb ff ff       	call   801001f0 <brelse>
+  for(inum = 1; inum < sb.ninodes; inum++){
+8010161c:	83 c4 10             	add    $0x10,%esp
+8010161f:	3b 3d c8 09 11 80    	cmp    0x801109c8,%edi
+80101625:	73 69                	jae    80101690 <ialloc+0xb0>
+    bp = bread(dev, IBLOCK(inum, sb));
+80101627:	89 f8                	mov    %edi,%eax
+80101629:	83 ec 08             	sub    $0x8,%esp
+8010162c:	c1 e8 03             	shr    $0x3,%eax
+8010162f:	03 05 d4 09 11 80    	add    0x801109d4,%eax
+80101635:	50                   	push   %eax
+80101636:	56                   	push   %esi
+80101637:	e8 94 ea ff ff       	call   801000d0 <bread>
+    if(dip->type == 0){  // a free inode
+8010163c:	83 c4 10             	add    $0x10,%esp
+    bp = bread(dev, IBLOCK(inum, sb));
+8010163f:	89 c3                	mov    %eax,%ebx
+    dip = (struct dinode*)bp->data + inum%IPB;
+80101641:	89 f8                	mov    %edi,%eax
+80101643:	83 e0 07             	and    $0x7,%eax
+80101646:	c1 e0 06             	shl    $0x6,%eax
+80101649:	8d 4c 03 5c          	lea    0x5c(%ebx,%eax,1),%ecx
+    if(dip->type == 0){  // a free inode
+8010164d:	66 83 39 00          	cmpw   $0x0,(%ecx)
+80101651:	75 bd                	jne    80101610 <ialloc+0x30>
+      memset(dip, 0, sizeof(*dip));
+80101653:	83 ec 04             	sub    $0x4,%esp
+80101656:	89 4d e0             	mov    %ecx,-0x20(%ebp)
+80101659:	6a 40                	push   $0x40
+8010165b:	6a 00                	push   $0x0
+8010165d:	51                   	push   %ecx
+8010165e:	e8 8d 32 00 00       	call   801048f0 <memset>
+      dip->type = type;
+80101663:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
+80101667:	8b 4d e0             	mov    -0x20(%ebp),%ecx
+8010166a:	66 89 01             	mov    %ax,(%ecx)
+      log_write(bp);   // mark it allocated on the disk
+8010166d:	89 1c 24             	mov    %ebx,(%esp)
+80101670:	e8 9b 18 00 00       	call   80102f10 <log_write>
+      brelse(bp);
+80101675:	89 1c 24             	mov    %ebx,(%esp)
+80101678:	e8 73 eb ff ff       	call   801001f0 <brelse>
+      return iget(dev, inum);
+8010167d:	83 c4 10             	add    $0x10,%esp
+}
+80101680:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return iget(dev, inum);
+80101683:	89 fa                	mov    %edi,%edx
+}
+80101685:	5b                   	pop    %ebx
+      return iget(dev, inum);
+80101686:	89 f0                	mov    %esi,%eax
+}
+80101688:	5e                   	pop    %esi
+80101689:	5f                   	pop    %edi
+8010168a:	5d                   	pop    %ebp
+      return iget(dev, inum);
+8010168b:	e9 b0 fc ff ff       	jmp    80101340 <iget>
+  panic("ialloc: no inodes");
+80101690:	83 ec 0c             	sub    $0xc,%esp
+80101693:	68 d8 75 10 80       	push   $0x801075d8
+80101698:	e8 f3 ec ff ff       	call   80100390 <panic>
+8010169d:	8d 76 00             	lea    0x0(%esi),%esi
+
+801016a0 <iupdate>:
+{
+801016a0:	f3 0f 1e fb          	endbr32 
+801016a4:	55                   	push   %ebp
+801016a5:	89 e5                	mov    %esp,%ebp
+801016a7:	56                   	push   %esi
+801016a8:	53                   	push   %ebx
+801016a9:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+801016ac:	8b 43 04             	mov    0x4(%ebx),%eax
+  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+801016af:	83 c3 5c             	add    $0x5c,%ebx
+  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+801016b2:	83 ec 08             	sub    $0x8,%esp
+801016b5:	c1 e8 03             	shr    $0x3,%eax
+801016b8:	03 05 d4 09 11 80    	add    0x801109d4,%eax
+801016be:	50                   	push   %eax
+801016bf:	ff 73 a4             	pushl  -0x5c(%ebx)
+801016c2:	e8 09 ea ff ff       	call   801000d0 <bread>
+  dip->type = ip->type;
+801016c7:	0f b7 53 f4          	movzwl -0xc(%ebx),%edx
+  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+801016cb:	83 c4 0c             	add    $0xc,%esp
+  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+801016ce:	89 c6                	mov    %eax,%esi
+  dip = (struct dinode*)bp->data + ip->inum%IPB;
+801016d0:	8b 43 a8             	mov    -0x58(%ebx),%eax
+801016d3:	83 e0 07             	and    $0x7,%eax
+801016d6:	c1 e0 06             	shl    $0x6,%eax
+801016d9:	8d 44 06 5c          	lea    0x5c(%esi,%eax,1),%eax
+  dip->type = ip->type;
+801016dd:	66 89 10             	mov    %dx,(%eax)
+  dip->major = ip->major;
+801016e0:	0f b7 53 f6          	movzwl -0xa(%ebx),%edx
+  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+801016e4:	83 c0 0c             	add    $0xc,%eax
+  dip->major = ip->major;
+801016e7:	66 89 50 f6          	mov    %dx,-0xa(%eax)
+  dip->minor = ip->minor;
+801016eb:	0f b7 53 f8          	movzwl -0x8(%ebx),%edx
+801016ef:	66 89 50 f8          	mov    %dx,-0x8(%eax)
+  dip->nlink = ip->nlink;
+801016f3:	0f b7 53 fa          	movzwl -0x6(%ebx),%edx
+801016f7:	66 89 50 fa          	mov    %dx,-0x6(%eax)
+  dip->size = ip->size;
+801016fb:	8b 53 fc             	mov    -0x4(%ebx),%edx
+801016fe:	89 50 fc             	mov    %edx,-0x4(%eax)
+  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+80101701:	6a 34                	push   $0x34
+80101703:	53                   	push   %ebx
+80101704:	50                   	push   %eax
+80101705:	e8 86 32 00 00       	call   80104990 <memmove>
+  log_write(bp);
+8010170a:	89 34 24             	mov    %esi,(%esp)
+8010170d:	e8 fe 17 00 00       	call   80102f10 <log_write>
+  brelse(bp);
+80101712:	89 75 08             	mov    %esi,0x8(%ebp)
+80101715:	83 c4 10             	add    $0x10,%esp
+}
+80101718:	8d 65 f8             	lea    -0x8(%ebp),%esp
+8010171b:	5b                   	pop    %ebx
+8010171c:	5e                   	pop    %esi
+8010171d:	5d                   	pop    %ebp
+  brelse(bp);
+8010171e:	e9 cd ea ff ff       	jmp    801001f0 <brelse>
+80101723:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010172a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80101730 <idup>:
+{
+80101730:	f3 0f 1e fb          	endbr32 
+80101734:	55                   	push   %ebp
+80101735:	89 e5                	mov    %esp,%ebp
+80101737:	53                   	push   %ebx
+80101738:	83 ec 10             	sub    $0x10,%esp
+8010173b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  acquire(&icache.lock);
+8010173e:	68 e0 09 11 80       	push   $0x801109e0
+80101743:	e8 98 30 00 00       	call   801047e0 <acquire>
+  ip->ref++;
+80101748:	83 43 08 01          	addl   $0x1,0x8(%ebx)
+  release(&icache.lock);
+8010174c:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+80101753:	e8 48 31 00 00       	call   801048a0 <release>
+}
+80101758:	89 d8                	mov    %ebx,%eax
+8010175a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+8010175d:	c9                   	leave  
+8010175e:	c3                   	ret    
+8010175f:	90                   	nop
+
+80101760 <ilock>:
+{
+80101760:	f3 0f 1e fb          	endbr32 
+80101764:	55                   	push   %ebp
+80101765:	89 e5                	mov    %esp,%ebp
+80101767:	56                   	push   %esi
+80101768:	53                   	push   %ebx
+80101769:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(ip == 0 || ip->ref < 1)
+8010176c:	85 db                	test   %ebx,%ebx
+8010176e:	0f 84 b3 00 00 00    	je     80101827 <ilock+0xc7>
+80101774:	8b 53 08             	mov    0x8(%ebx),%edx
+80101777:	85 d2                	test   %edx,%edx
+80101779:	0f 8e a8 00 00 00    	jle    80101827 <ilock+0xc7>
+  acquiresleep(&ip->lock);
+8010177f:	83 ec 0c             	sub    $0xc,%esp
+80101782:	8d 43 0c             	lea    0xc(%ebx),%eax
+80101785:	50                   	push   %eax
+80101786:	e8 d5 2d 00 00       	call   80104560 <acquiresleep>
+  if(ip->valid == 0){
+8010178b:	8b 43 4c             	mov    0x4c(%ebx),%eax
+8010178e:	83 c4 10             	add    $0x10,%esp
+80101791:	85 c0                	test   %eax,%eax
+80101793:	74 0b                	je     801017a0 <ilock+0x40>
+}
+80101795:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80101798:	5b                   	pop    %ebx
+80101799:	5e                   	pop    %esi
+8010179a:	5d                   	pop    %ebp
+8010179b:	c3                   	ret    
+8010179c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+801017a0:	8b 43 04             	mov    0x4(%ebx),%eax
+801017a3:	83 ec 08             	sub    $0x8,%esp
+801017a6:	c1 e8 03             	shr    $0x3,%eax
+801017a9:	03 05 d4 09 11 80    	add    0x801109d4,%eax
+801017af:	50                   	push   %eax
+801017b0:	ff 33                	pushl  (%ebx)
+801017b2:	e8 19 e9 ff ff       	call   801000d0 <bread>
+    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+801017b7:	83 c4 0c             	add    $0xc,%esp
+    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+801017ba:	89 c6                	mov    %eax,%esi
+    dip = (struct dinode*)bp->data + ip->inum%IPB;
+801017bc:	8b 43 04             	mov    0x4(%ebx),%eax
+801017bf:	83 e0 07             	and    $0x7,%eax
+801017c2:	c1 e0 06             	shl    $0x6,%eax
+801017c5:	8d 44 06 5c          	lea    0x5c(%esi,%eax,1),%eax
+    ip->type = dip->type;
+801017c9:	0f b7 10             	movzwl (%eax),%edx
+    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+801017cc:	83 c0 0c             	add    $0xc,%eax
+    ip->type = dip->type;
+801017cf:	66 89 53 50          	mov    %dx,0x50(%ebx)
+    ip->major = dip->major;
+801017d3:	0f b7 50 f6          	movzwl -0xa(%eax),%edx
+801017d7:	66 89 53 52          	mov    %dx,0x52(%ebx)
+    ip->minor = dip->minor;
+801017db:	0f b7 50 f8          	movzwl -0x8(%eax),%edx
+801017df:	66 89 53 54          	mov    %dx,0x54(%ebx)
+    ip->nlink = dip->nlink;
+801017e3:	0f b7 50 fa          	movzwl -0x6(%eax),%edx
+801017e7:	66 89 53 56          	mov    %dx,0x56(%ebx)
+    ip->size = dip->size;
+801017eb:	8b 50 fc             	mov    -0x4(%eax),%edx
+801017ee:	89 53 58             	mov    %edx,0x58(%ebx)
+    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+801017f1:	6a 34                	push   $0x34
+801017f3:	50                   	push   %eax
+801017f4:	8d 43 5c             	lea    0x5c(%ebx),%eax
+801017f7:	50                   	push   %eax
+801017f8:	e8 93 31 00 00       	call   80104990 <memmove>
+    brelse(bp);
+801017fd:	89 34 24             	mov    %esi,(%esp)
+80101800:	e8 eb e9 ff ff       	call   801001f0 <brelse>
+    if(ip->type == 0)
+80101805:	83 c4 10             	add    $0x10,%esp
+80101808:	66 83 7b 50 00       	cmpw   $0x0,0x50(%ebx)
+    ip->valid = 1;
+8010180d:	c7 43 4c 01 00 00 00 	movl   $0x1,0x4c(%ebx)
+    if(ip->type == 0)
+80101814:	0f 85 7b ff ff ff    	jne    80101795 <ilock+0x35>
+      panic("ilock: no type");
+8010181a:	83 ec 0c             	sub    $0xc,%esp
+8010181d:	68 f0 75 10 80       	push   $0x801075f0
+80101822:	e8 69 eb ff ff       	call   80100390 <panic>
+    panic("ilock");
+80101827:	83 ec 0c             	sub    $0xc,%esp
+8010182a:	68 ea 75 10 80       	push   $0x801075ea
+8010182f:	e8 5c eb ff ff       	call   80100390 <panic>
+80101834:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010183b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010183f:	90                   	nop
+
+80101840 <iunlock>:
+{
+80101840:	f3 0f 1e fb          	endbr32 
+80101844:	55                   	push   %ebp
+80101845:	89 e5                	mov    %esp,%ebp
+80101847:	56                   	push   %esi
+80101848:	53                   	push   %ebx
+80101849:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+8010184c:	85 db                	test   %ebx,%ebx
+8010184e:	74 28                	je     80101878 <iunlock+0x38>
+80101850:	83 ec 0c             	sub    $0xc,%esp
+80101853:	8d 73 0c             	lea    0xc(%ebx),%esi
+80101856:	56                   	push   %esi
+80101857:	e8 a4 2d 00 00       	call   80104600 <holdingsleep>
+8010185c:	83 c4 10             	add    $0x10,%esp
+8010185f:	85 c0                	test   %eax,%eax
+80101861:	74 15                	je     80101878 <iunlock+0x38>
+80101863:	8b 43 08             	mov    0x8(%ebx),%eax
+80101866:	85 c0                	test   %eax,%eax
+80101868:	7e 0e                	jle    80101878 <iunlock+0x38>
+  releasesleep(&ip->lock);
+8010186a:	89 75 08             	mov    %esi,0x8(%ebp)
+}
+8010186d:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80101870:	5b                   	pop    %ebx
+80101871:	5e                   	pop    %esi
+80101872:	5d                   	pop    %ebp
+  releasesleep(&ip->lock);
+80101873:	e9 48 2d 00 00       	jmp    801045c0 <releasesleep>
+    panic("iunlock");
+80101878:	83 ec 0c             	sub    $0xc,%esp
+8010187b:	68 ff 75 10 80       	push   $0x801075ff
+80101880:	e8 0b eb ff ff       	call   80100390 <panic>
+80101885:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010188c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80101890 <iput>:
+{
+80101890:	f3 0f 1e fb          	endbr32 
+80101894:	55                   	push   %ebp
+80101895:	89 e5                	mov    %esp,%ebp
+80101897:	57                   	push   %edi
+80101898:	56                   	push   %esi
+80101899:	53                   	push   %ebx
+8010189a:	83 ec 28             	sub    $0x28,%esp
+8010189d:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  acquiresleep(&ip->lock);
+801018a0:	8d 7b 0c             	lea    0xc(%ebx),%edi
+801018a3:	57                   	push   %edi
+801018a4:	e8 b7 2c 00 00       	call   80104560 <acquiresleep>
+  if(ip->valid && ip->nlink == 0){
+801018a9:	8b 53 4c             	mov    0x4c(%ebx),%edx
+801018ac:	83 c4 10             	add    $0x10,%esp
+801018af:	85 d2                	test   %edx,%edx
+801018b1:	74 07                	je     801018ba <iput+0x2a>
+801018b3:	66 83 7b 56 00       	cmpw   $0x0,0x56(%ebx)
+801018b8:	74 36                	je     801018f0 <iput+0x60>
+  releasesleep(&ip->lock);
+801018ba:	83 ec 0c             	sub    $0xc,%esp
+801018bd:	57                   	push   %edi
+801018be:	e8 fd 2c 00 00       	call   801045c0 <releasesleep>
+  acquire(&icache.lock);
+801018c3:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+801018ca:	e8 11 2f 00 00       	call   801047e0 <acquire>
+  ip->ref--;
+801018cf:	83 6b 08 01          	subl   $0x1,0x8(%ebx)
+  release(&icache.lock);
+801018d3:	83 c4 10             	add    $0x10,%esp
+801018d6:	c7 45 08 e0 09 11 80 	movl   $0x801109e0,0x8(%ebp)
+}
+801018dd:	8d 65 f4             	lea    -0xc(%ebp),%esp
+801018e0:	5b                   	pop    %ebx
+801018e1:	5e                   	pop    %esi
+801018e2:	5f                   	pop    %edi
+801018e3:	5d                   	pop    %ebp
+  release(&icache.lock);
+801018e4:	e9 b7 2f 00 00       	jmp    801048a0 <release>
+801018e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    acquire(&icache.lock);
+801018f0:	83 ec 0c             	sub    $0xc,%esp
+801018f3:	68 e0 09 11 80       	push   $0x801109e0
+801018f8:	e8 e3 2e 00 00       	call   801047e0 <acquire>
+    int r = ip->ref;
+801018fd:	8b 73 08             	mov    0x8(%ebx),%esi
+    release(&icache.lock);
+80101900:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+80101907:	e8 94 2f 00 00       	call   801048a0 <release>
+    if(r == 1){
+8010190c:	83 c4 10             	add    $0x10,%esp
+8010190f:	83 fe 01             	cmp    $0x1,%esi
+80101912:	75 a6                	jne    801018ba <iput+0x2a>
+80101914:	8d 8b 8c 00 00 00    	lea    0x8c(%ebx),%ecx
+8010191a:	89 7d e4             	mov    %edi,-0x1c(%ebp)
+8010191d:	8d 73 5c             	lea    0x5c(%ebx),%esi
+80101920:	89 cf                	mov    %ecx,%edi
+80101922:	eb 0b                	jmp    8010192f <iput+0x9f>
+80101924:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+{
+  int i, j;
+  struct buf *bp;
+  uint *a;
+
+  for(i = 0; i < NDIRECT; i++){
+80101928:	83 c6 04             	add    $0x4,%esi
+8010192b:	39 fe                	cmp    %edi,%esi
+8010192d:	74 19                	je     80101948 <iput+0xb8>
+    if(ip->addrs[i]){
+8010192f:	8b 16                	mov    (%esi),%edx
+80101931:	85 d2                	test   %edx,%edx
+80101933:	74 f3                	je     80101928 <iput+0x98>
+      bfree(ip->dev, ip->addrs[i]);
+80101935:	8b 03                	mov    (%ebx),%eax
+80101937:	e8 74 f8 ff ff       	call   801011b0 <bfree>
+      ip->addrs[i] = 0;
+8010193c:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
+80101942:	eb e4                	jmp    80101928 <iput+0x98>
+80101944:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+
+  if(ip->addrs[NDIRECT]){
+80101948:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
+8010194e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
+80101951:	85 c0                	test   %eax,%eax
+80101953:	75 33                	jne    80101988 <iput+0xf8>
+    bfree(ip->dev, ip->addrs[NDIRECT]);
+    ip->addrs[NDIRECT] = 0;
+  }
+
+  ip->size = 0;
+  iupdate(ip);
+80101955:	83 ec 0c             	sub    $0xc,%esp
+  ip->size = 0;
+80101958:	c7 43 58 00 00 00 00 	movl   $0x0,0x58(%ebx)
+  iupdate(ip);
+8010195f:	53                   	push   %ebx
+80101960:	e8 3b fd ff ff       	call   801016a0 <iupdate>
+      ip->type = 0;
+80101965:	31 c0                	xor    %eax,%eax
+80101967:	66 89 43 50          	mov    %ax,0x50(%ebx)
+      iupdate(ip);
+8010196b:	89 1c 24             	mov    %ebx,(%esp)
+8010196e:	e8 2d fd ff ff       	call   801016a0 <iupdate>
+      ip->valid = 0;
+80101973:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
+8010197a:	83 c4 10             	add    $0x10,%esp
+8010197d:	e9 38 ff ff ff       	jmp    801018ba <iput+0x2a>
+80101982:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+80101988:	83 ec 08             	sub    $0x8,%esp
+8010198b:	50                   	push   %eax
+8010198c:	ff 33                	pushl  (%ebx)
+8010198e:	e8 3d e7 ff ff       	call   801000d0 <bread>
+80101993:	89 7d e0             	mov    %edi,-0x20(%ebp)
+80101996:	83 c4 10             	add    $0x10,%esp
+80101999:	8d 88 5c 02 00 00    	lea    0x25c(%eax),%ecx
+8010199f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    for(j = 0; j < NINDIRECT; j++){
+801019a2:	8d 70 5c             	lea    0x5c(%eax),%esi
+801019a5:	89 cf                	mov    %ecx,%edi
+801019a7:	eb 0e                	jmp    801019b7 <iput+0x127>
+801019a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801019b0:	83 c6 04             	add    $0x4,%esi
+801019b3:	39 f7                	cmp    %esi,%edi
+801019b5:	74 19                	je     801019d0 <iput+0x140>
+      if(a[j])
+801019b7:	8b 16                	mov    (%esi),%edx
+801019b9:	85 d2                	test   %edx,%edx
+801019bb:	74 f3                	je     801019b0 <iput+0x120>
+        bfree(ip->dev, a[j]);
+801019bd:	8b 03                	mov    (%ebx),%eax
+801019bf:	e8 ec f7 ff ff       	call   801011b0 <bfree>
+801019c4:	eb ea                	jmp    801019b0 <iput+0x120>
+801019c6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801019cd:	8d 76 00             	lea    0x0(%esi),%esi
+    brelse(bp);
+801019d0:	83 ec 0c             	sub    $0xc,%esp
+801019d3:	ff 75 e4             	pushl  -0x1c(%ebp)
+801019d6:	8b 7d e0             	mov    -0x20(%ebp),%edi
+801019d9:	e8 12 e8 ff ff       	call   801001f0 <brelse>
+    bfree(ip->dev, ip->addrs[NDIRECT]);
+801019de:	8b 93 8c 00 00 00    	mov    0x8c(%ebx),%edx
+801019e4:	8b 03                	mov    (%ebx),%eax
+801019e6:	e8 c5 f7 ff ff       	call   801011b0 <bfree>
+    ip->addrs[NDIRECT] = 0;
+801019eb:	83 c4 10             	add    $0x10,%esp
+801019ee:	c7 83 8c 00 00 00 00 	movl   $0x0,0x8c(%ebx)
+801019f5:	00 00 00 
+801019f8:	e9 58 ff ff ff       	jmp    80101955 <iput+0xc5>
+801019fd:	8d 76 00             	lea    0x0(%esi),%esi
+
+80101a00 <iunlockput>:
+{
+80101a00:	f3 0f 1e fb          	endbr32 
+80101a04:	55                   	push   %ebp
+80101a05:	89 e5                	mov    %esp,%ebp
+80101a07:	53                   	push   %ebx
+80101a08:	83 ec 10             	sub    $0x10,%esp
+80101a0b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  iunlock(ip);
+80101a0e:	53                   	push   %ebx
+80101a0f:	e8 2c fe ff ff       	call   80101840 <iunlock>
+  iput(ip);
+80101a14:	89 5d 08             	mov    %ebx,0x8(%ebp)
+80101a17:	83 c4 10             	add    $0x10,%esp
+}
+80101a1a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80101a1d:	c9                   	leave  
+  iput(ip);
+80101a1e:	e9 6d fe ff ff       	jmp    80101890 <iput>
+80101a23:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101a2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80101a30 <stati>:
+
+// Copy stat information from inode.
+// Caller must hold ip->lock.
+void
+stati(struct inode *ip, struct stat *st)
+{
+80101a30:	f3 0f 1e fb          	endbr32 
+80101a34:	55                   	push   %ebp
+80101a35:	89 e5                	mov    %esp,%ebp
+80101a37:	8b 55 08             	mov    0x8(%ebp),%edx
+80101a3a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  st->dev = ip->dev;
+80101a3d:	8b 0a                	mov    (%edx),%ecx
+80101a3f:	89 48 04             	mov    %ecx,0x4(%eax)
+  st->ino = ip->inum;
+80101a42:	8b 4a 04             	mov    0x4(%edx),%ecx
+80101a45:	89 48 08             	mov    %ecx,0x8(%eax)
+  st->type = ip->type;
+80101a48:	0f b7 4a 50          	movzwl 0x50(%edx),%ecx
+80101a4c:	66 89 08             	mov    %cx,(%eax)
+  st->nlink = ip->nlink;
+80101a4f:	0f b7 4a 56          	movzwl 0x56(%edx),%ecx
+80101a53:	66 89 48 0c          	mov    %cx,0xc(%eax)
+  st->size = ip->size;
+80101a57:	8b 52 58             	mov    0x58(%edx),%edx
+80101a5a:	89 50 10             	mov    %edx,0x10(%eax)
+}
+80101a5d:	5d                   	pop    %ebp
+80101a5e:	c3                   	ret    
+80101a5f:	90                   	nop
+
+80101a60 <readi>:
+//PAGEBREAK!
+// Read data from inode.
+// Caller must hold ip->lock.
+int
+readi(struct inode *ip, char *dst, uint off, uint n)
+{
+80101a60:	f3 0f 1e fb          	endbr32 
+80101a64:	55                   	push   %ebp
+80101a65:	89 e5                	mov    %esp,%ebp
+80101a67:	57                   	push   %edi
+80101a68:	56                   	push   %esi
+80101a69:	53                   	push   %ebx
+80101a6a:	83 ec 1c             	sub    $0x1c,%esp
+80101a6d:	8b 7d 0c             	mov    0xc(%ebp),%edi
+80101a70:	8b 45 08             	mov    0x8(%ebp),%eax
+80101a73:	8b 75 10             	mov    0x10(%ebp),%esi
+80101a76:	89 7d e0             	mov    %edi,-0x20(%ebp)
+80101a79:	8b 7d 14             	mov    0x14(%ebp),%edi
+  uint tot, m;
+  struct buf *bp;
+
+  if(ip->type == T_DEV){
+80101a7c:	66 83 78 50 03       	cmpw   $0x3,0x50(%eax)
+{
+80101a81:	89 45 d8             	mov    %eax,-0x28(%ebp)
+80101a84:	89 7d e4             	mov    %edi,-0x1c(%ebp)
+  if(ip->type == T_DEV){
+80101a87:	0f 84 a3 00 00 00    	je     80101b30 <readi+0xd0>
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+      return -1;
+    return devsw[ip->major].read(ip, dst, n);
+  }
+
+  if(off > ip->size || off + n < off)
+80101a8d:	8b 45 d8             	mov    -0x28(%ebp),%eax
+80101a90:	8b 40 58             	mov    0x58(%eax),%eax
+80101a93:	39 c6                	cmp    %eax,%esi
+80101a95:	0f 87 b6 00 00 00    	ja     80101b51 <readi+0xf1>
+80101a9b:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
+80101a9e:	31 c9                	xor    %ecx,%ecx
+80101aa0:	89 da                	mov    %ebx,%edx
+80101aa2:	01 f2                	add    %esi,%edx
+80101aa4:	0f 92 c1             	setb   %cl
+80101aa7:	89 cf                	mov    %ecx,%edi
+80101aa9:	0f 82 a2 00 00 00    	jb     80101b51 <readi+0xf1>
+    return -1;
+  if(off + n > ip->size)
+    n = ip->size - off;
+80101aaf:	89 c1                	mov    %eax,%ecx
+80101ab1:	29 f1                	sub    %esi,%ecx
+80101ab3:	39 d0                	cmp    %edx,%eax
+80101ab5:	0f 43 cb             	cmovae %ebx,%ecx
+80101ab8:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+80101abb:	85 c9                	test   %ecx,%ecx
+80101abd:	74 63                	je     80101b22 <readi+0xc2>
+80101abf:	90                   	nop
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+80101ac0:	8b 5d d8             	mov    -0x28(%ebp),%ebx
+80101ac3:	89 f2                	mov    %esi,%edx
+80101ac5:	c1 ea 09             	shr    $0x9,%edx
+80101ac8:	89 d8                	mov    %ebx,%eax
+80101aca:	e8 61 f9 ff ff       	call   80101430 <bmap>
+80101acf:	83 ec 08             	sub    $0x8,%esp
+80101ad2:	50                   	push   %eax
+80101ad3:	ff 33                	pushl  (%ebx)
+80101ad5:	e8 f6 e5 ff ff       	call   801000d0 <bread>
+    m = min(n - tot, BSIZE - off%BSIZE);
+80101ada:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
+80101add:	b9 00 02 00 00       	mov    $0x200,%ecx
+80101ae2:	83 c4 0c             	add    $0xc,%esp
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+80101ae5:	89 c2                	mov    %eax,%edx
+    m = min(n - tot, BSIZE - off%BSIZE);
+80101ae7:	89 f0                	mov    %esi,%eax
+80101ae9:	25 ff 01 00 00       	and    $0x1ff,%eax
+80101aee:	29 fb                	sub    %edi,%ebx
+    memmove(dst, bp->data + off%BSIZE, m);
+80101af0:	89 55 dc             	mov    %edx,-0x24(%ebp)
+    m = min(n - tot, BSIZE - off%BSIZE);
+80101af3:	29 c1                	sub    %eax,%ecx
+    memmove(dst, bp->data + off%BSIZE, m);
+80101af5:	8d 44 02 5c          	lea    0x5c(%edx,%eax,1),%eax
+    m = min(n - tot, BSIZE - off%BSIZE);
+80101af9:	39 d9                	cmp    %ebx,%ecx
+80101afb:	0f 46 d9             	cmovbe %ecx,%ebx
+    memmove(dst, bp->data + off%BSIZE, m);
+80101afe:	53                   	push   %ebx
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+80101aff:	01 df                	add    %ebx,%edi
+80101b01:	01 de                	add    %ebx,%esi
+    memmove(dst, bp->data + off%BSIZE, m);
+80101b03:	50                   	push   %eax
+80101b04:	ff 75 e0             	pushl  -0x20(%ebp)
+80101b07:	e8 84 2e 00 00       	call   80104990 <memmove>
+    brelse(bp);
+80101b0c:	8b 55 dc             	mov    -0x24(%ebp),%edx
+80101b0f:	89 14 24             	mov    %edx,(%esp)
+80101b12:	e8 d9 e6 ff ff       	call   801001f0 <brelse>
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+80101b17:	01 5d e0             	add    %ebx,-0x20(%ebp)
+80101b1a:	83 c4 10             	add    $0x10,%esp
+80101b1d:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
+80101b20:	77 9e                	ja     80101ac0 <readi+0x60>
+  }
+  return n;
+80101b22:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+}
+80101b25:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80101b28:	5b                   	pop    %ebx
+80101b29:	5e                   	pop    %esi
+80101b2a:	5f                   	pop    %edi
+80101b2b:	5d                   	pop    %ebp
+80101b2c:	c3                   	ret    
+80101b2d:	8d 76 00             	lea    0x0(%esi),%esi
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+80101b30:	0f bf 40 52          	movswl 0x52(%eax),%eax
+80101b34:	66 83 f8 09          	cmp    $0x9,%ax
+80101b38:	77 17                	ja     80101b51 <readi+0xf1>
+80101b3a:	8b 04 c5 60 09 11 80 	mov    -0x7feef6a0(,%eax,8),%eax
+80101b41:	85 c0                	test   %eax,%eax
+80101b43:	74 0c                	je     80101b51 <readi+0xf1>
+    return devsw[ip->major].read(ip, dst, n);
+80101b45:	89 7d 10             	mov    %edi,0x10(%ebp)
+}
+80101b48:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80101b4b:	5b                   	pop    %ebx
+80101b4c:	5e                   	pop    %esi
+80101b4d:	5f                   	pop    %edi
+80101b4e:	5d                   	pop    %ebp
+    return devsw[ip->major].read(ip, dst, n);
+80101b4f:	ff e0                	jmp    *%eax
+      return -1;
+80101b51:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80101b56:	eb cd                	jmp    80101b25 <readi+0xc5>
+80101b58:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101b5f:	90                   	nop
+
+80101b60 <writei>:
+// PAGEBREAK!
+// Write data to inode.
+// Caller must hold ip->lock.
+int
+writei(struct inode *ip, char *src, uint off, uint n)
+{
+80101b60:	f3 0f 1e fb          	endbr32 
+80101b64:	55                   	push   %ebp
+80101b65:	89 e5                	mov    %esp,%ebp
+80101b67:	57                   	push   %edi
+80101b68:	56                   	push   %esi
+80101b69:	53                   	push   %ebx
+80101b6a:	83 ec 1c             	sub    $0x1c,%esp
+80101b6d:	8b 45 08             	mov    0x8(%ebp),%eax
+80101b70:	8b 75 0c             	mov    0xc(%ebp),%esi
+80101b73:	8b 7d 14             	mov    0x14(%ebp),%edi
+  uint tot, m;
+  struct buf *bp;
+
+  if(ip->type == T_DEV){
+80101b76:	66 83 78 50 03       	cmpw   $0x3,0x50(%eax)
+{
+80101b7b:	89 75 dc             	mov    %esi,-0x24(%ebp)
+80101b7e:	89 45 d8             	mov    %eax,-0x28(%ebp)
+80101b81:	8b 75 10             	mov    0x10(%ebp),%esi
+80101b84:	89 7d e0             	mov    %edi,-0x20(%ebp)
+  if(ip->type == T_DEV){
+80101b87:	0f 84 b3 00 00 00    	je     80101c40 <writei+0xe0>
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+      return -1;
+    return devsw[ip->major].write(ip, src, n);
+  }
+
+  if(off > ip->size || off + n < off)
+80101b8d:	8b 45 d8             	mov    -0x28(%ebp),%eax
+80101b90:	39 70 58             	cmp    %esi,0x58(%eax)
+80101b93:	0f 82 e3 00 00 00    	jb     80101c7c <writei+0x11c>
+    return -1;
+  if(off + n > MAXFILE*BSIZE)
+80101b99:	8b 7d e0             	mov    -0x20(%ebp),%edi
+80101b9c:	89 f8                	mov    %edi,%eax
+80101b9e:	01 f0                	add    %esi,%eax
+80101ba0:	0f 82 d6 00 00 00    	jb     80101c7c <writei+0x11c>
+80101ba6:	3d 00 18 01 00       	cmp    $0x11800,%eax
+80101bab:	0f 87 cb 00 00 00    	ja     80101c7c <writei+0x11c>
+    return -1;
+
+  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+80101bb1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+80101bb8:	85 ff                	test   %edi,%edi
+80101bba:	74 75                	je     80101c31 <writei+0xd1>
+80101bbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+80101bc0:	8b 7d d8             	mov    -0x28(%ebp),%edi
+80101bc3:	89 f2                	mov    %esi,%edx
+80101bc5:	c1 ea 09             	shr    $0x9,%edx
+80101bc8:	89 f8                	mov    %edi,%eax
+80101bca:	e8 61 f8 ff ff       	call   80101430 <bmap>
+80101bcf:	83 ec 08             	sub    $0x8,%esp
+80101bd2:	50                   	push   %eax
+80101bd3:	ff 37                	pushl  (%edi)
+80101bd5:	e8 f6 e4 ff ff       	call   801000d0 <bread>
+    m = min(n - tot, BSIZE - off%BSIZE);
+80101bda:	b9 00 02 00 00       	mov    $0x200,%ecx
+80101bdf:	8b 5d e0             	mov    -0x20(%ebp),%ebx
+80101be2:	2b 5d e4             	sub    -0x1c(%ebp),%ebx
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+80101be5:	89 c7                	mov    %eax,%edi
+    m = min(n - tot, BSIZE - off%BSIZE);
+80101be7:	89 f0                	mov    %esi,%eax
+80101be9:	83 c4 0c             	add    $0xc,%esp
+80101bec:	25 ff 01 00 00       	and    $0x1ff,%eax
+80101bf1:	29 c1                	sub    %eax,%ecx
+    memmove(bp->data + off%BSIZE, src, m);
+80101bf3:	8d 44 07 5c          	lea    0x5c(%edi,%eax,1),%eax
+    m = min(n - tot, BSIZE - off%BSIZE);
+80101bf7:	39 d9                	cmp    %ebx,%ecx
+80101bf9:	0f 46 d9             	cmovbe %ecx,%ebx
+    memmove(bp->data + off%BSIZE, src, m);
+80101bfc:	53                   	push   %ebx
+  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+80101bfd:	01 de                	add    %ebx,%esi
+    memmove(bp->data + off%BSIZE, src, m);
+80101bff:	ff 75 dc             	pushl  -0x24(%ebp)
+80101c02:	50                   	push   %eax
+80101c03:	e8 88 2d 00 00       	call   80104990 <memmove>
+    log_write(bp);
+80101c08:	89 3c 24             	mov    %edi,(%esp)
+80101c0b:	e8 00 13 00 00       	call   80102f10 <log_write>
+    brelse(bp);
+80101c10:	89 3c 24             	mov    %edi,(%esp)
+80101c13:	e8 d8 e5 ff ff       	call   801001f0 <brelse>
+  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+80101c18:	01 5d e4             	add    %ebx,-0x1c(%ebp)
+80101c1b:	83 c4 10             	add    $0x10,%esp
+80101c1e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80101c21:	01 5d dc             	add    %ebx,-0x24(%ebp)
+80101c24:	39 45 e0             	cmp    %eax,-0x20(%ebp)
+80101c27:	77 97                	ja     80101bc0 <writei+0x60>
+  }
+
+  if(n > 0 && off > ip->size){
+80101c29:	8b 45 d8             	mov    -0x28(%ebp),%eax
+80101c2c:	3b 70 58             	cmp    0x58(%eax),%esi
+80101c2f:	77 37                	ja     80101c68 <writei+0x108>
+    ip->size = off;
+    iupdate(ip);
+  }
+  return n;
+80101c31:	8b 45 e0             	mov    -0x20(%ebp),%eax
+}
+80101c34:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80101c37:	5b                   	pop    %ebx
+80101c38:	5e                   	pop    %esi
+80101c39:	5f                   	pop    %edi
+80101c3a:	5d                   	pop    %ebp
+80101c3b:	c3                   	ret    
+80101c3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+80101c40:	0f bf 40 52          	movswl 0x52(%eax),%eax
+80101c44:	66 83 f8 09          	cmp    $0x9,%ax
+80101c48:	77 32                	ja     80101c7c <writei+0x11c>
+80101c4a:	8b 04 c5 64 09 11 80 	mov    -0x7feef69c(,%eax,8),%eax
+80101c51:	85 c0                	test   %eax,%eax
+80101c53:	74 27                	je     80101c7c <writei+0x11c>
+    return devsw[ip->major].write(ip, src, n);
+80101c55:	89 7d 10             	mov    %edi,0x10(%ebp)
+}
+80101c58:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80101c5b:	5b                   	pop    %ebx
+80101c5c:	5e                   	pop    %esi
+80101c5d:	5f                   	pop    %edi
+80101c5e:	5d                   	pop    %ebp
+    return devsw[ip->major].write(ip, src, n);
+80101c5f:	ff e0                	jmp    *%eax
+80101c61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    ip->size = off;
+80101c68:	8b 45 d8             	mov    -0x28(%ebp),%eax
+    iupdate(ip);
+80101c6b:	83 ec 0c             	sub    $0xc,%esp
+    ip->size = off;
+80101c6e:	89 70 58             	mov    %esi,0x58(%eax)
+    iupdate(ip);
+80101c71:	50                   	push   %eax
+80101c72:	e8 29 fa ff ff       	call   801016a0 <iupdate>
+80101c77:	83 c4 10             	add    $0x10,%esp
+80101c7a:	eb b5                	jmp    80101c31 <writei+0xd1>
+      return -1;
+80101c7c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80101c81:	eb b1                	jmp    80101c34 <writei+0xd4>
+80101c83:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101c8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80101c90 <namecmp>:
+//PAGEBREAK!
+// Directories
+
+int
+namecmp(const char *s, const char *t)
+{
+80101c90:	f3 0f 1e fb          	endbr32 
+80101c94:	55                   	push   %ebp
+80101c95:	89 e5                	mov    %esp,%ebp
+80101c97:	83 ec 0c             	sub    $0xc,%esp
+  return strncmp(s, t, DIRSIZ);
+80101c9a:	6a 0e                	push   $0xe
+80101c9c:	ff 75 0c             	pushl  0xc(%ebp)
+80101c9f:	ff 75 08             	pushl  0x8(%ebp)
+80101ca2:	e8 59 2d 00 00       	call   80104a00 <strncmp>
+}
+80101ca7:	c9                   	leave  
+80101ca8:	c3                   	ret    
+80101ca9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80101cb0 <dirlookup>:
+
+// Look for a directory entry in a directory.
+// If found, set *poff to byte offset of entry.
+struct inode*
+dirlookup(struct inode *dp, char *name, uint *poff)
+{
+80101cb0:	f3 0f 1e fb          	endbr32 
+80101cb4:	55                   	push   %ebp
+80101cb5:	89 e5                	mov    %esp,%ebp
+80101cb7:	57                   	push   %edi
+80101cb8:	56                   	push   %esi
+80101cb9:	53                   	push   %ebx
+80101cba:	83 ec 1c             	sub    $0x1c,%esp
+80101cbd:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  uint off, inum;
+  struct dirent de;
+
+  if(dp->type != T_DIR)
+80101cc0:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
+80101cc5:	0f 85 89 00 00 00    	jne    80101d54 <dirlookup+0xa4>
+    panic("dirlookup not DIR");
+
+  for(off = 0; off < dp->size; off += sizeof(de)){
+80101ccb:	8b 53 58             	mov    0x58(%ebx),%edx
+80101cce:	31 ff                	xor    %edi,%edi
+80101cd0:	8d 75 d8             	lea    -0x28(%ebp),%esi
+80101cd3:	85 d2                	test   %edx,%edx
+80101cd5:	74 42                	je     80101d19 <dirlookup+0x69>
+80101cd7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101cde:	66 90                	xchg   %ax,%ax
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80101ce0:	6a 10                	push   $0x10
+80101ce2:	57                   	push   %edi
+80101ce3:	56                   	push   %esi
+80101ce4:	53                   	push   %ebx
+80101ce5:	e8 76 fd ff ff       	call   80101a60 <readi>
+80101cea:	83 c4 10             	add    $0x10,%esp
+80101ced:	83 f8 10             	cmp    $0x10,%eax
+80101cf0:	75 55                	jne    80101d47 <dirlookup+0x97>
+      panic("dirlookup read");
+    if(de.inum == 0)
+80101cf2:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
+80101cf7:	74 18                	je     80101d11 <dirlookup+0x61>
+  return strncmp(s, t, DIRSIZ);
+80101cf9:	83 ec 04             	sub    $0x4,%esp
+80101cfc:	8d 45 da             	lea    -0x26(%ebp),%eax
+80101cff:	6a 0e                	push   $0xe
+80101d01:	50                   	push   %eax
+80101d02:	ff 75 0c             	pushl  0xc(%ebp)
+80101d05:	e8 f6 2c 00 00       	call   80104a00 <strncmp>
+      continue;
+    if(namecmp(name, de.name) == 0){
+80101d0a:	83 c4 10             	add    $0x10,%esp
+80101d0d:	85 c0                	test   %eax,%eax
+80101d0f:	74 17                	je     80101d28 <dirlookup+0x78>
+  for(off = 0; off < dp->size; off += sizeof(de)){
+80101d11:	83 c7 10             	add    $0x10,%edi
+80101d14:	3b 7b 58             	cmp    0x58(%ebx),%edi
+80101d17:	72 c7                	jb     80101ce0 <dirlookup+0x30>
+      return iget(dp->dev, inum);
+    }
+  }
+
+  return 0;
+}
+80101d19:	8d 65 f4             	lea    -0xc(%ebp),%esp
+  return 0;
+80101d1c:	31 c0                	xor    %eax,%eax
+}
+80101d1e:	5b                   	pop    %ebx
+80101d1f:	5e                   	pop    %esi
+80101d20:	5f                   	pop    %edi
+80101d21:	5d                   	pop    %ebp
+80101d22:	c3                   	ret    
+80101d23:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80101d27:	90                   	nop
+      if(poff)
+80101d28:	8b 45 10             	mov    0x10(%ebp),%eax
+80101d2b:	85 c0                	test   %eax,%eax
+80101d2d:	74 05                	je     80101d34 <dirlookup+0x84>
+        *poff = off;
+80101d2f:	8b 45 10             	mov    0x10(%ebp),%eax
+80101d32:	89 38                	mov    %edi,(%eax)
+      inum = de.inum;
+80101d34:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
+      return iget(dp->dev, inum);
+80101d38:	8b 03                	mov    (%ebx),%eax
+80101d3a:	e8 01 f6 ff ff       	call   80101340 <iget>
+}
+80101d3f:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80101d42:	5b                   	pop    %ebx
+80101d43:	5e                   	pop    %esi
+80101d44:	5f                   	pop    %edi
+80101d45:	5d                   	pop    %ebp
+80101d46:	c3                   	ret    
+      panic("dirlookup read");
+80101d47:	83 ec 0c             	sub    $0xc,%esp
+80101d4a:	68 19 76 10 80       	push   $0x80107619
+80101d4f:	e8 3c e6 ff ff       	call   80100390 <panic>
+    panic("dirlookup not DIR");
+80101d54:	83 ec 0c             	sub    $0xc,%esp
+80101d57:	68 07 76 10 80       	push   $0x80107607
+80101d5c:	e8 2f e6 ff ff       	call   80100390 <panic>
+80101d61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101d68:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101d6f:	90                   	nop
+
+80101d70 <namex>:
+// If parent != 0, return the inode for the parent and copy the final
+// path element into name, which must have room for DIRSIZ bytes.
+// Must be called inside a transaction since it calls iput().
+static struct inode*
+namex(char *path, int nameiparent, char *name)
+{
+80101d70:	55                   	push   %ebp
+80101d71:	89 e5                	mov    %esp,%ebp
+80101d73:	57                   	push   %edi
+80101d74:	56                   	push   %esi
+80101d75:	53                   	push   %ebx
+80101d76:	89 c3                	mov    %eax,%ebx
+80101d78:	83 ec 1c             	sub    $0x1c,%esp
+  struct inode *ip, *next;
+
+  if(*path == '/')
+80101d7b:	80 38 2f             	cmpb   $0x2f,(%eax)
+{
+80101d7e:	89 55 e0             	mov    %edx,-0x20(%ebp)
+80101d81:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+  if(*path == '/')
+80101d84:	0f 84 86 01 00 00    	je     80101f10 <namex+0x1a0>
+    ip = iget(ROOTDEV, ROOTINO);
+  else
+    ip = idup(myproc()->cwd);
+80101d8a:	e8 d1 1b 00 00       	call   80103960 <myproc>
+  acquire(&icache.lock);
+80101d8f:	83 ec 0c             	sub    $0xc,%esp
+80101d92:	89 df                	mov    %ebx,%edi
+    ip = idup(myproc()->cwd);
+80101d94:	8b 70 68             	mov    0x68(%eax),%esi
+  acquire(&icache.lock);
+80101d97:	68 e0 09 11 80       	push   $0x801109e0
+80101d9c:	e8 3f 2a 00 00       	call   801047e0 <acquire>
+  ip->ref++;
+80101da1:	83 46 08 01          	addl   $0x1,0x8(%esi)
+  release(&icache.lock);
+80101da5:	c7 04 24 e0 09 11 80 	movl   $0x801109e0,(%esp)
+80101dac:	e8 ef 2a 00 00       	call   801048a0 <release>
+80101db1:	83 c4 10             	add    $0x10,%esp
+80101db4:	eb 0d                	jmp    80101dc3 <namex+0x53>
+80101db6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101dbd:	8d 76 00             	lea    0x0(%esi),%esi
+    path++;
+80101dc0:	83 c7 01             	add    $0x1,%edi
+  while(*path == '/')
+80101dc3:	0f b6 07             	movzbl (%edi),%eax
+80101dc6:	3c 2f                	cmp    $0x2f,%al
+80101dc8:	74 f6                	je     80101dc0 <namex+0x50>
+  if(*path == 0)
+80101dca:	84 c0                	test   %al,%al
+80101dcc:	0f 84 ee 00 00 00    	je     80101ec0 <namex+0x150>
+  while(*path != '/' && *path != 0)
+80101dd2:	0f b6 07             	movzbl (%edi),%eax
+80101dd5:	84 c0                	test   %al,%al
+80101dd7:	0f 84 fb 00 00 00    	je     80101ed8 <namex+0x168>
+80101ddd:	89 fb                	mov    %edi,%ebx
+80101ddf:	3c 2f                	cmp    $0x2f,%al
+80101de1:	0f 84 f1 00 00 00    	je     80101ed8 <namex+0x168>
+80101de7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101dee:	66 90                	xchg   %ax,%ax
+80101df0:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
+    path++;
+80101df4:	83 c3 01             	add    $0x1,%ebx
+  while(*path != '/' && *path != 0)
+80101df7:	3c 2f                	cmp    $0x2f,%al
+80101df9:	74 04                	je     80101dff <namex+0x8f>
+80101dfb:	84 c0                	test   %al,%al
+80101dfd:	75 f1                	jne    80101df0 <namex+0x80>
+  len = path - s;
+80101dff:	89 d8                	mov    %ebx,%eax
+80101e01:	29 f8                	sub    %edi,%eax
+  if(len >= DIRSIZ)
+80101e03:	83 f8 0d             	cmp    $0xd,%eax
+80101e06:	0f 8e 84 00 00 00    	jle    80101e90 <namex+0x120>
+    memmove(name, s, DIRSIZ);
+80101e0c:	83 ec 04             	sub    $0x4,%esp
+80101e0f:	6a 0e                	push   $0xe
+80101e11:	57                   	push   %edi
+    path++;
+80101e12:	89 df                	mov    %ebx,%edi
+    memmove(name, s, DIRSIZ);
+80101e14:	ff 75 e4             	pushl  -0x1c(%ebp)
+80101e17:	e8 74 2b 00 00       	call   80104990 <memmove>
+80101e1c:	83 c4 10             	add    $0x10,%esp
+  while(*path == '/')
+80101e1f:	80 3b 2f             	cmpb   $0x2f,(%ebx)
+80101e22:	75 0c                	jne    80101e30 <namex+0xc0>
+80101e24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    path++;
+80101e28:	83 c7 01             	add    $0x1,%edi
+  while(*path == '/')
+80101e2b:	80 3f 2f             	cmpb   $0x2f,(%edi)
+80101e2e:	74 f8                	je     80101e28 <namex+0xb8>
+
+  while((path = skipelem(path, name)) != 0){
+    ilock(ip);
+80101e30:	83 ec 0c             	sub    $0xc,%esp
+80101e33:	56                   	push   %esi
+80101e34:	e8 27 f9 ff ff       	call   80101760 <ilock>
+    if(ip->type != T_DIR){
+80101e39:	83 c4 10             	add    $0x10,%esp
+80101e3c:	66 83 7e 50 01       	cmpw   $0x1,0x50(%esi)
+80101e41:	0f 85 a1 00 00 00    	jne    80101ee8 <namex+0x178>
+      iunlockput(ip);
+      return 0;
+    }
+    if(nameiparent && *path == '\0'){
+80101e47:	8b 55 e0             	mov    -0x20(%ebp),%edx
+80101e4a:	85 d2                	test   %edx,%edx
+80101e4c:	74 09                	je     80101e57 <namex+0xe7>
+80101e4e:	80 3f 00             	cmpb   $0x0,(%edi)
+80101e51:	0f 84 d9 00 00 00    	je     80101f30 <namex+0x1c0>
+      // Stop one level early.
+      iunlock(ip);
+      return ip;
+    }
+    if((next = dirlookup(ip, name, 0)) == 0){
+80101e57:	83 ec 04             	sub    $0x4,%esp
+80101e5a:	6a 00                	push   $0x0
+80101e5c:	ff 75 e4             	pushl  -0x1c(%ebp)
+80101e5f:	56                   	push   %esi
+80101e60:	e8 4b fe ff ff       	call   80101cb0 <dirlookup>
+80101e65:	83 c4 10             	add    $0x10,%esp
+80101e68:	89 c3                	mov    %eax,%ebx
+80101e6a:	85 c0                	test   %eax,%eax
+80101e6c:	74 7a                	je     80101ee8 <namex+0x178>
+  iunlock(ip);
+80101e6e:	83 ec 0c             	sub    $0xc,%esp
+80101e71:	56                   	push   %esi
+80101e72:	e8 c9 f9 ff ff       	call   80101840 <iunlock>
+  iput(ip);
+80101e77:	89 34 24             	mov    %esi,(%esp)
+80101e7a:	89 de                	mov    %ebx,%esi
+80101e7c:	e8 0f fa ff ff       	call   80101890 <iput>
+80101e81:	83 c4 10             	add    $0x10,%esp
+80101e84:	e9 3a ff ff ff       	jmp    80101dc3 <namex+0x53>
+80101e89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101e90:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+80101e93:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
+80101e96:	89 4d dc             	mov    %ecx,-0x24(%ebp)
+    memmove(name, s, len);
+80101e99:	83 ec 04             	sub    $0x4,%esp
+80101e9c:	50                   	push   %eax
+80101e9d:	57                   	push   %edi
+    name[len] = 0;
+80101e9e:	89 df                	mov    %ebx,%edi
+    memmove(name, s, len);
+80101ea0:	ff 75 e4             	pushl  -0x1c(%ebp)
+80101ea3:	e8 e8 2a 00 00       	call   80104990 <memmove>
+    name[len] = 0;
+80101ea8:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80101eab:	83 c4 10             	add    $0x10,%esp
+80101eae:	c6 00 00             	movb   $0x0,(%eax)
+80101eb1:	e9 69 ff ff ff       	jmp    80101e1f <namex+0xaf>
+80101eb6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101ebd:	8d 76 00             	lea    0x0(%esi),%esi
+      return 0;
+    }
+    iunlockput(ip);
+    ip = next;
+  }
+  if(nameiparent){
+80101ec0:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80101ec3:	85 c0                	test   %eax,%eax
+80101ec5:	0f 85 85 00 00 00    	jne    80101f50 <namex+0x1e0>
+    iput(ip);
+    return 0;
+  }
+  return ip;
+}
+80101ecb:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80101ece:	89 f0                	mov    %esi,%eax
+80101ed0:	5b                   	pop    %ebx
+80101ed1:	5e                   	pop    %esi
+80101ed2:	5f                   	pop    %edi
+80101ed3:	5d                   	pop    %ebp
+80101ed4:	c3                   	ret    
+80101ed5:	8d 76 00             	lea    0x0(%esi),%esi
+  while(*path != '/' && *path != 0)
+80101ed8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80101edb:	89 fb                	mov    %edi,%ebx
+80101edd:	89 45 dc             	mov    %eax,-0x24(%ebp)
+80101ee0:	31 c0                	xor    %eax,%eax
+80101ee2:	eb b5                	jmp    80101e99 <namex+0x129>
+80101ee4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  iunlock(ip);
+80101ee8:	83 ec 0c             	sub    $0xc,%esp
+80101eeb:	56                   	push   %esi
+80101eec:	e8 4f f9 ff ff       	call   80101840 <iunlock>
+  iput(ip);
+80101ef1:	89 34 24             	mov    %esi,(%esp)
+      return 0;
+80101ef4:	31 f6                	xor    %esi,%esi
+  iput(ip);
+80101ef6:	e8 95 f9 ff ff       	call   80101890 <iput>
+      return 0;
+80101efb:	83 c4 10             	add    $0x10,%esp
+}
+80101efe:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80101f01:	89 f0                	mov    %esi,%eax
+80101f03:	5b                   	pop    %ebx
+80101f04:	5e                   	pop    %esi
+80101f05:	5f                   	pop    %edi
+80101f06:	5d                   	pop    %ebp
+80101f07:	c3                   	ret    
+80101f08:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101f0f:	90                   	nop
+    ip = iget(ROOTDEV, ROOTINO);
+80101f10:	ba 01 00 00 00       	mov    $0x1,%edx
+80101f15:	b8 01 00 00 00       	mov    $0x1,%eax
+80101f1a:	89 df                	mov    %ebx,%edi
+80101f1c:	e8 1f f4 ff ff       	call   80101340 <iget>
+80101f21:	89 c6                	mov    %eax,%esi
+80101f23:	e9 9b fe ff ff       	jmp    80101dc3 <namex+0x53>
+80101f28:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101f2f:	90                   	nop
+      iunlock(ip);
+80101f30:	83 ec 0c             	sub    $0xc,%esp
+80101f33:	56                   	push   %esi
+80101f34:	e8 07 f9 ff ff       	call   80101840 <iunlock>
+      return ip;
+80101f39:	83 c4 10             	add    $0x10,%esp
+}
+80101f3c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80101f3f:	89 f0                	mov    %esi,%eax
+80101f41:	5b                   	pop    %ebx
+80101f42:	5e                   	pop    %esi
+80101f43:	5f                   	pop    %edi
+80101f44:	5d                   	pop    %ebp
+80101f45:	c3                   	ret    
+80101f46:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101f4d:	8d 76 00             	lea    0x0(%esi),%esi
+    iput(ip);
+80101f50:	83 ec 0c             	sub    $0xc,%esp
+80101f53:	56                   	push   %esi
+    return 0;
+80101f54:	31 f6                	xor    %esi,%esi
+    iput(ip);
+80101f56:	e8 35 f9 ff ff       	call   80101890 <iput>
+    return 0;
+80101f5b:	83 c4 10             	add    $0x10,%esp
+80101f5e:	e9 68 ff ff ff       	jmp    80101ecb <namex+0x15b>
+80101f63:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80101f6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80101f70 <dirlink>:
+{
+80101f70:	f3 0f 1e fb          	endbr32 
+80101f74:	55                   	push   %ebp
+80101f75:	89 e5                	mov    %esp,%ebp
+80101f77:	57                   	push   %edi
+80101f78:	56                   	push   %esi
+80101f79:	53                   	push   %ebx
+80101f7a:	83 ec 20             	sub    $0x20,%esp
+80101f7d:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if((ip = dirlookup(dp, name, 0)) != 0){
+80101f80:	6a 00                	push   $0x0
+80101f82:	ff 75 0c             	pushl  0xc(%ebp)
+80101f85:	53                   	push   %ebx
+80101f86:	e8 25 fd ff ff       	call   80101cb0 <dirlookup>
+80101f8b:	83 c4 10             	add    $0x10,%esp
+80101f8e:	85 c0                	test   %eax,%eax
+80101f90:	75 6b                	jne    80101ffd <dirlink+0x8d>
+  for(off = 0; off < dp->size; off += sizeof(de)){
+80101f92:	8b 7b 58             	mov    0x58(%ebx),%edi
+80101f95:	8d 75 d8             	lea    -0x28(%ebp),%esi
+80101f98:	85 ff                	test   %edi,%edi
+80101f9a:	74 2d                	je     80101fc9 <dirlink+0x59>
+80101f9c:	31 ff                	xor    %edi,%edi
+80101f9e:	8d 75 d8             	lea    -0x28(%ebp),%esi
+80101fa1:	eb 0d                	jmp    80101fb0 <dirlink+0x40>
+80101fa3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80101fa7:	90                   	nop
+80101fa8:	83 c7 10             	add    $0x10,%edi
+80101fab:	3b 7b 58             	cmp    0x58(%ebx),%edi
+80101fae:	73 19                	jae    80101fc9 <dirlink+0x59>
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80101fb0:	6a 10                	push   $0x10
+80101fb2:	57                   	push   %edi
+80101fb3:	56                   	push   %esi
+80101fb4:	53                   	push   %ebx
+80101fb5:	e8 a6 fa ff ff       	call   80101a60 <readi>
+80101fba:	83 c4 10             	add    $0x10,%esp
+80101fbd:	83 f8 10             	cmp    $0x10,%eax
+80101fc0:	75 4e                	jne    80102010 <dirlink+0xa0>
+    if(de.inum == 0)
+80101fc2:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
+80101fc7:	75 df                	jne    80101fa8 <dirlink+0x38>
+  strncpy(de.name, name, DIRSIZ);
+80101fc9:	83 ec 04             	sub    $0x4,%esp
+80101fcc:	8d 45 da             	lea    -0x26(%ebp),%eax
+80101fcf:	6a 0e                	push   $0xe
+80101fd1:	ff 75 0c             	pushl  0xc(%ebp)
+80101fd4:	50                   	push   %eax
+80101fd5:	e8 76 2a 00 00       	call   80104a50 <strncpy>
+  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80101fda:	6a 10                	push   $0x10
+  de.inum = inum;
+80101fdc:	8b 45 10             	mov    0x10(%ebp),%eax
+  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80101fdf:	57                   	push   %edi
+80101fe0:	56                   	push   %esi
+80101fe1:	53                   	push   %ebx
+  de.inum = inum;
+80101fe2:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
+  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80101fe6:	e8 75 fb ff ff       	call   80101b60 <writei>
+80101feb:	83 c4 20             	add    $0x20,%esp
+80101fee:	83 f8 10             	cmp    $0x10,%eax
+80101ff1:	75 2a                	jne    8010201d <dirlink+0xad>
+  return 0;
+80101ff3:	31 c0                	xor    %eax,%eax
+}
+80101ff5:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80101ff8:	5b                   	pop    %ebx
+80101ff9:	5e                   	pop    %esi
+80101ffa:	5f                   	pop    %edi
+80101ffb:	5d                   	pop    %ebp
+80101ffc:	c3                   	ret    
+    iput(ip);
+80101ffd:	83 ec 0c             	sub    $0xc,%esp
+80102000:	50                   	push   %eax
+80102001:	e8 8a f8 ff ff       	call   80101890 <iput>
+    return -1;
+80102006:	83 c4 10             	add    $0x10,%esp
+80102009:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010200e:	eb e5                	jmp    80101ff5 <dirlink+0x85>
+      panic("dirlink read");
+80102010:	83 ec 0c             	sub    $0xc,%esp
+80102013:	68 28 76 10 80       	push   $0x80107628
+80102018:	e8 73 e3 ff ff       	call   80100390 <panic>
+    panic("dirlink");
+8010201d:	83 ec 0c             	sub    $0xc,%esp
+80102020:	68 0e 7c 10 80       	push   $0x80107c0e
+80102025:	e8 66 e3 ff ff       	call   80100390 <panic>
+8010202a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80102030 <namei>:
+
+struct inode*
+namei(char *path)
+{
+80102030:	f3 0f 1e fb          	endbr32 
+80102034:	55                   	push   %ebp
+  char name[DIRSIZ];
+  return namex(path, 0, name);
+80102035:	31 d2                	xor    %edx,%edx
+{
+80102037:	89 e5                	mov    %esp,%ebp
+80102039:	83 ec 18             	sub    $0x18,%esp
+  return namex(path, 0, name);
+8010203c:	8b 45 08             	mov    0x8(%ebp),%eax
+8010203f:	8d 4d ea             	lea    -0x16(%ebp),%ecx
+80102042:	e8 29 fd ff ff       	call   80101d70 <namex>
+}
+80102047:	c9                   	leave  
+80102048:	c3                   	ret    
+80102049:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80102050 <nameiparent>:
+
+struct inode*
+nameiparent(char *path, char *name)
+{
+80102050:	f3 0f 1e fb          	endbr32 
+80102054:	55                   	push   %ebp
+  return namex(path, 1, name);
+80102055:	ba 01 00 00 00       	mov    $0x1,%edx
+{
+8010205a:	89 e5                	mov    %esp,%ebp
+  return namex(path, 1, name);
+8010205c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+8010205f:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+80102062:	5d                   	pop    %ebp
+  return namex(path, 1, name);
+80102063:	e9 08 fd ff ff       	jmp    80101d70 <namex>
+80102068:	66 90                	xchg   %ax,%ax
+8010206a:	66 90                	xchg   %ax,%ax
+8010206c:	66 90                	xchg   %ax,%ax
+8010206e:	66 90                	xchg   %ax,%ax
+
+80102070 <idestart>:
+}
+
+// Start the request for b.  Caller must hold idelock.
+static void
+idestart(struct buf *b)
+{
+80102070:	55                   	push   %ebp
+80102071:	89 e5                	mov    %esp,%ebp
+80102073:	57                   	push   %edi
+80102074:	56                   	push   %esi
+80102075:	53                   	push   %ebx
+80102076:	83 ec 0c             	sub    $0xc,%esp
+  if(b == 0)
+80102079:	85 c0                	test   %eax,%eax
+8010207b:	0f 84 b4 00 00 00    	je     80102135 <idestart+0xc5>
+    panic("idestart");
+  if(b->blockno >= FSSIZE)
+80102081:	8b 70 08             	mov    0x8(%eax),%esi
+80102084:	89 c3                	mov    %eax,%ebx
+80102086:	81 fe e7 03 00 00    	cmp    $0x3e7,%esi
+8010208c:	0f 87 96 00 00 00    	ja     80102128 <idestart+0xb8>
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102092:	b9 f7 01 00 00       	mov    $0x1f7,%ecx
+80102097:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010209e:	66 90                	xchg   %ax,%ax
+801020a0:	89 ca                	mov    %ecx,%edx
+801020a2:	ec                   	in     (%dx),%al
+  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
+801020a3:	83 e0 c0             	and    $0xffffffc0,%eax
+801020a6:	3c 40                	cmp    $0x40,%al
+801020a8:	75 f6                	jne    801020a0 <idestart+0x30>
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801020aa:	31 ff                	xor    %edi,%edi
+801020ac:	ba f6 03 00 00       	mov    $0x3f6,%edx
+801020b1:	89 f8                	mov    %edi,%eax
+801020b3:	ee                   	out    %al,(%dx)
+801020b4:	b8 01 00 00 00       	mov    $0x1,%eax
+801020b9:	ba f2 01 00 00       	mov    $0x1f2,%edx
+801020be:	ee                   	out    %al,(%dx)
+801020bf:	ba f3 01 00 00       	mov    $0x1f3,%edx
+801020c4:	89 f0                	mov    %esi,%eax
+801020c6:	ee                   	out    %al,(%dx)
+
+  idewait(0);
+  outb(0x3f6, 0);  // generate interrupt
+  outb(0x1f2, sector_per_block);  // number of sectors
+  outb(0x1f3, sector & 0xff);
+  outb(0x1f4, (sector >> 8) & 0xff);
+801020c7:	89 f0                	mov    %esi,%eax
+801020c9:	ba f4 01 00 00       	mov    $0x1f4,%edx
+801020ce:	c1 f8 08             	sar    $0x8,%eax
+801020d1:	ee                   	out    %al,(%dx)
+801020d2:	ba f5 01 00 00       	mov    $0x1f5,%edx
+801020d7:	89 f8                	mov    %edi,%eax
+801020d9:	ee                   	out    %al,(%dx)
+  outb(0x1f5, (sector >> 16) & 0xff);
+  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
+801020da:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
+801020de:	ba f6 01 00 00       	mov    $0x1f6,%edx
+801020e3:	c1 e0 04             	shl    $0x4,%eax
+801020e6:	83 e0 10             	and    $0x10,%eax
+801020e9:	83 c8 e0             	or     $0xffffffe0,%eax
+801020ec:	ee                   	out    %al,(%dx)
+  if(b->flags & B_DIRTY){
+801020ed:	f6 03 04             	testb  $0x4,(%ebx)
+801020f0:	75 16                	jne    80102108 <idestart+0x98>
+801020f2:	b8 20 00 00 00       	mov    $0x20,%eax
+801020f7:	89 ca                	mov    %ecx,%edx
+801020f9:	ee                   	out    %al,(%dx)
+    outb(0x1f7, write_cmd);
+    outsl(0x1f0, b->data, BSIZE/4);
+  } else {
+    outb(0x1f7, read_cmd);
+  }
+}
+801020fa:	8d 65 f4             	lea    -0xc(%ebp),%esp
+801020fd:	5b                   	pop    %ebx
+801020fe:	5e                   	pop    %esi
+801020ff:	5f                   	pop    %edi
+80102100:	5d                   	pop    %ebp
+80102101:	c3                   	ret    
+80102102:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80102108:	b8 30 00 00 00       	mov    $0x30,%eax
+8010210d:	89 ca                	mov    %ecx,%edx
+8010210f:	ee                   	out    %al,(%dx)
+  asm volatile("cld; rep outsl" :
+80102110:	b9 80 00 00 00       	mov    $0x80,%ecx
+    outsl(0x1f0, b->data, BSIZE/4);
+80102115:	8d 73 5c             	lea    0x5c(%ebx),%esi
+80102118:	ba f0 01 00 00       	mov    $0x1f0,%edx
+8010211d:	fc                   	cld    
+8010211e:	f3 6f                	rep outsl %ds:(%esi),(%dx)
+}
+80102120:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80102123:	5b                   	pop    %ebx
+80102124:	5e                   	pop    %esi
+80102125:	5f                   	pop    %edi
+80102126:	5d                   	pop    %ebp
+80102127:	c3                   	ret    
+    panic("incorrect blockno");
+80102128:	83 ec 0c             	sub    $0xc,%esp
+8010212b:	68 94 76 10 80       	push   $0x80107694
+80102130:	e8 5b e2 ff ff       	call   80100390 <panic>
+    panic("idestart");
+80102135:	83 ec 0c             	sub    $0xc,%esp
+80102138:	68 8b 76 10 80       	push   $0x8010768b
+8010213d:	e8 4e e2 ff ff       	call   80100390 <panic>
+80102142:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80102149:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80102150 <ideinit>:
+{
+80102150:	f3 0f 1e fb          	endbr32 
+80102154:	55                   	push   %ebp
+80102155:	89 e5                	mov    %esp,%ebp
+80102157:	83 ec 10             	sub    $0x10,%esp
+  initlock(&idelock, "ide");
+8010215a:	68 a6 76 10 80       	push   $0x801076a6
+8010215f:	68 80 a5 10 80       	push   $0x8010a580
+80102164:	e8 f7 24 00 00       	call   80104660 <initlock>
+  ioapicenable(IRQ_IDE, ncpu - 1);
+80102169:	58                   	pop    %eax
+8010216a:	a1 00 2d 11 80       	mov    0x80112d00,%eax
+8010216f:	5a                   	pop    %edx
+80102170:	83 e8 01             	sub    $0x1,%eax
+80102173:	50                   	push   %eax
+80102174:	6a 0e                	push   $0xe
+80102176:	e8 b5 02 00 00       	call   80102430 <ioapicenable>
+  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
+8010217b:	83 c4 10             	add    $0x10,%esp
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+8010217e:	ba f7 01 00 00       	mov    $0x1f7,%edx
+80102183:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80102187:	90                   	nop
+80102188:	ec                   	in     (%dx),%al
+80102189:	83 e0 c0             	and    $0xffffffc0,%eax
+8010218c:	3c 40                	cmp    $0x40,%al
+8010218e:	75 f8                	jne    80102188 <ideinit+0x38>
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80102190:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
+80102195:	ba f6 01 00 00       	mov    $0x1f6,%edx
+8010219a:	ee                   	out    %al,(%dx)
+8010219b:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+801021a0:	ba f7 01 00 00       	mov    $0x1f7,%edx
+801021a5:	eb 0e                	jmp    801021b5 <ideinit+0x65>
+801021a7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801021ae:	66 90                	xchg   %ax,%ax
+  for(i=0; i<1000; i++){
+801021b0:	83 e9 01             	sub    $0x1,%ecx
+801021b3:	74 0f                	je     801021c4 <ideinit+0x74>
+801021b5:	ec                   	in     (%dx),%al
+    if(inb(0x1f7) != 0){
+801021b6:	84 c0                	test   %al,%al
+801021b8:	74 f6                	je     801021b0 <ideinit+0x60>
+      havedisk1 = 1;
+801021ba:	c7 05 60 a5 10 80 01 	movl   $0x1,0x8010a560
+801021c1:	00 00 00 
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801021c4:	b8 e0 ff ff ff       	mov    $0xffffffe0,%eax
+801021c9:	ba f6 01 00 00       	mov    $0x1f6,%edx
+801021ce:	ee                   	out    %al,(%dx)
+}
+801021cf:	c9                   	leave  
+801021d0:	c3                   	ret    
+801021d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801021d8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801021df:	90                   	nop
+
+801021e0 <ideintr>:
+
+// Interrupt handler.
+void
+ideintr(void)
+{
+801021e0:	f3 0f 1e fb          	endbr32 
+801021e4:	55                   	push   %ebp
+801021e5:	89 e5                	mov    %esp,%ebp
+801021e7:	57                   	push   %edi
+801021e8:	56                   	push   %esi
+801021e9:	53                   	push   %ebx
+801021ea:	83 ec 18             	sub    $0x18,%esp
+  struct buf *b;
+
+  // First queued buffer is the active request.
+  acquire(&idelock);
+801021ed:	68 80 a5 10 80       	push   $0x8010a580
+801021f2:	e8 e9 25 00 00       	call   801047e0 <acquire>
+
+  if((b = idequeue) == 0){
+801021f7:	8b 1d 64 a5 10 80    	mov    0x8010a564,%ebx
+801021fd:	83 c4 10             	add    $0x10,%esp
+80102200:	85 db                	test   %ebx,%ebx
+80102202:	74 5f                	je     80102263 <ideintr+0x83>
+    release(&idelock);
+    return;
+  }
+  idequeue = b->qnext;
+80102204:	8b 43 58             	mov    0x58(%ebx),%eax
+80102207:	a3 64 a5 10 80       	mov    %eax,0x8010a564
+
+  // Read data if needed.
+  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
+8010220c:	8b 33                	mov    (%ebx),%esi
+8010220e:	f7 c6 04 00 00 00    	test   $0x4,%esi
+80102214:	75 2b                	jne    80102241 <ideintr+0x61>
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102216:	ba f7 01 00 00       	mov    $0x1f7,%edx
+8010221b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010221f:	90                   	nop
+80102220:	ec                   	in     (%dx),%al
+  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
+80102221:	89 c1                	mov    %eax,%ecx
+80102223:	83 e1 c0             	and    $0xffffffc0,%ecx
+80102226:	80 f9 40             	cmp    $0x40,%cl
+80102229:	75 f5                	jne    80102220 <ideintr+0x40>
+  if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
+8010222b:	a8 21                	test   $0x21,%al
+8010222d:	75 12                	jne    80102241 <ideintr+0x61>
+    insl(0x1f0, b->data, BSIZE/4);
+8010222f:	8d 7b 5c             	lea    0x5c(%ebx),%edi
+  asm volatile("cld; rep insl" :
+80102232:	b9 80 00 00 00       	mov    $0x80,%ecx
+80102237:	ba f0 01 00 00       	mov    $0x1f0,%edx
+8010223c:	fc                   	cld    
+8010223d:	f3 6d                	rep insl (%dx),%es:(%edi)
+8010223f:	8b 33                	mov    (%ebx),%esi
+
+  // Wake process waiting for this buf.
+  b->flags |= B_VALID;
+  b->flags &= ~B_DIRTY;
+80102241:	83 e6 fb             	and    $0xfffffffb,%esi
+  wakeup(b);
+80102244:	83 ec 0c             	sub    $0xc,%esp
+  b->flags &= ~B_DIRTY;
+80102247:	83 ce 02             	or     $0x2,%esi
+8010224a:	89 33                	mov    %esi,(%ebx)
+  wakeup(b);
+8010224c:	53                   	push   %ebx
+8010224d:	e8 8e 1e 00 00       	call   801040e0 <wakeup>
+
+  // Start disk on next buf in queue.
+  if(idequeue != 0)
+80102252:	a1 64 a5 10 80       	mov    0x8010a564,%eax
+80102257:	83 c4 10             	add    $0x10,%esp
+8010225a:	85 c0                	test   %eax,%eax
+8010225c:	74 05                	je     80102263 <ideintr+0x83>
+    idestart(idequeue);
+8010225e:	e8 0d fe ff ff       	call   80102070 <idestart>
+    release(&idelock);
+80102263:	83 ec 0c             	sub    $0xc,%esp
+80102266:	68 80 a5 10 80       	push   $0x8010a580
+8010226b:	e8 30 26 00 00       	call   801048a0 <release>
+
+  release(&idelock);
+}
+80102270:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80102273:	5b                   	pop    %ebx
+80102274:	5e                   	pop    %esi
+80102275:	5f                   	pop    %edi
+80102276:	5d                   	pop    %ebp
+80102277:	c3                   	ret    
+80102278:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010227f:	90                   	nop
+
+80102280 <iderw>:
+// Sync buf with disk.
+// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
+// Else if B_VALID is not set, read buf from disk, set B_VALID.
+void
+iderw(struct buf *b)
+{
+80102280:	f3 0f 1e fb          	endbr32 
+80102284:	55                   	push   %ebp
+80102285:	89 e5                	mov    %esp,%ebp
+80102287:	53                   	push   %ebx
+80102288:	83 ec 10             	sub    $0x10,%esp
+8010228b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  struct buf **pp;
+
+  if(!holdingsleep(&b->lock))
+8010228e:	8d 43 0c             	lea    0xc(%ebx),%eax
+80102291:	50                   	push   %eax
+80102292:	e8 69 23 00 00       	call   80104600 <holdingsleep>
+80102297:	83 c4 10             	add    $0x10,%esp
+8010229a:	85 c0                	test   %eax,%eax
+8010229c:	0f 84 cf 00 00 00    	je     80102371 <iderw+0xf1>
+    panic("iderw: buf not locked");
+  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+801022a2:	8b 03                	mov    (%ebx),%eax
+801022a4:	83 e0 06             	and    $0x6,%eax
+801022a7:	83 f8 02             	cmp    $0x2,%eax
+801022aa:	0f 84 b4 00 00 00    	je     80102364 <iderw+0xe4>
+    panic("iderw: nothing to do");
+  if(b->dev != 0 && !havedisk1)
+801022b0:	8b 53 04             	mov    0x4(%ebx),%edx
+801022b3:	85 d2                	test   %edx,%edx
+801022b5:	74 0d                	je     801022c4 <iderw+0x44>
+801022b7:	a1 60 a5 10 80       	mov    0x8010a560,%eax
+801022bc:	85 c0                	test   %eax,%eax
+801022be:	0f 84 93 00 00 00    	je     80102357 <iderw+0xd7>
+    panic("iderw: ide disk 1 not present");
+
+  acquire(&idelock);  //DOC:acquire-lock
+801022c4:	83 ec 0c             	sub    $0xc,%esp
+801022c7:	68 80 a5 10 80       	push   $0x8010a580
+801022cc:	e8 0f 25 00 00       	call   801047e0 <acquire>
+
+  // Append b to idequeue.
+  b->qnext = 0;
+  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+801022d1:	a1 64 a5 10 80       	mov    0x8010a564,%eax
+  b->qnext = 0;
+801022d6:	c7 43 58 00 00 00 00 	movl   $0x0,0x58(%ebx)
+  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+801022dd:	83 c4 10             	add    $0x10,%esp
+801022e0:	85 c0                	test   %eax,%eax
+801022e2:	74 6c                	je     80102350 <iderw+0xd0>
+801022e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801022e8:	89 c2                	mov    %eax,%edx
+801022ea:	8b 40 58             	mov    0x58(%eax),%eax
+801022ed:	85 c0                	test   %eax,%eax
+801022ef:	75 f7                	jne    801022e8 <iderw+0x68>
+801022f1:	83 c2 58             	add    $0x58,%edx
+    ;
+  *pp = b;
+801022f4:	89 1a                	mov    %ebx,(%edx)
+
+  // Start disk if necessary.
+  if(idequeue == b)
+801022f6:	39 1d 64 a5 10 80    	cmp    %ebx,0x8010a564
+801022fc:	74 42                	je     80102340 <iderw+0xc0>
+    idestart(b);
+
+  // Wait for request to finish.
+  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+801022fe:	8b 03                	mov    (%ebx),%eax
+80102300:	83 e0 06             	and    $0x6,%eax
+80102303:	83 f8 02             	cmp    $0x2,%eax
+80102306:	74 23                	je     8010232b <iderw+0xab>
+80102308:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010230f:	90                   	nop
+    sleep(b, &idelock);
+80102310:	83 ec 08             	sub    $0x8,%esp
+80102313:	68 80 a5 10 80       	push   $0x8010a580
+80102318:	53                   	push   %ebx
+80102319:	e8 02 1c 00 00       	call   80103f20 <sleep>
+  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+8010231e:	8b 03                	mov    (%ebx),%eax
+80102320:	83 c4 10             	add    $0x10,%esp
+80102323:	83 e0 06             	and    $0x6,%eax
+80102326:	83 f8 02             	cmp    $0x2,%eax
+80102329:	75 e5                	jne    80102310 <iderw+0x90>
+  }
+
+
+  release(&idelock);
+8010232b:	c7 45 08 80 a5 10 80 	movl   $0x8010a580,0x8(%ebp)
+}
+80102332:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80102335:	c9                   	leave  
+  release(&idelock);
+80102336:	e9 65 25 00 00       	jmp    801048a0 <release>
+8010233b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010233f:	90                   	nop
+    idestart(b);
+80102340:	89 d8                	mov    %ebx,%eax
+80102342:	e8 29 fd ff ff       	call   80102070 <idestart>
+80102347:	eb b5                	jmp    801022fe <iderw+0x7e>
+80102349:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+80102350:	ba 64 a5 10 80       	mov    $0x8010a564,%edx
+80102355:	eb 9d                	jmp    801022f4 <iderw+0x74>
+    panic("iderw: ide disk 1 not present");
+80102357:	83 ec 0c             	sub    $0xc,%esp
+8010235a:	68 d5 76 10 80       	push   $0x801076d5
+8010235f:	e8 2c e0 ff ff       	call   80100390 <panic>
+    panic("iderw: nothing to do");
+80102364:	83 ec 0c             	sub    $0xc,%esp
+80102367:	68 c0 76 10 80       	push   $0x801076c0
+8010236c:	e8 1f e0 ff ff       	call   80100390 <panic>
+    panic("iderw: buf not locked");
+80102371:	83 ec 0c             	sub    $0xc,%esp
+80102374:	68 aa 76 10 80       	push   $0x801076aa
+80102379:	e8 12 e0 ff ff       	call   80100390 <panic>
+8010237e:	66 90                	xchg   %ax,%ax
+
+80102380 <ioapicinit>:
+  ioapic->data = data;
+}
+
+void
+ioapicinit(void)
+{
+80102380:	f3 0f 1e fb          	endbr32 
+80102384:	55                   	push   %ebp
+  int i, id, maxintr;
+
+  ioapic = (volatile struct ioapic*)IOAPIC;
+80102385:	c7 05 34 26 11 80 00 	movl   $0xfec00000,0x80112634
+8010238c:	00 c0 fe 
+{
+8010238f:	89 e5                	mov    %esp,%ebp
+80102391:	56                   	push   %esi
+80102392:	53                   	push   %ebx
+  ioapic->reg = reg;
+80102393:	c7 05 00 00 c0 fe 01 	movl   $0x1,0xfec00000
+8010239a:	00 00 00 
+  return ioapic->data;
+8010239d:	8b 15 34 26 11 80    	mov    0x80112634,%edx
+801023a3:	8b 72 10             	mov    0x10(%edx),%esi
+  ioapic->reg = reg;
+801023a6:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
+  return ioapic->data;
+801023ac:	8b 0d 34 26 11 80    	mov    0x80112634,%ecx
+  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
+  id = ioapicread(REG_ID) >> 24;
+  if(id != ioapicid)
+801023b2:	0f b6 15 60 27 11 80 	movzbl 0x80112760,%edx
+  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
+801023b9:	c1 ee 10             	shr    $0x10,%esi
+801023bc:	89 f0                	mov    %esi,%eax
+801023be:	0f b6 f0             	movzbl %al,%esi
+  return ioapic->data;
+801023c1:	8b 41 10             	mov    0x10(%ecx),%eax
+  id = ioapicread(REG_ID) >> 24;
+801023c4:	c1 e8 18             	shr    $0x18,%eax
+  if(id != ioapicid)
+801023c7:	39 c2                	cmp    %eax,%edx
+801023c9:	74 16                	je     801023e1 <ioapicinit+0x61>
+    cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
+801023cb:	83 ec 0c             	sub    $0xc,%esp
+801023ce:	68 f4 76 10 80       	push   $0x801076f4
+801023d3:	e8 d8 e2 ff ff       	call   801006b0 <cprintf>
+801023d8:	8b 0d 34 26 11 80    	mov    0x80112634,%ecx
+801023de:	83 c4 10             	add    $0x10,%esp
+801023e1:	83 c6 21             	add    $0x21,%esi
+{
+801023e4:	ba 10 00 00 00       	mov    $0x10,%edx
+801023e9:	b8 20 00 00 00       	mov    $0x20,%eax
+801023ee:	66 90                	xchg   %ax,%ax
+  ioapic->reg = reg;
+801023f0:	89 11                	mov    %edx,(%ecx)
+
+  // Mark all interrupts edge-triggered, active high, disabled,
+  // and not routed to any CPUs.
+  for(i = 0; i <= maxintr; i++){
+    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
+801023f2:	89 c3                	mov    %eax,%ebx
+  ioapic->data = data;
+801023f4:	8b 0d 34 26 11 80    	mov    0x80112634,%ecx
+801023fa:	83 c0 01             	add    $0x1,%eax
+    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
+801023fd:	81 cb 00 00 01 00    	or     $0x10000,%ebx
+  ioapic->data = data;
+80102403:	89 59 10             	mov    %ebx,0x10(%ecx)
+  ioapic->reg = reg;
+80102406:	8d 5a 01             	lea    0x1(%edx),%ebx
+80102409:	83 c2 02             	add    $0x2,%edx
+8010240c:	89 19                	mov    %ebx,(%ecx)
+  ioapic->data = data;
+8010240e:	8b 0d 34 26 11 80    	mov    0x80112634,%ecx
+80102414:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
+  for(i = 0; i <= maxintr; i++){
+8010241b:	39 f0                	cmp    %esi,%eax
+8010241d:	75 d1                	jne    801023f0 <ioapicinit+0x70>
+    ioapicwrite(REG_TABLE+2*i+1, 0);
+  }
+}
+8010241f:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80102422:	5b                   	pop    %ebx
+80102423:	5e                   	pop    %esi
+80102424:	5d                   	pop    %ebp
+80102425:	c3                   	ret    
+80102426:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010242d:	8d 76 00             	lea    0x0(%esi),%esi
+
+80102430 <ioapicenable>:
+
+void
+ioapicenable(int irq, int cpunum)
+{
+80102430:	f3 0f 1e fb          	endbr32 
+80102434:	55                   	push   %ebp
+  ioapic->reg = reg;
+80102435:	8b 0d 34 26 11 80    	mov    0x80112634,%ecx
+{
+8010243b:	89 e5                	mov    %esp,%ebp
+8010243d:	8b 45 08             	mov    0x8(%ebp),%eax
+  // Mark interrupt edge-triggered, active high,
+  // enabled, and routed to the given cpunum,
+  // which happens to be that cpu's APIC ID.
+  ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
+80102440:	8d 50 20             	lea    0x20(%eax),%edx
+80102443:	8d 44 00 10          	lea    0x10(%eax,%eax,1),%eax
+  ioapic->reg = reg;
+80102447:	89 01                	mov    %eax,(%ecx)
+  ioapic->data = data;
+80102449:	8b 0d 34 26 11 80    	mov    0x80112634,%ecx
+  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
+8010244f:	83 c0 01             	add    $0x1,%eax
+  ioapic->data = data;
+80102452:	89 51 10             	mov    %edx,0x10(%ecx)
+  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
+80102455:	8b 55 0c             	mov    0xc(%ebp),%edx
+  ioapic->reg = reg;
+80102458:	89 01                	mov    %eax,(%ecx)
+  ioapic->data = data;
+8010245a:	a1 34 26 11 80       	mov    0x80112634,%eax
+  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
+8010245f:	c1 e2 18             	shl    $0x18,%edx
+  ioapic->data = data;
+80102462:	89 50 10             	mov    %edx,0x10(%eax)
+}
+80102465:	5d                   	pop    %ebp
+80102466:	c3                   	ret    
+80102467:	66 90                	xchg   %ax,%ax
+80102469:	66 90                	xchg   %ax,%ax
+8010246b:	66 90                	xchg   %ax,%ax
+8010246d:	66 90                	xchg   %ax,%ax
+8010246f:	90                   	nop
+
+80102470 <kfree>:
+// which normally should have been returned by a
+// call to kalloc().  (The exception is when
+// initializing the allocator; see kinit above.)
+void
+kfree(char *v)
+{
+80102470:	f3 0f 1e fb          	endbr32 
+80102474:	55                   	push   %ebp
+80102475:	89 e5                	mov    %esp,%ebp
+80102477:	53                   	push   %ebx
+80102478:	83 ec 04             	sub    $0x4,%esp
+8010247b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  struct run *r;
+
+  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
+8010247e:	f7 c3 ff 0f 00 00    	test   $0xfff,%ebx
+80102484:	75 7a                	jne    80102500 <kfree+0x90>
+80102486:	81 fb a8 55 11 80    	cmp    $0x801155a8,%ebx
+8010248c:	72 72                	jb     80102500 <kfree+0x90>
+8010248e:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
+80102494:	3d ff ff ff 0d       	cmp    $0xdffffff,%eax
+80102499:	77 65                	ja     80102500 <kfree+0x90>
+    panic("kfree");
+
+  // Fill with junk to catch dangling refs.
+  memset(v, 1, PGSIZE);
+8010249b:	83 ec 04             	sub    $0x4,%esp
+8010249e:	68 00 10 00 00       	push   $0x1000
+801024a3:	6a 01                	push   $0x1
+801024a5:	53                   	push   %ebx
+801024a6:	e8 45 24 00 00       	call   801048f0 <memset>
+
+  if(kmem.use_lock)
+801024ab:	8b 15 74 26 11 80    	mov    0x80112674,%edx
+801024b1:	83 c4 10             	add    $0x10,%esp
+801024b4:	85 d2                	test   %edx,%edx
+801024b6:	75 20                	jne    801024d8 <kfree+0x68>
+    acquire(&kmem.lock);
+  r = (struct run*)v;
+  r->next = kmem.freelist;
+801024b8:	a1 78 26 11 80       	mov    0x80112678,%eax
+801024bd:	89 03                	mov    %eax,(%ebx)
+  kmem.freelist = r;
+  if(kmem.use_lock)
+801024bf:	a1 74 26 11 80       	mov    0x80112674,%eax
+  kmem.freelist = r;
+801024c4:	89 1d 78 26 11 80    	mov    %ebx,0x80112678
+  if(kmem.use_lock)
+801024ca:	85 c0                	test   %eax,%eax
+801024cc:	75 22                	jne    801024f0 <kfree+0x80>
+    release(&kmem.lock);
+}
+801024ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+801024d1:	c9                   	leave  
+801024d2:	c3                   	ret    
+801024d3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801024d7:	90                   	nop
+    acquire(&kmem.lock);
+801024d8:	83 ec 0c             	sub    $0xc,%esp
+801024db:	68 40 26 11 80       	push   $0x80112640
+801024e0:	e8 fb 22 00 00       	call   801047e0 <acquire>
+801024e5:	83 c4 10             	add    $0x10,%esp
+801024e8:	eb ce                	jmp    801024b8 <kfree+0x48>
+801024ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    release(&kmem.lock);
+801024f0:	c7 45 08 40 26 11 80 	movl   $0x80112640,0x8(%ebp)
+}
+801024f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+801024fa:	c9                   	leave  
+    release(&kmem.lock);
+801024fb:	e9 a0 23 00 00       	jmp    801048a0 <release>
+    panic("kfree");
+80102500:	83 ec 0c             	sub    $0xc,%esp
+80102503:	68 26 77 10 80       	push   $0x80107726
+80102508:	e8 83 de ff ff       	call   80100390 <panic>
+8010250d:	8d 76 00             	lea    0x0(%esi),%esi
+
+80102510 <freerange>:
+{
+80102510:	f3 0f 1e fb          	endbr32 
+80102514:	55                   	push   %ebp
+80102515:	89 e5                	mov    %esp,%ebp
+80102517:	56                   	push   %esi
+  p = (char*)PGROUNDUP((uint)vstart);
+80102518:	8b 45 08             	mov    0x8(%ebp),%eax
+{
+8010251b:	8b 75 0c             	mov    0xc(%ebp),%esi
+8010251e:	53                   	push   %ebx
+  p = (char*)PGROUNDUP((uint)vstart);
+8010251f:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
+80102525:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+8010252b:	81 c3 00 10 00 00    	add    $0x1000,%ebx
+80102531:	39 de                	cmp    %ebx,%esi
+80102533:	72 1f                	jb     80102554 <freerange+0x44>
+80102535:	8d 76 00             	lea    0x0(%esi),%esi
+    kfree(p);
+80102538:	83 ec 0c             	sub    $0xc,%esp
+8010253b:	8d 83 00 f0 ff ff    	lea    -0x1000(%ebx),%eax
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+80102541:	81 c3 00 10 00 00    	add    $0x1000,%ebx
+    kfree(p);
+80102547:	50                   	push   %eax
+80102548:	e8 23 ff ff ff       	call   80102470 <kfree>
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+8010254d:	83 c4 10             	add    $0x10,%esp
+80102550:	39 f3                	cmp    %esi,%ebx
+80102552:	76 e4                	jbe    80102538 <freerange+0x28>
+}
+80102554:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80102557:	5b                   	pop    %ebx
+80102558:	5e                   	pop    %esi
+80102559:	5d                   	pop    %ebp
+8010255a:	c3                   	ret    
+8010255b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010255f:	90                   	nop
+
+80102560 <kinit1>:
+{
+80102560:	f3 0f 1e fb          	endbr32 
+80102564:	55                   	push   %ebp
+80102565:	89 e5                	mov    %esp,%ebp
+80102567:	56                   	push   %esi
+80102568:	53                   	push   %ebx
+80102569:	8b 75 0c             	mov    0xc(%ebp),%esi
+  initlock(&kmem.lock, "kmem");
+8010256c:	83 ec 08             	sub    $0x8,%esp
+8010256f:	68 2c 77 10 80       	push   $0x8010772c
+80102574:	68 40 26 11 80       	push   $0x80112640
+80102579:	e8 e2 20 00 00       	call   80104660 <initlock>
+  p = (char*)PGROUNDUP((uint)vstart);
+8010257e:	8b 45 08             	mov    0x8(%ebp),%eax
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+80102581:	83 c4 10             	add    $0x10,%esp
+  kmem.use_lock = 0;
+80102584:	c7 05 74 26 11 80 00 	movl   $0x0,0x80112674
+8010258b:	00 00 00 
+  p = (char*)PGROUNDUP((uint)vstart);
+8010258e:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
+80102594:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+8010259a:	81 c3 00 10 00 00    	add    $0x1000,%ebx
+801025a0:	39 de                	cmp    %ebx,%esi
+801025a2:	72 20                	jb     801025c4 <kinit1+0x64>
+801025a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    kfree(p);
+801025a8:	83 ec 0c             	sub    $0xc,%esp
+801025ab:	8d 83 00 f0 ff ff    	lea    -0x1000(%ebx),%eax
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+801025b1:	81 c3 00 10 00 00    	add    $0x1000,%ebx
+    kfree(p);
+801025b7:	50                   	push   %eax
+801025b8:	e8 b3 fe ff ff       	call   80102470 <kfree>
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+801025bd:	83 c4 10             	add    $0x10,%esp
+801025c0:	39 de                	cmp    %ebx,%esi
+801025c2:	73 e4                	jae    801025a8 <kinit1+0x48>
+}
+801025c4:	8d 65 f8             	lea    -0x8(%ebp),%esp
+801025c7:	5b                   	pop    %ebx
+801025c8:	5e                   	pop    %esi
+801025c9:	5d                   	pop    %ebp
+801025ca:	c3                   	ret    
+801025cb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801025cf:	90                   	nop
+
+801025d0 <kinit2>:
+{
+801025d0:	f3 0f 1e fb          	endbr32 
+801025d4:	55                   	push   %ebp
+801025d5:	89 e5                	mov    %esp,%ebp
+801025d7:	56                   	push   %esi
+  p = (char*)PGROUNDUP((uint)vstart);
+801025d8:	8b 45 08             	mov    0x8(%ebp),%eax
+{
+801025db:	8b 75 0c             	mov    0xc(%ebp),%esi
+801025de:	53                   	push   %ebx
+  p = (char*)PGROUNDUP((uint)vstart);
+801025df:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
+801025e5:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+801025eb:	81 c3 00 10 00 00    	add    $0x1000,%ebx
+801025f1:	39 de                	cmp    %ebx,%esi
+801025f3:	72 1f                	jb     80102614 <kinit2+0x44>
+801025f5:	8d 76 00             	lea    0x0(%esi),%esi
+    kfree(p);
+801025f8:	83 ec 0c             	sub    $0xc,%esp
+801025fb:	8d 83 00 f0 ff ff    	lea    -0x1000(%ebx),%eax
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+80102601:	81 c3 00 10 00 00    	add    $0x1000,%ebx
+    kfree(p);
+80102607:	50                   	push   %eax
+80102608:	e8 63 fe ff ff       	call   80102470 <kfree>
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+8010260d:	83 c4 10             	add    $0x10,%esp
+80102610:	39 de                	cmp    %ebx,%esi
+80102612:	73 e4                	jae    801025f8 <kinit2+0x28>
+  kmem.use_lock = 1;
+80102614:	c7 05 74 26 11 80 01 	movl   $0x1,0x80112674
+8010261b:	00 00 00 
+}
+8010261e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80102621:	5b                   	pop    %ebx
+80102622:	5e                   	pop    %esi
+80102623:	5d                   	pop    %ebp
+80102624:	c3                   	ret    
+80102625:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010262c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80102630 <kalloc>:
+// Allocate one 4096-byte page of physical memory.
+// Returns a pointer that the kernel can use.
+// Returns 0 if the memory cannot be allocated.
+char*
+kalloc(void)
+{
+80102630:	f3 0f 1e fb          	endbr32 
+  struct run *r;
+
+  if(kmem.use_lock)
+80102634:	a1 74 26 11 80       	mov    0x80112674,%eax
+80102639:	85 c0                	test   %eax,%eax
+8010263b:	75 1b                	jne    80102658 <kalloc+0x28>
+    acquire(&kmem.lock);
+  r = kmem.freelist;
+8010263d:	a1 78 26 11 80       	mov    0x80112678,%eax
+  if(r)
+80102642:	85 c0                	test   %eax,%eax
+80102644:	74 0a                	je     80102650 <kalloc+0x20>
+    kmem.freelist = r->next;
+80102646:	8b 10                	mov    (%eax),%edx
+80102648:	89 15 78 26 11 80    	mov    %edx,0x80112678
+  if(kmem.use_lock)
+8010264e:	c3                   	ret    
+8010264f:	90                   	nop
+    release(&kmem.lock);
+  return (char*)r;
+}
+80102650:	c3                   	ret    
+80102651:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+{
+80102658:	55                   	push   %ebp
+80102659:	89 e5                	mov    %esp,%ebp
+8010265b:	83 ec 24             	sub    $0x24,%esp
+    acquire(&kmem.lock);
+8010265e:	68 40 26 11 80       	push   $0x80112640
+80102663:	e8 78 21 00 00       	call   801047e0 <acquire>
+  r = kmem.freelist;
+80102668:	a1 78 26 11 80       	mov    0x80112678,%eax
+  if(r)
+8010266d:	8b 15 74 26 11 80    	mov    0x80112674,%edx
+80102673:	83 c4 10             	add    $0x10,%esp
+80102676:	85 c0                	test   %eax,%eax
+80102678:	74 08                	je     80102682 <kalloc+0x52>
+    kmem.freelist = r->next;
+8010267a:	8b 08                	mov    (%eax),%ecx
+8010267c:	89 0d 78 26 11 80    	mov    %ecx,0x80112678
+  if(kmem.use_lock)
+80102682:	85 d2                	test   %edx,%edx
+80102684:	74 16                	je     8010269c <kalloc+0x6c>
+    release(&kmem.lock);
+80102686:	83 ec 0c             	sub    $0xc,%esp
+80102689:	89 45 f4             	mov    %eax,-0xc(%ebp)
+8010268c:	68 40 26 11 80       	push   $0x80112640
+80102691:	e8 0a 22 00 00       	call   801048a0 <release>
+  return (char*)r;
+80102696:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    release(&kmem.lock);
+80102699:	83 c4 10             	add    $0x10,%esp
+}
+8010269c:	c9                   	leave  
+8010269d:	c3                   	ret    
+8010269e:	66 90                	xchg   %ax,%ax
+
+801026a0 <kbdgetc>:
+#include "defs.h"
+#include "kbd.h"
+
+int
+kbdgetc(void)
+{
+801026a0:	f3 0f 1e fb          	endbr32 
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+801026a4:	ba 64 00 00 00       	mov    $0x64,%edx
+801026a9:	ec                   	in     (%dx),%al
+    normalmap, shiftmap, ctlmap, ctlmap
+  };
+  uint st, data, c;
+
+  st = inb(KBSTATP);
+  if((st & KBS_DIB) == 0)
+801026aa:	a8 01                	test   $0x1,%al
+801026ac:	0f 84 be 00 00 00    	je     80102770 <kbdgetc+0xd0>
+{
+801026b2:	55                   	push   %ebp
+801026b3:	ba 60 00 00 00       	mov    $0x60,%edx
+801026b8:	89 e5                	mov    %esp,%ebp
+801026ba:	53                   	push   %ebx
+801026bb:	ec                   	in     (%dx),%al
+  return data;
+801026bc:	8b 1d b4 a5 10 80    	mov    0x8010a5b4,%ebx
+    return -1;
+  data = inb(KBDATAP);
+801026c2:	0f b6 d0             	movzbl %al,%edx
+
+  if(data == 0xE0){
+801026c5:	3c e0                	cmp    $0xe0,%al
+801026c7:	74 57                	je     80102720 <kbdgetc+0x80>
+    shift |= E0ESC;
+    return 0;
+  } else if(data & 0x80){
+801026c9:	89 d9                	mov    %ebx,%ecx
+801026cb:	83 e1 40             	and    $0x40,%ecx
+801026ce:	84 c0                	test   %al,%al
+801026d0:	78 5e                	js     80102730 <kbdgetc+0x90>
+    // Key released
+    data = (shift & E0ESC ? data : data & 0x7F);
+    shift &= ~(shiftcode[data] | E0ESC);
+    return 0;
+  } else if(shift & E0ESC){
+801026d2:	85 c9                	test   %ecx,%ecx
+801026d4:	74 09                	je     801026df <kbdgetc+0x3f>
+    // Last character was an E0 escape; or with 0x80
+    data |= 0x80;
+801026d6:	83 c8 80             	or     $0xffffff80,%eax
+    shift &= ~E0ESC;
+801026d9:	83 e3 bf             	and    $0xffffffbf,%ebx
+    data |= 0x80;
+801026dc:	0f b6 d0             	movzbl %al,%edx
+  }
+
+  shift |= shiftcode[data];
+801026df:	0f b6 8a 60 78 10 80 	movzbl -0x7fef87a0(%edx),%ecx
+  shift ^= togglecode[data];
+801026e6:	0f b6 82 60 77 10 80 	movzbl -0x7fef88a0(%edx),%eax
+  shift |= shiftcode[data];
+801026ed:	09 d9                	or     %ebx,%ecx
+  shift ^= togglecode[data];
+801026ef:	31 c1                	xor    %eax,%ecx
+  c = charcode[shift & (CTL | SHIFT)][data];
+801026f1:	89 c8                	mov    %ecx,%eax
+  shift ^= togglecode[data];
+801026f3:	89 0d b4 a5 10 80    	mov    %ecx,0x8010a5b4
+  c = charcode[shift & (CTL | SHIFT)][data];
+801026f9:	83 e0 03             	and    $0x3,%eax
+  if(shift & CAPSLOCK){
+801026fc:	83 e1 08             	and    $0x8,%ecx
+  c = charcode[shift & (CTL | SHIFT)][data];
+801026ff:	8b 04 85 40 77 10 80 	mov    -0x7fef88c0(,%eax,4),%eax
+80102706:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
+  if(shift & CAPSLOCK){
+8010270a:	74 0b                	je     80102717 <kbdgetc+0x77>
+    if('a' <= c && c <= 'z')
+8010270c:	8d 50 9f             	lea    -0x61(%eax),%edx
+8010270f:	83 fa 19             	cmp    $0x19,%edx
+80102712:	77 44                	ja     80102758 <kbdgetc+0xb8>
+      c += 'A' - 'a';
+80102714:	83 e8 20             	sub    $0x20,%eax
+    else if('A' <= c && c <= 'Z')
+      c += 'a' - 'A';
+  }
+  return c;
+}
+80102717:	5b                   	pop    %ebx
+80102718:	5d                   	pop    %ebp
+80102719:	c3                   	ret    
+8010271a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    shift |= E0ESC;
+80102720:	83 cb 40             	or     $0x40,%ebx
+    return 0;
+80102723:	31 c0                	xor    %eax,%eax
+    shift |= E0ESC;
+80102725:	89 1d b4 a5 10 80    	mov    %ebx,0x8010a5b4
+}
+8010272b:	5b                   	pop    %ebx
+8010272c:	5d                   	pop    %ebp
+8010272d:	c3                   	ret    
+8010272e:	66 90                	xchg   %ax,%ax
+    data = (shift & E0ESC ? data : data & 0x7F);
+80102730:	83 e0 7f             	and    $0x7f,%eax
+80102733:	85 c9                	test   %ecx,%ecx
+80102735:	0f 44 d0             	cmove  %eax,%edx
+    return 0;
+80102738:	31 c0                	xor    %eax,%eax
+    shift &= ~(shiftcode[data] | E0ESC);
+8010273a:	0f b6 8a 60 78 10 80 	movzbl -0x7fef87a0(%edx),%ecx
+80102741:	83 c9 40             	or     $0x40,%ecx
+80102744:	0f b6 c9             	movzbl %cl,%ecx
+80102747:	f7 d1                	not    %ecx
+80102749:	21 d9                	and    %ebx,%ecx
+}
+8010274b:	5b                   	pop    %ebx
+8010274c:	5d                   	pop    %ebp
+    shift &= ~(shiftcode[data] | E0ESC);
+8010274d:	89 0d b4 a5 10 80    	mov    %ecx,0x8010a5b4
+}
+80102753:	c3                   	ret    
+80102754:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    else if('A' <= c && c <= 'Z')
+80102758:	8d 48 bf             	lea    -0x41(%eax),%ecx
+      c += 'a' - 'A';
+8010275b:	8d 50 20             	lea    0x20(%eax),%edx
+}
+8010275e:	5b                   	pop    %ebx
+8010275f:	5d                   	pop    %ebp
+      c += 'a' - 'A';
+80102760:	83 f9 1a             	cmp    $0x1a,%ecx
+80102763:	0f 42 c2             	cmovb  %edx,%eax
+}
+80102766:	c3                   	ret    
+80102767:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010276e:	66 90                	xchg   %ax,%ax
+    return -1;
+80102770:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80102775:	c3                   	ret    
+80102776:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010277d:	8d 76 00             	lea    0x0(%esi),%esi
+
+80102780 <kbdintr>:
+
+void
+kbdintr(void)
+{
+80102780:	f3 0f 1e fb          	endbr32 
+80102784:	55                   	push   %ebp
+80102785:	89 e5                	mov    %esp,%ebp
+80102787:	83 ec 14             	sub    $0x14,%esp
+  consoleintr(kbdgetc);
+8010278a:	68 a0 26 10 80       	push   $0x801026a0
+8010278f:	e8 cc e0 ff ff       	call   80100860 <consoleintr>
+}
+80102794:	83 c4 10             	add    $0x10,%esp
+80102797:	c9                   	leave  
+80102798:	c3                   	ret    
+80102799:	66 90                	xchg   %ax,%ax
+8010279b:	66 90                	xchg   %ax,%ax
+8010279d:	66 90                	xchg   %ax,%ax
+8010279f:	90                   	nop
+
+801027a0 <lapicinit>:
+  lapic[ID];  // wait for write to finish, by reading
+}
+
+void
+lapicinit(void)
+{
+801027a0:	f3 0f 1e fb          	endbr32 
+  if(!lapic)
+801027a4:	a1 7c 26 11 80       	mov    0x8011267c,%eax
+801027a9:	85 c0                	test   %eax,%eax
+801027ab:	0f 84 c7 00 00 00    	je     80102878 <lapicinit+0xd8>
+  lapic[index] = value;
+801027b1:	c7 80 f0 00 00 00 3f 	movl   $0x13f,0xf0(%eax)
+801027b8:	01 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+801027bb:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+801027be:	c7 80 e0 03 00 00 0b 	movl   $0xb,0x3e0(%eax)
+801027c5:	00 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+801027c8:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+801027cb:	c7 80 20 03 00 00 20 	movl   $0x20020,0x320(%eax)
+801027d2:	00 02 00 
+  lapic[ID];  // wait for write to finish, by reading
+801027d5:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+801027d8:	c7 80 80 03 00 00 80 	movl   $0x989680,0x380(%eax)
+801027df:	96 98 00 
+  lapic[ID];  // wait for write to finish, by reading
+801027e2:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+801027e5:	c7 80 50 03 00 00 00 	movl   $0x10000,0x350(%eax)
+801027ec:	00 01 00 
+  lapic[ID];  // wait for write to finish, by reading
+801027ef:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+801027f2:	c7 80 60 03 00 00 00 	movl   $0x10000,0x360(%eax)
+801027f9:	00 01 00 
+  lapic[ID];  // wait for write to finish, by reading
+801027fc:	8b 50 20             	mov    0x20(%eax),%edx
+  lapicw(LINT0, MASKED);
+  lapicw(LINT1, MASKED);
+
+  // Disable performance counter overflow interrupts
+  // on machines that provide that interrupt entry.
+  if(((lapic[VER]>>16) & 0xFF) >= 4)
+801027ff:	8b 50 30             	mov    0x30(%eax),%edx
+80102802:	c1 ea 10             	shr    $0x10,%edx
+80102805:	81 e2 fc 00 00 00    	and    $0xfc,%edx
+8010280b:	75 73                	jne    80102880 <lapicinit+0xe0>
+  lapic[index] = value;
+8010280d:	c7 80 70 03 00 00 33 	movl   $0x33,0x370(%eax)
+80102814:	00 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+80102817:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+8010281a:	c7 80 80 02 00 00 00 	movl   $0x0,0x280(%eax)
+80102821:	00 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+80102824:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+80102827:	c7 80 80 02 00 00 00 	movl   $0x0,0x280(%eax)
+8010282e:	00 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+80102831:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+80102834:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
+8010283b:	00 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+8010283e:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+80102841:	c7 80 10 03 00 00 00 	movl   $0x0,0x310(%eax)
+80102848:	00 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+8010284b:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+8010284e:	c7 80 00 03 00 00 00 	movl   $0x88500,0x300(%eax)
+80102855:	85 08 00 
+  lapic[ID];  // wait for write to finish, by reading
+80102858:	8b 50 20             	mov    0x20(%eax),%edx
+8010285b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010285f:	90                   	nop
+  lapicw(EOI, 0);
+
+  // Send an Init Level De-Assert to synchronise arbitration ID's.
+  lapicw(ICRHI, 0);
+  lapicw(ICRLO, BCAST | INIT | LEVEL);
+  while(lapic[ICRLO] & DELIVS)
+80102860:	8b 90 00 03 00 00    	mov    0x300(%eax),%edx
+80102866:	80 e6 10             	and    $0x10,%dh
+80102869:	75 f5                	jne    80102860 <lapicinit+0xc0>
+  lapic[index] = value;
+8010286b:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
+80102872:	00 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+80102875:	8b 40 20             	mov    0x20(%eax),%eax
+    ;
+
+  // Enable interrupts on the APIC (but not on the processor).
+  lapicw(TPR, 0);
+}
+80102878:	c3                   	ret    
+80102879:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  lapic[index] = value;
+80102880:	c7 80 40 03 00 00 00 	movl   $0x10000,0x340(%eax)
+80102887:	00 01 00 
+  lapic[ID];  // wait for write to finish, by reading
+8010288a:	8b 50 20             	mov    0x20(%eax),%edx
+}
+8010288d:	e9 7b ff ff ff       	jmp    8010280d <lapicinit+0x6d>
+80102892:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80102899:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+801028a0 <lapicid>:
+
+int
+lapicid(void)
+{
+801028a0:	f3 0f 1e fb          	endbr32 
+  if (!lapic)
+801028a4:	a1 7c 26 11 80       	mov    0x8011267c,%eax
+801028a9:	85 c0                	test   %eax,%eax
+801028ab:	74 0b                	je     801028b8 <lapicid+0x18>
+    return 0;
+  return lapic[ID] >> 24;
+801028ad:	8b 40 20             	mov    0x20(%eax),%eax
+801028b0:	c1 e8 18             	shr    $0x18,%eax
+801028b3:	c3                   	ret    
+801028b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return 0;
+801028b8:	31 c0                	xor    %eax,%eax
+}
+801028ba:	c3                   	ret    
+801028bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801028bf:	90                   	nop
+
+801028c0 <lapiceoi>:
+
+// Acknowledge interrupt.
+void
+lapiceoi(void)
+{
+801028c0:	f3 0f 1e fb          	endbr32 
+  if(lapic)
+801028c4:	a1 7c 26 11 80       	mov    0x8011267c,%eax
+801028c9:	85 c0                	test   %eax,%eax
+801028cb:	74 0d                	je     801028da <lapiceoi+0x1a>
+  lapic[index] = value;
+801028cd:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
+801028d4:	00 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+801028d7:	8b 40 20             	mov    0x20(%eax),%eax
+    lapicw(EOI, 0);
+}
+801028da:	c3                   	ret    
+801028db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801028df:	90                   	nop
+
+801028e0 <microdelay>:
+
+// Spin for a given number of microseconds.
+// On real hardware would want to tune this dynamically.
+void
+microdelay(int us)
+{
+801028e0:	f3 0f 1e fb          	endbr32 
+}
+801028e4:	c3                   	ret    
+801028e5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801028ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+801028f0 <lapicstartap>:
+
+// Start additional processor running entry code at addr.
+// See Appendix B of MultiProcessor Specification.
+void
+lapicstartap(uchar apicid, uint addr)
+{
+801028f0:	f3 0f 1e fb          	endbr32 
+801028f4:	55                   	push   %ebp
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801028f5:	b8 0f 00 00 00       	mov    $0xf,%eax
+801028fa:	ba 70 00 00 00       	mov    $0x70,%edx
+801028ff:	89 e5                	mov    %esp,%ebp
+80102901:	53                   	push   %ebx
+80102902:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+80102905:	8b 5d 08             	mov    0x8(%ebp),%ebx
+80102908:	ee                   	out    %al,(%dx)
+80102909:	b8 0a 00 00 00       	mov    $0xa,%eax
+8010290e:	ba 71 00 00 00       	mov    $0x71,%edx
+80102913:	ee                   	out    %al,(%dx)
+  // and the warm reset vector (DWORD based at 40:67) to point at
+  // the AP startup code prior to the [universal startup algorithm]."
+  outb(CMOS_PORT, 0xF);  // offset 0xF is shutdown code
+  outb(CMOS_PORT+1, 0x0A);
+  wrv = (ushort*)P2V((0x40<<4 | 0x67));  // Warm reset vector
+  wrv[0] = 0;
+80102914:	31 c0                	xor    %eax,%eax
+  wrv[1] = addr >> 4;
+
+  // "Universal startup algorithm."
+  // Send INIT (level-triggered) interrupt to reset other CPU.
+  lapicw(ICRHI, apicid<<24);
+80102916:	c1 e3 18             	shl    $0x18,%ebx
+  wrv[0] = 0;
+80102919:	66 a3 67 04 00 80    	mov    %ax,0x80000467
+  wrv[1] = addr >> 4;
+8010291f:	89 c8                	mov    %ecx,%eax
+  // when it is in the halted state due to an INIT.  So the second
+  // should be ignored, but it is part of the official Intel algorithm.
+  // Bochs complains about the second one.  Too bad for Bochs.
+  for(i = 0; i < 2; i++){
+    lapicw(ICRHI, apicid<<24);
+    lapicw(ICRLO, STARTUP | (addr>>12));
+80102921:	c1 e9 0c             	shr    $0xc,%ecx
+  lapicw(ICRHI, apicid<<24);
+80102924:	89 da                	mov    %ebx,%edx
+  wrv[1] = addr >> 4;
+80102926:	c1 e8 04             	shr    $0x4,%eax
+    lapicw(ICRLO, STARTUP | (addr>>12));
+80102929:	80 cd 06             	or     $0x6,%ch
+  wrv[1] = addr >> 4;
+8010292c:	66 a3 69 04 00 80    	mov    %ax,0x80000469
+  lapic[index] = value;
+80102932:	a1 7c 26 11 80       	mov    0x8011267c,%eax
+80102937:	89 98 10 03 00 00    	mov    %ebx,0x310(%eax)
+  lapic[ID];  // wait for write to finish, by reading
+8010293d:	8b 58 20             	mov    0x20(%eax),%ebx
+  lapic[index] = value;
+80102940:	c7 80 00 03 00 00 00 	movl   $0xc500,0x300(%eax)
+80102947:	c5 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+8010294a:	8b 58 20             	mov    0x20(%eax),%ebx
+  lapic[index] = value;
+8010294d:	c7 80 00 03 00 00 00 	movl   $0x8500,0x300(%eax)
+80102954:	85 00 00 
+  lapic[ID];  // wait for write to finish, by reading
+80102957:	8b 58 20             	mov    0x20(%eax),%ebx
+  lapic[index] = value;
+8010295a:	89 90 10 03 00 00    	mov    %edx,0x310(%eax)
+  lapic[ID];  // wait for write to finish, by reading
+80102960:	8b 58 20             	mov    0x20(%eax),%ebx
+  lapic[index] = value;
+80102963:	89 88 00 03 00 00    	mov    %ecx,0x300(%eax)
+  lapic[ID];  // wait for write to finish, by reading
+80102969:	8b 58 20             	mov    0x20(%eax),%ebx
+  lapic[index] = value;
+8010296c:	89 90 10 03 00 00    	mov    %edx,0x310(%eax)
+  lapic[ID];  // wait for write to finish, by reading
+80102972:	8b 50 20             	mov    0x20(%eax),%edx
+  lapic[index] = value;
+80102975:	89 88 00 03 00 00    	mov    %ecx,0x300(%eax)
+    microdelay(200);
+  }
+}
+8010297b:	5b                   	pop    %ebx
+  lapic[ID];  // wait for write to finish, by reading
+8010297c:	8b 40 20             	mov    0x20(%eax),%eax
+}
+8010297f:	5d                   	pop    %ebp
+80102980:	c3                   	ret    
+80102981:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80102988:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010298f:	90                   	nop
+
+80102990 <cmostime>:
+}
+
+// qemu seems to use 24-hour GWT and the values are BCD encoded
+void
+cmostime(struct rtcdate *r)
+{
+80102990:	f3 0f 1e fb          	endbr32 
+80102994:	55                   	push   %ebp
+80102995:	b8 0b 00 00 00       	mov    $0xb,%eax
+8010299a:	ba 70 00 00 00       	mov    $0x70,%edx
+8010299f:	89 e5                	mov    %esp,%ebp
+801029a1:	57                   	push   %edi
+801029a2:	56                   	push   %esi
+801029a3:	53                   	push   %ebx
+801029a4:	83 ec 4c             	sub    $0x4c,%esp
+801029a7:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+801029a8:	ba 71 00 00 00       	mov    $0x71,%edx
+801029ad:	ec                   	in     (%dx),%al
+  struct rtcdate t1, t2;
+  int sb, bcd;
+
+  sb = cmos_read(CMOS_STATB);
+
+  bcd = (sb & (1 << 2)) == 0;
+801029ae:	83 e0 04             	and    $0x4,%eax
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801029b1:	bb 70 00 00 00       	mov    $0x70,%ebx
+801029b6:	88 45 b3             	mov    %al,-0x4d(%ebp)
+801029b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801029c0:	31 c0                	xor    %eax,%eax
+801029c2:	89 da                	mov    %ebx,%edx
+801029c4:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+801029c5:	b9 71 00 00 00       	mov    $0x71,%ecx
+801029ca:	89 ca                	mov    %ecx,%edx
+801029cc:	ec                   	in     (%dx),%al
+801029cd:	88 45 b7             	mov    %al,-0x49(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801029d0:	89 da                	mov    %ebx,%edx
+801029d2:	b8 02 00 00 00       	mov    $0x2,%eax
+801029d7:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+801029d8:	89 ca                	mov    %ecx,%edx
+801029da:	ec                   	in     (%dx),%al
+801029db:	88 45 b6             	mov    %al,-0x4a(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801029de:	89 da                	mov    %ebx,%edx
+801029e0:	b8 04 00 00 00       	mov    $0x4,%eax
+801029e5:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+801029e6:	89 ca                	mov    %ecx,%edx
+801029e8:	ec                   	in     (%dx),%al
+801029e9:	88 45 b5             	mov    %al,-0x4b(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801029ec:	89 da                	mov    %ebx,%edx
+801029ee:	b8 07 00 00 00       	mov    $0x7,%eax
+801029f3:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+801029f4:	89 ca                	mov    %ecx,%edx
+801029f6:	ec                   	in     (%dx),%al
+801029f7:	88 45 b4             	mov    %al,-0x4c(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801029fa:	89 da                	mov    %ebx,%edx
+801029fc:	b8 08 00 00 00       	mov    $0x8,%eax
+80102a01:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102a02:	89 ca                	mov    %ecx,%edx
+80102a04:	ec                   	in     (%dx),%al
+80102a05:	89 c7                	mov    %eax,%edi
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80102a07:	89 da                	mov    %ebx,%edx
+80102a09:	b8 09 00 00 00       	mov    $0x9,%eax
+80102a0e:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102a0f:	89 ca                	mov    %ecx,%edx
+80102a11:	ec                   	in     (%dx),%al
+80102a12:	89 c6                	mov    %eax,%esi
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80102a14:	89 da                	mov    %ebx,%edx
+80102a16:	b8 0a 00 00 00       	mov    $0xa,%eax
+80102a1b:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102a1c:	89 ca                	mov    %ecx,%edx
+80102a1e:	ec                   	in     (%dx),%al
+
+  // make sure CMOS doesn't modify time while we read it
+  for(;;) {
+    fill_rtcdate(&t1);
+    if(cmos_read(CMOS_STATA) & CMOS_UIP)
+80102a1f:	84 c0                	test   %al,%al
+80102a21:	78 9d                	js     801029c0 <cmostime+0x30>
+  return inb(CMOS_RETURN);
+80102a23:	0f b6 45 b7          	movzbl -0x49(%ebp),%eax
+80102a27:	89 fa                	mov    %edi,%edx
+80102a29:	0f b6 fa             	movzbl %dl,%edi
+80102a2c:	89 f2                	mov    %esi,%edx
+80102a2e:	89 45 b8             	mov    %eax,-0x48(%ebp)
+80102a31:	0f b6 45 b6          	movzbl -0x4a(%ebp),%eax
+80102a35:	0f b6 f2             	movzbl %dl,%esi
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80102a38:	89 da                	mov    %ebx,%edx
+80102a3a:	89 7d c8             	mov    %edi,-0x38(%ebp)
+80102a3d:	89 45 bc             	mov    %eax,-0x44(%ebp)
+80102a40:	0f b6 45 b5          	movzbl -0x4b(%ebp),%eax
+80102a44:	89 75 cc             	mov    %esi,-0x34(%ebp)
+80102a47:	89 45 c0             	mov    %eax,-0x40(%ebp)
+80102a4a:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
+80102a4e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+80102a51:	31 c0                	xor    %eax,%eax
+80102a53:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102a54:	89 ca                	mov    %ecx,%edx
+80102a56:	ec                   	in     (%dx),%al
+80102a57:	0f b6 c0             	movzbl %al,%eax
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80102a5a:	89 da                	mov    %ebx,%edx
+80102a5c:	89 45 d0             	mov    %eax,-0x30(%ebp)
+80102a5f:	b8 02 00 00 00       	mov    $0x2,%eax
+80102a64:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102a65:	89 ca                	mov    %ecx,%edx
+80102a67:	ec                   	in     (%dx),%al
+80102a68:	0f b6 c0             	movzbl %al,%eax
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80102a6b:	89 da                	mov    %ebx,%edx
+80102a6d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+80102a70:	b8 04 00 00 00       	mov    $0x4,%eax
+80102a75:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102a76:	89 ca                	mov    %ecx,%edx
+80102a78:	ec                   	in     (%dx),%al
+80102a79:	0f b6 c0             	movzbl %al,%eax
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80102a7c:	89 da                	mov    %ebx,%edx
+80102a7e:	89 45 d8             	mov    %eax,-0x28(%ebp)
+80102a81:	b8 07 00 00 00       	mov    $0x7,%eax
+80102a86:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102a87:	89 ca                	mov    %ecx,%edx
+80102a89:	ec                   	in     (%dx),%al
+80102a8a:	0f b6 c0             	movzbl %al,%eax
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80102a8d:	89 da                	mov    %ebx,%edx
+80102a8f:	89 45 dc             	mov    %eax,-0x24(%ebp)
+80102a92:	b8 08 00 00 00       	mov    $0x8,%eax
+80102a97:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102a98:	89 ca                	mov    %ecx,%edx
+80102a9a:	ec                   	in     (%dx),%al
+80102a9b:	0f b6 c0             	movzbl %al,%eax
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80102a9e:	89 da                	mov    %ebx,%edx
+80102aa0:	89 45 e0             	mov    %eax,-0x20(%ebp)
+80102aa3:	b8 09 00 00 00       	mov    $0x9,%eax
+80102aa8:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102aa9:	89 ca                	mov    %ecx,%edx
+80102aab:	ec                   	in     (%dx),%al
+80102aac:	0f b6 c0             	movzbl %al,%eax
+        continue;
+    fill_rtcdate(&t2);
+    if(memcmp(&t1, &t2, sizeof(t1)) == 0)
+80102aaf:	83 ec 04             	sub    $0x4,%esp
+  return inb(CMOS_RETURN);
+80102ab2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(memcmp(&t1, &t2, sizeof(t1)) == 0)
+80102ab5:	8d 45 d0             	lea    -0x30(%ebp),%eax
+80102ab8:	6a 18                	push   $0x18
+80102aba:	50                   	push   %eax
+80102abb:	8d 45 b8             	lea    -0x48(%ebp),%eax
+80102abe:	50                   	push   %eax
+80102abf:	e8 7c 1e 00 00       	call   80104940 <memcmp>
+80102ac4:	83 c4 10             	add    $0x10,%esp
+80102ac7:	85 c0                	test   %eax,%eax
+80102ac9:	0f 85 f1 fe ff ff    	jne    801029c0 <cmostime+0x30>
+      break;
+  }
+
+  // convert
+  if(bcd) {
+80102acf:	80 7d b3 00          	cmpb   $0x0,-0x4d(%ebp)
+80102ad3:	75 78                	jne    80102b4d <cmostime+0x1bd>
+#define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
+    CONV(second);
+80102ad5:	8b 45 b8             	mov    -0x48(%ebp),%eax
+80102ad8:	89 c2                	mov    %eax,%edx
+80102ada:	83 e0 0f             	and    $0xf,%eax
+80102add:	c1 ea 04             	shr    $0x4,%edx
+80102ae0:	8d 14 92             	lea    (%edx,%edx,4),%edx
+80102ae3:	8d 04 50             	lea    (%eax,%edx,2),%eax
+80102ae6:	89 45 b8             	mov    %eax,-0x48(%ebp)
+    CONV(minute);
+80102ae9:	8b 45 bc             	mov    -0x44(%ebp),%eax
+80102aec:	89 c2                	mov    %eax,%edx
+80102aee:	83 e0 0f             	and    $0xf,%eax
+80102af1:	c1 ea 04             	shr    $0x4,%edx
+80102af4:	8d 14 92             	lea    (%edx,%edx,4),%edx
+80102af7:	8d 04 50             	lea    (%eax,%edx,2),%eax
+80102afa:	89 45 bc             	mov    %eax,-0x44(%ebp)
+    CONV(hour  );
+80102afd:	8b 45 c0             	mov    -0x40(%ebp),%eax
+80102b00:	89 c2                	mov    %eax,%edx
+80102b02:	83 e0 0f             	and    $0xf,%eax
+80102b05:	c1 ea 04             	shr    $0x4,%edx
+80102b08:	8d 14 92             	lea    (%edx,%edx,4),%edx
+80102b0b:	8d 04 50             	lea    (%eax,%edx,2),%eax
+80102b0e:	89 45 c0             	mov    %eax,-0x40(%ebp)
+    CONV(day   );
+80102b11:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+80102b14:	89 c2                	mov    %eax,%edx
+80102b16:	83 e0 0f             	and    $0xf,%eax
+80102b19:	c1 ea 04             	shr    $0x4,%edx
+80102b1c:	8d 14 92             	lea    (%edx,%edx,4),%edx
+80102b1f:	8d 04 50             	lea    (%eax,%edx,2),%eax
+80102b22:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+    CONV(month );
+80102b25:	8b 45 c8             	mov    -0x38(%ebp),%eax
+80102b28:	89 c2                	mov    %eax,%edx
+80102b2a:	83 e0 0f             	and    $0xf,%eax
+80102b2d:	c1 ea 04             	shr    $0x4,%edx
+80102b30:	8d 14 92             	lea    (%edx,%edx,4),%edx
+80102b33:	8d 04 50             	lea    (%eax,%edx,2),%eax
+80102b36:	89 45 c8             	mov    %eax,-0x38(%ebp)
+    CONV(year  );
+80102b39:	8b 45 cc             	mov    -0x34(%ebp),%eax
+80102b3c:	89 c2                	mov    %eax,%edx
+80102b3e:	83 e0 0f             	and    $0xf,%eax
+80102b41:	c1 ea 04             	shr    $0x4,%edx
+80102b44:	8d 14 92             	lea    (%edx,%edx,4),%edx
+80102b47:	8d 04 50             	lea    (%eax,%edx,2),%eax
+80102b4a:	89 45 cc             	mov    %eax,-0x34(%ebp)
+#undef     CONV
+  }
+
+  *r = t1;
+80102b4d:	8b 75 08             	mov    0x8(%ebp),%esi
+80102b50:	8b 45 b8             	mov    -0x48(%ebp),%eax
+80102b53:	89 06                	mov    %eax,(%esi)
+80102b55:	8b 45 bc             	mov    -0x44(%ebp),%eax
+80102b58:	89 46 04             	mov    %eax,0x4(%esi)
+80102b5b:	8b 45 c0             	mov    -0x40(%ebp),%eax
+80102b5e:	89 46 08             	mov    %eax,0x8(%esi)
+80102b61:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+80102b64:	89 46 0c             	mov    %eax,0xc(%esi)
+80102b67:	8b 45 c8             	mov    -0x38(%ebp),%eax
+80102b6a:	89 46 10             	mov    %eax,0x10(%esi)
+80102b6d:	8b 45 cc             	mov    -0x34(%ebp),%eax
+80102b70:	89 46 14             	mov    %eax,0x14(%esi)
+  r->year += 2000;
+80102b73:	81 46 14 d0 07 00 00 	addl   $0x7d0,0x14(%esi)
+}
+80102b7a:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80102b7d:	5b                   	pop    %ebx
+80102b7e:	5e                   	pop    %esi
+80102b7f:	5f                   	pop    %edi
+80102b80:	5d                   	pop    %ebp
+80102b81:	c3                   	ret    
+80102b82:	66 90                	xchg   %ax,%ax
+80102b84:	66 90                	xchg   %ax,%ax
+80102b86:	66 90                	xchg   %ax,%ax
+80102b88:	66 90                	xchg   %ax,%ax
+80102b8a:	66 90                	xchg   %ax,%ax
+80102b8c:	66 90                	xchg   %ax,%ax
+80102b8e:	66 90                	xchg   %ax,%ax
+
+80102b90 <install_trans>:
+static void
+install_trans(void)
+{
+  int tail;
+
+  for (tail = 0; tail < log.lh.n; tail++) {
+80102b90:	8b 0d c8 26 11 80    	mov    0x801126c8,%ecx
+80102b96:	85 c9                	test   %ecx,%ecx
+80102b98:	0f 8e 8a 00 00 00    	jle    80102c28 <install_trans+0x98>
+{
+80102b9e:	55                   	push   %ebp
+80102b9f:	89 e5                	mov    %esp,%ebp
+80102ba1:	57                   	push   %edi
+  for (tail = 0; tail < log.lh.n; tail++) {
+80102ba2:	31 ff                	xor    %edi,%edi
+{
+80102ba4:	56                   	push   %esi
+80102ba5:	53                   	push   %ebx
+80102ba6:	83 ec 0c             	sub    $0xc,%esp
+80102ba9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
+80102bb0:	a1 b4 26 11 80       	mov    0x801126b4,%eax
+80102bb5:	83 ec 08             	sub    $0x8,%esp
+80102bb8:	01 f8                	add    %edi,%eax
+80102bba:	83 c0 01             	add    $0x1,%eax
+80102bbd:	50                   	push   %eax
+80102bbe:	ff 35 c4 26 11 80    	pushl  0x801126c4
+80102bc4:	e8 07 d5 ff ff       	call   801000d0 <bread>
+80102bc9:	89 c6                	mov    %eax,%esi
+    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
+80102bcb:	58                   	pop    %eax
+80102bcc:	5a                   	pop    %edx
+80102bcd:	ff 34 bd cc 26 11 80 	pushl  -0x7feed934(,%edi,4)
+80102bd4:	ff 35 c4 26 11 80    	pushl  0x801126c4
+  for (tail = 0; tail < log.lh.n; tail++) {
+80102bda:	83 c7 01             	add    $0x1,%edi
+    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
+80102bdd:	e8 ee d4 ff ff       	call   801000d0 <bread>
+    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+80102be2:	83 c4 0c             	add    $0xc,%esp
+    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
+80102be5:	89 c3                	mov    %eax,%ebx
+    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+80102be7:	8d 46 5c             	lea    0x5c(%esi),%eax
+80102bea:	68 00 02 00 00       	push   $0x200
+80102bef:	50                   	push   %eax
+80102bf0:	8d 43 5c             	lea    0x5c(%ebx),%eax
+80102bf3:	50                   	push   %eax
+80102bf4:	e8 97 1d 00 00       	call   80104990 <memmove>
+    bwrite(dbuf);  // write dst to disk
+80102bf9:	89 1c 24             	mov    %ebx,(%esp)
+80102bfc:	e8 af d5 ff ff       	call   801001b0 <bwrite>
+    brelse(lbuf);
+80102c01:	89 34 24             	mov    %esi,(%esp)
+80102c04:	e8 e7 d5 ff ff       	call   801001f0 <brelse>
+    brelse(dbuf);
+80102c09:	89 1c 24             	mov    %ebx,(%esp)
+80102c0c:	e8 df d5 ff ff       	call   801001f0 <brelse>
+  for (tail = 0; tail < log.lh.n; tail++) {
+80102c11:	83 c4 10             	add    $0x10,%esp
+80102c14:	39 3d c8 26 11 80    	cmp    %edi,0x801126c8
+80102c1a:	7f 94                	jg     80102bb0 <install_trans+0x20>
+  }
+}
+80102c1c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80102c1f:	5b                   	pop    %ebx
+80102c20:	5e                   	pop    %esi
+80102c21:	5f                   	pop    %edi
+80102c22:	5d                   	pop    %ebp
+80102c23:	c3                   	ret    
+80102c24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80102c28:	c3                   	ret    
+80102c29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80102c30 <write_head>:
+// Write in-memory log header to disk.
+// This is the true point at which the
+// current transaction commits.
+static void
+write_head(void)
+{
+80102c30:	55                   	push   %ebp
+80102c31:	89 e5                	mov    %esp,%ebp
+80102c33:	53                   	push   %ebx
+80102c34:	83 ec 0c             	sub    $0xc,%esp
+  struct buf *buf = bread(log.dev, log.start);
+80102c37:	ff 35 b4 26 11 80    	pushl  0x801126b4
+80102c3d:	ff 35 c4 26 11 80    	pushl  0x801126c4
+80102c43:	e8 88 d4 ff ff       	call   801000d0 <bread>
+  struct logheader *hb = (struct logheader *) (buf->data);
+  int i;
+  hb->n = log.lh.n;
+  for (i = 0; i < log.lh.n; i++) {
+80102c48:	83 c4 10             	add    $0x10,%esp
+  struct buf *buf = bread(log.dev, log.start);
+80102c4b:	89 c3                	mov    %eax,%ebx
+  hb->n = log.lh.n;
+80102c4d:	a1 c8 26 11 80       	mov    0x801126c8,%eax
+80102c52:	89 43 5c             	mov    %eax,0x5c(%ebx)
+  for (i = 0; i < log.lh.n; i++) {
+80102c55:	85 c0                	test   %eax,%eax
+80102c57:	7e 19                	jle    80102c72 <write_head+0x42>
+80102c59:	31 d2                	xor    %edx,%edx
+80102c5b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80102c5f:	90                   	nop
+    hb->block[i] = log.lh.block[i];
+80102c60:	8b 0c 95 cc 26 11 80 	mov    -0x7feed934(,%edx,4),%ecx
+80102c67:	89 4c 93 60          	mov    %ecx,0x60(%ebx,%edx,4)
+  for (i = 0; i < log.lh.n; i++) {
+80102c6b:	83 c2 01             	add    $0x1,%edx
+80102c6e:	39 d0                	cmp    %edx,%eax
+80102c70:	75 ee                	jne    80102c60 <write_head+0x30>
+  }
+  bwrite(buf);
+80102c72:	83 ec 0c             	sub    $0xc,%esp
+80102c75:	53                   	push   %ebx
+80102c76:	e8 35 d5 ff ff       	call   801001b0 <bwrite>
+  brelse(buf);
+80102c7b:	89 1c 24             	mov    %ebx,(%esp)
+80102c7e:	e8 6d d5 ff ff       	call   801001f0 <brelse>
+}
+80102c83:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80102c86:	83 c4 10             	add    $0x10,%esp
+80102c89:	c9                   	leave  
+80102c8a:	c3                   	ret    
+80102c8b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80102c8f:	90                   	nop
+
+80102c90 <initlog>:
+{
+80102c90:	f3 0f 1e fb          	endbr32 
+80102c94:	55                   	push   %ebp
+80102c95:	89 e5                	mov    %esp,%ebp
+80102c97:	53                   	push   %ebx
+80102c98:	83 ec 2c             	sub    $0x2c,%esp
+80102c9b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  initlock(&log.lock, "log");
+80102c9e:	68 60 79 10 80       	push   $0x80107960
+80102ca3:	68 80 26 11 80       	push   $0x80112680
+80102ca8:	e8 b3 19 00 00       	call   80104660 <initlock>
+  readsb(dev, &sb);
+80102cad:	58                   	pop    %eax
+80102cae:	8d 45 dc             	lea    -0x24(%ebp),%eax
+80102cb1:	5a                   	pop    %edx
+80102cb2:	50                   	push   %eax
+80102cb3:	53                   	push   %ebx
+80102cb4:	e8 47 e8 ff ff       	call   80101500 <readsb>
+  log.start = sb.logstart;
+80102cb9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  struct buf *buf = bread(log.dev, log.start);
+80102cbc:	59                   	pop    %ecx
+  log.dev = dev;
+80102cbd:	89 1d c4 26 11 80    	mov    %ebx,0x801126c4
+  log.size = sb.nlog;
+80102cc3:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  log.start = sb.logstart;
+80102cc6:	a3 b4 26 11 80       	mov    %eax,0x801126b4
+  log.size = sb.nlog;
+80102ccb:	89 15 b8 26 11 80    	mov    %edx,0x801126b8
+  struct buf *buf = bread(log.dev, log.start);
+80102cd1:	5a                   	pop    %edx
+80102cd2:	50                   	push   %eax
+80102cd3:	53                   	push   %ebx
+80102cd4:	e8 f7 d3 ff ff       	call   801000d0 <bread>
+  for (i = 0; i < log.lh.n; i++) {
+80102cd9:	83 c4 10             	add    $0x10,%esp
+  log.lh.n = lh->n;
+80102cdc:	8b 48 5c             	mov    0x5c(%eax),%ecx
+80102cdf:	89 0d c8 26 11 80    	mov    %ecx,0x801126c8
+  for (i = 0; i < log.lh.n; i++) {
+80102ce5:	85 c9                	test   %ecx,%ecx
+80102ce7:	7e 19                	jle    80102d02 <initlog+0x72>
+80102ce9:	31 d2                	xor    %edx,%edx
+80102ceb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80102cef:	90                   	nop
+    log.lh.block[i] = lh->block[i];
+80102cf0:	8b 5c 90 60          	mov    0x60(%eax,%edx,4),%ebx
+80102cf4:	89 1c 95 cc 26 11 80 	mov    %ebx,-0x7feed934(,%edx,4)
+  for (i = 0; i < log.lh.n; i++) {
+80102cfb:	83 c2 01             	add    $0x1,%edx
+80102cfe:	39 d1                	cmp    %edx,%ecx
+80102d00:	75 ee                	jne    80102cf0 <initlog+0x60>
+  brelse(buf);
+80102d02:	83 ec 0c             	sub    $0xc,%esp
+80102d05:	50                   	push   %eax
+80102d06:	e8 e5 d4 ff ff       	call   801001f0 <brelse>
+
+static void
+recover_from_log(void)
+{
+  read_head();
+  install_trans(); // if committed, copy from log to disk
+80102d0b:	e8 80 fe ff ff       	call   80102b90 <install_trans>
+  log.lh.n = 0;
+80102d10:	c7 05 c8 26 11 80 00 	movl   $0x0,0x801126c8
+80102d17:	00 00 00 
+  write_head(); // clear the log
+80102d1a:	e8 11 ff ff ff       	call   80102c30 <write_head>
+}
+80102d1f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80102d22:	83 c4 10             	add    $0x10,%esp
+80102d25:	c9                   	leave  
+80102d26:	c3                   	ret    
+80102d27:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80102d2e:	66 90                	xchg   %ax,%ax
+
+80102d30 <begin_op>:
+}
+
+// called at the start of each FS system call.
+void
+begin_op(void)
+{
+80102d30:	f3 0f 1e fb          	endbr32 
+80102d34:	55                   	push   %ebp
+80102d35:	89 e5                	mov    %esp,%ebp
+80102d37:	83 ec 14             	sub    $0x14,%esp
+  acquire(&log.lock);
+80102d3a:	68 80 26 11 80       	push   $0x80112680
+80102d3f:	e8 9c 1a 00 00       	call   801047e0 <acquire>
+80102d44:	83 c4 10             	add    $0x10,%esp
+80102d47:	eb 1c                	jmp    80102d65 <begin_op+0x35>
+80102d49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  while(1){
+    if(log.committing){
+      sleep(&log, &log.lock);
+80102d50:	83 ec 08             	sub    $0x8,%esp
+80102d53:	68 80 26 11 80       	push   $0x80112680
+80102d58:	68 80 26 11 80       	push   $0x80112680
+80102d5d:	e8 be 11 00 00       	call   80103f20 <sleep>
+80102d62:	83 c4 10             	add    $0x10,%esp
+    if(log.committing){
+80102d65:	a1 c0 26 11 80       	mov    0x801126c0,%eax
+80102d6a:	85 c0                	test   %eax,%eax
+80102d6c:	75 e2                	jne    80102d50 <begin_op+0x20>
+    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
+80102d6e:	a1 bc 26 11 80       	mov    0x801126bc,%eax
+80102d73:	8b 15 c8 26 11 80    	mov    0x801126c8,%edx
+80102d79:	83 c0 01             	add    $0x1,%eax
+80102d7c:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
+80102d7f:	8d 14 4a             	lea    (%edx,%ecx,2),%edx
+80102d82:	83 fa 1e             	cmp    $0x1e,%edx
+80102d85:	7f c9                	jg     80102d50 <begin_op+0x20>
+      // this op might exhaust log space; wait for commit.
+      sleep(&log, &log.lock);
+    } else {
+      log.outstanding += 1;
+      release(&log.lock);
+80102d87:	83 ec 0c             	sub    $0xc,%esp
+      log.outstanding += 1;
+80102d8a:	a3 bc 26 11 80       	mov    %eax,0x801126bc
+      release(&log.lock);
+80102d8f:	68 80 26 11 80       	push   $0x80112680
+80102d94:	e8 07 1b 00 00       	call   801048a0 <release>
+      break;
+    }
+  }
+}
+80102d99:	83 c4 10             	add    $0x10,%esp
+80102d9c:	c9                   	leave  
+80102d9d:	c3                   	ret    
+80102d9e:	66 90                	xchg   %ax,%ax
+
+80102da0 <end_op>:
+
+// called at the end of each FS system call.
+// commits if this was the last outstanding operation.
+void
+end_op(void)
+{
+80102da0:	f3 0f 1e fb          	endbr32 
+80102da4:	55                   	push   %ebp
+80102da5:	89 e5                	mov    %esp,%ebp
+80102da7:	57                   	push   %edi
+80102da8:	56                   	push   %esi
+80102da9:	53                   	push   %ebx
+80102daa:	83 ec 18             	sub    $0x18,%esp
+  int do_commit = 0;
+
+  acquire(&log.lock);
+80102dad:	68 80 26 11 80       	push   $0x80112680
+80102db2:	e8 29 1a 00 00       	call   801047e0 <acquire>
+  log.outstanding -= 1;
+80102db7:	a1 bc 26 11 80       	mov    0x801126bc,%eax
+  if(log.committing)
+80102dbc:	8b 35 c0 26 11 80    	mov    0x801126c0,%esi
+80102dc2:	83 c4 10             	add    $0x10,%esp
+  log.outstanding -= 1;
+80102dc5:	8d 58 ff             	lea    -0x1(%eax),%ebx
+80102dc8:	89 1d bc 26 11 80    	mov    %ebx,0x801126bc
+  if(log.committing)
+80102dce:	85 f6                	test   %esi,%esi
+80102dd0:	0f 85 1e 01 00 00    	jne    80102ef4 <end_op+0x154>
+    panic("log.committing");
+  if(log.outstanding == 0){
+80102dd6:	85 db                	test   %ebx,%ebx
+80102dd8:	0f 85 f2 00 00 00    	jne    80102ed0 <end_op+0x130>
+    do_commit = 1;
+    log.committing = 1;
+80102dde:	c7 05 c0 26 11 80 01 	movl   $0x1,0x801126c0
+80102de5:	00 00 00 
+    // begin_op() may be waiting for log space,
+    // and decrementing log.outstanding has decreased
+    // the amount of reserved space.
+    wakeup(&log);
+  }
+  release(&log.lock);
+80102de8:	83 ec 0c             	sub    $0xc,%esp
+80102deb:	68 80 26 11 80       	push   $0x80112680
+80102df0:	e8 ab 1a 00 00       	call   801048a0 <release>
+}
+
+static void
+commit()
+{
+  if (log.lh.n > 0) {
+80102df5:	8b 0d c8 26 11 80    	mov    0x801126c8,%ecx
+80102dfb:	83 c4 10             	add    $0x10,%esp
+80102dfe:	85 c9                	test   %ecx,%ecx
+80102e00:	7f 3e                	jg     80102e40 <end_op+0xa0>
+    acquire(&log.lock);
+80102e02:	83 ec 0c             	sub    $0xc,%esp
+80102e05:	68 80 26 11 80       	push   $0x80112680
+80102e0a:	e8 d1 19 00 00       	call   801047e0 <acquire>
+    wakeup(&log);
+80102e0f:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
+    log.committing = 0;
+80102e16:	c7 05 c0 26 11 80 00 	movl   $0x0,0x801126c0
+80102e1d:	00 00 00 
+    wakeup(&log);
+80102e20:	e8 bb 12 00 00       	call   801040e0 <wakeup>
+    release(&log.lock);
+80102e25:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
+80102e2c:	e8 6f 1a 00 00       	call   801048a0 <release>
+80102e31:	83 c4 10             	add    $0x10,%esp
+}
+80102e34:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80102e37:	5b                   	pop    %ebx
+80102e38:	5e                   	pop    %esi
+80102e39:	5f                   	pop    %edi
+80102e3a:	5d                   	pop    %ebp
+80102e3b:	c3                   	ret    
+80102e3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    struct buf *to = bread(log.dev, log.start+tail+1); // log block
+80102e40:	a1 b4 26 11 80       	mov    0x801126b4,%eax
+80102e45:	83 ec 08             	sub    $0x8,%esp
+80102e48:	01 d8                	add    %ebx,%eax
+80102e4a:	83 c0 01             	add    $0x1,%eax
+80102e4d:	50                   	push   %eax
+80102e4e:	ff 35 c4 26 11 80    	pushl  0x801126c4
+80102e54:	e8 77 d2 ff ff       	call   801000d0 <bread>
+80102e59:	89 c6                	mov    %eax,%esi
+    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+80102e5b:	58                   	pop    %eax
+80102e5c:	5a                   	pop    %edx
+80102e5d:	ff 34 9d cc 26 11 80 	pushl  -0x7feed934(,%ebx,4)
+80102e64:	ff 35 c4 26 11 80    	pushl  0x801126c4
+  for (tail = 0; tail < log.lh.n; tail++) {
+80102e6a:	83 c3 01             	add    $0x1,%ebx
+    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+80102e6d:	e8 5e d2 ff ff       	call   801000d0 <bread>
+    memmove(to->data, from->data, BSIZE);
+80102e72:	83 c4 0c             	add    $0xc,%esp
+    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+80102e75:	89 c7                	mov    %eax,%edi
+    memmove(to->data, from->data, BSIZE);
+80102e77:	8d 40 5c             	lea    0x5c(%eax),%eax
+80102e7a:	68 00 02 00 00       	push   $0x200
+80102e7f:	50                   	push   %eax
+80102e80:	8d 46 5c             	lea    0x5c(%esi),%eax
+80102e83:	50                   	push   %eax
+80102e84:	e8 07 1b 00 00       	call   80104990 <memmove>
+    bwrite(to);  // write the log
+80102e89:	89 34 24             	mov    %esi,(%esp)
+80102e8c:	e8 1f d3 ff ff       	call   801001b0 <bwrite>
+    brelse(from);
+80102e91:	89 3c 24             	mov    %edi,(%esp)
+80102e94:	e8 57 d3 ff ff       	call   801001f0 <brelse>
+    brelse(to);
+80102e99:	89 34 24             	mov    %esi,(%esp)
+80102e9c:	e8 4f d3 ff ff       	call   801001f0 <brelse>
+  for (tail = 0; tail < log.lh.n; tail++) {
+80102ea1:	83 c4 10             	add    $0x10,%esp
+80102ea4:	3b 1d c8 26 11 80    	cmp    0x801126c8,%ebx
+80102eaa:	7c 94                	jl     80102e40 <end_op+0xa0>
+    write_log();     // Write modified blocks from cache to log
+    write_head();    // Write header to disk -- the real commit
+80102eac:	e8 7f fd ff ff       	call   80102c30 <write_head>
+    install_trans(); // Now install writes to home locations
+80102eb1:	e8 da fc ff ff       	call   80102b90 <install_trans>
+    log.lh.n = 0;
+80102eb6:	c7 05 c8 26 11 80 00 	movl   $0x0,0x801126c8
+80102ebd:	00 00 00 
+    write_head();    // Erase the transaction from the log
+80102ec0:	e8 6b fd ff ff       	call   80102c30 <write_head>
+80102ec5:	e9 38 ff ff ff       	jmp    80102e02 <end_op+0x62>
+80102eca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    wakeup(&log);
+80102ed0:	83 ec 0c             	sub    $0xc,%esp
+80102ed3:	68 80 26 11 80       	push   $0x80112680
+80102ed8:	e8 03 12 00 00       	call   801040e0 <wakeup>
+  release(&log.lock);
+80102edd:	c7 04 24 80 26 11 80 	movl   $0x80112680,(%esp)
+80102ee4:	e8 b7 19 00 00       	call   801048a0 <release>
+80102ee9:	83 c4 10             	add    $0x10,%esp
+}
+80102eec:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80102eef:	5b                   	pop    %ebx
+80102ef0:	5e                   	pop    %esi
+80102ef1:	5f                   	pop    %edi
+80102ef2:	5d                   	pop    %ebp
+80102ef3:	c3                   	ret    
+    panic("log.committing");
+80102ef4:	83 ec 0c             	sub    $0xc,%esp
+80102ef7:	68 64 79 10 80       	push   $0x80107964
+80102efc:	e8 8f d4 ff ff       	call   80100390 <panic>
+80102f01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80102f08:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80102f0f:	90                   	nop
+
+80102f10 <log_write>:
+//   modify bp->data[]
+//   log_write(bp)
+//   brelse(bp)
+void
+log_write(struct buf *b)
+{
+80102f10:	f3 0f 1e fb          	endbr32 
+80102f14:	55                   	push   %ebp
+80102f15:	89 e5                	mov    %esp,%ebp
+80102f17:	53                   	push   %ebx
+80102f18:	83 ec 04             	sub    $0x4,%esp
+  int i;
+
+  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
+80102f1b:	8b 15 c8 26 11 80    	mov    0x801126c8,%edx
+{
+80102f21:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
+80102f24:	83 fa 1d             	cmp    $0x1d,%edx
+80102f27:	0f 8f 91 00 00 00    	jg     80102fbe <log_write+0xae>
+80102f2d:	a1 b8 26 11 80       	mov    0x801126b8,%eax
+80102f32:	83 e8 01             	sub    $0x1,%eax
+80102f35:	39 c2                	cmp    %eax,%edx
+80102f37:	0f 8d 81 00 00 00    	jge    80102fbe <log_write+0xae>
+    panic("too big a transaction");
+  if (log.outstanding < 1)
+80102f3d:	a1 bc 26 11 80       	mov    0x801126bc,%eax
+80102f42:	85 c0                	test   %eax,%eax
+80102f44:	0f 8e 81 00 00 00    	jle    80102fcb <log_write+0xbb>
+    panic("log_write outside of trans");
+
+  acquire(&log.lock);
+80102f4a:	83 ec 0c             	sub    $0xc,%esp
+80102f4d:	68 80 26 11 80       	push   $0x80112680
+80102f52:	e8 89 18 00 00       	call   801047e0 <acquire>
+  for (i = 0; i < log.lh.n; i++) {
+80102f57:	8b 15 c8 26 11 80    	mov    0x801126c8,%edx
+80102f5d:	83 c4 10             	add    $0x10,%esp
+80102f60:	85 d2                	test   %edx,%edx
+80102f62:	7e 4e                	jle    80102fb2 <log_write+0xa2>
+    if (log.lh.block[i] == b->blockno)   // log absorbtion
+80102f64:	8b 4b 08             	mov    0x8(%ebx),%ecx
+  for (i = 0; i < log.lh.n; i++) {
+80102f67:	31 c0                	xor    %eax,%eax
+80102f69:	eb 0c                	jmp    80102f77 <log_write+0x67>
+80102f6b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80102f6f:	90                   	nop
+80102f70:	83 c0 01             	add    $0x1,%eax
+80102f73:	39 c2                	cmp    %eax,%edx
+80102f75:	74 29                	je     80102fa0 <log_write+0x90>
+    if (log.lh.block[i] == b->blockno)   // log absorbtion
+80102f77:	39 0c 85 cc 26 11 80 	cmp    %ecx,-0x7feed934(,%eax,4)
+80102f7e:	75 f0                	jne    80102f70 <log_write+0x60>
+      break;
+  }
+  log.lh.block[i] = b->blockno;
+80102f80:	89 0c 85 cc 26 11 80 	mov    %ecx,-0x7feed934(,%eax,4)
+  if (i == log.lh.n)
+    log.lh.n++;
+  b->flags |= B_DIRTY; // prevent eviction
+80102f87:	83 0b 04             	orl    $0x4,(%ebx)
+  release(&log.lock);
+}
+80102f8a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+  release(&log.lock);
+80102f8d:	c7 45 08 80 26 11 80 	movl   $0x80112680,0x8(%ebp)
+}
+80102f94:	c9                   	leave  
+  release(&log.lock);
+80102f95:	e9 06 19 00 00       	jmp    801048a0 <release>
+80102f9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  log.lh.block[i] = b->blockno;
+80102fa0:	89 0c 95 cc 26 11 80 	mov    %ecx,-0x7feed934(,%edx,4)
+    log.lh.n++;
+80102fa7:	83 c2 01             	add    $0x1,%edx
+80102faa:	89 15 c8 26 11 80    	mov    %edx,0x801126c8
+80102fb0:	eb d5                	jmp    80102f87 <log_write+0x77>
+  log.lh.block[i] = b->blockno;
+80102fb2:	8b 43 08             	mov    0x8(%ebx),%eax
+80102fb5:	a3 cc 26 11 80       	mov    %eax,0x801126cc
+  if (i == log.lh.n)
+80102fba:	75 cb                	jne    80102f87 <log_write+0x77>
+80102fbc:	eb e9                	jmp    80102fa7 <log_write+0x97>
+    panic("too big a transaction");
+80102fbe:	83 ec 0c             	sub    $0xc,%esp
+80102fc1:	68 73 79 10 80       	push   $0x80107973
+80102fc6:	e8 c5 d3 ff ff       	call   80100390 <panic>
+    panic("log_write outside of trans");
+80102fcb:	83 ec 0c             	sub    $0xc,%esp
+80102fce:	68 89 79 10 80       	push   $0x80107989
+80102fd3:	e8 b8 d3 ff ff       	call   80100390 <panic>
+80102fd8:	66 90                	xchg   %ax,%ax
+80102fda:	66 90                	xchg   %ax,%ax
+80102fdc:	66 90                	xchg   %ax,%ax
+80102fde:	66 90                	xchg   %ax,%ax
+
+80102fe0 <mpmain>:
+}
+
+// Common CPU setup code.
+static void
+mpmain(void)
+{
+80102fe0:	55                   	push   %ebp
+80102fe1:	89 e5                	mov    %esp,%ebp
+80102fe3:	53                   	push   %ebx
+80102fe4:	83 ec 04             	sub    $0x4,%esp
+  cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
+80102fe7:	e8 54 09 00 00       	call   80103940 <cpuid>
+80102fec:	89 c3                	mov    %eax,%ebx
+80102fee:	e8 4d 09 00 00       	call   80103940 <cpuid>
+80102ff3:	83 ec 04             	sub    $0x4,%esp
+80102ff6:	53                   	push   %ebx
+80102ff7:	50                   	push   %eax
+80102ff8:	68 a4 79 10 80       	push   $0x801079a4
+80102ffd:	e8 ae d6 ff ff       	call   801006b0 <cprintf>
+  idtinit();       // load idt register
+80103002:	e8 f9 2c 00 00       	call   80105d00 <idtinit>
+  xchg(&(mycpu()->started), 1); // tell startothers() we're up
+80103007:	e8 c4 08 00 00       	call   801038d0 <mycpu>
+8010300c:	89 c2                	mov    %eax,%edx
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+8010300e:	b8 01 00 00 00       	mov    $0x1,%eax
+80103013:	f0 87 82 a0 00 00 00 	lock xchg %eax,0xa0(%edx)
+  scheduler();     // start running processes
+8010301a:	e8 11 0c 00 00       	call   80103c30 <scheduler>
+8010301f:	90                   	nop
+
+80103020 <mpenter>:
+{
+80103020:	f3 0f 1e fb          	endbr32 
+80103024:	55                   	push   %ebp
+80103025:	89 e5                	mov    %esp,%ebp
+80103027:	83 ec 08             	sub    $0x8,%esp
+  switchkvm();
+8010302a:	e8 a1 3d 00 00       	call   80106dd0 <switchkvm>
+  seginit();
+8010302f:	e8 0c 3d 00 00       	call   80106d40 <seginit>
+  lapicinit();
+80103034:	e8 67 f7 ff ff       	call   801027a0 <lapicinit>
+  mpmain();
+80103039:	e8 a2 ff ff ff       	call   80102fe0 <mpmain>
+8010303e:	66 90                	xchg   %ax,%ax
+
+80103040 <main>:
+{
+80103040:	f3 0f 1e fb          	endbr32 
+80103044:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+80103048:	83 e4 f0             	and    $0xfffffff0,%esp
+8010304b:	ff 71 fc             	pushl  -0x4(%ecx)
+8010304e:	55                   	push   %ebp
+8010304f:	89 e5                	mov    %esp,%ebp
+80103051:	53                   	push   %ebx
+80103052:	51                   	push   %ecx
+  kinit1(end, P2V(4*1024*1024)); // phys page allocator
+80103053:	83 ec 08             	sub    $0x8,%esp
+80103056:	68 00 00 40 80       	push   $0x80400000
+8010305b:	68 a8 55 11 80       	push   $0x801155a8
+80103060:	e8 fb f4 ff ff       	call   80102560 <kinit1>
+  kvmalloc();      // kernel page table
+80103065:	e8 46 42 00 00       	call   801072b0 <kvmalloc>
+  mpinit();        // detect other processors
+8010306a:	e8 81 01 00 00       	call   801031f0 <mpinit>
+  lapicinit();     // interrupt controller
+8010306f:	e8 2c f7 ff ff       	call   801027a0 <lapicinit>
+  seginit();       // segment descriptors
+80103074:	e8 c7 3c 00 00       	call   80106d40 <seginit>
+  picinit();       // disable pic
+80103079:	e8 52 03 00 00       	call   801033d0 <picinit>
+  ioapicinit();    // another interrupt controller
+8010307e:	e8 fd f2 ff ff       	call   80102380 <ioapicinit>
+  consoleinit();   // console hardware
+80103083:	e8 a8 d9 ff ff       	call   80100a30 <consoleinit>
+  uartinit();      // serial port
+80103088:	e8 73 2f 00 00       	call   80106000 <uartinit>
+  pinit();         // process table
+8010308d:	e8 1e 08 00 00       	call   801038b0 <pinit>
+  tvinit();        // trap vectors
+80103092:	e8 e9 2b 00 00       	call   80105c80 <tvinit>
+  binit();         // buffer cache
+80103097:	e8 a4 cf ff ff       	call   80100040 <binit>
+  fileinit();      // file table
+8010309c:	e8 3f dd ff ff       	call   80100de0 <fileinit>
+  ideinit();       // disk 
+801030a1:	e8 aa f0 ff ff       	call   80102150 <ideinit>
+
+  // Write entry code to unused memory at 0x7000.
+  // The linker has placed the image of entryother.S in
+  // _binary_entryother_start.
+  code = P2V(0x7000);
+  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
+801030a6:	83 c4 0c             	add    $0xc,%esp
+801030a9:	68 8a 00 00 00       	push   $0x8a
+801030ae:	68 8c a4 10 80       	push   $0x8010a48c
+801030b3:	68 00 70 00 80       	push   $0x80007000
+801030b8:	e8 d3 18 00 00       	call   80104990 <memmove>
+
+  for(c = cpus; c < cpus+ncpu; c++){
+801030bd:	83 c4 10             	add    $0x10,%esp
+801030c0:	69 05 00 2d 11 80 b0 	imul   $0xb0,0x80112d00,%eax
+801030c7:	00 00 00 
+801030ca:	05 80 27 11 80       	add    $0x80112780,%eax
+801030cf:	3d 80 27 11 80       	cmp    $0x80112780,%eax
+801030d4:	76 7a                	jbe    80103150 <main+0x110>
+801030d6:	bb 80 27 11 80       	mov    $0x80112780,%ebx
+801030db:	eb 1c                	jmp    801030f9 <main+0xb9>
+801030dd:	8d 76 00             	lea    0x0(%esi),%esi
+801030e0:	69 05 00 2d 11 80 b0 	imul   $0xb0,0x80112d00,%eax
+801030e7:	00 00 00 
+801030ea:	81 c3 b0 00 00 00    	add    $0xb0,%ebx
+801030f0:	05 80 27 11 80       	add    $0x80112780,%eax
+801030f5:	39 c3                	cmp    %eax,%ebx
+801030f7:	73 57                	jae    80103150 <main+0x110>
+    if(c == mycpu())  // We've started already.
+801030f9:	e8 d2 07 00 00       	call   801038d0 <mycpu>
+801030fe:	39 c3                	cmp    %eax,%ebx
+80103100:	74 de                	je     801030e0 <main+0xa0>
+      continue;
+
+    // Tell entryother.S what stack to use, where to enter, and what
+    // pgdir to use. We cannot use kpgdir yet, because the AP processor
+    // is running in low  memory, so we use entrypgdir for the APs too.
+    stack = kalloc();
+80103102:	e8 29 f5 ff ff       	call   80102630 <kalloc>
+    *(void**)(code-4) = stack + KSTACKSIZE;
+    *(void(**)(void))(code-8) = mpenter;
+    *(int**)(code-12) = (void *) V2P(entrypgdir);
+
+    lapicstartap(c->apicid, V2P(code));
+80103107:	83 ec 08             	sub    $0x8,%esp
+    *(void(**)(void))(code-8) = mpenter;
+8010310a:	c7 05 f8 6f 00 80 20 	movl   $0x80103020,0x80006ff8
+80103111:	30 10 80 
+    *(int**)(code-12) = (void *) V2P(entrypgdir);
+80103114:	c7 05 f4 6f 00 80 00 	movl   $0x109000,0x80006ff4
+8010311b:	90 10 00 
+    *(void**)(code-4) = stack + KSTACKSIZE;
+8010311e:	05 00 10 00 00       	add    $0x1000,%eax
+80103123:	a3 fc 6f 00 80       	mov    %eax,0x80006ffc
+    lapicstartap(c->apicid, V2P(code));
+80103128:	0f b6 03             	movzbl (%ebx),%eax
+8010312b:	68 00 70 00 00       	push   $0x7000
+80103130:	50                   	push   %eax
+80103131:	e8 ba f7 ff ff       	call   801028f0 <lapicstartap>
+
+    // wait for cpu to finish mpmain()
+    while(c->started == 0)
+80103136:	83 c4 10             	add    $0x10,%esp
+80103139:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80103140:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
+80103146:	85 c0                	test   %eax,%eax
+80103148:	74 f6                	je     80103140 <main+0x100>
+8010314a:	eb 94                	jmp    801030e0 <main+0xa0>
+8010314c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
+80103150:	83 ec 08             	sub    $0x8,%esp
+80103153:	68 00 00 00 8e       	push   $0x8e000000
+80103158:	68 00 00 40 80       	push   $0x80400000
+8010315d:	e8 6e f4 ff ff       	call   801025d0 <kinit2>
+  userinit();      // first user process
+80103162:	e8 29 08 00 00       	call   80103990 <userinit>
+  mpmain();        // finish this processor's setup
+80103167:	e8 74 fe ff ff       	call   80102fe0 <mpmain>
+8010316c:	66 90                	xchg   %ax,%ax
+8010316e:	66 90                	xchg   %ax,%ax
+
+80103170 <mpsearch1>:
+}
+
+// Look for an MP structure in the len bytes at addr.
+static struct mp*
+mpsearch1(uint a, int len)
+{
+80103170:	55                   	push   %ebp
+80103171:	89 e5                	mov    %esp,%ebp
+80103173:	57                   	push   %edi
+80103174:	56                   	push   %esi
+  uchar *e, *p, *addr;
+
+  addr = P2V(a);
+80103175:	8d b0 00 00 00 80    	lea    -0x80000000(%eax),%esi
+{
+8010317b:	53                   	push   %ebx
+  e = addr+len;
+8010317c:	8d 1c 16             	lea    (%esi,%edx,1),%ebx
+{
+8010317f:	83 ec 0c             	sub    $0xc,%esp
+  for(p = addr; p < e; p += sizeof(struct mp))
+80103182:	39 de                	cmp    %ebx,%esi
+80103184:	72 10                	jb     80103196 <mpsearch1+0x26>
+80103186:	eb 50                	jmp    801031d8 <mpsearch1+0x68>
+80103188:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010318f:	90                   	nop
+80103190:	89 fe                	mov    %edi,%esi
+80103192:	39 fb                	cmp    %edi,%ebx
+80103194:	76 42                	jbe    801031d8 <mpsearch1+0x68>
+    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
+80103196:	83 ec 04             	sub    $0x4,%esp
+80103199:	8d 7e 10             	lea    0x10(%esi),%edi
+8010319c:	6a 04                	push   $0x4
+8010319e:	68 b8 79 10 80       	push   $0x801079b8
+801031a3:	56                   	push   %esi
+801031a4:	e8 97 17 00 00       	call   80104940 <memcmp>
+801031a9:	83 c4 10             	add    $0x10,%esp
+801031ac:	85 c0                	test   %eax,%eax
+801031ae:	75 e0                	jne    80103190 <mpsearch1+0x20>
+801031b0:	89 f2                	mov    %esi,%edx
+801031b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    sum += addr[i];
+801031b8:	0f b6 0a             	movzbl (%edx),%ecx
+801031bb:	83 c2 01             	add    $0x1,%edx
+801031be:	01 c8                	add    %ecx,%eax
+  for(i=0; i<len; i++)
+801031c0:	39 fa                	cmp    %edi,%edx
+801031c2:	75 f4                	jne    801031b8 <mpsearch1+0x48>
+    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
+801031c4:	84 c0                	test   %al,%al
+801031c6:	75 c8                	jne    80103190 <mpsearch1+0x20>
+      return (struct mp*)p;
+  return 0;
+}
+801031c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
+801031cb:	89 f0                	mov    %esi,%eax
+801031cd:	5b                   	pop    %ebx
+801031ce:	5e                   	pop    %esi
+801031cf:	5f                   	pop    %edi
+801031d0:	5d                   	pop    %ebp
+801031d1:	c3                   	ret    
+801031d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+801031d8:	8d 65 f4             	lea    -0xc(%ebp),%esp
+  return 0;
+801031db:	31 f6                	xor    %esi,%esi
+}
+801031dd:	5b                   	pop    %ebx
+801031de:	89 f0                	mov    %esi,%eax
+801031e0:	5e                   	pop    %esi
+801031e1:	5f                   	pop    %edi
+801031e2:	5d                   	pop    %ebp
+801031e3:	c3                   	ret    
+801031e4:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801031eb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801031ef:	90                   	nop
+
+801031f0 <mpinit>:
+  return conf;
+}
+
+void
+mpinit(void)
+{
+801031f0:	f3 0f 1e fb          	endbr32 
+801031f4:	55                   	push   %ebp
+801031f5:	89 e5                	mov    %esp,%ebp
+801031f7:	57                   	push   %edi
+801031f8:	56                   	push   %esi
+801031f9:	53                   	push   %ebx
+801031fa:	83 ec 1c             	sub    $0x1c,%esp
+  if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
+801031fd:	0f b6 05 0f 04 00 80 	movzbl 0x8000040f,%eax
+80103204:	0f b6 15 0e 04 00 80 	movzbl 0x8000040e,%edx
+8010320b:	c1 e0 08             	shl    $0x8,%eax
+8010320e:	09 d0                	or     %edx,%eax
+80103210:	c1 e0 04             	shl    $0x4,%eax
+80103213:	75 1b                	jne    80103230 <mpinit+0x40>
+    p = ((bda[0x14]<<8)|bda[0x13])*1024;
+80103215:	0f b6 05 14 04 00 80 	movzbl 0x80000414,%eax
+8010321c:	0f b6 15 13 04 00 80 	movzbl 0x80000413,%edx
+80103223:	c1 e0 08             	shl    $0x8,%eax
+80103226:	09 d0                	or     %edx,%eax
+80103228:	c1 e0 0a             	shl    $0xa,%eax
+    if((mp = mpsearch1(p-1024, 1024)))
+8010322b:	2d 00 04 00 00       	sub    $0x400,%eax
+    if((mp = mpsearch1(p, 1024)))
+80103230:	ba 00 04 00 00       	mov    $0x400,%edx
+80103235:	e8 36 ff ff ff       	call   80103170 <mpsearch1>
+8010323a:	89 c6                	mov    %eax,%esi
+8010323c:	85 c0                	test   %eax,%eax
+8010323e:	0f 84 4c 01 00 00    	je     80103390 <mpinit+0x1a0>
+  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+80103244:	8b 5e 04             	mov    0x4(%esi),%ebx
+80103247:	85 db                	test   %ebx,%ebx
+80103249:	0f 84 61 01 00 00    	je     801033b0 <mpinit+0x1c0>
+  if(memcmp(conf, "PCMP", 4) != 0)
+8010324f:	83 ec 04             	sub    $0x4,%esp
+  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+80103252:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
+  if(memcmp(conf, "PCMP", 4) != 0)
+80103258:	6a 04                	push   $0x4
+8010325a:	68 bd 79 10 80       	push   $0x801079bd
+8010325f:	50                   	push   %eax
+  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+80103260:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  if(memcmp(conf, "PCMP", 4) != 0)
+80103263:	e8 d8 16 00 00       	call   80104940 <memcmp>
+80103268:	83 c4 10             	add    $0x10,%esp
+8010326b:	85 c0                	test   %eax,%eax
+8010326d:	0f 85 3d 01 00 00    	jne    801033b0 <mpinit+0x1c0>
+  if(conf->version != 1 && conf->version != 4)
+80103273:	0f b6 83 06 00 00 80 	movzbl -0x7ffffffa(%ebx),%eax
+8010327a:	3c 01                	cmp    $0x1,%al
+8010327c:	74 08                	je     80103286 <mpinit+0x96>
+8010327e:	3c 04                	cmp    $0x4,%al
+80103280:	0f 85 2a 01 00 00    	jne    801033b0 <mpinit+0x1c0>
+  if(sum((uchar*)conf, conf->length) != 0)
+80103286:	0f b7 93 04 00 00 80 	movzwl -0x7ffffffc(%ebx),%edx
+  for(i=0; i<len; i++)
+8010328d:	66 85 d2             	test   %dx,%dx
+80103290:	74 26                	je     801032b8 <mpinit+0xc8>
+80103292:	8d 3c 1a             	lea    (%edx,%ebx,1),%edi
+80103295:	89 d8                	mov    %ebx,%eax
+  sum = 0;
+80103297:	31 d2                	xor    %edx,%edx
+80103299:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    sum += addr[i];
+801032a0:	0f b6 88 00 00 00 80 	movzbl -0x80000000(%eax),%ecx
+801032a7:	83 c0 01             	add    $0x1,%eax
+801032aa:	01 ca                	add    %ecx,%edx
+  for(i=0; i<len; i++)
+801032ac:	39 f8                	cmp    %edi,%eax
+801032ae:	75 f0                	jne    801032a0 <mpinit+0xb0>
+  if(sum((uchar*)conf, conf->length) != 0)
+801032b0:	84 d2                	test   %dl,%dl
+801032b2:	0f 85 f8 00 00 00    	jne    801033b0 <mpinit+0x1c0>
+  struct mpioapic *ioapic;
+
+  if((conf = mpconfig(&mp)) == 0)
+    panic("Expect to run on an SMP");
+  ismp = 1;
+  lapic = (uint*)conf->lapicaddr;
+801032b8:	8b 83 24 00 00 80    	mov    -0x7fffffdc(%ebx),%eax
+801032be:	a3 7c 26 11 80       	mov    %eax,0x8011267c
+  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+801032c3:	8d 83 2c 00 00 80    	lea    -0x7fffffd4(%ebx),%eax
+801032c9:	0f b7 93 04 00 00 80 	movzwl -0x7ffffffc(%ebx),%edx
+  ismp = 1;
+801032d0:	bb 01 00 00 00       	mov    $0x1,%ebx
+  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+801032d5:	03 55 e4             	add    -0x1c(%ebp),%edx
+801032d8:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
+801032db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801032df:	90                   	nop
+801032e0:	39 c2                	cmp    %eax,%edx
+801032e2:	76 15                	jbe    801032f9 <mpinit+0x109>
+    switch(*p){
+801032e4:	0f b6 08             	movzbl (%eax),%ecx
+801032e7:	80 f9 02             	cmp    $0x2,%cl
+801032ea:	74 5c                	je     80103348 <mpinit+0x158>
+801032ec:	77 42                	ja     80103330 <mpinit+0x140>
+801032ee:	84 c9                	test   %cl,%cl
+801032f0:	74 6e                	je     80103360 <mpinit+0x170>
+      p += sizeof(struct mpioapic);
+      continue;
+    case MPBUS:
+    case MPIOINTR:
+    case MPLINTR:
+      p += 8;
+801032f2:	83 c0 08             	add    $0x8,%eax
+  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+801032f5:	39 c2                	cmp    %eax,%edx
+801032f7:	77 eb                	ja     801032e4 <mpinit+0xf4>
+801032f9:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
+    default:
+      ismp = 0;
+      break;
+    }
+  }
+  if(!ismp)
+801032fc:	85 db                	test   %ebx,%ebx
+801032fe:	0f 84 b9 00 00 00    	je     801033bd <mpinit+0x1cd>
+    panic("Didn't find a suitable machine");
+
+  if(mp->imcrp){
+80103304:	80 7e 0c 00          	cmpb   $0x0,0xc(%esi)
+80103308:	74 15                	je     8010331f <mpinit+0x12f>
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+8010330a:	b8 70 00 00 00       	mov    $0x70,%eax
+8010330f:	ba 22 00 00 00       	mov    $0x22,%edx
+80103314:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80103315:	ba 23 00 00 00       	mov    $0x23,%edx
+8010331a:	ec                   	in     (%dx),%al
+    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
+    // But it would on real hardware.
+    outb(0x22, 0x70);   // Select IMCR
+    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
+8010331b:	83 c8 01             	or     $0x1,%eax
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+8010331e:	ee                   	out    %al,(%dx)
+  }
+}
+8010331f:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80103322:	5b                   	pop    %ebx
+80103323:	5e                   	pop    %esi
+80103324:	5f                   	pop    %edi
+80103325:	5d                   	pop    %ebp
+80103326:	c3                   	ret    
+80103327:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010332e:	66 90                	xchg   %ax,%ax
+    switch(*p){
+80103330:	83 e9 03             	sub    $0x3,%ecx
+80103333:	80 f9 01             	cmp    $0x1,%cl
+80103336:	76 ba                	jbe    801032f2 <mpinit+0x102>
+80103338:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+8010333f:	eb 9f                	jmp    801032e0 <mpinit+0xf0>
+80103341:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      ioapicid = ioapic->apicno;
+80103348:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
+      p += sizeof(struct mpioapic);
+8010334c:	83 c0 08             	add    $0x8,%eax
+      ioapicid = ioapic->apicno;
+8010334f:	88 0d 60 27 11 80    	mov    %cl,0x80112760
+      continue;
+80103355:	eb 89                	jmp    801032e0 <mpinit+0xf0>
+80103357:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010335e:	66 90                	xchg   %ax,%ax
+      if(ncpu < NCPU) {
+80103360:	8b 0d 00 2d 11 80    	mov    0x80112d00,%ecx
+80103366:	83 f9 07             	cmp    $0x7,%ecx
+80103369:	7f 19                	jg     80103384 <mpinit+0x194>
+        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
+8010336b:	69 f9 b0 00 00 00    	imul   $0xb0,%ecx,%edi
+80103371:	0f b6 58 01          	movzbl 0x1(%eax),%ebx
+        ncpu++;
+80103375:	83 c1 01             	add    $0x1,%ecx
+80103378:	89 0d 00 2d 11 80    	mov    %ecx,0x80112d00
+        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
+8010337e:	88 9f 80 27 11 80    	mov    %bl,-0x7feed880(%edi)
+      p += sizeof(struct mpproc);
+80103384:	83 c0 14             	add    $0x14,%eax
+      continue;
+80103387:	e9 54 ff ff ff       	jmp    801032e0 <mpinit+0xf0>
+8010338c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  return mpsearch1(0xF0000, 0x10000);
+80103390:	ba 00 00 01 00       	mov    $0x10000,%edx
+80103395:	b8 00 00 0f 00       	mov    $0xf0000,%eax
+8010339a:	e8 d1 fd ff ff       	call   80103170 <mpsearch1>
+8010339f:	89 c6                	mov    %eax,%esi
+  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+801033a1:	85 c0                	test   %eax,%eax
+801033a3:	0f 85 9b fe ff ff    	jne    80103244 <mpinit+0x54>
+801033a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    panic("Expect to run on an SMP");
+801033b0:	83 ec 0c             	sub    $0xc,%esp
+801033b3:	68 c2 79 10 80       	push   $0x801079c2
+801033b8:	e8 d3 cf ff ff       	call   80100390 <panic>
+    panic("Didn't find a suitable machine");
+801033bd:	83 ec 0c             	sub    $0xc,%esp
+801033c0:	68 dc 79 10 80       	push   $0x801079dc
+801033c5:	e8 c6 cf ff ff       	call   80100390 <panic>
+801033ca:	66 90                	xchg   %ax,%ax
+801033cc:	66 90                	xchg   %ax,%ax
+801033ce:	66 90                	xchg   %ax,%ax
+
+801033d0 <picinit>:
+#define IO_PIC2         0xA0    // Slave (IRQs 8-15)
+
+// Don't use the 8259A interrupt controllers.  Xv6 assumes SMP hardware.
+void
+picinit(void)
+{
+801033d0:	f3 0f 1e fb          	endbr32 
+801033d4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801033d9:	ba 21 00 00 00       	mov    $0x21,%edx
+801033de:	ee                   	out    %al,(%dx)
+801033df:	ba a1 00 00 00       	mov    $0xa1,%edx
+801033e4:	ee                   	out    %al,(%dx)
+  // mask all interrupts
+  outb(IO_PIC1+1, 0xFF);
+  outb(IO_PIC2+1, 0xFF);
+}
+801033e5:	c3                   	ret    
+801033e6:	66 90                	xchg   %ax,%ax
+801033e8:	66 90                	xchg   %ax,%ax
+801033ea:	66 90                	xchg   %ax,%ax
+801033ec:	66 90                	xchg   %ax,%ax
+801033ee:	66 90                	xchg   %ax,%ax
+
+801033f0 <pipealloc>:
+  int writeopen;  // write fd is still open
+};
+
+int
+pipealloc(struct file **f0, struct file **f1)
+{
+801033f0:	f3 0f 1e fb          	endbr32 
+801033f4:	55                   	push   %ebp
+801033f5:	89 e5                	mov    %esp,%ebp
+801033f7:	57                   	push   %edi
+801033f8:	56                   	push   %esi
+801033f9:	53                   	push   %ebx
+801033fa:	83 ec 0c             	sub    $0xc,%esp
+801033fd:	8b 5d 08             	mov    0x8(%ebp),%ebx
+80103400:	8b 75 0c             	mov    0xc(%ebp),%esi
+  struct pipe *p;
+
+  p = 0;
+  *f0 = *f1 = 0;
+80103403:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
+80103409:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
+  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
+8010340f:	e8 ec d9 ff ff       	call   80100e00 <filealloc>
+80103414:	89 03                	mov    %eax,(%ebx)
+80103416:	85 c0                	test   %eax,%eax
+80103418:	0f 84 ac 00 00 00    	je     801034ca <pipealloc+0xda>
+8010341e:	e8 dd d9 ff ff       	call   80100e00 <filealloc>
+80103423:	89 06                	mov    %eax,(%esi)
+80103425:	85 c0                	test   %eax,%eax
+80103427:	0f 84 8b 00 00 00    	je     801034b8 <pipealloc+0xc8>
+    goto bad;
+  if((p = (struct pipe*)kalloc()) == 0)
+8010342d:	e8 fe f1 ff ff       	call   80102630 <kalloc>
+80103432:	89 c7                	mov    %eax,%edi
+80103434:	85 c0                	test   %eax,%eax
+80103436:	0f 84 b4 00 00 00    	je     801034f0 <pipealloc+0x100>
+    goto bad;
+  p->readopen = 1;
+8010343c:	c7 80 3c 02 00 00 01 	movl   $0x1,0x23c(%eax)
+80103443:	00 00 00 
+  p->writeopen = 1;
+  p->nwrite = 0;
+  p->nread = 0;
+  initlock(&p->lock, "pipe");
+80103446:	83 ec 08             	sub    $0x8,%esp
+  p->writeopen = 1;
+80103449:	c7 80 40 02 00 00 01 	movl   $0x1,0x240(%eax)
+80103450:	00 00 00 
+  p->nwrite = 0;
+80103453:	c7 80 38 02 00 00 00 	movl   $0x0,0x238(%eax)
+8010345a:	00 00 00 
+  p->nread = 0;
+8010345d:	c7 80 34 02 00 00 00 	movl   $0x0,0x234(%eax)
+80103464:	00 00 00 
+  initlock(&p->lock, "pipe");
+80103467:	68 fb 79 10 80       	push   $0x801079fb
+8010346c:	50                   	push   %eax
+8010346d:	e8 ee 11 00 00       	call   80104660 <initlock>
+  (*f0)->type = FD_PIPE;
+80103472:	8b 03                	mov    (%ebx),%eax
+  (*f0)->pipe = p;
+  (*f1)->type = FD_PIPE;
+  (*f1)->readable = 0;
+  (*f1)->writable = 1;
+  (*f1)->pipe = p;
+  return 0;
+80103474:	83 c4 10             	add    $0x10,%esp
+  (*f0)->type = FD_PIPE;
+80103477:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
+  (*f0)->readable = 1;
+8010347d:	8b 03                	mov    (%ebx),%eax
+8010347f:	c6 40 08 01          	movb   $0x1,0x8(%eax)
+  (*f0)->writable = 0;
+80103483:	8b 03                	mov    (%ebx),%eax
+80103485:	c6 40 09 00          	movb   $0x0,0x9(%eax)
+  (*f0)->pipe = p;
+80103489:	8b 03                	mov    (%ebx),%eax
+8010348b:	89 78 0c             	mov    %edi,0xc(%eax)
+  (*f1)->type = FD_PIPE;
+8010348e:	8b 06                	mov    (%esi),%eax
+80103490:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
+  (*f1)->readable = 0;
+80103496:	8b 06                	mov    (%esi),%eax
+80103498:	c6 40 08 00          	movb   $0x0,0x8(%eax)
+  (*f1)->writable = 1;
+8010349c:	8b 06                	mov    (%esi),%eax
+8010349e:	c6 40 09 01          	movb   $0x1,0x9(%eax)
+  (*f1)->pipe = p;
+801034a2:	8b 06                	mov    (%esi),%eax
+801034a4:	89 78 0c             	mov    %edi,0xc(%eax)
+  if(*f0)
+    fileclose(*f0);
+  if(*f1)
+    fileclose(*f1);
+  return -1;
+}
+801034a7:	8d 65 f4             	lea    -0xc(%ebp),%esp
+  return 0;
+801034aa:	31 c0                	xor    %eax,%eax
+}
+801034ac:	5b                   	pop    %ebx
+801034ad:	5e                   	pop    %esi
+801034ae:	5f                   	pop    %edi
+801034af:	5d                   	pop    %ebp
+801034b0:	c3                   	ret    
+801034b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  if(*f0)
+801034b8:	8b 03                	mov    (%ebx),%eax
+801034ba:	85 c0                	test   %eax,%eax
+801034bc:	74 1e                	je     801034dc <pipealloc+0xec>
+    fileclose(*f0);
+801034be:	83 ec 0c             	sub    $0xc,%esp
+801034c1:	50                   	push   %eax
+801034c2:	e8 f9 d9 ff ff       	call   80100ec0 <fileclose>
+801034c7:	83 c4 10             	add    $0x10,%esp
+  if(*f1)
+801034ca:	8b 06                	mov    (%esi),%eax
+801034cc:	85 c0                	test   %eax,%eax
+801034ce:	74 0c                	je     801034dc <pipealloc+0xec>
+    fileclose(*f1);
+801034d0:	83 ec 0c             	sub    $0xc,%esp
+801034d3:	50                   	push   %eax
+801034d4:	e8 e7 d9 ff ff       	call   80100ec0 <fileclose>
+801034d9:	83 c4 10             	add    $0x10,%esp
+}
+801034dc:	8d 65 f4             	lea    -0xc(%ebp),%esp
+  return -1;
+801034df:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+801034e4:	5b                   	pop    %ebx
+801034e5:	5e                   	pop    %esi
+801034e6:	5f                   	pop    %edi
+801034e7:	5d                   	pop    %ebp
+801034e8:	c3                   	ret    
+801034e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  if(*f0)
+801034f0:	8b 03                	mov    (%ebx),%eax
+801034f2:	85 c0                	test   %eax,%eax
+801034f4:	75 c8                	jne    801034be <pipealloc+0xce>
+801034f6:	eb d2                	jmp    801034ca <pipealloc+0xda>
+801034f8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801034ff:	90                   	nop
+
+80103500 <pipeclose>:
+
+void
+pipeclose(struct pipe *p, int writable)
+{
+80103500:	f3 0f 1e fb          	endbr32 
+80103504:	55                   	push   %ebp
+80103505:	89 e5                	mov    %esp,%ebp
+80103507:	56                   	push   %esi
+80103508:	53                   	push   %ebx
+80103509:	8b 5d 08             	mov    0x8(%ebp),%ebx
+8010350c:	8b 75 0c             	mov    0xc(%ebp),%esi
+  acquire(&p->lock);
+8010350f:	83 ec 0c             	sub    $0xc,%esp
+80103512:	53                   	push   %ebx
+80103513:	e8 c8 12 00 00       	call   801047e0 <acquire>
+  if(writable){
+80103518:	83 c4 10             	add    $0x10,%esp
+8010351b:	85 f6                	test   %esi,%esi
+8010351d:	74 41                	je     80103560 <pipeclose+0x60>
+    p->writeopen = 0;
+    wakeup(&p->nread);
+8010351f:	83 ec 0c             	sub    $0xc,%esp
+80103522:	8d 83 34 02 00 00    	lea    0x234(%ebx),%eax
+    p->writeopen = 0;
+80103528:	c7 83 40 02 00 00 00 	movl   $0x0,0x240(%ebx)
+8010352f:	00 00 00 
+    wakeup(&p->nread);
+80103532:	50                   	push   %eax
+80103533:	e8 a8 0b 00 00       	call   801040e0 <wakeup>
+80103538:	83 c4 10             	add    $0x10,%esp
+  } else {
+    p->readopen = 0;
+    wakeup(&p->nwrite);
+  }
+  if(p->readopen == 0 && p->writeopen == 0){
+8010353b:	8b 93 3c 02 00 00    	mov    0x23c(%ebx),%edx
+80103541:	85 d2                	test   %edx,%edx
+80103543:	75 0a                	jne    8010354f <pipeclose+0x4f>
+80103545:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
+8010354b:	85 c0                	test   %eax,%eax
+8010354d:	74 31                	je     80103580 <pipeclose+0x80>
+    release(&p->lock);
+    kfree((char*)p);
+  } else
+    release(&p->lock);
+8010354f:	89 5d 08             	mov    %ebx,0x8(%ebp)
+}
+80103552:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80103555:	5b                   	pop    %ebx
+80103556:	5e                   	pop    %esi
+80103557:	5d                   	pop    %ebp
+    release(&p->lock);
+80103558:	e9 43 13 00 00       	jmp    801048a0 <release>
+8010355d:	8d 76 00             	lea    0x0(%esi),%esi
+    wakeup(&p->nwrite);
+80103560:	83 ec 0c             	sub    $0xc,%esp
+80103563:	8d 83 38 02 00 00    	lea    0x238(%ebx),%eax
+    p->readopen = 0;
+80103569:	c7 83 3c 02 00 00 00 	movl   $0x0,0x23c(%ebx)
+80103570:	00 00 00 
+    wakeup(&p->nwrite);
+80103573:	50                   	push   %eax
+80103574:	e8 67 0b 00 00       	call   801040e0 <wakeup>
+80103579:	83 c4 10             	add    $0x10,%esp
+8010357c:	eb bd                	jmp    8010353b <pipeclose+0x3b>
+8010357e:	66 90                	xchg   %ax,%ax
+    release(&p->lock);
+80103580:	83 ec 0c             	sub    $0xc,%esp
+80103583:	53                   	push   %ebx
+80103584:	e8 17 13 00 00       	call   801048a0 <release>
+    kfree((char*)p);
+80103589:	89 5d 08             	mov    %ebx,0x8(%ebp)
+8010358c:	83 c4 10             	add    $0x10,%esp
+}
+8010358f:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80103592:	5b                   	pop    %ebx
+80103593:	5e                   	pop    %esi
+80103594:	5d                   	pop    %ebp
+    kfree((char*)p);
+80103595:	e9 d6 ee ff ff       	jmp    80102470 <kfree>
+8010359a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+801035a0 <pipewrite>:
+
+//PAGEBREAK: 40
+int
+pipewrite(struct pipe *p, char *addr, int n)
+{
+801035a0:	f3 0f 1e fb          	endbr32 
+801035a4:	55                   	push   %ebp
+801035a5:	89 e5                	mov    %esp,%ebp
+801035a7:	57                   	push   %edi
+801035a8:	56                   	push   %esi
+801035a9:	53                   	push   %ebx
+801035aa:	83 ec 28             	sub    $0x28,%esp
+801035ad:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  int i;
+
+  acquire(&p->lock);
+801035b0:	53                   	push   %ebx
+801035b1:	e8 2a 12 00 00       	call   801047e0 <acquire>
+  for(i = 0; i < n; i++){
+801035b6:	8b 45 10             	mov    0x10(%ebp),%eax
+801035b9:	83 c4 10             	add    $0x10,%esp
+801035bc:	85 c0                	test   %eax,%eax
+801035be:	0f 8e bc 00 00 00    	jle    80103680 <pipewrite+0xe0>
+801035c4:	8b 45 0c             	mov    0xc(%ebp),%eax
+801035c7:	8b 8b 38 02 00 00    	mov    0x238(%ebx),%ecx
+    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+      if(p->readopen == 0 || myproc()->killed){
+        release(&p->lock);
+        return -1;
+      }
+      wakeup(&p->nread);
+801035cd:	8d bb 34 02 00 00    	lea    0x234(%ebx),%edi
+801035d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+801035d6:	03 45 10             	add    0x10(%ebp),%eax
+801035d9:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+801035dc:	8b 83 34 02 00 00    	mov    0x234(%ebx),%eax
+      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+801035e2:	8d b3 38 02 00 00    	lea    0x238(%ebx),%esi
+    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+801035e8:	89 ca                	mov    %ecx,%edx
+801035ea:	05 00 02 00 00       	add    $0x200,%eax
+801035ef:	39 c1                	cmp    %eax,%ecx
+801035f1:	74 3b                	je     8010362e <pipewrite+0x8e>
+801035f3:	eb 63                	jmp    80103658 <pipewrite+0xb8>
+801035f5:	8d 76 00             	lea    0x0(%esi),%esi
+      if(p->readopen == 0 || myproc()->killed){
+801035f8:	e8 63 03 00 00       	call   80103960 <myproc>
+801035fd:	8b 48 24             	mov    0x24(%eax),%ecx
+80103600:	85 c9                	test   %ecx,%ecx
+80103602:	75 34                	jne    80103638 <pipewrite+0x98>
+      wakeup(&p->nread);
+80103604:	83 ec 0c             	sub    $0xc,%esp
+80103607:	57                   	push   %edi
+80103608:	e8 d3 0a 00 00       	call   801040e0 <wakeup>
+      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+8010360d:	58                   	pop    %eax
+8010360e:	5a                   	pop    %edx
+8010360f:	53                   	push   %ebx
+80103610:	56                   	push   %esi
+80103611:	e8 0a 09 00 00       	call   80103f20 <sleep>
+    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+80103616:	8b 83 34 02 00 00    	mov    0x234(%ebx),%eax
+8010361c:	8b 93 38 02 00 00    	mov    0x238(%ebx),%edx
+80103622:	83 c4 10             	add    $0x10,%esp
+80103625:	05 00 02 00 00       	add    $0x200,%eax
+8010362a:	39 c2                	cmp    %eax,%edx
+8010362c:	75 2a                	jne    80103658 <pipewrite+0xb8>
+      if(p->readopen == 0 || myproc()->killed){
+8010362e:	8b 83 3c 02 00 00    	mov    0x23c(%ebx),%eax
+80103634:	85 c0                	test   %eax,%eax
+80103636:	75 c0                	jne    801035f8 <pipewrite+0x58>
+        release(&p->lock);
+80103638:	83 ec 0c             	sub    $0xc,%esp
+8010363b:	53                   	push   %ebx
+8010363c:	e8 5f 12 00 00       	call   801048a0 <release>
+        return -1;
+80103641:	83 c4 10             	add    $0x10,%esp
+80103644:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+  }
+  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+  release(&p->lock);
+  return n;
+}
+80103649:	8d 65 f4             	lea    -0xc(%ebp),%esp
+8010364c:	5b                   	pop    %ebx
+8010364d:	5e                   	pop    %esi
+8010364e:	5f                   	pop    %edi
+8010364f:	5d                   	pop    %ebp
+80103650:	c3                   	ret    
+80103651:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+80103658:	8b 75 e4             	mov    -0x1c(%ebp),%esi
+8010365b:	8d 4a 01             	lea    0x1(%edx),%ecx
+8010365e:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
+80103664:	89 8b 38 02 00 00    	mov    %ecx,0x238(%ebx)
+8010366a:	0f b6 06             	movzbl (%esi),%eax
+8010366d:	83 c6 01             	add    $0x1,%esi
+80103670:	89 75 e4             	mov    %esi,-0x1c(%ebp)
+80103673:	88 44 13 34          	mov    %al,0x34(%ebx,%edx,1)
+  for(i = 0; i < n; i++){
+80103677:	3b 75 e0             	cmp    -0x20(%ebp),%esi
+8010367a:	0f 85 5c ff ff ff    	jne    801035dc <pipewrite+0x3c>
+  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+80103680:	83 ec 0c             	sub    $0xc,%esp
+80103683:	8d 83 34 02 00 00    	lea    0x234(%ebx),%eax
+80103689:	50                   	push   %eax
+8010368a:	e8 51 0a 00 00       	call   801040e0 <wakeup>
+  release(&p->lock);
+8010368f:	89 1c 24             	mov    %ebx,(%esp)
+80103692:	e8 09 12 00 00       	call   801048a0 <release>
+  return n;
+80103697:	8b 45 10             	mov    0x10(%ebp),%eax
+8010369a:	83 c4 10             	add    $0x10,%esp
+8010369d:	eb aa                	jmp    80103649 <pipewrite+0xa9>
+8010369f:	90                   	nop
+
+801036a0 <piperead>:
+
+int
+piperead(struct pipe *p, char *addr, int n)
+{
+801036a0:	f3 0f 1e fb          	endbr32 
+801036a4:	55                   	push   %ebp
+801036a5:	89 e5                	mov    %esp,%ebp
+801036a7:	57                   	push   %edi
+801036a8:	56                   	push   %esi
+801036a9:	53                   	push   %ebx
+801036aa:	83 ec 18             	sub    $0x18,%esp
+801036ad:	8b 75 08             	mov    0x8(%ebp),%esi
+801036b0:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  int i;
+
+  acquire(&p->lock);
+801036b3:	56                   	push   %esi
+801036b4:	8d 9e 34 02 00 00    	lea    0x234(%esi),%ebx
+801036ba:	e8 21 11 00 00       	call   801047e0 <acquire>
+  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+801036bf:	8b 86 34 02 00 00    	mov    0x234(%esi),%eax
+801036c5:	83 c4 10             	add    $0x10,%esp
+801036c8:	39 86 38 02 00 00    	cmp    %eax,0x238(%esi)
+801036ce:	74 33                	je     80103703 <piperead+0x63>
+801036d0:	eb 3b                	jmp    8010370d <piperead+0x6d>
+801036d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    if(myproc()->killed){
+801036d8:	e8 83 02 00 00       	call   80103960 <myproc>
+801036dd:	8b 48 24             	mov    0x24(%eax),%ecx
+801036e0:	85 c9                	test   %ecx,%ecx
+801036e2:	0f 85 88 00 00 00    	jne    80103770 <piperead+0xd0>
+      release(&p->lock);
+      return -1;
+    }
+    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+801036e8:	83 ec 08             	sub    $0x8,%esp
+801036eb:	56                   	push   %esi
+801036ec:	53                   	push   %ebx
+801036ed:	e8 2e 08 00 00       	call   80103f20 <sleep>
+  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+801036f2:	8b 86 38 02 00 00    	mov    0x238(%esi),%eax
+801036f8:	83 c4 10             	add    $0x10,%esp
+801036fb:	39 86 34 02 00 00    	cmp    %eax,0x234(%esi)
+80103701:	75 0a                	jne    8010370d <piperead+0x6d>
+80103703:	8b 86 40 02 00 00    	mov    0x240(%esi),%eax
+80103709:	85 c0                	test   %eax,%eax
+8010370b:	75 cb                	jne    801036d8 <piperead+0x38>
+  }
+  for(i = 0; i < n; i++){  //DOC: piperead-copy
+8010370d:	8b 55 10             	mov    0x10(%ebp),%edx
+80103710:	31 db                	xor    %ebx,%ebx
+80103712:	85 d2                	test   %edx,%edx
+80103714:	7f 28                	jg     8010373e <piperead+0x9e>
+80103716:	eb 34                	jmp    8010374c <piperead+0xac>
+80103718:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010371f:	90                   	nop
+    if(p->nread == p->nwrite)
+      break;
+    addr[i] = p->data[p->nread++ % PIPESIZE];
+80103720:	8d 48 01             	lea    0x1(%eax),%ecx
+80103723:	25 ff 01 00 00       	and    $0x1ff,%eax
+80103728:	89 8e 34 02 00 00    	mov    %ecx,0x234(%esi)
+8010372e:	0f b6 44 06 34       	movzbl 0x34(%esi,%eax,1),%eax
+80103733:	88 04 1f             	mov    %al,(%edi,%ebx,1)
+  for(i = 0; i < n; i++){  //DOC: piperead-copy
+80103736:	83 c3 01             	add    $0x1,%ebx
+80103739:	39 5d 10             	cmp    %ebx,0x10(%ebp)
+8010373c:	74 0e                	je     8010374c <piperead+0xac>
+    if(p->nread == p->nwrite)
+8010373e:	8b 86 34 02 00 00    	mov    0x234(%esi),%eax
+80103744:	3b 86 38 02 00 00    	cmp    0x238(%esi),%eax
+8010374a:	75 d4                	jne    80103720 <piperead+0x80>
+  }
+  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+8010374c:	83 ec 0c             	sub    $0xc,%esp
+8010374f:	8d 86 38 02 00 00    	lea    0x238(%esi),%eax
+80103755:	50                   	push   %eax
+80103756:	e8 85 09 00 00       	call   801040e0 <wakeup>
+  release(&p->lock);
+8010375b:	89 34 24             	mov    %esi,(%esp)
+8010375e:	e8 3d 11 00 00       	call   801048a0 <release>
+  return i;
+80103763:	83 c4 10             	add    $0x10,%esp
+}
+80103766:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80103769:	89 d8                	mov    %ebx,%eax
+8010376b:	5b                   	pop    %ebx
+8010376c:	5e                   	pop    %esi
+8010376d:	5f                   	pop    %edi
+8010376e:	5d                   	pop    %ebp
+8010376f:	c3                   	ret    
+      release(&p->lock);
+80103770:	83 ec 0c             	sub    $0xc,%esp
+      return -1;
+80103773:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
+      release(&p->lock);
+80103778:	56                   	push   %esi
+80103779:	e8 22 11 00 00       	call   801048a0 <release>
+      return -1;
+8010377e:	83 c4 10             	add    $0x10,%esp
+}
+80103781:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80103784:	89 d8                	mov    %ebx,%eax
+80103786:	5b                   	pop    %ebx
+80103787:	5e                   	pop    %esi
+80103788:	5f                   	pop    %edi
+80103789:	5d                   	pop    %ebp
+8010378a:	c3                   	ret    
+8010378b:	66 90                	xchg   %ax,%ax
+8010378d:	66 90                	xchg   %ax,%ax
+8010378f:	90                   	nop
+
+80103790 <allocproc>:
+// If found, change state to EMBRYO and initialize
+// state required to run in the kernel.
+// Otherwise return 0.
+static struct proc*
+allocproc(void)
+{
+80103790:	55                   	push   %ebp
+80103791:	89 e5                	mov    %esp,%ebp
+80103793:	53                   	push   %ebx
+  struct proc *p;
+  char *sp;
+
+  acquire(&ptable.lock);
+
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+80103794:	bb 54 2d 11 80       	mov    $0x80112d54,%ebx
+{
+80103799:	83 ec 10             	sub    $0x10,%esp
+  acquire(&ptable.lock);
+8010379c:	68 20 2d 11 80       	push   $0x80112d20
+801037a1:	e8 3a 10 00 00       	call   801047e0 <acquire>
+801037a6:	83 c4 10             	add    $0x10,%esp
+801037a9:	eb 10                	jmp    801037bb <allocproc+0x2b>
+801037ab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801037af:	90                   	nop
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+801037b0:	83 eb 80             	sub    $0xffffff80,%ebx
+801037b3:	81 fb 54 4d 11 80    	cmp    $0x80114d54,%ebx
+801037b9:	74 75                	je     80103830 <allocproc+0xa0>
+    if(p->state == UNUSED)
+801037bb:	8b 43 0c             	mov    0xc(%ebx),%eax
+801037be:	85 c0                	test   %eax,%eax
+801037c0:	75 ee                	jne    801037b0 <allocproc+0x20>
+  release(&ptable.lock);
+  return 0;
+
+found:
+  p->state = EMBRYO;
+  p->pid = nextpid++;
+801037c2:	a1 04 a0 10 80       	mov    0x8010a004,%eax
+
+  release(&ptable.lock);
+801037c7:	83 ec 0c             	sub    $0xc,%esp
+  p->state = EMBRYO;
+801037ca:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
+  p->pid = nextpid++;
+801037d1:	89 43 10             	mov    %eax,0x10(%ebx)
+801037d4:	8d 50 01             	lea    0x1(%eax),%edx
+  release(&ptable.lock);
+801037d7:	68 20 2d 11 80       	push   $0x80112d20
+  p->pid = nextpid++;
+801037dc:	89 15 04 a0 10 80    	mov    %edx,0x8010a004
+  release(&ptable.lock);
+801037e2:	e8 b9 10 00 00       	call   801048a0 <release>
+
+  // Allocate kernel stack.
+  if((p->kstack = kalloc()) == 0){
+801037e7:	e8 44 ee ff ff       	call   80102630 <kalloc>
+801037ec:	83 c4 10             	add    $0x10,%esp
+801037ef:	89 43 08             	mov    %eax,0x8(%ebx)
+801037f2:	85 c0                	test   %eax,%eax
+801037f4:	74 53                	je     80103849 <allocproc+0xb9>
+    return 0;
+  }
+  sp = p->kstack + KSTACKSIZE;
+
+  // Leave room for trap frame.
+  sp -= sizeof *p->tf;
+801037f6:	8d 90 b4 0f 00 00    	lea    0xfb4(%eax),%edx
+  sp -= 4;
+  *(uint*)sp = (uint)trapret;
+
+  sp -= sizeof *p->context;
+  p->context = (struct context*)sp;
+  memset(p->context, 0, sizeof *p->context);
+801037fc:	83 ec 04             	sub    $0x4,%esp
+  sp -= sizeof *p->context;
+801037ff:	05 9c 0f 00 00       	add    $0xf9c,%eax
+  sp -= sizeof *p->tf;
+80103804:	89 53 18             	mov    %edx,0x18(%ebx)
+  *(uint*)sp = (uint)trapret;
+80103807:	c7 40 14 67 5c 10 80 	movl   $0x80105c67,0x14(%eax)
+  p->context = (struct context*)sp;
+8010380e:	89 43 1c             	mov    %eax,0x1c(%ebx)
+  memset(p->context, 0, sizeof *p->context);
+80103811:	6a 14                	push   $0x14
+80103813:	6a 00                	push   $0x0
+80103815:	50                   	push   %eax
+80103816:	e8 d5 10 00 00       	call   801048f0 <memset>
+  p->context->eip = (uint)forkret;
+8010381b:	8b 43 1c             	mov    0x1c(%ebx),%eax
+
+  return p;
+8010381e:	83 c4 10             	add    $0x10,%esp
+  p->context->eip = (uint)forkret;
+80103821:	c7 40 10 60 38 10 80 	movl   $0x80103860,0x10(%eax)
+}
+80103828:	89 d8                	mov    %ebx,%eax
+8010382a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+8010382d:	c9                   	leave  
+8010382e:	c3                   	ret    
+8010382f:	90                   	nop
+  release(&ptable.lock);
+80103830:	83 ec 0c             	sub    $0xc,%esp
+  return 0;
+80103833:	31 db                	xor    %ebx,%ebx
+  release(&ptable.lock);
+80103835:	68 20 2d 11 80       	push   $0x80112d20
+8010383a:	e8 61 10 00 00       	call   801048a0 <release>
+}
+8010383f:	89 d8                	mov    %ebx,%eax
+  return 0;
+80103841:	83 c4 10             	add    $0x10,%esp
+}
+80103844:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80103847:	c9                   	leave  
+80103848:	c3                   	ret    
+    p->state = UNUSED;
+80103849:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
+    return 0;
+80103850:	31 db                	xor    %ebx,%ebx
+}
+80103852:	89 d8                	mov    %ebx,%eax
+80103854:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80103857:	c9                   	leave  
+80103858:	c3                   	ret    
+80103859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80103860 <forkret>:
+
+// A fork child's very first scheduling by scheduler()
+// will swtch here.  "Return" to user space.
+void
+forkret(void)
+{
+80103860:	f3 0f 1e fb          	endbr32 
+80103864:	55                   	push   %ebp
+80103865:	89 e5                	mov    %esp,%ebp
+80103867:	83 ec 14             	sub    $0x14,%esp
+  static int first = 1;
+  // Still holding ptable.lock from scheduler.
+  release(&ptable.lock);
+8010386a:	68 20 2d 11 80       	push   $0x80112d20
+8010386f:	e8 2c 10 00 00       	call   801048a0 <release>
+
+  if (first) {
+80103874:	a1 00 a0 10 80       	mov    0x8010a000,%eax
+80103879:	83 c4 10             	add    $0x10,%esp
+8010387c:	85 c0                	test   %eax,%eax
+8010387e:	75 08                	jne    80103888 <forkret+0x28>
+    iinit(ROOTDEV);
+    initlog(ROOTDEV);
+  }
+
+  // Return to "caller", actually trapret (see allocproc).
+}
+80103880:	c9                   	leave  
+80103881:	c3                   	ret    
+80103882:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    first = 0;
+80103888:	c7 05 00 a0 10 80 00 	movl   $0x0,0x8010a000
+8010388f:	00 00 00 
+    iinit(ROOTDEV);
+80103892:	83 ec 0c             	sub    $0xc,%esp
+80103895:	6a 01                	push   $0x1
+80103897:	e8 a4 dc ff ff       	call   80101540 <iinit>
+    initlog(ROOTDEV);
+8010389c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+801038a3:	e8 e8 f3 ff ff       	call   80102c90 <initlog>
+}
+801038a8:	83 c4 10             	add    $0x10,%esp
+801038ab:	c9                   	leave  
+801038ac:	c3                   	ret    
+801038ad:	8d 76 00             	lea    0x0(%esi),%esi
+
+801038b0 <pinit>:
+{
+801038b0:	f3 0f 1e fb          	endbr32 
+801038b4:	55                   	push   %ebp
+801038b5:	89 e5                	mov    %esp,%ebp
+801038b7:	83 ec 10             	sub    $0x10,%esp
+  initlock(&ptable.lock, "ptable");
+801038ba:	68 00 7a 10 80       	push   $0x80107a00
+801038bf:	68 20 2d 11 80       	push   $0x80112d20
+801038c4:	e8 97 0d 00 00       	call   80104660 <initlock>
+}
+801038c9:	83 c4 10             	add    $0x10,%esp
+801038cc:	c9                   	leave  
+801038cd:	c3                   	ret    
+801038ce:	66 90                	xchg   %ax,%ax
+
+801038d0 <mycpu>:
+{
+801038d0:	f3 0f 1e fb          	endbr32 
+801038d4:	55                   	push   %ebp
+801038d5:	89 e5                	mov    %esp,%ebp
+801038d7:	56                   	push   %esi
+801038d8:	53                   	push   %ebx
+  asm volatile("pushfl; popl %0" : "=r" (eflags));
+801038d9:	9c                   	pushf  
+801038da:	58                   	pop    %eax
+  if(readeflags()&FL_IF)
+801038db:	f6 c4 02             	test   $0x2,%ah
+801038de:	75 4a                	jne    8010392a <mycpu+0x5a>
+  apicid = lapicid();
+801038e0:	e8 bb ef ff ff       	call   801028a0 <lapicid>
+  for (i = 0; i < ncpu; ++i) {
+801038e5:	8b 35 00 2d 11 80    	mov    0x80112d00,%esi
+  apicid = lapicid();
+801038eb:	89 c3                	mov    %eax,%ebx
+  for (i = 0; i < ncpu; ++i) {
+801038ed:	85 f6                	test   %esi,%esi
+801038ef:	7e 2c                	jle    8010391d <mycpu+0x4d>
+801038f1:	31 d2                	xor    %edx,%edx
+801038f3:	eb 0a                	jmp    801038ff <mycpu+0x2f>
+801038f5:	8d 76 00             	lea    0x0(%esi),%esi
+801038f8:	83 c2 01             	add    $0x1,%edx
+801038fb:	39 f2                	cmp    %esi,%edx
+801038fd:	74 1e                	je     8010391d <mycpu+0x4d>
+    if (cpus[i].apicid == apicid)
+801038ff:	69 ca b0 00 00 00    	imul   $0xb0,%edx,%ecx
+80103905:	0f b6 81 80 27 11 80 	movzbl -0x7feed880(%ecx),%eax
+8010390c:	39 d8                	cmp    %ebx,%eax
+8010390e:	75 e8                	jne    801038f8 <mycpu+0x28>
+}
+80103910:	8d 65 f8             	lea    -0x8(%ebp),%esp
+      return &cpus[i];
+80103913:	8d 81 80 27 11 80    	lea    -0x7feed880(%ecx),%eax
+}
+80103919:	5b                   	pop    %ebx
+8010391a:	5e                   	pop    %esi
+8010391b:	5d                   	pop    %ebp
+8010391c:	c3                   	ret    
+  panic("unknown apicid\n");
+8010391d:	83 ec 0c             	sub    $0xc,%esp
+80103920:	68 07 7a 10 80       	push   $0x80107a07
+80103925:	e8 66 ca ff ff       	call   80100390 <panic>
+    panic("mycpu called with interrupts enabled\n");
+8010392a:	83 ec 0c             	sub    $0xc,%esp
+8010392d:	68 e4 7a 10 80       	push   $0x80107ae4
+80103932:	e8 59 ca ff ff       	call   80100390 <panic>
+80103937:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010393e:	66 90                	xchg   %ax,%ax
+
+80103940 <cpuid>:
+cpuid() {
+80103940:	f3 0f 1e fb          	endbr32 
+80103944:	55                   	push   %ebp
+80103945:	89 e5                	mov    %esp,%ebp
+80103947:	83 ec 08             	sub    $0x8,%esp
+  return mycpu()-cpus;
+8010394a:	e8 81 ff ff ff       	call   801038d0 <mycpu>
+}
+8010394f:	c9                   	leave  
+  return mycpu()-cpus;
+80103950:	2d 80 27 11 80       	sub    $0x80112780,%eax
+80103955:	c1 f8 04             	sar    $0x4,%eax
+80103958:	69 c0 a3 8b 2e ba    	imul   $0xba2e8ba3,%eax,%eax
+}
+8010395e:	c3                   	ret    
+8010395f:	90                   	nop
+
+80103960 <myproc>:
+myproc(void) {
+80103960:	f3 0f 1e fb          	endbr32 
+80103964:	55                   	push   %ebp
+80103965:	89 e5                	mov    %esp,%ebp
+80103967:	53                   	push   %ebx
+80103968:	83 ec 04             	sub    $0x4,%esp
+  pushcli();
+8010396b:	e8 70 0d 00 00       	call   801046e0 <pushcli>
+  c = mycpu();
+80103970:	e8 5b ff ff ff       	call   801038d0 <mycpu>
+  p = c->proc;
+80103975:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
+  popcli();
+8010397b:	e8 b0 0d 00 00       	call   80104730 <popcli>
+}
+80103980:	83 c4 04             	add    $0x4,%esp
+80103983:	89 d8                	mov    %ebx,%eax
+80103985:	5b                   	pop    %ebx
+80103986:	5d                   	pop    %ebp
+80103987:	c3                   	ret    
+80103988:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010398f:	90                   	nop
+
+80103990 <userinit>:
+{
+80103990:	f3 0f 1e fb          	endbr32 
+80103994:	55                   	push   %ebp
+80103995:	89 e5                	mov    %esp,%ebp
+80103997:	53                   	push   %ebx
+80103998:	83 ec 04             	sub    $0x4,%esp
+  p = allocproc();
+8010399b:	e8 f0 fd ff ff       	call   80103790 <allocproc>
+801039a0:	89 c3                	mov    %eax,%ebx
+  initproc = p;
+801039a2:	a3 b8 a5 10 80       	mov    %eax,0x8010a5b8
+  if((p->pgdir = setupkvm()) == 0)
+801039a7:	e8 84 38 00 00       	call   80107230 <setupkvm>
+801039ac:	89 43 04             	mov    %eax,0x4(%ebx)
+801039af:	85 c0                	test   %eax,%eax
+801039b1:	0f 84 bd 00 00 00    	je     80103a74 <userinit+0xe4>
+  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+801039b7:	83 ec 04             	sub    $0x4,%esp
+801039ba:	68 2c 00 00 00       	push   $0x2c
+801039bf:	68 60 a4 10 80       	push   $0x8010a460
+801039c4:	50                   	push   %eax
+801039c5:	e8 36 35 00 00       	call   80106f00 <inituvm>
+  memset(p->tf, 0, sizeof(*p->tf));
+801039ca:	83 c4 0c             	add    $0xc,%esp
+  p->sz = PGSIZE;
+801039cd:	c7 03 00 10 00 00    	movl   $0x1000,(%ebx)
+  memset(p->tf, 0, sizeof(*p->tf));
+801039d3:	6a 4c                	push   $0x4c
+801039d5:	6a 00                	push   $0x0
+801039d7:	ff 73 18             	pushl  0x18(%ebx)
+801039da:	e8 11 0f 00 00       	call   801048f0 <memset>
+  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+801039df:	8b 43 18             	mov    0x18(%ebx),%eax
+801039e2:	ba 1b 00 00 00       	mov    $0x1b,%edx
+  safestrcpy(p->name, "initcode", sizeof(p->name));
+801039e7:	83 c4 0c             	add    $0xc,%esp
+  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+801039ea:	b9 23 00 00 00       	mov    $0x23,%ecx
+  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+801039ef:	66 89 50 3c          	mov    %dx,0x3c(%eax)
+  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+801039f3:	8b 43 18             	mov    0x18(%ebx),%eax
+801039f6:	66 89 48 2c          	mov    %cx,0x2c(%eax)
+  p->tf->es = p->tf->ds;
+801039fa:	8b 43 18             	mov    0x18(%ebx),%eax
+801039fd:	0f b7 50 2c          	movzwl 0x2c(%eax),%edx
+80103a01:	66 89 50 28          	mov    %dx,0x28(%eax)
+  p->tf->ss = p->tf->ds;
+80103a05:	8b 43 18             	mov    0x18(%ebx),%eax
+80103a08:	0f b7 50 2c          	movzwl 0x2c(%eax),%edx
+80103a0c:	66 89 50 48          	mov    %dx,0x48(%eax)
+  p->tf->eflags = FL_IF;
+80103a10:	8b 43 18             	mov    0x18(%ebx),%eax
+80103a13:	c7 40 40 00 02 00 00 	movl   $0x200,0x40(%eax)
+  p->tf->esp = PGSIZE;
+80103a1a:	8b 43 18             	mov    0x18(%ebx),%eax
+80103a1d:	c7 40 44 00 10 00 00 	movl   $0x1000,0x44(%eax)
+  p->tf->eip = 0;  // beginning of initcode.S
+80103a24:	8b 43 18             	mov    0x18(%ebx),%eax
+80103a27:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
+  safestrcpy(p->name, "initcode", sizeof(p->name));
+80103a2e:	8d 43 6c             	lea    0x6c(%ebx),%eax
+80103a31:	6a 10                	push   $0x10
+80103a33:	68 30 7a 10 80       	push   $0x80107a30
+80103a38:	50                   	push   %eax
+80103a39:	e8 72 10 00 00       	call   80104ab0 <safestrcpy>
+  p->cwd = namei("/");
+80103a3e:	c7 04 24 39 7a 10 80 	movl   $0x80107a39,(%esp)
+80103a45:	e8 e6 e5 ff ff       	call   80102030 <namei>
+80103a4a:	89 43 68             	mov    %eax,0x68(%ebx)
+  acquire(&ptable.lock);
+80103a4d:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103a54:	e8 87 0d 00 00       	call   801047e0 <acquire>
+  p->state = RUNNABLE;
+80103a59:	c7 43 0c 03 00 00 00 	movl   $0x3,0xc(%ebx)
+  release(&ptable.lock);
+80103a60:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103a67:	e8 34 0e 00 00       	call   801048a0 <release>
+}
+80103a6c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80103a6f:	83 c4 10             	add    $0x10,%esp
+80103a72:	c9                   	leave  
+80103a73:	c3                   	ret    
+    panic("userinit: out of memory?");
+80103a74:	83 ec 0c             	sub    $0xc,%esp
+80103a77:	68 17 7a 10 80       	push   $0x80107a17
+80103a7c:	e8 0f c9 ff ff       	call   80100390 <panic>
+80103a81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80103a88:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80103a8f:	90                   	nop
+
+80103a90 <growproc>:
+{
+80103a90:	f3 0f 1e fb          	endbr32 
+80103a94:	55                   	push   %ebp
+80103a95:	89 e5                	mov    %esp,%ebp
+80103a97:	56                   	push   %esi
+80103a98:	53                   	push   %ebx
+80103a99:	8b 75 08             	mov    0x8(%ebp),%esi
+  pushcli();
+80103a9c:	e8 3f 0c 00 00       	call   801046e0 <pushcli>
+  c = mycpu();
+80103aa1:	e8 2a fe ff ff       	call   801038d0 <mycpu>
+  p = c->proc;
+80103aa6:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
+  popcli();
+80103aac:	e8 7f 0c 00 00       	call   80104730 <popcli>
+  sz = curproc->sz;
+80103ab1:	8b 03                	mov    (%ebx),%eax
+  if(n > 0){
+80103ab3:	85 f6                	test   %esi,%esi
+80103ab5:	7f 19                	jg     80103ad0 <growproc+0x40>
+  } else if(n < 0){
+80103ab7:	75 37                	jne    80103af0 <growproc+0x60>
+  switchuvm(curproc);
+80103ab9:	83 ec 0c             	sub    $0xc,%esp
+  curproc->sz = sz;
+80103abc:	89 03                	mov    %eax,(%ebx)
+  switchuvm(curproc);
+80103abe:	53                   	push   %ebx
+80103abf:	e8 2c 33 00 00       	call   80106df0 <switchuvm>
+  return 0;
+80103ac4:	83 c4 10             	add    $0x10,%esp
+80103ac7:	31 c0                	xor    %eax,%eax
+}
+80103ac9:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80103acc:	5b                   	pop    %ebx
+80103acd:	5e                   	pop    %esi
+80103ace:	5d                   	pop    %ebp
+80103acf:	c3                   	ret    
+    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+80103ad0:	83 ec 04             	sub    $0x4,%esp
+80103ad3:	01 c6                	add    %eax,%esi
+80103ad5:	56                   	push   %esi
+80103ad6:	50                   	push   %eax
+80103ad7:	ff 73 04             	pushl  0x4(%ebx)
+80103ada:	e8 71 35 00 00       	call   80107050 <allocuvm>
+80103adf:	83 c4 10             	add    $0x10,%esp
+80103ae2:	85 c0                	test   %eax,%eax
+80103ae4:	75 d3                	jne    80103ab9 <growproc+0x29>
+      return -1;
+80103ae6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80103aeb:	eb dc                	jmp    80103ac9 <growproc+0x39>
+80103aed:	8d 76 00             	lea    0x0(%esi),%esi
+    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+80103af0:	83 ec 04             	sub    $0x4,%esp
+80103af3:	01 c6                	add    %eax,%esi
+80103af5:	56                   	push   %esi
+80103af6:	50                   	push   %eax
+80103af7:	ff 73 04             	pushl  0x4(%ebx)
+80103afa:	e8 81 36 00 00       	call   80107180 <deallocuvm>
+80103aff:	83 c4 10             	add    $0x10,%esp
+80103b02:	85 c0                	test   %eax,%eax
+80103b04:	75 b3                	jne    80103ab9 <growproc+0x29>
+80103b06:	eb de                	jmp    80103ae6 <growproc+0x56>
+80103b08:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80103b0f:	90                   	nop
+
+80103b10 <fork>:
+{
+80103b10:	f3 0f 1e fb          	endbr32 
+80103b14:	55                   	push   %ebp
+80103b15:	89 e5                	mov    %esp,%ebp
+80103b17:	57                   	push   %edi
+80103b18:	56                   	push   %esi
+80103b19:	53                   	push   %ebx
+80103b1a:	83 ec 1c             	sub    $0x1c,%esp
+  pushcli();
+80103b1d:	e8 be 0b 00 00       	call   801046e0 <pushcli>
+  c = mycpu();
+80103b22:	e8 a9 fd ff ff       	call   801038d0 <mycpu>
+  p = c->proc;
+80103b27:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
+  popcli();
+80103b2d:	e8 fe 0b 00 00       	call   80104730 <popcli>
+  if((np = allocproc()) == 0){
+80103b32:	e8 59 fc ff ff       	call   80103790 <allocproc>
+80103b37:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+80103b3a:	85 c0                	test   %eax,%eax
+80103b3c:	0f 84 bb 00 00 00    	je     80103bfd <fork+0xed>
+  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+80103b42:	83 ec 08             	sub    $0x8,%esp
+80103b45:	ff 33                	pushl  (%ebx)
+80103b47:	89 c7                	mov    %eax,%edi
+80103b49:	ff 73 04             	pushl  0x4(%ebx)
+80103b4c:	e8 af 37 00 00       	call   80107300 <copyuvm>
+80103b51:	83 c4 10             	add    $0x10,%esp
+80103b54:	89 47 04             	mov    %eax,0x4(%edi)
+80103b57:	85 c0                	test   %eax,%eax
+80103b59:	0f 84 a5 00 00 00    	je     80103c04 <fork+0xf4>
+  np->sz = curproc->sz;
+80103b5f:	8b 03                	mov    (%ebx),%eax
+80103b61:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+80103b64:	89 01                	mov    %eax,(%ecx)
+  *np->tf = *curproc->tf;
+80103b66:	8b 79 18             	mov    0x18(%ecx),%edi
+  np->parent = curproc;
+80103b69:	89 c8                	mov    %ecx,%eax
+80103b6b:	89 59 14             	mov    %ebx,0x14(%ecx)
+  *np->tf = *curproc->tf;
+80103b6e:	b9 13 00 00 00       	mov    $0x13,%ecx
+80103b73:	8b 73 18             	mov    0x18(%ebx),%esi
+80103b76:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  for(i = 0; i < NOFILE; i++)
+80103b78:	31 f6                	xor    %esi,%esi
+  np->tf->eax = 0;
+80103b7a:	8b 40 18             	mov    0x18(%eax),%eax
+80103b7d:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
+  for(i = 0; i < NOFILE; i++)
+80103b84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    if(curproc->ofile[i])
+80103b88:	8b 44 b3 28          	mov    0x28(%ebx,%esi,4),%eax
+80103b8c:	85 c0                	test   %eax,%eax
+80103b8e:	74 13                	je     80103ba3 <fork+0x93>
+      np->ofile[i] = filedup(curproc->ofile[i]);
+80103b90:	83 ec 0c             	sub    $0xc,%esp
+80103b93:	50                   	push   %eax
+80103b94:	e8 d7 d2 ff ff       	call   80100e70 <filedup>
+80103b99:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+80103b9c:	83 c4 10             	add    $0x10,%esp
+80103b9f:	89 44 b2 28          	mov    %eax,0x28(%edx,%esi,4)
+  for(i = 0; i < NOFILE; i++)
+80103ba3:	83 c6 01             	add    $0x1,%esi
+80103ba6:	83 fe 10             	cmp    $0x10,%esi
+80103ba9:	75 dd                	jne    80103b88 <fork+0x78>
+  np->cwd = idup(curproc->cwd);
+80103bab:	83 ec 0c             	sub    $0xc,%esp
+80103bae:	ff 73 68             	pushl  0x68(%ebx)
+  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+80103bb1:	83 c3 6c             	add    $0x6c,%ebx
+  np->cwd = idup(curproc->cwd);
+80103bb4:	e8 77 db ff ff       	call   80101730 <idup>
+80103bb9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
+  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+80103bbc:	83 c4 0c             	add    $0xc,%esp
+  np->cwd = idup(curproc->cwd);
+80103bbf:	89 47 68             	mov    %eax,0x68(%edi)
+  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+80103bc2:	8d 47 6c             	lea    0x6c(%edi),%eax
+80103bc5:	6a 10                	push   $0x10
+80103bc7:	53                   	push   %ebx
+80103bc8:	50                   	push   %eax
+80103bc9:	e8 e2 0e 00 00       	call   80104ab0 <safestrcpy>
+  pid = np->pid;
+80103bce:	8b 5f 10             	mov    0x10(%edi),%ebx
+  acquire(&ptable.lock);
+80103bd1:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103bd8:	e8 03 0c 00 00       	call   801047e0 <acquire>
+  np->state = RUNNABLE;
+80103bdd:	c7 47 0c 03 00 00 00 	movl   $0x3,0xc(%edi)
+  release(&ptable.lock);
+80103be4:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103beb:	e8 b0 0c 00 00       	call   801048a0 <release>
+  return pid;
+80103bf0:	83 c4 10             	add    $0x10,%esp
+}
+80103bf3:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80103bf6:	89 d8                	mov    %ebx,%eax
+80103bf8:	5b                   	pop    %ebx
+80103bf9:	5e                   	pop    %esi
+80103bfa:	5f                   	pop    %edi
+80103bfb:	5d                   	pop    %ebp
+80103bfc:	c3                   	ret    
+    return -1;
+80103bfd:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
+80103c02:	eb ef                	jmp    80103bf3 <fork+0xe3>
+    kfree(np->kstack);
+80103c04:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
+80103c07:	83 ec 0c             	sub    $0xc,%esp
+80103c0a:	ff 73 08             	pushl  0x8(%ebx)
+80103c0d:	e8 5e e8 ff ff       	call   80102470 <kfree>
+    np->kstack = 0;
+80103c12:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
+    return -1;
+80103c19:	83 c4 10             	add    $0x10,%esp
+    np->state = UNUSED;
+80103c1c:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
+    return -1;
+80103c23:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
+80103c28:	eb c9                	jmp    80103bf3 <fork+0xe3>
+80103c2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80103c30 <scheduler>:
+{
+80103c30:	f3 0f 1e fb          	endbr32 
+80103c34:	55                   	push   %ebp
+80103c35:	89 e5                	mov    %esp,%ebp
+80103c37:	57                   	push   %edi
+80103c38:	56                   	push   %esi
+80103c39:	53                   	push   %ebx
+80103c3a:	83 ec 0c             	sub    $0xc,%esp
+  struct cpu *c = mycpu();
+80103c3d:	e8 8e fc ff ff       	call   801038d0 <mycpu>
+  c->proc = 0;
+80103c42:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
+80103c49:	00 00 00 
+  struct cpu *c = mycpu();
+80103c4c:	89 c6                	mov    %eax,%esi
+  c->proc = 0;
+80103c4e:	8d 78 04             	lea    0x4(%eax),%edi
+80103c51:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  asm volatile("sti");
+80103c58:	fb                   	sti    
+    acquire(&ptable.lock);
+80103c59:	83 ec 0c             	sub    $0xc,%esp
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80103c5c:	bb 54 2d 11 80       	mov    $0x80112d54,%ebx
+    acquire(&ptable.lock);
+80103c61:	68 20 2d 11 80       	push   $0x80112d20
+80103c66:	e8 75 0b 00 00       	call   801047e0 <acquire>
+80103c6b:	83 c4 10             	add    $0x10,%esp
+80103c6e:	66 90                	xchg   %ax,%ax
+      if(p->state != RUNNABLE)
+80103c70:	83 7b 0c 03          	cmpl   $0x3,0xc(%ebx)
+80103c74:	75 33                	jne    80103ca9 <scheduler+0x79>
+      switchuvm(p);
+80103c76:	83 ec 0c             	sub    $0xc,%esp
+      c->proc = p;
+80103c79:	89 9e ac 00 00 00    	mov    %ebx,0xac(%esi)
+      switchuvm(p);
+80103c7f:	53                   	push   %ebx
+80103c80:	e8 6b 31 00 00       	call   80106df0 <switchuvm>
+      swtch(&(c->scheduler), p->context);
+80103c85:	58                   	pop    %eax
+80103c86:	5a                   	pop    %edx
+80103c87:	ff 73 1c             	pushl  0x1c(%ebx)
+80103c8a:	57                   	push   %edi
+      p->state = RUNNING;
+80103c8b:	c7 43 0c 04 00 00 00 	movl   $0x4,0xc(%ebx)
+      swtch(&(c->scheduler), p->context);
+80103c92:	e8 7c 0e 00 00       	call   80104b13 <swtch>
+      switchkvm();
+80103c97:	e8 34 31 00 00       	call   80106dd0 <switchkvm>
+      c->proc = 0;
+80103c9c:	83 c4 10             	add    $0x10,%esp
+80103c9f:	c7 86 ac 00 00 00 00 	movl   $0x0,0xac(%esi)
+80103ca6:	00 00 00 
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80103ca9:	83 eb 80             	sub    $0xffffff80,%ebx
+80103cac:	81 fb 54 4d 11 80    	cmp    $0x80114d54,%ebx
+80103cb2:	75 bc                	jne    80103c70 <scheduler+0x40>
+    release(&ptable.lock);
+80103cb4:	83 ec 0c             	sub    $0xc,%esp
+80103cb7:	68 20 2d 11 80       	push   $0x80112d20
+80103cbc:	e8 df 0b 00 00       	call   801048a0 <release>
+    sti();
+80103cc1:	83 c4 10             	add    $0x10,%esp
+80103cc4:	eb 92                	jmp    80103c58 <scheduler+0x28>
+80103cc6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80103ccd:	8d 76 00             	lea    0x0(%esi),%esi
+
+80103cd0 <sched>:
+{
+80103cd0:	f3 0f 1e fb          	endbr32 
+80103cd4:	55                   	push   %ebp
+80103cd5:	89 e5                	mov    %esp,%ebp
+80103cd7:	56                   	push   %esi
+80103cd8:	53                   	push   %ebx
+  pushcli();
+80103cd9:	e8 02 0a 00 00       	call   801046e0 <pushcli>
+  c = mycpu();
+80103cde:	e8 ed fb ff ff       	call   801038d0 <mycpu>
+  p = c->proc;
+80103ce3:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
+  popcli();
+80103ce9:	e8 42 0a 00 00       	call   80104730 <popcli>
+  if(!holding(&ptable.lock))
+80103cee:	83 ec 0c             	sub    $0xc,%esp
+80103cf1:	68 20 2d 11 80       	push   $0x80112d20
+80103cf6:	e8 95 0a 00 00       	call   80104790 <holding>
+80103cfb:	83 c4 10             	add    $0x10,%esp
+80103cfe:	85 c0                	test   %eax,%eax
+80103d00:	74 4f                	je     80103d51 <sched+0x81>
+  if(mycpu()->ncli != 1)
+80103d02:	e8 c9 fb ff ff       	call   801038d0 <mycpu>
+80103d07:	83 b8 a4 00 00 00 01 	cmpl   $0x1,0xa4(%eax)
+80103d0e:	75 68                	jne    80103d78 <sched+0xa8>
+  if(p->state == RUNNING)
+80103d10:	83 7b 0c 04          	cmpl   $0x4,0xc(%ebx)
+80103d14:	74 55                	je     80103d6b <sched+0x9b>
+  asm volatile("pushfl; popl %0" : "=r" (eflags));
+80103d16:	9c                   	pushf  
+80103d17:	58                   	pop    %eax
+  if(readeflags()&FL_IF)
+80103d18:	f6 c4 02             	test   $0x2,%ah
+80103d1b:	75 41                	jne    80103d5e <sched+0x8e>
+  intena = mycpu()->intena;
+80103d1d:	e8 ae fb ff ff       	call   801038d0 <mycpu>
+  swtch(&p->context, mycpu()->scheduler);
+80103d22:	83 c3 1c             	add    $0x1c,%ebx
+  intena = mycpu()->intena;
+80103d25:	8b b0 a8 00 00 00    	mov    0xa8(%eax),%esi
+  swtch(&p->context, mycpu()->scheduler);
+80103d2b:	e8 a0 fb ff ff       	call   801038d0 <mycpu>
+80103d30:	83 ec 08             	sub    $0x8,%esp
+80103d33:	ff 70 04             	pushl  0x4(%eax)
+80103d36:	53                   	push   %ebx
+80103d37:	e8 d7 0d 00 00       	call   80104b13 <swtch>
+  mycpu()->intena = intena;
+80103d3c:	e8 8f fb ff ff       	call   801038d0 <mycpu>
+}
+80103d41:	83 c4 10             	add    $0x10,%esp
+  mycpu()->intena = intena;
+80103d44:	89 b0 a8 00 00 00    	mov    %esi,0xa8(%eax)
+}
+80103d4a:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80103d4d:	5b                   	pop    %ebx
+80103d4e:	5e                   	pop    %esi
+80103d4f:	5d                   	pop    %ebp
+80103d50:	c3                   	ret    
+    panic("sched ptable.lock");
+80103d51:	83 ec 0c             	sub    $0xc,%esp
+80103d54:	68 3b 7a 10 80       	push   $0x80107a3b
+80103d59:	e8 32 c6 ff ff       	call   80100390 <panic>
+    panic("sched interruptible");
+80103d5e:	83 ec 0c             	sub    $0xc,%esp
+80103d61:	68 67 7a 10 80       	push   $0x80107a67
+80103d66:	e8 25 c6 ff ff       	call   80100390 <panic>
+    panic("sched running");
+80103d6b:	83 ec 0c             	sub    $0xc,%esp
+80103d6e:	68 59 7a 10 80       	push   $0x80107a59
+80103d73:	e8 18 c6 ff ff       	call   80100390 <panic>
+    panic("sched locks");
+80103d78:	83 ec 0c             	sub    $0xc,%esp
+80103d7b:	68 4d 7a 10 80       	push   $0x80107a4d
+80103d80:	e8 0b c6 ff ff       	call   80100390 <panic>
+80103d85:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80103d8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80103d90 <exit>:
+{
+80103d90:	f3 0f 1e fb          	endbr32 
+80103d94:	55                   	push   %ebp
+80103d95:	89 e5                	mov    %esp,%ebp
+80103d97:	57                   	push   %edi
+80103d98:	56                   	push   %esi
+80103d99:	53                   	push   %ebx
+80103d9a:	83 ec 0c             	sub    $0xc,%esp
+  pushcli();
+80103d9d:	e8 3e 09 00 00       	call   801046e0 <pushcli>
+  c = mycpu();
+80103da2:	e8 29 fb ff ff       	call   801038d0 <mycpu>
+  p = c->proc;
+80103da7:	8b b0 ac 00 00 00    	mov    0xac(%eax),%esi
+  popcli();
+80103dad:	e8 7e 09 00 00       	call   80104730 <popcli>
+  if(curproc == initproc)
+80103db2:	8d 5e 28             	lea    0x28(%esi),%ebx
+80103db5:	8d 7e 68             	lea    0x68(%esi),%edi
+80103db8:	39 35 b8 a5 10 80    	cmp    %esi,0x8010a5b8
+80103dbe:	0f 84 f3 00 00 00    	je     80103eb7 <exit+0x127>
+80103dc4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    if(curproc->ofile[fd]){
+80103dc8:	8b 03                	mov    (%ebx),%eax
+80103dca:	85 c0                	test   %eax,%eax
+80103dcc:	74 12                	je     80103de0 <exit+0x50>
+      fileclose(curproc->ofile[fd]);
+80103dce:	83 ec 0c             	sub    $0xc,%esp
+80103dd1:	50                   	push   %eax
+80103dd2:	e8 e9 d0 ff ff       	call   80100ec0 <fileclose>
+      curproc->ofile[fd] = 0;
+80103dd7:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
+80103ddd:	83 c4 10             	add    $0x10,%esp
+  for(fd = 0; fd < NOFILE; fd++){
+80103de0:	83 c3 04             	add    $0x4,%ebx
+80103de3:	39 df                	cmp    %ebx,%edi
+80103de5:	75 e1                	jne    80103dc8 <exit+0x38>
+  begin_op();
+80103de7:	e8 44 ef ff ff       	call   80102d30 <begin_op>
+  iput(curproc->cwd);
+80103dec:	83 ec 0c             	sub    $0xc,%esp
+80103def:	ff 76 68             	pushl  0x68(%esi)
+80103df2:	e8 99 da ff ff       	call   80101890 <iput>
+  end_op();
+80103df7:	e8 a4 ef ff ff       	call   80102da0 <end_op>
+  curproc->cwd = 0;
+80103dfc:	c7 46 68 00 00 00 00 	movl   $0x0,0x68(%esi)
+  acquire(&ptable.lock);
+80103e03:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103e0a:	e8 d1 09 00 00       	call   801047e0 <acquire>
+  wakeup1(curproc->parent);
+80103e0f:	8b 56 14             	mov    0x14(%esi),%edx
+80103e12:	83 c4 10             	add    $0x10,%esp
+static void
+wakeup1(void *chan)
+{
+  struct proc *p;
+
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+80103e15:	b8 54 2d 11 80       	mov    $0x80112d54,%eax
+80103e1a:	eb 0e                	jmp    80103e2a <exit+0x9a>
+80103e1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80103e20:	83 e8 80             	sub    $0xffffff80,%eax
+80103e23:	3d 54 4d 11 80       	cmp    $0x80114d54,%eax
+80103e28:	74 1c                	je     80103e46 <exit+0xb6>
+    if(p->state == SLEEPING && p->chan == chan)
+80103e2a:	83 78 0c 02          	cmpl   $0x2,0xc(%eax)
+80103e2e:	75 f0                	jne    80103e20 <exit+0x90>
+80103e30:	3b 50 20             	cmp    0x20(%eax),%edx
+80103e33:	75 eb                	jne    80103e20 <exit+0x90>
+      p->state = RUNNABLE;
+80103e35:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+80103e3c:	83 e8 80             	sub    $0xffffff80,%eax
+80103e3f:	3d 54 4d 11 80       	cmp    $0x80114d54,%eax
+80103e44:	75 e4                	jne    80103e2a <exit+0x9a>
+      p->parent = initproc;
+80103e46:	8b 0d b8 a5 10 80    	mov    0x8010a5b8,%ecx
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80103e4c:	ba 54 2d 11 80       	mov    $0x80112d54,%edx
+80103e51:	eb 10                	jmp    80103e63 <exit+0xd3>
+80103e53:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80103e57:	90                   	nop
+80103e58:	83 ea 80             	sub    $0xffffff80,%edx
+80103e5b:	81 fa 54 4d 11 80    	cmp    $0x80114d54,%edx
+80103e61:	74 3b                	je     80103e9e <exit+0x10e>
+    if(p->parent == curproc){
+80103e63:	39 72 14             	cmp    %esi,0x14(%edx)
+80103e66:	75 f0                	jne    80103e58 <exit+0xc8>
+      if(p->state == ZOMBIE)
+80103e68:	83 7a 0c 05          	cmpl   $0x5,0xc(%edx)
+      p->parent = initproc;
+80103e6c:	89 4a 14             	mov    %ecx,0x14(%edx)
+      if(p->state == ZOMBIE)
+80103e6f:	75 e7                	jne    80103e58 <exit+0xc8>
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+80103e71:	b8 54 2d 11 80       	mov    $0x80112d54,%eax
+80103e76:	eb 12                	jmp    80103e8a <exit+0xfa>
+80103e78:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80103e7f:	90                   	nop
+80103e80:	83 e8 80             	sub    $0xffffff80,%eax
+80103e83:	3d 54 4d 11 80       	cmp    $0x80114d54,%eax
+80103e88:	74 ce                	je     80103e58 <exit+0xc8>
+    if(p->state == SLEEPING && p->chan == chan)
+80103e8a:	83 78 0c 02          	cmpl   $0x2,0xc(%eax)
+80103e8e:	75 f0                	jne    80103e80 <exit+0xf0>
+80103e90:	3b 48 20             	cmp    0x20(%eax),%ecx
+80103e93:	75 eb                	jne    80103e80 <exit+0xf0>
+      p->state = RUNNABLE;
+80103e95:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
+80103e9c:	eb e2                	jmp    80103e80 <exit+0xf0>
+  curproc->state = ZOMBIE;
+80103e9e:	c7 46 0c 05 00 00 00 	movl   $0x5,0xc(%esi)
+  sched();
+80103ea5:	e8 26 fe ff ff       	call   80103cd0 <sched>
+  panic("zombie exit");
+80103eaa:	83 ec 0c             	sub    $0xc,%esp
+80103ead:	68 88 7a 10 80       	push   $0x80107a88
+80103eb2:	e8 d9 c4 ff ff       	call   80100390 <panic>
+    panic("init exiting");
+80103eb7:	83 ec 0c             	sub    $0xc,%esp
+80103eba:	68 7b 7a 10 80       	push   $0x80107a7b
+80103ebf:	e8 cc c4 ff ff       	call   80100390 <panic>
+80103ec4:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80103ecb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80103ecf:	90                   	nop
+
+80103ed0 <yield>:
+{
+80103ed0:	f3 0f 1e fb          	endbr32 
+80103ed4:	55                   	push   %ebp
+80103ed5:	89 e5                	mov    %esp,%ebp
+80103ed7:	53                   	push   %ebx
+80103ed8:	83 ec 10             	sub    $0x10,%esp
+  acquire(&ptable.lock);  //DOC: yieldlock
+80103edb:	68 20 2d 11 80       	push   $0x80112d20
+80103ee0:	e8 fb 08 00 00       	call   801047e0 <acquire>
+  pushcli();
+80103ee5:	e8 f6 07 00 00       	call   801046e0 <pushcli>
+  c = mycpu();
+80103eea:	e8 e1 f9 ff ff       	call   801038d0 <mycpu>
+  p = c->proc;
+80103eef:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
+  popcli();
+80103ef5:	e8 36 08 00 00       	call   80104730 <popcli>
+  myproc()->state = RUNNABLE;
+80103efa:	c7 43 0c 03 00 00 00 	movl   $0x3,0xc(%ebx)
+  sched();
+80103f01:	e8 ca fd ff ff       	call   80103cd0 <sched>
+  release(&ptable.lock);
+80103f06:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103f0d:	e8 8e 09 00 00       	call   801048a0 <release>
+}
+80103f12:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80103f15:	83 c4 10             	add    $0x10,%esp
+80103f18:	c9                   	leave  
+80103f19:	c3                   	ret    
+80103f1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80103f20 <sleep>:
+{
+80103f20:	f3 0f 1e fb          	endbr32 
+80103f24:	55                   	push   %ebp
+80103f25:	89 e5                	mov    %esp,%ebp
+80103f27:	57                   	push   %edi
+80103f28:	56                   	push   %esi
+80103f29:	53                   	push   %ebx
+80103f2a:	83 ec 0c             	sub    $0xc,%esp
+80103f2d:	8b 7d 08             	mov    0x8(%ebp),%edi
+80103f30:	8b 75 0c             	mov    0xc(%ebp),%esi
+  pushcli();
+80103f33:	e8 a8 07 00 00       	call   801046e0 <pushcli>
+  c = mycpu();
+80103f38:	e8 93 f9 ff ff       	call   801038d0 <mycpu>
+  p = c->proc;
+80103f3d:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
+  popcli();
+80103f43:	e8 e8 07 00 00       	call   80104730 <popcli>
+  if(p == 0)
+80103f48:	85 db                	test   %ebx,%ebx
+80103f4a:	0f 84 83 00 00 00    	je     80103fd3 <sleep+0xb3>
+  if(lk == 0)
+80103f50:	85 f6                	test   %esi,%esi
+80103f52:	74 72                	je     80103fc6 <sleep+0xa6>
+  if(lk != &ptable.lock){  //DOC: sleeplock0
+80103f54:	81 fe 20 2d 11 80    	cmp    $0x80112d20,%esi
+80103f5a:	74 4c                	je     80103fa8 <sleep+0x88>
+    acquire(&ptable.lock);  //DOC: sleeplock1
+80103f5c:	83 ec 0c             	sub    $0xc,%esp
+80103f5f:	68 20 2d 11 80       	push   $0x80112d20
+80103f64:	e8 77 08 00 00       	call   801047e0 <acquire>
+    release(lk);
+80103f69:	89 34 24             	mov    %esi,(%esp)
+80103f6c:	e8 2f 09 00 00       	call   801048a0 <release>
+  p->chan = chan;
+80103f71:	89 7b 20             	mov    %edi,0x20(%ebx)
+  p->state = SLEEPING;
+80103f74:	c7 43 0c 02 00 00 00 	movl   $0x2,0xc(%ebx)
+  sched();
+80103f7b:	e8 50 fd ff ff       	call   80103cd0 <sched>
+  p->chan = 0;
+80103f80:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
+    release(&ptable.lock);
+80103f87:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+80103f8e:	e8 0d 09 00 00       	call   801048a0 <release>
+    acquire(lk);
+80103f93:	89 75 08             	mov    %esi,0x8(%ebp)
+80103f96:	83 c4 10             	add    $0x10,%esp
+}
+80103f99:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80103f9c:	5b                   	pop    %ebx
+80103f9d:	5e                   	pop    %esi
+80103f9e:	5f                   	pop    %edi
+80103f9f:	5d                   	pop    %ebp
+    acquire(lk);
+80103fa0:	e9 3b 08 00 00       	jmp    801047e0 <acquire>
+80103fa5:	8d 76 00             	lea    0x0(%esi),%esi
+  p->chan = chan;
+80103fa8:	89 7b 20             	mov    %edi,0x20(%ebx)
+  p->state = SLEEPING;
+80103fab:	c7 43 0c 02 00 00 00 	movl   $0x2,0xc(%ebx)
+  sched();
+80103fb2:	e8 19 fd ff ff       	call   80103cd0 <sched>
+  p->chan = 0;
+80103fb7:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
+}
+80103fbe:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80103fc1:	5b                   	pop    %ebx
+80103fc2:	5e                   	pop    %esi
+80103fc3:	5f                   	pop    %edi
+80103fc4:	5d                   	pop    %ebp
+80103fc5:	c3                   	ret    
+    panic("sleep without lk");
+80103fc6:	83 ec 0c             	sub    $0xc,%esp
+80103fc9:	68 9a 7a 10 80       	push   $0x80107a9a
+80103fce:	e8 bd c3 ff ff       	call   80100390 <panic>
+    panic("sleep");
+80103fd3:	83 ec 0c             	sub    $0xc,%esp
+80103fd6:	68 94 7a 10 80       	push   $0x80107a94
+80103fdb:	e8 b0 c3 ff ff       	call   80100390 <panic>
+
+80103fe0 <wait>:
+{
+80103fe0:	f3 0f 1e fb          	endbr32 
+80103fe4:	55                   	push   %ebp
+80103fe5:	89 e5                	mov    %esp,%ebp
+80103fe7:	56                   	push   %esi
+80103fe8:	53                   	push   %ebx
+  pushcli();
+80103fe9:	e8 f2 06 00 00       	call   801046e0 <pushcli>
+  c = mycpu();
+80103fee:	e8 dd f8 ff ff       	call   801038d0 <mycpu>
+  p = c->proc;
+80103ff3:	8b b0 ac 00 00 00    	mov    0xac(%eax),%esi
+  popcli();
+80103ff9:	e8 32 07 00 00       	call   80104730 <popcli>
+  acquire(&ptable.lock);
+80103ffe:	83 ec 0c             	sub    $0xc,%esp
+80104001:	68 20 2d 11 80       	push   $0x80112d20
+80104006:	e8 d5 07 00 00       	call   801047e0 <acquire>
+8010400b:	83 c4 10             	add    $0x10,%esp
+    havekids = 0;
+8010400e:	31 c0                	xor    %eax,%eax
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104010:	bb 54 2d 11 80       	mov    $0x80112d54,%ebx
+80104015:	eb 14                	jmp    8010402b <wait+0x4b>
+80104017:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010401e:	66 90                	xchg   %ax,%ax
+80104020:	83 eb 80             	sub    $0xffffff80,%ebx
+80104023:	81 fb 54 4d 11 80    	cmp    $0x80114d54,%ebx
+80104029:	74 1b                	je     80104046 <wait+0x66>
+      if(p->parent != curproc)
+8010402b:	39 73 14             	cmp    %esi,0x14(%ebx)
+8010402e:	75 f0                	jne    80104020 <wait+0x40>
+      if(p->state == ZOMBIE){
+80104030:	83 7b 0c 05          	cmpl   $0x5,0xc(%ebx)
+80104034:	74 32                	je     80104068 <wait+0x88>
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104036:	83 eb 80             	sub    $0xffffff80,%ebx
+      havekids = 1;
+80104039:	b8 01 00 00 00       	mov    $0x1,%eax
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+8010403e:	81 fb 54 4d 11 80    	cmp    $0x80114d54,%ebx
+80104044:	75 e5                	jne    8010402b <wait+0x4b>
+    if(!havekids || curproc->killed){
+80104046:	85 c0                	test   %eax,%eax
+80104048:	74 74                	je     801040be <wait+0xde>
+8010404a:	8b 46 24             	mov    0x24(%esi),%eax
+8010404d:	85 c0                	test   %eax,%eax
+8010404f:	75 6d                	jne    801040be <wait+0xde>
+    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+80104051:	83 ec 08             	sub    $0x8,%esp
+80104054:	68 20 2d 11 80       	push   $0x80112d20
+80104059:	56                   	push   %esi
+8010405a:	e8 c1 fe ff ff       	call   80103f20 <sleep>
+    havekids = 0;
+8010405f:	83 c4 10             	add    $0x10,%esp
+80104062:	eb aa                	jmp    8010400e <wait+0x2e>
+80104064:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        kfree(p->kstack);
+80104068:	83 ec 0c             	sub    $0xc,%esp
+8010406b:	ff 73 08             	pushl  0x8(%ebx)
+        pid = p->pid;
+8010406e:	8b 73 10             	mov    0x10(%ebx),%esi
+        kfree(p->kstack);
+80104071:	e8 fa e3 ff ff       	call   80102470 <kfree>
+        freevm(p->pgdir);
+80104076:	5a                   	pop    %edx
+80104077:	ff 73 04             	pushl  0x4(%ebx)
+        p->kstack = 0;
+8010407a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
+        freevm(p->pgdir);
+80104081:	e8 2a 31 00 00       	call   801071b0 <freevm>
+        release(&ptable.lock);
+80104086:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+        p->pid = 0;
+8010408d:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
+        p->parent = 0;
+80104094:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
+        p->name[0] = 0;
+8010409b:	c6 43 6c 00          	movb   $0x0,0x6c(%ebx)
+        p->killed = 0;
+8010409f:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
+        p->state = UNUSED;
+801040a6:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
+        release(&ptable.lock);
+801040ad:	e8 ee 07 00 00       	call   801048a0 <release>
+        return pid;
+801040b2:	83 c4 10             	add    $0x10,%esp
+}
+801040b5:	8d 65 f8             	lea    -0x8(%ebp),%esp
+801040b8:	89 f0                	mov    %esi,%eax
+801040ba:	5b                   	pop    %ebx
+801040bb:	5e                   	pop    %esi
+801040bc:	5d                   	pop    %ebp
+801040bd:	c3                   	ret    
+      release(&ptable.lock);
+801040be:	83 ec 0c             	sub    $0xc,%esp
+      return -1;
+801040c1:	be ff ff ff ff       	mov    $0xffffffff,%esi
+      release(&ptable.lock);
+801040c6:	68 20 2d 11 80       	push   $0x80112d20
+801040cb:	e8 d0 07 00 00       	call   801048a0 <release>
+      return -1;
+801040d0:	83 c4 10             	add    $0x10,%esp
+801040d3:	eb e0                	jmp    801040b5 <wait+0xd5>
+801040d5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801040dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+801040e0 <wakeup>:
+}
+
+// Wake up all processes sleeping on chan.
+void
+wakeup(void *chan)
+{
+801040e0:	f3 0f 1e fb          	endbr32 
+801040e4:	55                   	push   %ebp
+801040e5:	89 e5                	mov    %esp,%ebp
+801040e7:	53                   	push   %ebx
+801040e8:	83 ec 10             	sub    $0x10,%esp
+801040eb:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  acquire(&ptable.lock);
+801040ee:	68 20 2d 11 80       	push   $0x80112d20
+801040f3:	e8 e8 06 00 00       	call   801047e0 <acquire>
+801040f8:	83 c4 10             	add    $0x10,%esp
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+801040fb:	b8 54 2d 11 80       	mov    $0x80112d54,%eax
+80104100:	eb 10                	jmp    80104112 <wakeup+0x32>
+80104102:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80104108:	83 e8 80             	sub    $0xffffff80,%eax
+8010410b:	3d 54 4d 11 80       	cmp    $0x80114d54,%eax
+80104110:	74 1c                	je     8010412e <wakeup+0x4e>
+    if(p->state == SLEEPING && p->chan == chan)
+80104112:	83 78 0c 02          	cmpl   $0x2,0xc(%eax)
+80104116:	75 f0                	jne    80104108 <wakeup+0x28>
+80104118:	3b 58 20             	cmp    0x20(%eax),%ebx
+8010411b:	75 eb                	jne    80104108 <wakeup+0x28>
+      p->state = RUNNABLE;
+8010411d:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+80104124:	83 e8 80             	sub    $0xffffff80,%eax
+80104127:	3d 54 4d 11 80       	cmp    $0x80114d54,%eax
+8010412c:	75 e4                	jne    80104112 <wakeup+0x32>
+  wakeup1(chan);
+  release(&ptable.lock);
+8010412e:	c7 45 08 20 2d 11 80 	movl   $0x80112d20,0x8(%ebp)
+}
+80104135:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80104138:	c9                   	leave  
+  release(&ptable.lock);
+80104139:	e9 62 07 00 00       	jmp    801048a0 <release>
+8010413e:	66 90                	xchg   %ax,%ax
+
+80104140 <kill>:
+// Kill the process with the given pid.
+// Process won't exit until it returns
+// to user space (see trap in trap.c).
+int
+kill(int pid)
+{
+80104140:	f3 0f 1e fb          	endbr32 
+80104144:	55                   	push   %ebp
+80104145:	89 e5                	mov    %esp,%ebp
+80104147:	53                   	push   %ebx
+80104148:	83 ec 10             	sub    $0x10,%esp
+8010414b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  struct proc *p;
+
+  acquire(&ptable.lock);
+8010414e:	68 20 2d 11 80       	push   $0x80112d20
+80104153:	e8 88 06 00 00       	call   801047e0 <acquire>
+80104158:	83 c4 10             	add    $0x10,%esp
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+8010415b:	b8 54 2d 11 80       	mov    $0x80112d54,%eax
+80104160:	eb 10                	jmp    80104172 <kill+0x32>
+80104162:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80104168:	83 e8 80             	sub    $0xffffff80,%eax
+8010416b:	3d 54 4d 11 80       	cmp    $0x80114d54,%eax
+80104170:	74 36                	je     801041a8 <kill+0x68>
+    if(p->pid == pid){
+80104172:	39 58 10             	cmp    %ebx,0x10(%eax)
+80104175:	75 f1                	jne    80104168 <kill+0x28>
+      p->killed = 1;
+      // Wake process from sleep if necessary.
+      if(p->state == SLEEPING)
+80104177:	83 78 0c 02          	cmpl   $0x2,0xc(%eax)
+      p->killed = 1;
+8010417b:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
+      if(p->state == SLEEPING)
+80104182:	75 07                	jne    8010418b <kill+0x4b>
+        p->state = RUNNABLE;
+80104184:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
+      release(&ptable.lock);
+8010418b:	83 ec 0c             	sub    $0xc,%esp
+8010418e:	68 20 2d 11 80       	push   $0x80112d20
+80104193:	e8 08 07 00 00       	call   801048a0 <release>
+      return 0;
+    }
+  }
+  release(&ptable.lock);
+  return -1;
+}
+80104198:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+      return 0;
+8010419b:	83 c4 10             	add    $0x10,%esp
+8010419e:	31 c0                	xor    %eax,%eax
+}
+801041a0:	c9                   	leave  
+801041a1:	c3                   	ret    
+801041a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  release(&ptable.lock);
+801041a8:	83 ec 0c             	sub    $0xc,%esp
+801041ab:	68 20 2d 11 80       	push   $0x80112d20
+801041b0:	e8 eb 06 00 00       	call   801048a0 <release>
+}
+801041b5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+  return -1;
+801041b8:	83 c4 10             	add    $0x10,%esp
+801041bb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+801041c0:	c9                   	leave  
+801041c1:	c3                   	ret    
+801041c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801041c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+801041d0 <procdump>:
+// Print a process listing to console.  For debugging.
+// Runs when user types ^P on console.
+// No lock to avoid wedging a stuck machine further.
+void
+procdump(void)
+{
+801041d0:	f3 0f 1e fb          	endbr32 
+801041d4:	55                   	push   %ebp
+801041d5:	89 e5                	mov    %esp,%ebp
+801041d7:	57                   	push   %edi
+801041d8:	56                   	push   %esi
+801041d9:	8d 75 e8             	lea    -0x18(%ebp),%esi
+801041dc:	53                   	push   %ebx
+801041dd:	bb c0 2d 11 80       	mov    $0x80112dc0,%ebx
+801041e2:	83 ec 3c             	sub    $0x3c,%esp
+801041e5:	eb 28                	jmp    8010420f <procdump+0x3f>
+801041e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801041ee:	66 90                	xchg   %ax,%ax
+    if(p->state == SLEEPING){
+      getcallerpcs((uint*)p->context->ebp+2, pc);
+      for(i=0; i<10 && pc[i] != 0; i++)
+        cprintf(" %p", pc[i]);
+    }
+    cprintf("\n");
+801041f0:	83 ec 0c             	sub    $0xc,%esp
+801041f3:	68 27 7e 10 80       	push   $0x80107e27
+801041f8:	e8 b3 c4 ff ff       	call   801006b0 <cprintf>
+801041fd:	83 c4 10             	add    $0x10,%esp
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104200:	83 eb 80             	sub    $0xffffff80,%ebx
+80104203:	81 fb c0 4d 11 80    	cmp    $0x80114dc0,%ebx
+80104209:	0f 84 81 00 00 00    	je     80104290 <procdump+0xc0>
+    if(p->state == UNUSED)
+8010420f:	8b 43 a0             	mov    -0x60(%ebx),%eax
+80104212:	85 c0                	test   %eax,%eax
+80104214:	74 ea                	je     80104200 <procdump+0x30>
+      state = "???";
+80104216:	ba ab 7a 10 80       	mov    $0x80107aab,%edx
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+8010421b:	83 f8 05             	cmp    $0x5,%eax
+8010421e:	77 11                	ja     80104231 <procdump+0x61>
+80104220:	8b 14 85 0c 7b 10 80 	mov    -0x7fef84f4(,%eax,4),%edx
+      state = "???";
+80104227:	b8 ab 7a 10 80       	mov    $0x80107aab,%eax
+8010422c:	85 d2                	test   %edx,%edx
+8010422e:	0f 44 d0             	cmove  %eax,%edx
+    cprintf("%d %s %s", p->pid, state, p->name);
+80104231:	53                   	push   %ebx
+80104232:	52                   	push   %edx
+80104233:	ff 73 a4             	pushl  -0x5c(%ebx)
+80104236:	68 af 7a 10 80       	push   $0x80107aaf
+8010423b:	e8 70 c4 ff ff       	call   801006b0 <cprintf>
+    if(p->state == SLEEPING){
+80104240:	83 c4 10             	add    $0x10,%esp
+80104243:	83 7b a0 02          	cmpl   $0x2,-0x60(%ebx)
+80104247:	75 a7                	jne    801041f0 <procdump+0x20>
+      getcallerpcs((uint*)p->context->ebp+2, pc);
+80104249:	83 ec 08             	sub    $0x8,%esp
+8010424c:	8d 45 c0             	lea    -0x40(%ebp),%eax
+8010424f:	8d 7d c0             	lea    -0x40(%ebp),%edi
+80104252:	50                   	push   %eax
+80104253:	8b 43 b0             	mov    -0x50(%ebx),%eax
+80104256:	8b 40 0c             	mov    0xc(%eax),%eax
+80104259:	83 c0 08             	add    $0x8,%eax
+8010425c:	50                   	push   %eax
+8010425d:	e8 1e 04 00 00       	call   80104680 <getcallerpcs>
+      for(i=0; i<10 && pc[i] != 0; i++)
+80104262:	83 c4 10             	add    $0x10,%esp
+80104265:	8d 76 00             	lea    0x0(%esi),%esi
+80104268:	8b 17                	mov    (%edi),%edx
+8010426a:	85 d2                	test   %edx,%edx
+8010426c:	74 82                	je     801041f0 <procdump+0x20>
+        cprintf(" %p", pc[i]);
+8010426e:	83 ec 08             	sub    $0x8,%esp
+80104271:	83 c7 04             	add    $0x4,%edi
+80104274:	52                   	push   %edx
+80104275:	68 01 75 10 80       	push   $0x80107501
+8010427a:	e8 31 c4 ff ff       	call   801006b0 <cprintf>
+      for(i=0; i<10 && pc[i] != 0; i++)
+8010427f:	83 c4 10             	add    $0x10,%esp
+80104282:	39 fe                	cmp    %edi,%esi
+80104284:	75 e2                	jne    80104268 <procdump+0x98>
+80104286:	e9 65 ff ff ff       	jmp    801041f0 <procdump+0x20>
+8010428b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010428f:	90                   	nop
+  }
+}
+80104290:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80104293:	5b                   	pop    %ebx
+80104294:	5e                   	pop    %esi
+80104295:	5f                   	pop    %edi
+80104296:	5d                   	pop    %ebp
+80104297:	c3                   	ret    
+80104298:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010429f:	90                   	nop
+
+801042a0 <thread_create>:
+//You should just set user's eip to start execution from *fcn.
+	  //you should set it in the trapframe --
+	  //that's the eip that the kernel restores before exiting back into the process
+	  //The new thread starts executing at the address specified by fcn .
+int thread_create(void(*fcn)(void*), void *arg, void *stack)
+{
+801042a0:	f3 0f 1e fb          	endbr32 
+801042a4:	55                   	push   %ebp
+801042a5:	89 e5                	mov    %esp,%ebp
+801042a7:	57                   	push   %edi
+801042a8:	56                   	push   %esi
+801042a9:	53                   	push   %ebx
+801042aa:	83 ec 2c             	sub    $0x2c,%esp
+  pushcli();
+801042ad:	e8 2e 04 00 00       	call   801046e0 <pushcli>
+  c = mycpu();
+801042b2:	e8 19 f6 ff ff       	call   801038d0 <mycpu>
+  p = c->proc;
+801042b7:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
+801042bd:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  popcli();
+801042c0:	e8 6b 04 00 00       	call   80104730 <popcli>
+	  int i, pid;
+	  struct proc *nt;
+	  struct proc *curproc = myproc();
+
+    //Allocate thread.
+	  if((nt = allocproc()) == 0){
+801042c5:	e8 c6 f4 ff ff       	call   80103790 <allocproc>
+801042ca:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+801042cd:	85 c0                	test   %eax,%eax
+801042cf:	0f 84 20 01 00 00    	je     801043f5 <thread_create+0x155>
+801042d5:	89 c3                	mov    %eax,%ebx
+    //pagedir is shared hence unlike fork, we do not copy it.
+	  nt->pgdir = curproc->pgdir;
+    //setting size and trapframe of new thread from parent process.
+	  nt->sz = curproc->sz;
+	  nt->parent = curproc;
+	  *nt->tf = *curproc->tf;
+801042d7:	b9 13 00 00 00       	mov    $0x13,%ecx
+    //creating user stack.
+    uint ustack[2];
+
+    //making sure stack is one page in size
+	  sp = (uint)stack + PGSIZE;
+	  memset((char*)stack, 0, PGSIZE); //main may recycle stack page, so need to clear it first
+801042dc:	83 ec 04             	sub    $0x4,%esp
+	  *nt->tf = *curproc->tf;
+801042df:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+	  nt->thread = 1;
+801042e2:	c7 40 7c 01 00 00 00 	movl   $0x1,0x7c(%eax)
+	  nt->pgdir = curproc->pgdir;
+801042e9:	8b 42 04             	mov    0x4(%edx),%eax
+	  *nt->tf = *curproc->tf;
+801042ec:	8b 7b 18             	mov    0x18(%ebx),%edi
+	  nt->pgdir = curproc->pgdir;
+801042ef:	89 43 04             	mov    %eax,0x4(%ebx)
+	  nt->sz = curproc->sz;
+801042f2:	8b 02                	mov    (%edx),%eax
+	  nt->parent = curproc;
+801042f4:	89 53 14             	mov    %edx,0x14(%ebx)
+	  nt->sz = curproc->sz;
+801042f7:	89 03                	mov    %eax,(%ebx)
+	  *nt->tf = *curproc->tf;
+801042f9:	8b 72 18             	mov    0x18(%edx),%esi
+801042fc:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+	  memset((char*)stack, 0, PGSIZE); //main may recycle stack page, so need to clear it first
+801042fe:	68 00 10 00 00       	push   $0x1000
+80104303:	6a 00                	push   $0x0
+80104305:	ff 75 10             	pushl  0x10(%ebp)
+80104308:	e8 e3 05 00 00       	call   801048f0 <memset>
+
+    // tls is a small structure holding thread information like thread id and index, held at the top of every stack created.
+	  struct tls t;
+	  t.tid = nt->pid - curproc->pid - 1; //tid starts from 0
+8010430d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+80104310:	8b 43 10             	mov    0x10(%ebx),%eax
+	  sp -= sizeof(struct tls);
+	  memmove((char*)sp, (char*)&t, sizeof(struct tls));
+80104313:	83 c4 0c             	add    $0xc,%esp
+	  t.tid = nt->pid - curproc->pid - 1; //tid starts from 0
+80104316:	2b 42 10             	sub    0x10(%edx),%eax
+	  memmove((char*)sp, (char*)&t, sizeof(struct tls));
+80104319:	6a 04                	push   $0x4
+	  t.tid = nt->pid - curproc->pid - 1; //tid starts from 0
+8010431b:	83 e8 01             	sub    $0x1,%eax
+8010431e:	89 45 dc             	mov    %eax,-0x24(%ebp)
+	  memmove((char*)sp, (char*)&t, sizeof(struct tls));
+80104321:	8d 45 dc             	lea    -0x24(%ebp),%eax
+80104324:	50                   	push   %eax
+	  sp -= sizeof(struct tls);
+80104325:	8b 45 10             	mov    0x10(%ebp),%eax
+80104328:	05 fc 0f 00 00       	add    $0xffc,%eax
+	  memmove((char*)sp, (char*)&t, sizeof(struct tls));
+8010432d:	50                   	push   %eax
+8010432e:	e8 5d 06 00 00       	call   80104990 <memmove>
+
+    //passing fake return PC to user stack
+	  ustack[0] = 0xffffffff; 
+
+    //passing arg to user stack
+	  ustack[1] = (uint)arg;
+80104333:	8b 45 0c             	mov    0xc(%ebp),%eax
+	  //void do_work(void *arg)
+	  sp -= 2*4;
+	  if(copyout(nt->pgdir, sp, ustack, 2*4) < 0) return -1;
+80104336:	6a 08                	push   $0x8
+	  ustack[0] = 0xffffffff; 
+80104338:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+	  ustack[1] = (uint)arg;
+8010433f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+	  sp -= 2*4;
+80104342:	8b 45 10             	mov    0x10(%ebp),%eax
+80104345:	8d b0 f4 0f 00 00    	lea    0xff4(%eax),%esi
+	  if(copyout(nt->pgdir, sp, ustack, 2*4) < 0) return -1;
+8010434b:	8d 45 e0             	lea    -0x20(%ebp),%eax
+8010434e:	50                   	push   %eax
+8010434f:	56                   	push   %esi
+80104350:	ff 73 04             	pushl  0x4(%ebx)
+80104353:	e8 d8 30 00 00       	call   80107430 <copyout>
+80104358:	83 c4 20             	add    $0x20,%esp
+8010435b:	85 c0                	test   %eax,%eax
+8010435d:	0f 88 92 00 00 00    	js     801043f5 <thread_create+0x155>
+
+	  //initialize thread's stack pointer
+	  nt->tf->esp = sp;
+80104363:	8b 43 18             	mov    0x18(%ebx),%eax
+
+	  // Clear %eax so that fork returns 0 in the child.
+	  //np->tf->eax = 0;
+    //setting the instruction pointer to fcn from where the execution begins
+	  nt->tf->eip = (uint)fcn;
+80104366:	8b 4d 08             	mov    0x8(%ebp),%ecx
+
+	  //we will copy file descriptors in the same manner fork() does it.
+	  for(i = 0; i < NOFILE; i++)
+80104369:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+	  nt->tf->esp = sp;
+8010436c:	89 70 44             	mov    %esi,0x44(%eax)
+	  nt->tf->eip = (uint)fcn;
+8010436f:	8b 43 18             	mov    0x18(%ebx),%eax
+	  for(i = 0; i < NOFILE; i++)
+80104372:	31 f6                	xor    %esi,%esi
+80104374:	89 d7                	mov    %edx,%edi
+	  nt->tf->eip = (uint)fcn;
+80104376:	89 48 38             	mov    %ecx,0x38(%eax)
+	  for(i = 0; i < NOFILE; i++)
+80104379:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+	    if(curproc->ofile[i])
+80104380:	8b 44 b7 28          	mov    0x28(%edi,%esi,4),%eax
+80104384:	85 c0                	test   %eax,%eax
+80104386:	74 10                	je     80104398 <thread_create+0xf8>
+	      nt->ofile[i] = filedup(curproc->ofile[i]);
+80104388:	83 ec 0c             	sub    $0xc,%esp
+8010438b:	50                   	push   %eax
+8010438c:	e8 df ca ff ff       	call   80100e70 <filedup>
+80104391:	83 c4 10             	add    $0x10,%esp
+80104394:	89 44 b3 28          	mov    %eax,0x28(%ebx,%esi,4)
+	  for(i = 0; i < NOFILE; i++)
+80104398:	83 c6 01             	add    $0x1,%esi
+8010439b:	83 fe 10             	cmp    $0x10,%esi
+8010439e:	75 e0                	jne    80104380 <thread_create+0xe0>
+
+    //setting new thread's current working dfirectory to the same directory as the parent process.
+	  nt->cwd = idup(curproc->cwd);
+801043a0:	83 ec 0c             	sub    $0xc,%esp
+801043a3:	ff 77 68             	pushl  0x68(%edi)
+801043a6:	89 7d d4             	mov    %edi,-0x2c(%ebp)
+801043a9:	e8 82 d3 ff ff       	call   80101730 <idup>
+	  safestrcpy(nt->name, curproc->name, sizeof(nt->name));
+801043ae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+801043b1:	83 c4 0c             	add    $0xc,%esp
+	  nt->cwd = idup(curproc->cwd);
+801043b4:	89 43 68             	mov    %eax,0x68(%ebx)
+	  safestrcpy(nt->name, curproc->name, sizeof(nt->name));
+801043b7:	8d 43 6c             	lea    0x6c(%ebx),%eax
+801043ba:	83 c2 6c             	add    $0x6c,%edx
+801043bd:	6a 10                	push   $0x10
+801043bf:	52                   	push   %edx
+801043c0:	50                   	push   %eax
+801043c1:	e8 ea 06 00 00       	call   80104ab0 <safestrcpy>
+	  pid = nt->pid;
+801043c6:	8b 73 10             	mov    0x10(%ebx),%esi
+
+	  acquire(&ptable.lock);
+801043c9:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+801043d0:	e8 0b 04 00 00       	call   801047e0 <acquire>
+
+	  nt->state = RUNNABLE;
+801043d5:	c7 43 0c 03 00 00 00 	movl   $0x3,0xc(%ebx)
+
+	  release(&ptable.lock);
+801043dc:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+801043e3:	e8 b8 04 00 00       	call   801048a0 <release>
+
+	  //As with fork(), the PID of the new thread is returned to the parent.
+	  return pid;
+801043e8:	83 c4 10             	add    $0x10,%esp
+}
+801043eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
+801043ee:	89 f0                	mov    %esi,%eax
+801043f0:	5b                   	pop    %ebx
+801043f1:	5e                   	pop    %esi
+801043f2:	5f                   	pop    %edi
+801043f3:	5d                   	pop    %ebp
+801043f4:	c3                   	ret    
+	    return -1;
+801043f5:	be ff ff ff ff       	mov    $0xffffffff,%esi
+801043fa:	eb ef                	jmp    801043eb <thread_create+0x14b>
+801043fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80104400 <thread_join>:
+
+int thread_join(void){
+80104400:	f3 0f 1e fb          	endbr32 
+80104404:	55                   	push   %ebp
+80104405:	89 e5                	mov    %esp,%ebp
+80104407:	56                   	push   %esi
+80104408:	53                   	push   %ebx
+  pushcli();
+80104409:	e8 d2 02 00 00       	call   801046e0 <pushcli>
+  c = mycpu();
+8010440e:	e8 bd f4 ff ff       	call   801038d0 <mycpu>
+  p = c->proc;
+80104413:	8b b0 ac 00 00 00    	mov    0xac(%eax),%esi
+  popcli();
+80104419:	e8 12 03 00 00       	call   80104730 <popcli>
+
+	  struct proc *p;
+	  int havekids, pid;
+	  struct proc *curproc = myproc();
+
+	  acquire(&ptable.lock);
+8010441e:	83 ec 0c             	sub    $0xc,%esp
+80104421:	68 20 2d 11 80       	push   $0x80112d20
+80104426:	e8 b5 03 00 00       	call   801047e0 <acquire>
+8010442b:	83 c4 10             	add    $0x10,%esp
+
+	  for(;;){
+	    // Scan through table looking for exited children.
+	    havekids = 0;
+8010442e:	31 c0                	xor    %eax,%eax
+	    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104430:	bb 54 2d 11 80       	mov    $0x80112d54,%ebx
+80104435:	eb 14                	jmp    8010444b <thread_join+0x4b>
+80104437:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010443e:	66 90                	xchg   %ax,%ax
+80104440:	83 eb 80             	sub    $0xffffff80,%ebx
+80104443:	81 fb 54 4d 11 80    	cmp    $0x80114d54,%ebx
+80104449:	74 21                	je     8010446c <thread_join+0x6c>
+	      if(p->parent != curproc || p->thread != 1)
+8010444b:	39 73 14             	cmp    %esi,0x14(%ebx)
+8010444e:	75 f0                	jne    80104440 <thread_join+0x40>
+80104450:	83 7b 7c 01          	cmpl   $0x1,0x7c(%ebx)
+80104454:	75 ea                	jne    80104440 <thread_join+0x40>
+	        continue;
+	      havekids = 1;
+	      if(p->state == ZOMBIE){
+80104456:	83 7b 0c 05          	cmpl   $0x5,0xc(%ebx)
+8010445a:	74 34                	je     80104490 <thread_join+0x90>
+	    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+8010445c:	83 eb 80             	sub    $0xffffff80,%ebx
+	      havekids = 1;
+8010445f:	b8 01 00 00 00       	mov    $0x1,%eax
+	    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104464:	81 fb 54 4d 11 80    	cmp    $0x80114d54,%ebx
+8010446a:	75 df                	jne    8010444b <thread_join+0x4b>
+	        return pid;
+	      }
+	    }
+
+	    // No point waiting if we don't have any children.
+	    if(!havekids || curproc->killed){
+8010446c:	85 c0                	test   %eax,%eax
+8010446e:	74 7b                	je     801044eb <thread_join+0xeb>
+80104470:	8b 46 24             	mov    0x24(%esi),%eax
+80104473:	85 c0                	test   %eax,%eax
+80104475:	75 74                	jne    801044eb <thread_join+0xeb>
+	      release(&ptable.lock);
+	      return -1;
+	    }
+
+	    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+	    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+80104477:	83 ec 08             	sub    $0x8,%esp
+8010447a:	68 20 2d 11 80       	push   $0x80112d20
+8010447f:	56                   	push   %esi
+80104480:	e8 9b fa ff ff       	call   80103f20 <sleep>
+	    havekids = 0;
+80104485:	83 c4 10             	add    $0x10,%esp
+80104488:	eb a4                	jmp    8010442e <thread_join+0x2e>
+8010448a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+	        kfree(p->kstack);
+80104490:	83 ec 0c             	sub    $0xc,%esp
+80104493:	ff 73 08             	pushl  0x8(%ebx)
+	        pid = p->pid;
+80104496:	8b 73 10             	mov    0x10(%ebx),%esi
+	        kfree(p->kstack);
+80104499:	e8 d2 df ff ff       	call   80102470 <kfree>
+	        release(&ptable.lock);
+8010449e:	c7 04 24 20 2d 11 80 	movl   $0x80112d20,(%esp)
+	        p->kstack = 0;
+801044a5:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
+	        p->pgdir = 0;;//slight change here.
+801044ac:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
+	        p->pid = 0;
+801044b3:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
+	        p->parent = 0;
+801044ba:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
+	        p->name[0] = 0;
+801044c1:	c6 43 6c 00          	movb   $0x0,0x6c(%ebx)
+	        p->killed = 0;
+801044c5:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
+	        p->state = UNUSED;
+801044cc:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
+	        p->thread = 0;
+801044d3:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
+	        release(&ptable.lock);
+801044da:	e8 c1 03 00 00       	call   801048a0 <release>
+	        return pid;
+801044df:	83 c4 10             	add    $0x10,%esp
+	  }
+
+	  return -1;
+}
+801044e2:	8d 65 f8             	lea    -0x8(%ebp),%esp
+801044e5:	89 f0                	mov    %esi,%eax
+801044e7:	5b                   	pop    %ebx
+801044e8:	5e                   	pop    %esi
+801044e9:	5d                   	pop    %ebp
+801044ea:	c3                   	ret    
+	      release(&ptable.lock);
+801044eb:	83 ec 0c             	sub    $0xc,%esp
+	      return -1;
+801044ee:	be ff ff ff ff       	mov    $0xffffffff,%esi
+	      release(&ptable.lock);
+801044f3:	68 20 2d 11 80       	push   $0x80112d20
+801044f8:	e8 a3 03 00 00       	call   801048a0 <release>
+	      return -1;
+801044fd:	83 c4 10             	add    $0x10,%esp
+80104500:	eb e0                	jmp    801044e2 <thread_join+0xe2>
+80104502:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104509:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80104510 <thread_exit>:
+80104510:	f3 0f 1e fb          	endbr32 
+80104514:	55                   	push   %ebp
+80104515:	89 e5                	mov    %esp,%ebp
+80104517:	83 ec 08             	sub    $0x8,%esp
+8010451a:	e8 71 f8 ff ff       	call   80103d90 <exit>
+8010451f:	90                   	nop
+
+80104520 <initsleeplock>:
+#include "spinlock.h"
+#include "sleeplock.h"
+
+void
+initsleeplock(struct sleeplock *lk, char *name)
+{
+80104520:	f3 0f 1e fb          	endbr32 
+80104524:	55                   	push   %ebp
+80104525:	89 e5                	mov    %esp,%ebp
+80104527:	53                   	push   %ebx
+80104528:	83 ec 0c             	sub    $0xc,%esp
+8010452b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  initlock(&lk->lk, "sleep lock");
+8010452e:	68 24 7b 10 80       	push   $0x80107b24
+80104533:	8d 43 04             	lea    0x4(%ebx),%eax
+80104536:	50                   	push   %eax
+80104537:	e8 24 01 00 00       	call   80104660 <initlock>
+  lk->name = name;
+8010453c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  lk->locked = 0;
+8010453f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
+  lk->pid = 0;
+}
+80104545:	83 c4 10             	add    $0x10,%esp
+  lk->pid = 0;
+80104548:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
+  lk->name = name;
+8010454f:	89 43 38             	mov    %eax,0x38(%ebx)
+}
+80104552:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80104555:	c9                   	leave  
+80104556:	c3                   	ret    
+80104557:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010455e:	66 90                	xchg   %ax,%ax
+
+80104560 <acquiresleep>:
+
+void
+acquiresleep(struct sleeplock *lk)
+{
+80104560:	f3 0f 1e fb          	endbr32 
+80104564:	55                   	push   %ebp
+80104565:	89 e5                	mov    %esp,%ebp
+80104567:	56                   	push   %esi
+80104568:	53                   	push   %ebx
+80104569:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  acquire(&lk->lk);
+8010456c:	8d 73 04             	lea    0x4(%ebx),%esi
+8010456f:	83 ec 0c             	sub    $0xc,%esp
+80104572:	56                   	push   %esi
+80104573:	e8 68 02 00 00       	call   801047e0 <acquire>
+  while (lk->locked) {
+80104578:	8b 13                	mov    (%ebx),%edx
+8010457a:	83 c4 10             	add    $0x10,%esp
+8010457d:	85 d2                	test   %edx,%edx
+8010457f:	74 1a                	je     8010459b <acquiresleep+0x3b>
+80104581:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    sleep(lk, &lk->lk);
+80104588:	83 ec 08             	sub    $0x8,%esp
+8010458b:	56                   	push   %esi
+8010458c:	53                   	push   %ebx
+8010458d:	e8 8e f9 ff ff       	call   80103f20 <sleep>
+  while (lk->locked) {
+80104592:	8b 03                	mov    (%ebx),%eax
+80104594:	83 c4 10             	add    $0x10,%esp
+80104597:	85 c0                	test   %eax,%eax
+80104599:	75 ed                	jne    80104588 <acquiresleep+0x28>
+  }
+  lk->locked = 1;
+8010459b:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
+  lk->pid = myproc()->pid;
+801045a1:	e8 ba f3 ff ff       	call   80103960 <myproc>
+801045a6:	8b 40 10             	mov    0x10(%eax),%eax
+801045a9:	89 43 3c             	mov    %eax,0x3c(%ebx)
+  release(&lk->lk);
+801045ac:	89 75 08             	mov    %esi,0x8(%ebp)
+}
+801045af:	8d 65 f8             	lea    -0x8(%ebp),%esp
+801045b2:	5b                   	pop    %ebx
+801045b3:	5e                   	pop    %esi
+801045b4:	5d                   	pop    %ebp
+  release(&lk->lk);
+801045b5:	e9 e6 02 00 00       	jmp    801048a0 <release>
+801045ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+801045c0 <releasesleep>:
+
+void
+releasesleep(struct sleeplock *lk)
+{
+801045c0:	f3 0f 1e fb          	endbr32 
+801045c4:	55                   	push   %ebp
+801045c5:	89 e5                	mov    %esp,%ebp
+801045c7:	56                   	push   %esi
+801045c8:	53                   	push   %ebx
+801045c9:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  acquire(&lk->lk);
+801045cc:	8d 73 04             	lea    0x4(%ebx),%esi
+801045cf:	83 ec 0c             	sub    $0xc,%esp
+801045d2:	56                   	push   %esi
+801045d3:	e8 08 02 00 00       	call   801047e0 <acquire>
+  lk->locked = 0;
+801045d8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
+  lk->pid = 0;
+801045de:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
+  wakeup(lk);
+801045e5:	89 1c 24             	mov    %ebx,(%esp)
+801045e8:	e8 f3 fa ff ff       	call   801040e0 <wakeup>
+  release(&lk->lk);
+801045ed:	89 75 08             	mov    %esi,0x8(%ebp)
+801045f0:	83 c4 10             	add    $0x10,%esp
+}
+801045f3:	8d 65 f8             	lea    -0x8(%ebp),%esp
+801045f6:	5b                   	pop    %ebx
+801045f7:	5e                   	pop    %esi
+801045f8:	5d                   	pop    %ebp
+  release(&lk->lk);
+801045f9:	e9 a2 02 00 00       	jmp    801048a0 <release>
+801045fe:	66 90                	xchg   %ax,%ax
+
+80104600 <holdingsleep>:
+
+int
+holdingsleep(struct sleeplock *lk)
+{
+80104600:	f3 0f 1e fb          	endbr32 
+80104604:	55                   	push   %ebp
+80104605:	89 e5                	mov    %esp,%ebp
+80104607:	57                   	push   %edi
+80104608:	31 ff                	xor    %edi,%edi
+8010460a:	56                   	push   %esi
+8010460b:	53                   	push   %ebx
+8010460c:	83 ec 18             	sub    $0x18,%esp
+8010460f:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  int r;
+  
+  acquire(&lk->lk);
+80104612:	8d 73 04             	lea    0x4(%ebx),%esi
+80104615:	56                   	push   %esi
+80104616:	e8 c5 01 00 00       	call   801047e0 <acquire>
+  r = lk->locked && (lk->pid == myproc()->pid);
+8010461b:	8b 03                	mov    (%ebx),%eax
+8010461d:	83 c4 10             	add    $0x10,%esp
+80104620:	85 c0                	test   %eax,%eax
+80104622:	75 1c                	jne    80104640 <holdingsleep+0x40>
+  release(&lk->lk);
+80104624:	83 ec 0c             	sub    $0xc,%esp
+80104627:	56                   	push   %esi
+80104628:	e8 73 02 00 00       	call   801048a0 <release>
+  return r;
+}
+8010462d:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80104630:	89 f8                	mov    %edi,%eax
+80104632:	5b                   	pop    %ebx
+80104633:	5e                   	pop    %esi
+80104634:	5f                   	pop    %edi
+80104635:	5d                   	pop    %ebp
+80104636:	c3                   	ret    
+80104637:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010463e:	66 90                	xchg   %ax,%ax
+  r = lk->locked && (lk->pid == myproc()->pid);
+80104640:	8b 5b 3c             	mov    0x3c(%ebx),%ebx
+80104643:	e8 18 f3 ff ff       	call   80103960 <myproc>
+80104648:	39 58 10             	cmp    %ebx,0x10(%eax)
+8010464b:	0f 94 c0             	sete   %al
+8010464e:	0f b6 c0             	movzbl %al,%eax
+80104651:	89 c7                	mov    %eax,%edi
+80104653:	eb cf                	jmp    80104624 <holdingsleep+0x24>
+80104655:	66 90                	xchg   %ax,%ax
+80104657:	66 90                	xchg   %ax,%ax
+80104659:	66 90                	xchg   %ax,%ax
+8010465b:	66 90                	xchg   %ax,%ax
+8010465d:	66 90                	xchg   %ax,%ax
+8010465f:	90                   	nop
+
+80104660 <initlock>:
+#include "proc.h"
+#include "spinlock.h"
+
+void
+initlock(struct spinlock *lk, char *name)
+{
+80104660:	f3 0f 1e fb          	endbr32 
+80104664:	55                   	push   %ebp
+80104665:	89 e5                	mov    %esp,%ebp
+80104667:	8b 45 08             	mov    0x8(%ebp),%eax
+  lk->name = name;
+8010466a:	8b 55 0c             	mov    0xc(%ebp),%edx
+  lk->locked = 0;
+8010466d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+  lk->name = name;
+80104673:	89 50 04             	mov    %edx,0x4(%eax)
+  lk->cpu = 0;
+80104676:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+}
+8010467d:	5d                   	pop    %ebp
+8010467e:	c3                   	ret    
+8010467f:	90                   	nop
+
+80104680 <getcallerpcs>:
+}
+
+// Record the current call stack in pcs[] by following the %ebp chain.
+void
+getcallerpcs(void *v, uint pcs[])
+{
+80104680:	f3 0f 1e fb          	endbr32 
+80104684:	55                   	push   %ebp
+  uint *ebp;
+  int i;
+
+  ebp = (uint*)v - 2;
+  for(i = 0; i < 10; i++){
+80104685:	31 d2                	xor    %edx,%edx
+{
+80104687:	89 e5                	mov    %esp,%ebp
+80104689:	53                   	push   %ebx
+  ebp = (uint*)v - 2;
+8010468a:	8b 45 08             	mov    0x8(%ebp),%eax
+{
+8010468d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  ebp = (uint*)v - 2;
+80104690:	83 e8 08             	sub    $0x8,%eax
+  for(i = 0; i < 10; i++){
+80104693:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80104697:	90                   	nop
+    if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
+80104698:	8d 98 00 00 00 80    	lea    -0x80000000(%eax),%ebx
+8010469e:	81 fb fe ff ff 7f    	cmp    $0x7ffffffe,%ebx
+801046a4:	77 1a                	ja     801046c0 <getcallerpcs+0x40>
+      break;
+    pcs[i] = ebp[1];     // saved %eip
+801046a6:	8b 58 04             	mov    0x4(%eax),%ebx
+801046a9:	89 1c 91             	mov    %ebx,(%ecx,%edx,4)
+  for(i = 0; i < 10; i++){
+801046ac:	83 c2 01             	add    $0x1,%edx
+    ebp = (uint*)ebp[0]; // saved %ebp
+801046af:	8b 00                	mov    (%eax),%eax
+  for(i = 0; i < 10; i++){
+801046b1:	83 fa 0a             	cmp    $0xa,%edx
+801046b4:	75 e2                	jne    80104698 <getcallerpcs+0x18>
+  }
+  for(; i < 10; i++)
+    pcs[i] = 0;
+}
+801046b6:	5b                   	pop    %ebx
+801046b7:	5d                   	pop    %ebp
+801046b8:	c3                   	ret    
+801046b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  for(; i < 10; i++)
+801046c0:	8d 04 91             	lea    (%ecx,%edx,4),%eax
+801046c3:	8d 51 28             	lea    0x28(%ecx),%edx
+801046c6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801046cd:	8d 76 00             	lea    0x0(%esi),%esi
+    pcs[i] = 0;
+801046d0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+  for(; i < 10; i++)
+801046d6:	83 c0 04             	add    $0x4,%eax
+801046d9:	39 d0                	cmp    %edx,%eax
+801046db:	75 f3                	jne    801046d0 <getcallerpcs+0x50>
+}
+801046dd:	5b                   	pop    %ebx
+801046de:	5d                   	pop    %ebp
+801046df:	c3                   	ret    
+
+801046e0 <pushcli>:
+// it takes two popcli to undo two pushcli.  Also, if interrupts
+// are off, then pushcli, popcli leaves them off.
+
+void
+pushcli(void)
+{
+801046e0:	f3 0f 1e fb          	endbr32 
+801046e4:	55                   	push   %ebp
+801046e5:	89 e5                	mov    %esp,%ebp
+801046e7:	53                   	push   %ebx
+801046e8:	83 ec 04             	sub    $0x4,%esp
+801046eb:	9c                   	pushf  
+801046ec:	5b                   	pop    %ebx
+  asm volatile("cli");
+801046ed:	fa                   	cli    
+  int eflags;
+
+  eflags = readeflags();
+  cli();
+  if(mycpu()->ncli == 0)
+801046ee:	e8 dd f1 ff ff       	call   801038d0 <mycpu>
+801046f3:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
+801046f9:	85 c0                	test   %eax,%eax
+801046fb:	74 13                	je     80104710 <pushcli+0x30>
+    mycpu()->intena = eflags & FL_IF;
+  mycpu()->ncli += 1;
+801046fd:	e8 ce f1 ff ff       	call   801038d0 <mycpu>
+80104702:	83 80 a4 00 00 00 01 	addl   $0x1,0xa4(%eax)
+}
+80104709:	83 c4 04             	add    $0x4,%esp
+8010470c:	5b                   	pop    %ebx
+8010470d:	5d                   	pop    %ebp
+8010470e:	c3                   	ret    
+8010470f:	90                   	nop
+    mycpu()->intena = eflags & FL_IF;
+80104710:	e8 bb f1 ff ff       	call   801038d0 <mycpu>
+80104715:	81 e3 00 02 00 00    	and    $0x200,%ebx
+8010471b:	89 98 a8 00 00 00    	mov    %ebx,0xa8(%eax)
+80104721:	eb da                	jmp    801046fd <pushcli+0x1d>
+80104723:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010472a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80104730 <popcli>:
+
+void
+popcli(void)
+{
+80104730:	f3 0f 1e fb          	endbr32 
+80104734:	55                   	push   %ebp
+80104735:	89 e5                	mov    %esp,%ebp
+80104737:	83 ec 08             	sub    $0x8,%esp
+  asm volatile("pushfl; popl %0" : "=r" (eflags));
+8010473a:	9c                   	pushf  
+8010473b:	58                   	pop    %eax
+  if(readeflags()&FL_IF)
+8010473c:	f6 c4 02             	test   $0x2,%ah
+8010473f:	75 31                	jne    80104772 <popcli+0x42>
+    panic("popcli - interruptible");
+  if(--mycpu()->ncli < 0)
+80104741:	e8 8a f1 ff ff       	call   801038d0 <mycpu>
+80104746:	83 a8 a4 00 00 00 01 	subl   $0x1,0xa4(%eax)
+8010474d:	78 30                	js     8010477f <popcli+0x4f>
+    panic("popcli");
+  if(mycpu()->ncli == 0 && mycpu()->intena)
+8010474f:	e8 7c f1 ff ff       	call   801038d0 <mycpu>
+80104754:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
+8010475a:	85 d2                	test   %edx,%edx
+8010475c:	74 02                	je     80104760 <popcli+0x30>
+    sti();
+}
+8010475e:	c9                   	leave  
+8010475f:	c3                   	ret    
+  if(mycpu()->ncli == 0 && mycpu()->intena)
+80104760:	e8 6b f1 ff ff       	call   801038d0 <mycpu>
+80104765:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
+8010476b:	85 c0                	test   %eax,%eax
+8010476d:	74 ef                	je     8010475e <popcli+0x2e>
+  asm volatile("sti");
+8010476f:	fb                   	sti    
+}
+80104770:	c9                   	leave  
+80104771:	c3                   	ret    
+    panic("popcli - interruptible");
+80104772:	83 ec 0c             	sub    $0xc,%esp
+80104775:	68 2f 7b 10 80       	push   $0x80107b2f
+8010477a:	e8 11 bc ff ff       	call   80100390 <panic>
+    panic("popcli");
+8010477f:	83 ec 0c             	sub    $0xc,%esp
+80104782:	68 46 7b 10 80       	push   $0x80107b46
+80104787:	e8 04 bc ff ff       	call   80100390 <panic>
+8010478c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80104790 <holding>:
+{
+80104790:	f3 0f 1e fb          	endbr32 
+80104794:	55                   	push   %ebp
+80104795:	89 e5                	mov    %esp,%ebp
+80104797:	56                   	push   %esi
+80104798:	53                   	push   %ebx
+80104799:	8b 75 08             	mov    0x8(%ebp),%esi
+8010479c:	31 db                	xor    %ebx,%ebx
+  pushcli();
+8010479e:	e8 3d ff ff ff       	call   801046e0 <pushcli>
+  r = lock->locked && lock->cpu == mycpu();
+801047a3:	8b 06                	mov    (%esi),%eax
+801047a5:	85 c0                	test   %eax,%eax
+801047a7:	75 0f                	jne    801047b8 <holding+0x28>
+  popcli();
+801047a9:	e8 82 ff ff ff       	call   80104730 <popcli>
+}
+801047ae:	89 d8                	mov    %ebx,%eax
+801047b0:	5b                   	pop    %ebx
+801047b1:	5e                   	pop    %esi
+801047b2:	5d                   	pop    %ebp
+801047b3:	c3                   	ret    
+801047b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  r = lock->locked && lock->cpu == mycpu();
+801047b8:	8b 5e 08             	mov    0x8(%esi),%ebx
+801047bb:	e8 10 f1 ff ff       	call   801038d0 <mycpu>
+801047c0:	39 c3                	cmp    %eax,%ebx
+801047c2:	0f 94 c3             	sete   %bl
+  popcli();
+801047c5:	e8 66 ff ff ff       	call   80104730 <popcli>
+  r = lock->locked && lock->cpu == mycpu();
+801047ca:	0f b6 db             	movzbl %bl,%ebx
+}
+801047cd:	89 d8                	mov    %ebx,%eax
+801047cf:	5b                   	pop    %ebx
+801047d0:	5e                   	pop    %esi
+801047d1:	5d                   	pop    %ebp
+801047d2:	c3                   	ret    
+801047d3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801047da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+801047e0 <acquire>:
+{
+801047e0:	f3 0f 1e fb          	endbr32 
+801047e4:	55                   	push   %ebp
+801047e5:	89 e5                	mov    %esp,%ebp
+801047e7:	56                   	push   %esi
+801047e8:	53                   	push   %ebx
+  pushcli(); // disable interrupts to avoid deadlock.
+801047e9:	e8 f2 fe ff ff       	call   801046e0 <pushcli>
+  if(holding(lk))
+801047ee:	8b 5d 08             	mov    0x8(%ebp),%ebx
+801047f1:	83 ec 0c             	sub    $0xc,%esp
+801047f4:	53                   	push   %ebx
+801047f5:	e8 96 ff ff ff       	call   80104790 <holding>
+801047fa:	83 c4 10             	add    $0x10,%esp
+801047fd:	85 c0                	test   %eax,%eax
+801047ff:	0f 85 7f 00 00 00    	jne    80104884 <acquire+0xa4>
+80104805:	89 c6                	mov    %eax,%esi
+  asm volatile("lock; xchgl %0, %1" :
+80104807:	ba 01 00 00 00       	mov    $0x1,%edx
+8010480c:	eb 05                	jmp    80104813 <acquire+0x33>
+8010480e:	66 90                	xchg   %ax,%ax
+80104810:	8b 5d 08             	mov    0x8(%ebp),%ebx
+80104813:	89 d0                	mov    %edx,%eax
+80104815:	f0 87 03             	lock xchg %eax,(%ebx)
+  while(xchg(&lk->locked, 1) != 0)
+80104818:	85 c0                	test   %eax,%eax
+8010481a:	75 f4                	jne    80104810 <acquire+0x30>
+  __sync_synchronize();
+8010481c:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
+  lk->cpu = mycpu();
+80104821:	8b 5d 08             	mov    0x8(%ebp),%ebx
+80104824:	e8 a7 f0 ff ff       	call   801038d0 <mycpu>
+80104829:	89 43 08             	mov    %eax,0x8(%ebx)
+  ebp = (uint*)v - 2;
+8010482c:	89 e8                	mov    %ebp,%eax
+8010482e:	66 90                	xchg   %ax,%ax
+    if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
+80104830:	8d 90 00 00 00 80    	lea    -0x80000000(%eax),%edx
+80104836:	81 fa fe ff ff 7f    	cmp    $0x7ffffffe,%edx
+8010483c:	77 22                	ja     80104860 <acquire+0x80>
+    pcs[i] = ebp[1];     // saved %eip
+8010483e:	8b 50 04             	mov    0x4(%eax),%edx
+80104841:	89 54 b3 0c          	mov    %edx,0xc(%ebx,%esi,4)
+  for(i = 0; i < 10; i++){
+80104845:	83 c6 01             	add    $0x1,%esi
+    ebp = (uint*)ebp[0]; // saved %ebp
+80104848:	8b 00                	mov    (%eax),%eax
+  for(i = 0; i < 10; i++){
+8010484a:	83 fe 0a             	cmp    $0xa,%esi
+8010484d:	75 e1                	jne    80104830 <acquire+0x50>
+}
+8010484f:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80104852:	5b                   	pop    %ebx
+80104853:	5e                   	pop    %esi
+80104854:	5d                   	pop    %ebp
+80104855:	c3                   	ret    
+80104856:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010485d:	8d 76 00             	lea    0x0(%esi),%esi
+  for(; i < 10; i++)
+80104860:	8d 44 b3 0c          	lea    0xc(%ebx,%esi,4),%eax
+80104864:	83 c3 34             	add    $0x34,%ebx
+80104867:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010486e:	66 90                	xchg   %ax,%ax
+    pcs[i] = 0;
+80104870:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+  for(; i < 10; i++)
+80104876:	83 c0 04             	add    $0x4,%eax
+80104879:	39 d8                	cmp    %ebx,%eax
+8010487b:	75 f3                	jne    80104870 <acquire+0x90>
+}
+8010487d:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80104880:	5b                   	pop    %ebx
+80104881:	5e                   	pop    %esi
+80104882:	5d                   	pop    %ebp
+80104883:	c3                   	ret    
+    panic("acquire");
+80104884:	83 ec 0c             	sub    $0xc,%esp
+80104887:	68 4d 7b 10 80       	push   $0x80107b4d
+8010488c:	e8 ff ba ff ff       	call   80100390 <panic>
+80104891:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104898:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010489f:	90                   	nop
+
+801048a0 <release>:
+{
+801048a0:	f3 0f 1e fb          	endbr32 
+801048a4:	55                   	push   %ebp
+801048a5:	89 e5                	mov    %esp,%ebp
+801048a7:	53                   	push   %ebx
+801048a8:	83 ec 10             	sub    $0x10,%esp
+801048ab:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(!holding(lk))
+801048ae:	53                   	push   %ebx
+801048af:	e8 dc fe ff ff       	call   80104790 <holding>
+801048b4:	83 c4 10             	add    $0x10,%esp
+801048b7:	85 c0                	test   %eax,%eax
+801048b9:	74 22                	je     801048dd <release+0x3d>
+  lk->pcs[0] = 0;
+801048bb:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
+  lk->cpu = 0;
+801048c2:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
+  __sync_synchronize();
+801048c9:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+801048ce:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
+}
+801048d4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+801048d7:	c9                   	leave  
+  popcli();
+801048d8:	e9 53 fe ff ff       	jmp    80104730 <popcli>
+    panic("release");
+801048dd:	83 ec 0c             	sub    $0xc,%esp
+801048e0:	68 55 7b 10 80       	push   $0x80107b55
+801048e5:	e8 a6 ba ff ff       	call   80100390 <panic>
+801048ea:	66 90                	xchg   %ax,%ax
+801048ec:	66 90                	xchg   %ax,%ax
+801048ee:	66 90                	xchg   %ax,%ax
+
+801048f0 <memset>:
+#include "types.h"
+#include "x86.h"
+
+void*
+memset(void *dst, int c, uint n)
+{
+801048f0:	f3 0f 1e fb          	endbr32 
+801048f4:	55                   	push   %ebp
+801048f5:	89 e5                	mov    %esp,%ebp
+801048f7:	57                   	push   %edi
+801048f8:	8b 55 08             	mov    0x8(%ebp),%edx
+801048fb:	8b 4d 10             	mov    0x10(%ebp),%ecx
+801048fe:	53                   	push   %ebx
+801048ff:	8b 45 0c             	mov    0xc(%ebp),%eax
+  if ((int)dst%4 == 0 && n%4 == 0){
+80104902:	89 d7                	mov    %edx,%edi
+80104904:	09 cf                	or     %ecx,%edi
+80104906:	83 e7 03             	and    $0x3,%edi
+80104909:	75 25                	jne    80104930 <memset+0x40>
+    c &= 0xFF;
+8010490b:	0f b6 f8             	movzbl %al,%edi
+    stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
+8010490e:	c1 e0 18             	shl    $0x18,%eax
+80104911:	89 fb                	mov    %edi,%ebx
+80104913:	c1 e9 02             	shr    $0x2,%ecx
+80104916:	c1 e3 10             	shl    $0x10,%ebx
+80104919:	09 d8                	or     %ebx,%eax
+8010491b:	09 f8                	or     %edi,%eax
+8010491d:	c1 e7 08             	shl    $0x8,%edi
+80104920:	09 f8                	or     %edi,%eax
+  asm volatile("cld; rep stosl" :
+80104922:	89 d7                	mov    %edx,%edi
+80104924:	fc                   	cld    
+80104925:	f3 ab                	rep stos %eax,%es:(%edi)
+  } else
+    stosb(dst, c, n);
+  return dst;
+}
+80104927:	5b                   	pop    %ebx
+80104928:	89 d0                	mov    %edx,%eax
+8010492a:	5f                   	pop    %edi
+8010492b:	5d                   	pop    %ebp
+8010492c:	c3                   	ret    
+8010492d:	8d 76 00             	lea    0x0(%esi),%esi
+  asm volatile("cld; rep stosb" :
+80104930:	89 d7                	mov    %edx,%edi
+80104932:	fc                   	cld    
+80104933:	f3 aa                	rep stos %al,%es:(%edi)
+80104935:	5b                   	pop    %ebx
+80104936:	89 d0                	mov    %edx,%eax
+80104938:	5f                   	pop    %edi
+80104939:	5d                   	pop    %ebp
+8010493a:	c3                   	ret    
+8010493b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010493f:	90                   	nop
+
+80104940 <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, uint n)
+{
+80104940:	f3 0f 1e fb          	endbr32 
+80104944:	55                   	push   %ebp
+80104945:	89 e5                	mov    %esp,%ebp
+80104947:	56                   	push   %esi
+80104948:	8b 75 10             	mov    0x10(%ebp),%esi
+8010494b:	8b 55 08             	mov    0x8(%ebp),%edx
+8010494e:	53                   	push   %ebx
+8010494f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  const uchar *s1, *s2;
+
+  s1 = v1;
+  s2 = v2;
+  while(n-- > 0){
+80104952:	85 f6                	test   %esi,%esi
+80104954:	74 2a                	je     80104980 <memcmp+0x40>
+80104956:	01 c6                	add    %eax,%esi
+80104958:	eb 10                	jmp    8010496a <memcmp+0x2a>
+8010495a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    if(*s1 != *s2)
+      return *s1 - *s2;
+    s1++, s2++;
+80104960:	83 c0 01             	add    $0x1,%eax
+80104963:	83 c2 01             	add    $0x1,%edx
+  while(n-- > 0){
+80104966:	39 f0                	cmp    %esi,%eax
+80104968:	74 16                	je     80104980 <memcmp+0x40>
+    if(*s1 != *s2)
+8010496a:	0f b6 0a             	movzbl (%edx),%ecx
+8010496d:	0f b6 18             	movzbl (%eax),%ebx
+80104970:	38 d9                	cmp    %bl,%cl
+80104972:	74 ec                	je     80104960 <memcmp+0x20>
+      return *s1 - *s2;
+80104974:	0f b6 c1             	movzbl %cl,%eax
+80104977:	29 d8                	sub    %ebx,%eax
+  }
+
+  return 0;
+}
+80104979:	5b                   	pop    %ebx
+8010497a:	5e                   	pop    %esi
+8010497b:	5d                   	pop    %ebp
+8010497c:	c3                   	ret    
+8010497d:	8d 76 00             	lea    0x0(%esi),%esi
+80104980:	5b                   	pop    %ebx
+  return 0;
+80104981:	31 c0                	xor    %eax,%eax
+}
+80104983:	5e                   	pop    %esi
+80104984:	5d                   	pop    %ebp
+80104985:	c3                   	ret    
+80104986:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010498d:	8d 76 00             	lea    0x0(%esi),%esi
+
+80104990 <memmove>:
+
+void*
+memmove(void *dst, const void *src, uint n)
+{
+80104990:	f3 0f 1e fb          	endbr32 
+80104994:	55                   	push   %ebp
+80104995:	89 e5                	mov    %esp,%ebp
+80104997:	57                   	push   %edi
+80104998:	8b 55 08             	mov    0x8(%ebp),%edx
+8010499b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+8010499e:	56                   	push   %esi
+8010499f:	8b 75 0c             	mov    0xc(%ebp),%esi
+  const char *s;
+  char *d;
+
+  s = src;
+  d = dst;
+  if(s < d && s + n > d){
+801049a2:	39 d6                	cmp    %edx,%esi
+801049a4:	73 2a                	jae    801049d0 <memmove+0x40>
+801049a6:	8d 3c 0e             	lea    (%esi,%ecx,1),%edi
+801049a9:	39 fa                	cmp    %edi,%edx
+801049ab:	73 23                	jae    801049d0 <memmove+0x40>
+801049ad:	8d 41 ff             	lea    -0x1(%ecx),%eax
+    s += n;
+    d += n;
+    while(n-- > 0)
+801049b0:	85 c9                	test   %ecx,%ecx
+801049b2:	74 13                	je     801049c7 <memmove+0x37>
+801049b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      *--d = *--s;
+801049b8:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
+801049bc:	88 0c 02             	mov    %cl,(%edx,%eax,1)
+    while(n-- > 0)
+801049bf:	83 e8 01             	sub    $0x1,%eax
+801049c2:	83 f8 ff             	cmp    $0xffffffff,%eax
+801049c5:	75 f1                	jne    801049b8 <memmove+0x28>
+  } else
+    while(n-- > 0)
+      *d++ = *s++;
+
+  return dst;
+}
+801049c7:	5e                   	pop    %esi
+801049c8:	89 d0                	mov    %edx,%eax
+801049ca:	5f                   	pop    %edi
+801049cb:	5d                   	pop    %ebp
+801049cc:	c3                   	ret    
+801049cd:	8d 76 00             	lea    0x0(%esi),%esi
+    while(n-- > 0)
+801049d0:	8d 04 0e             	lea    (%esi,%ecx,1),%eax
+801049d3:	89 d7                	mov    %edx,%edi
+801049d5:	85 c9                	test   %ecx,%ecx
+801049d7:	74 ee                	je     801049c7 <memmove+0x37>
+801049d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      *d++ = *s++;
+801049e0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+    while(n-- > 0)
+801049e1:	39 f0                	cmp    %esi,%eax
+801049e3:	75 fb                	jne    801049e0 <memmove+0x50>
+}
+801049e5:	5e                   	pop    %esi
+801049e6:	89 d0                	mov    %edx,%eax
+801049e8:	5f                   	pop    %edi
+801049e9:	5d                   	pop    %ebp
+801049ea:	c3                   	ret    
+801049eb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801049ef:	90                   	nop
+
+801049f0 <memcpy>:
+
+// memcpy exists to placate GCC.  Use memmove.
+void*
+memcpy(void *dst, const void *src, uint n)
+{
+801049f0:	f3 0f 1e fb          	endbr32 
+  return memmove(dst, src, n);
+801049f4:	eb 9a                	jmp    80104990 <memmove>
+801049f6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801049fd:	8d 76 00             	lea    0x0(%esi),%esi
+
+80104a00 <strncmp>:
+}
+
+int
+strncmp(const char *p, const char *q, uint n)
+{
+80104a00:	f3 0f 1e fb          	endbr32 
+80104a04:	55                   	push   %ebp
+80104a05:	89 e5                	mov    %esp,%ebp
+80104a07:	56                   	push   %esi
+80104a08:	8b 75 10             	mov    0x10(%ebp),%esi
+80104a0b:	8b 4d 08             	mov    0x8(%ebp),%ecx
+80104a0e:	53                   	push   %ebx
+80104a0f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  while(n > 0 && *p && *p == *q)
+80104a12:	85 f6                	test   %esi,%esi
+80104a14:	74 32                	je     80104a48 <strncmp+0x48>
+80104a16:	01 c6                	add    %eax,%esi
+80104a18:	eb 14                	jmp    80104a2e <strncmp+0x2e>
+80104a1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80104a20:	38 da                	cmp    %bl,%dl
+80104a22:	75 14                	jne    80104a38 <strncmp+0x38>
+    n--, p++, q++;
+80104a24:	83 c0 01             	add    $0x1,%eax
+80104a27:	83 c1 01             	add    $0x1,%ecx
+  while(n > 0 && *p && *p == *q)
+80104a2a:	39 f0                	cmp    %esi,%eax
+80104a2c:	74 1a                	je     80104a48 <strncmp+0x48>
+80104a2e:	0f b6 11             	movzbl (%ecx),%edx
+80104a31:	0f b6 18             	movzbl (%eax),%ebx
+80104a34:	84 d2                	test   %dl,%dl
+80104a36:	75 e8                	jne    80104a20 <strncmp+0x20>
+  if(n == 0)
+    return 0;
+  return (uchar)*p - (uchar)*q;
+80104a38:	0f b6 c2             	movzbl %dl,%eax
+80104a3b:	29 d8                	sub    %ebx,%eax
+}
+80104a3d:	5b                   	pop    %ebx
+80104a3e:	5e                   	pop    %esi
+80104a3f:	5d                   	pop    %ebp
+80104a40:	c3                   	ret    
+80104a41:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104a48:	5b                   	pop    %ebx
+    return 0;
+80104a49:	31 c0                	xor    %eax,%eax
+}
+80104a4b:	5e                   	pop    %esi
+80104a4c:	5d                   	pop    %ebp
+80104a4d:	c3                   	ret    
+80104a4e:	66 90                	xchg   %ax,%ax
+
+80104a50 <strncpy>:
+
+char*
+strncpy(char *s, const char *t, int n)
+{
+80104a50:	f3 0f 1e fb          	endbr32 
+80104a54:	55                   	push   %ebp
+80104a55:	89 e5                	mov    %esp,%ebp
+80104a57:	57                   	push   %edi
+80104a58:	56                   	push   %esi
+80104a59:	8b 75 08             	mov    0x8(%ebp),%esi
+80104a5c:	53                   	push   %ebx
+80104a5d:	8b 45 10             	mov    0x10(%ebp),%eax
+  char *os;
+
+  os = s;
+  while(n-- > 0 && (*s++ = *t++) != 0)
+80104a60:	89 f2                	mov    %esi,%edx
+80104a62:	eb 1b                	jmp    80104a7f <strncpy+0x2f>
+80104a64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80104a68:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+80104a6c:	8b 7d 0c             	mov    0xc(%ebp),%edi
+80104a6f:	83 c2 01             	add    $0x1,%edx
+80104a72:	0f b6 7f ff          	movzbl -0x1(%edi),%edi
+80104a76:	89 f9                	mov    %edi,%ecx
+80104a78:	88 4a ff             	mov    %cl,-0x1(%edx)
+80104a7b:	84 c9                	test   %cl,%cl
+80104a7d:	74 09                	je     80104a88 <strncpy+0x38>
+80104a7f:	89 c3                	mov    %eax,%ebx
+80104a81:	83 e8 01             	sub    $0x1,%eax
+80104a84:	85 db                	test   %ebx,%ebx
+80104a86:	7f e0                	jg     80104a68 <strncpy+0x18>
+    ;
+  while(n-- > 0)
+80104a88:	89 d1                	mov    %edx,%ecx
+80104a8a:	85 c0                	test   %eax,%eax
+80104a8c:	7e 15                	jle    80104aa3 <strncpy+0x53>
+80104a8e:	66 90                	xchg   %ax,%ax
+    *s++ = 0;
+80104a90:	83 c1 01             	add    $0x1,%ecx
+80104a93:	c6 41 ff 00          	movb   $0x0,-0x1(%ecx)
+  while(n-- > 0)
+80104a97:	89 c8                	mov    %ecx,%eax
+80104a99:	f7 d0                	not    %eax
+80104a9b:	01 d0                	add    %edx,%eax
+80104a9d:	01 d8                	add    %ebx,%eax
+80104a9f:	85 c0                	test   %eax,%eax
+80104aa1:	7f ed                	jg     80104a90 <strncpy+0x40>
+  return os;
+}
+80104aa3:	5b                   	pop    %ebx
+80104aa4:	89 f0                	mov    %esi,%eax
+80104aa6:	5e                   	pop    %esi
+80104aa7:	5f                   	pop    %edi
+80104aa8:	5d                   	pop    %ebp
+80104aa9:	c3                   	ret    
+80104aaa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80104ab0 <safestrcpy>:
+
+// Like strncpy but guaranteed to NUL-terminate.
+char*
+safestrcpy(char *s, const char *t, int n)
+{
+80104ab0:	f3 0f 1e fb          	endbr32 
+80104ab4:	55                   	push   %ebp
+80104ab5:	89 e5                	mov    %esp,%ebp
+80104ab7:	56                   	push   %esi
+80104ab8:	8b 55 10             	mov    0x10(%ebp),%edx
+80104abb:	8b 75 08             	mov    0x8(%ebp),%esi
+80104abe:	53                   	push   %ebx
+80104abf:	8b 45 0c             	mov    0xc(%ebp),%eax
+  char *os;
+
+  os = s;
+  if(n <= 0)
+80104ac2:	85 d2                	test   %edx,%edx
+80104ac4:	7e 21                	jle    80104ae7 <safestrcpy+0x37>
+80104ac6:	8d 5c 10 ff          	lea    -0x1(%eax,%edx,1),%ebx
+80104aca:	89 f2                	mov    %esi,%edx
+80104acc:	eb 12                	jmp    80104ae0 <safestrcpy+0x30>
+80104ace:	66 90                	xchg   %ax,%ax
+    return os;
+  while(--n > 0 && (*s++ = *t++) != 0)
+80104ad0:	0f b6 08             	movzbl (%eax),%ecx
+80104ad3:	83 c0 01             	add    $0x1,%eax
+80104ad6:	83 c2 01             	add    $0x1,%edx
+80104ad9:	88 4a ff             	mov    %cl,-0x1(%edx)
+80104adc:	84 c9                	test   %cl,%cl
+80104ade:	74 04                	je     80104ae4 <safestrcpy+0x34>
+80104ae0:	39 d8                	cmp    %ebx,%eax
+80104ae2:	75 ec                	jne    80104ad0 <safestrcpy+0x20>
+    ;
+  *s = 0;
+80104ae4:	c6 02 00             	movb   $0x0,(%edx)
+  return os;
+}
+80104ae7:	89 f0                	mov    %esi,%eax
+80104ae9:	5b                   	pop    %ebx
+80104aea:	5e                   	pop    %esi
+80104aeb:	5d                   	pop    %ebp
+80104aec:	c3                   	ret    
+80104aed:	8d 76 00             	lea    0x0(%esi),%esi
+
+80104af0 <strlen>:
+
+int
+strlen(const char *s)
+{
+80104af0:	f3 0f 1e fb          	endbr32 
+80104af4:	55                   	push   %ebp
+  int n;
+
+  for(n = 0; s[n]; n++)
+80104af5:	31 c0                	xor    %eax,%eax
+{
+80104af7:	89 e5                	mov    %esp,%ebp
+80104af9:	8b 55 08             	mov    0x8(%ebp),%edx
+  for(n = 0; s[n]; n++)
+80104afc:	80 3a 00             	cmpb   $0x0,(%edx)
+80104aff:	74 10                	je     80104b11 <strlen+0x21>
+80104b01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104b08:	83 c0 01             	add    $0x1,%eax
+80104b0b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+80104b0f:	75 f7                	jne    80104b08 <strlen+0x18>
+    ;
+  return n;
+}
+80104b11:	5d                   	pop    %ebp
+80104b12:	c3                   	ret    
+
+80104b13 <swtch>:
+# a struct context, and save its address in *old.
+# Switch stacks to new and pop previously-saved registers.
+
+.globl swtch
+swtch:
+  movl 4(%esp), %eax
+80104b13:	8b 44 24 04          	mov    0x4(%esp),%eax
+  movl 8(%esp), %edx
+80104b17:	8b 54 24 08          	mov    0x8(%esp),%edx
+
+  # Save old callee-saved registers
+  pushl %ebp
+80104b1b:	55                   	push   %ebp
+  pushl %ebx
+80104b1c:	53                   	push   %ebx
+  pushl %esi
+80104b1d:	56                   	push   %esi
+  pushl %edi
+80104b1e:	57                   	push   %edi
+
+  # Switch stacks
+  movl %esp, (%eax)
+80104b1f:	89 20                	mov    %esp,(%eax)
+  movl %edx, %esp
+80104b21:	89 d4                	mov    %edx,%esp
+
+  # Load new callee-saved registers
+  popl %edi
+80104b23:	5f                   	pop    %edi
+  popl %esi
+80104b24:	5e                   	pop    %esi
+  popl %ebx
+80104b25:	5b                   	pop    %ebx
+  popl %ebp
+80104b26:	5d                   	pop    %ebp
+  ret
+80104b27:	c3                   	ret    
+80104b28:	66 90                	xchg   %ax,%ax
+80104b2a:	66 90                	xchg   %ax,%ax
+80104b2c:	66 90                	xchg   %ax,%ax
+80104b2e:	66 90                	xchg   %ax,%ax
+
+80104b30 <fetchint>:
+// to a saved program counter, and then the first argument.
+
+// Fetch the int at addr from the current process.
+int
+fetchint(uint addr, int *ip)
+{
+80104b30:	f3 0f 1e fb          	endbr32 
+80104b34:	55                   	push   %ebp
+80104b35:	89 e5                	mov    %esp,%ebp
+80104b37:	53                   	push   %ebx
+80104b38:	83 ec 04             	sub    $0x4,%esp
+80104b3b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  struct proc *curproc = myproc();
+80104b3e:	e8 1d ee ff ff       	call   80103960 <myproc>
+
+  if(addr >= curproc->sz || addr+4 > curproc->sz)
+80104b43:	8b 00                	mov    (%eax),%eax
+80104b45:	39 d8                	cmp    %ebx,%eax
+80104b47:	76 17                	jbe    80104b60 <fetchint+0x30>
+80104b49:	8d 53 04             	lea    0x4(%ebx),%edx
+80104b4c:	39 d0                	cmp    %edx,%eax
+80104b4e:	72 10                	jb     80104b60 <fetchint+0x30>
+    return -1;
+  *ip = *(int*)(addr);
+80104b50:	8b 45 0c             	mov    0xc(%ebp),%eax
+80104b53:	8b 13                	mov    (%ebx),%edx
+80104b55:	89 10                	mov    %edx,(%eax)
+  return 0;
+80104b57:	31 c0                	xor    %eax,%eax
+}
+80104b59:	83 c4 04             	add    $0x4,%esp
+80104b5c:	5b                   	pop    %ebx
+80104b5d:	5d                   	pop    %ebp
+80104b5e:	c3                   	ret    
+80104b5f:	90                   	nop
+    return -1;
+80104b60:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80104b65:	eb f2                	jmp    80104b59 <fetchint+0x29>
+80104b67:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104b6e:	66 90                	xchg   %ax,%ax
+
+80104b70 <fetchstr>:
+// Fetch the nul-terminated string at addr from the current process.
+// Doesn't actually copy the string - just sets *pp to point at it.
+// Returns length of string, not including nul.
+int
+fetchstr(uint addr, char **pp)
+{
+80104b70:	f3 0f 1e fb          	endbr32 
+80104b74:	55                   	push   %ebp
+80104b75:	89 e5                	mov    %esp,%ebp
+80104b77:	53                   	push   %ebx
+80104b78:	83 ec 04             	sub    $0x4,%esp
+80104b7b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  char *s, *ep;
+  struct proc *curproc = myproc();
+80104b7e:	e8 dd ed ff ff       	call   80103960 <myproc>
+
+  if(addr >= curproc->sz)
+80104b83:	39 18                	cmp    %ebx,(%eax)
+80104b85:	76 31                	jbe    80104bb8 <fetchstr+0x48>
+    return -1;
+  *pp = (char*)addr;
+80104b87:	8b 55 0c             	mov    0xc(%ebp),%edx
+80104b8a:	89 1a                	mov    %ebx,(%edx)
+  ep = (char*)curproc->sz;
+80104b8c:	8b 10                	mov    (%eax),%edx
+  for(s = *pp; s < ep; s++){
+80104b8e:	39 d3                	cmp    %edx,%ebx
+80104b90:	73 26                	jae    80104bb8 <fetchstr+0x48>
+80104b92:	89 d8                	mov    %ebx,%eax
+80104b94:	eb 11                	jmp    80104ba7 <fetchstr+0x37>
+80104b96:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104b9d:	8d 76 00             	lea    0x0(%esi),%esi
+80104ba0:	83 c0 01             	add    $0x1,%eax
+80104ba3:	39 c2                	cmp    %eax,%edx
+80104ba5:	76 11                	jbe    80104bb8 <fetchstr+0x48>
+    if(*s == 0)
+80104ba7:	80 38 00             	cmpb   $0x0,(%eax)
+80104baa:	75 f4                	jne    80104ba0 <fetchstr+0x30>
+      return s - *pp;
+  }
+  return -1;
+}
+80104bac:	83 c4 04             	add    $0x4,%esp
+      return s - *pp;
+80104baf:	29 d8                	sub    %ebx,%eax
+}
+80104bb1:	5b                   	pop    %ebx
+80104bb2:	5d                   	pop    %ebp
+80104bb3:	c3                   	ret    
+80104bb4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80104bb8:	83 c4 04             	add    $0x4,%esp
+    return -1;
+80104bbb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80104bc0:	5b                   	pop    %ebx
+80104bc1:	5d                   	pop    %ebp
+80104bc2:	c3                   	ret    
+80104bc3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104bca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80104bd0 <argint>:
+
+// Fetch the nth 32-bit system call argument.
+int
+argint(int n, int *ip)
+{
+80104bd0:	f3 0f 1e fb          	endbr32 
+80104bd4:	55                   	push   %ebp
+80104bd5:	89 e5                	mov    %esp,%ebp
+80104bd7:	56                   	push   %esi
+80104bd8:	53                   	push   %ebx
+  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
+80104bd9:	e8 82 ed ff ff       	call   80103960 <myproc>
+80104bde:	8b 55 08             	mov    0x8(%ebp),%edx
+80104be1:	8b 40 18             	mov    0x18(%eax),%eax
+80104be4:	8b 40 44             	mov    0x44(%eax),%eax
+80104be7:	8d 1c 90             	lea    (%eax,%edx,4),%ebx
+  struct proc *curproc = myproc();
+80104bea:	e8 71 ed ff ff       	call   80103960 <myproc>
+  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
+80104bef:	8d 73 04             	lea    0x4(%ebx),%esi
+  if(addr >= curproc->sz || addr+4 > curproc->sz)
+80104bf2:	8b 00                	mov    (%eax),%eax
+80104bf4:	39 c6                	cmp    %eax,%esi
+80104bf6:	73 18                	jae    80104c10 <argint+0x40>
+80104bf8:	8d 53 08             	lea    0x8(%ebx),%edx
+80104bfb:	39 d0                	cmp    %edx,%eax
+80104bfd:	72 11                	jb     80104c10 <argint+0x40>
+  *ip = *(int*)(addr);
+80104bff:	8b 45 0c             	mov    0xc(%ebp),%eax
+80104c02:	8b 53 04             	mov    0x4(%ebx),%edx
+80104c05:	89 10                	mov    %edx,(%eax)
+  return 0;
+80104c07:	31 c0                	xor    %eax,%eax
+}
+80104c09:	5b                   	pop    %ebx
+80104c0a:	5e                   	pop    %esi
+80104c0b:	5d                   	pop    %ebp
+80104c0c:	c3                   	ret    
+80104c0d:	8d 76 00             	lea    0x0(%esi),%esi
+    return -1;
+80104c10:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
+80104c15:	eb f2                	jmp    80104c09 <argint+0x39>
+80104c17:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104c1e:	66 90                	xchg   %ax,%ax
+
+80104c20 <argptr>:
+// Fetch the nth word-sized system call argument as a pointer
+// to a block of memory of size bytes.  Check that the pointer
+// lies within the process address space.
+int
+argptr(int n, char **pp, int size)
+{
+80104c20:	f3 0f 1e fb          	endbr32 
+80104c24:	55                   	push   %ebp
+80104c25:	89 e5                	mov    %esp,%ebp
+80104c27:	56                   	push   %esi
+80104c28:	53                   	push   %ebx
+80104c29:	83 ec 10             	sub    $0x10,%esp
+80104c2c:	8b 5d 10             	mov    0x10(%ebp),%ebx
+  int i;
+  struct proc *curproc = myproc();
+80104c2f:	e8 2c ed ff ff       	call   80103960 <myproc>
+ 
+  if(argint(n, &i) < 0)
+80104c34:	83 ec 08             	sub    $0x8,%esp
+  struct proc *curproc = myproc();
+80104c37:	89 c6                	mov    %eax,%esi
+  if(argint(n, &i) < 0)
+80104c39:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80104c3c:	50                   	push   %eax
+80104c3d:	ff 75 08             	pushl  0x8(%ebp)
+80104c40:	e8 8b ff ff ff       	call   80104bd0 <argint>
+    return -1;
+  if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
+80104c45:	83 c4 10             	add    $0x10,%esp
+80104c48:	85 c0                	test   %eax,%eax
+80104c4a:	78 24                	js     80104c70 <argptr+0x50>
+80104c4c:	85 db                	test   %ebx,%ebx
+80104c4e:	78 20                	js     80104c70 <argptr+0x50>
+80104c50:	8b 16                	mov    (%esi),%edx
+80104c52:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104c55:	39 c2                	cmp    %eax,%edx
+80104c57:	76 17                	jbe    80104c70 <argptr+0x50>
+80104c59:	01 c3                	add    %eax,%ebx
+80104c5b:	39 da                	cmp    %ebx,%edx
+80104c5d:	72 11                	jb     80104c70 <argptr+0x50>
+    return -1;
+  *pp = (char*)i;
+80104c5f:	8b 55 0c             	mov    0xc(%ebp),%edx
+80104c62:	89 02                	mov    %eax,(%edx)
+  return 0;
+80104c64:	31 c0                	xor    %eax,%eax
+}
+80104c66:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80104c69:	5b                   	pop    %ebx
+80104c6a:	5e                   	pop    %esi
+80104c6b:	5d                   	pop    %ebp
+80104c6c:	c3                   	ret    
+80104c6d:	8d 76 00             	lea    0x0(%esi),%esi
+    return -1;
+80104c70:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80104c75:	eb ef                	jmp    80104c66 <argptr+0x46>
+80104c77:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104c7e:	66 90                	xchg   %ax,%ax
+
+80104c80 <argstr>:
+// Check that the pointer is valid and the string is nul-terminated.
+// (There is no shared writable memory, so the string can't change
+// between this check and being used by the kernel.)
+int
+argstr(int n, char **pp)
+{
+80104c80:	f3 0f 1e fb          	endbr32 
+80104c84:	55                   	push   %ebp
+80104c85:	89 e5                	mov    %esp,%ebp
+80104c87:	83 ec 20             	sub    $0x20,%esp
+  int addr;
+  if(argint(n, &addr) < 0)
+80104c8a:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80104c8d:	50                   	push   %eax
+80104c8e:	ff 75 08             	pushl  0x8(%ebp)
+80104c91:	e8 3a ff ff ff       	call   80104bd0 <argint>
+80104c96:	83 c4 10             	add    $0x10,%esp
+80104c99:	85 c0                	test   %eax,%eax
+80104c9b:	78 13                	js     80104cb0 <argstr+0x30>
+    return -1;
+  return fetchstr(addr, pp);
+80104c9d:	83 ec 08             	sub    $0x8,%esp
+80104ca0:	ff 75 0c             	pushl  0xc(%ebp)
+80104ca3:	ff 75 f4             	pushl  -0xc(%ebp)
+80104ca6:	e8 c5 fe ff ff       	call   80104b70 <fetchstr>
+80104cab:	83 c4 10             	add    $0x10,%esp
+}
+80104cae:	c9                   	leave  
+80104caf:	c3                   	ret    
+80104cb0:	c9                   	leave  
+    return -1;
+80104cb1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80104cb6:	c3                   	ret    
+80104cb7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104cbe:	66 90                	xchg   %ax,%ax
+
+80104cc0 <syscall>:
+[SYS_thread_exit]   sys_thread_exit,
+};
+
+void
+syscall(void)
+{
+80104cc0:	f3 0f 1e fb          	endbr32 
+80104cc4:	55                   	push   %ebp
+80104cc5:	89 e5                	mov    %esp,%ebp
+80104cc7:	53                   	push   %ebx
+80104cc8:	83 ec 04             	sub    $0x4,%esp
+  int num;
+  struct proc *curproc = myproc();
+80104ccb:	e8 90 ec ff ff       	call   80103960 <myproc>
+80104cd0:	89 c3                	mov    %eax,%ebx
+
+  num = curproc->tf->eax;
+80104cd2:	8b 40 18             	mov    0x18(%eax),%eax
+80104cd5:	8b 40 1c             	mov    0x1c(%eax),%eax
+  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+80104cd8:	8d 50 ff             	lea    -0x1(%eax),%edx
+80104cdb:	83 fa 18             	cmp    $0x18,%edx
+80104cde:	77 20                	ja     80104d00 <syscall+0x40>
+80104ce0:	8b 14 85 80 7b 10 80 	mov    -0x7fef8480(,%eax,4),%edx
+80104ce7:	85 d2                	test   %edx,%edx
+80104ce9:	74 15                	je     80104d00 <syscall+0x40>
+    curproc->tf->eax = syscalls[num]();
+80104ceb:	ff d2                	call   *%edx
+80104ced:	89 c2                	mov    %eax,%edx
+80104cef:	8b 43 18             	mov    0x18(%ebx),%eax
+80104cf2:	89 50 1c             	mov    %edx,0x1c(%eax)
+  } else {
+    cprintf("%d %s: unknown sys call %d\n",
+            curproc->pid, curproc->name, num);
+    curproc->tf->eax = -1;
+  }
+}
+80104cf5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80104cf8:	c9                   	leave  
+80104cf9:	c3                   	ret    
+80104cfa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    cprintf("%d %s: unknown sys call %d\n",
+80104d00:	50                   	push   %eax
+            curproc->pid, curproc->name, num);
+80104d01:	8d 43 6c             	lea    0x6c(%ebx),%eax
+    cprintf("%d %s: unknown sys call %d\n",
+80104d04:	50                   	push   %eax
+80104d05:	ff 73 10             	pushl  0x10(%ebx)
+80104d08:	68 5d 7b 10 80       	push   $0x80107b5d
+80104d0d:	e8 9e b9 ff ff       	call   801006b0 <cprintf>
+    curproc->tf->eax = -1;
+80104d12:	8b 43 18             	mov    0x18(%ebx),%eax
+80104d15:	83 c4 10             	add    $0x10,%esp
+80104d18:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%eax)
+}
+80104d1f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80104d22:	c9                   	leave  
+80104d23:	c3                   	ret    
+80104d24:	66 90                	xchg   %ax,%ax
+80104d26:	66 90                	xchg   %ax,%ax
+80104d28:	66 90                	xchg   %ax,%ax
+80104d2a:	66 90                	xchg   %ax,%ax
+80104d2c:	66 90                	xchg   %ax,%ax
+80104d2e:	66 90                	xchg   %ax,%ax
+
+80104d30 <create>:
+  return -1;
+}
+
+static struct inode*
+create(char *path, short type, short major, short minor)
+{
+80104d30:	55                   	push   %ebp
+80104d31:	89 e5                	mov    %esp,%ebp
+80104d33:	57                   	push   %edi
+80104d34:	56                   	push   %esi
+  struct inode *ip, *dp;
+  char name[DIRSIZ];
+
+  if((dp = nameiparent(path, name)) == 0)
+80104d35:	8d 7d da             	lea    -0x26(%ebp),%edi
+{
+80104d38:	53                   	push   %ebx
+80104d39:	83 ec 34             	sub    $0x34,%esp
+80104d3c:	89 4d d0             	mov    %ecx,-0x30(%ebp)
+80104d3f:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  if((dp = nameiparent(path, name)) == 0)
+80104d42:	57                   	push   %edi
+80104d43:	50                   	push   %eax
+{
+80104d44:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+80104d47:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  if((dp = nameiparent(path, name)) == 0)
+80104d4a:	e8 01 d3 ff ff       	call   80102050 <nameiparent>
+80104d4f:	83 c4 10             	add    $0x10,%esp
+80104d52:	85 c0                	test   %eax,%eax
+80104d54:	0f 84 46 01 00 00    	je     80104ea0 <create+0x170>
+    return 0;
+  ilock(dp);
+80104d5a:	83 ec 0c             	sub    $0xc,%esp
+80104d5d:	89 c3                	mov    %eax,%ebx
+80104d5f:	50                   	push   %eax
+80104d60:	e8 fb c9 ff ff       	call   80101760 <ilock>
+
+  if((ip = dirlookup(dp, name, 0)) != 0){
+80104d65:	83 c4 0c             	add    $0xc,%esp
+80104d68:	6a 00                	push   $0x0
+80104d6a:	57                   	push   %edi
+80104d6b:	53                   	push   %ebx
+80104d6c:	e8 3f cf ff ff       	call   80101cb0 <dirlookup>
+80104d71:	83 c4 10             	add    $0x10,%esp
+80104d74:	89 c6                	mov    %eax,%esi
+80104d76:	85 c0                	test   %eax,%eax
+80104d78:	74 56                	je     80104dd0 <create+0xa0>
+    iunlockput(dp);
+80104d7a:	83 ec 0c             	sub    $0xc,%esp
+80104d7d:	53                   	push   %ebx
+80104d7e:	e8 7d cc ff ff       	call   80101a00 <iunlockput>
+    ilock(ip);
+80104d83:	89 34 24             	mov    %esi,(%esp)
+80104d86:	e8 d5 c9 ff ff       	call   80101760 <ilock>
+    if(type == T_FILE && ip->type == T_FILE)
+80104d8b:	83 c4 10             	add    $0x10,%esp
+80104d8e:	66 83 7d d4 02       	cmpw   $0x2,-0x2c(%ebp)
+80104d93:	75 1b                	jne    80104db0 <create+0x80>
+80104d95:	66 83 7e 50 02       	cmpw   $0x2,0x50(%esi)
+80104d9a:	75 14                	jne    80104db0 <create+0x80>
+    panic("create: dirlink");
+
+  iunlockput(dp);
+
+  return ip;
+}
+80104d9c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80104d9f:	89 f0                	mov    %esi,%eax
+80104da1:	5b                   	pop    %ebx
+80104da2:	5e                   	pop    %esi
+80104da3:	5f                   	pop    %edi
+80104da4:	5d                   	pop    %ebp
+80104da5:	c3                   	ret    
+80104da6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104dad:	8d 76 00             	lea    0x0(%esi),%esi
+    iunlockput(ip);
+80104db0:	83 ec 0c             	sub    $0xc,%esp
+80104db3:	56                   	push   %esi
+    return 0;
+80104db4:	31 f6                	xor    %esi,%esi
+    iunlockput(ip);
+80104db6:	e8 45 cc ff ff       	call   80101a00 <iunlockput>
+    return 0;
+80104dbb:	83 c4 10             	add    $0x10,%esp
+}
+80104dbe:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80104dc1:	89 f0                	mov    %esi,%eax
+80104dc3:	5b                   	pop    %ebx
+80104dc4:	5e                   	pop    %esi
+80104dc5:	5f                   	pop    %edi
+80104dc6:	5d                   	pop    %ebp
+80104dc7:	c3                   	ret    
+80104dc8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104dcf:	90                   	nop
+  if((ip = ialloc(dp->dev, type)) == 0)
+80104dd0:	0f bf 45 d4          	movswl -0x2c(%ebp),%eax
+80104dd4:	83 ec 08             	sub    $0x8,%esp
+80104dd7:	50                   	push   %eax
+80104dd8:	ff 33                	pushl  (%ebx)
+80104dda:	e8 01 c8 ff ff       	call   801015e0 <ialloc>
+80104ddf:	83 c4 10             	add    $0x10,%esp
+80104de2:	89 c6                	mov    %eax,%esi
+80104de4:	85 c0                	test   %eax,%eax
+80104de6:	0f 84 cd 00 00 00    	je     80104eb9 <create+0x189>
+  ilock(ip);
+80104dec:	83 ec 0c             	sub    $0xc,%esp
+80104def:	50                   	push   %eax
+80104df0:	e8 6b c9 ff ff       	call   80101760 <ilock>
+  ip->major = major;
+80104df5:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
+80104df9:	66 89 46 52          	mov    %ax,0x52(%esi)
+  ip->minor = minor;
+80104dfd:	0f b7 45 cc          	movzwl -0x34(%ebp),%eax
+80104e01:	66 89 46 54          	mov    %ax,0x54(%esi)
+  ip->nlink = 1;
+80104e05:	b8 01 00 00 00       	mov    $0x1,%eax
+80104e0a:	66 89 46 56          	mov    %ax,0x56(%esi)
+  iupdate(ip);
+80104e0e:	89 34 24             	mov    %esi,(%esp)
+80104e11:	e8 8a c8 ff ff       	call   801016a0 <iupdate>
+  if(type == T_DIR){  // Create . and .. entries.
+80104e16:	83 c4 10             	add    $0x10,%esp
+80104e19:	66 83 7d d4 01       	cmpw   $0x1,-0x2c(%ebp)
+80104e1e:	74 30                	je     80104e50 <create+0x120>
+  if(dirlink(dp, name, ip->inum) < 0)
+80104e20:	83 ec 04             	sub    $0x4,%esp
+80104e23:	ff 76 04             	pushl  0x4(%esi)
+80104e26:	57                   	push   %edi
+80104e27:	53                   	push   %ebx
+80104e28:	e8 43 d1 ff ff       	call   80101f70 <dirlink>
+80104e2d:	83 c4 10             	add    $0x10,%esp
+80104e30:	85 c0                	test   %eax,%eax
+80104e32:	78 78                	js     80104eac <create+0x17c>
+  iunlockput(dp);
+80104e34:	83 ec 0c             	sub    $0xc,%esp
+80104e37:	53                   	push   %ebx
+80104e38:	e8 c3 cb ff ff       	call   80101a00 <iunlockput>
+  return ip;
+80104e3d:	83 c4 10             	add    $0x10,%esp
+}
+80104e40:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80104e43:	89 f0                	mov    %esi,%eax
+80104e45:	5b                   	pop    %ebx
+80104e46:	5e                   	pop    %esi
+80104e47:	5f                   	pop    %edi
+80104e48:	5d                   	pop    %ebp
+80104e49:	c3                   	ret    
+80104e4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    iupdate(dp);
+80104e50:	83 ec 0c             	sub    $0xc,%esp
+    dp->nlink++;  // for ".."
+80104e53:	66 83 43 56 01       	addw   $0x1,0x56(%ebx)
+    iupdate(dp);
+80104e58:	53                   	push   %ebx
+80104e59:	e8 42 c8 ff ff       	call   801016a0 <iupdate>
+    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+80104e5e:	83 c4 0c             	add    $0xc,%esp
+80104e61:	ff 76 04             	pushl  0x4(%esi)
+80104e64:	68 04 7c 10 80       	push   $0x80107c04
+80104e69:	56                   	push   %esi
+80104e6a:	e8 01 d1 ff ff       	call   80101f70 <dirlink>
+80104e6f:	83 c4 10             	add    $0x10,%esp
+80104e72:	85 c0                	test   %eax,%eax
+80104e74:	78 18                	js     80104e8e <create+0x15e>
+80104e76:	83 ec 04             	sub    $0x4,%esp
+80104e79:	ff 73 04             	pushl  0x4(%ebx)
+80104e7c:	68 03 7c 10 80       	push   $0x80107c03
+80104e81:	56                   	push   %esi
+80104e82:	e8 e9 d0 ff ff       	call   80101f70 <dirlink>
+80104e87:	83 c4 10             	add    $0x10,%esp
+80104e8a:	85 c0                	test   %eax,%eax
+80104e8c:	79 92                	jns    80104e20 <create+0xf0>
+      panic("create dots");
+80104e8e:	83 ec 0c             	sub    $0xc,%esp
+80104e91:	68 f7 7b 10 80       	push   $0x80107bf7
+80104e96:	e8 f5 b4 ff ff       	call   80100390 <panic>
+80104e9b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80104e9f:	90                   	nop
+}
+80104ea0:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    return 0;
+80104ea3:	31 f6                	xor    %esi,%esi
+}
+80104ea5:	5b                   	pop    %ebx
+80104ea6:	89 f0                	mov    %esi,%eax
+80104ea8:	5e                   	pop    %esi
+80104ea9:	5f                   	pop    %edi
+80104eaa:	5d                   	pop    %ebp
+80104eab:	c3                   	ret    
+    panic("create: dirlink");
+80104eac:	83 ec 0c             	sub    $0xc,%esp
+80104eaf:	68 06 7c 10 80       	push   $0x80107c06
+80104eb4:	e8 d7 b4 ff ff       	call   80100390 <panic>
+    panic("create: ialloc");
+80104eb9:	83 ec 0c             	sub    $0xc,%esp
+80104ebc:	68 e8 7b 10 80       	push   $0x80107be8
+80104ec1:	e8 ca b4 ff ff       	call   80100390 <panic>
+80104ec6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104ecd:	8d 76 00             	lea    0x0(%esi),%esi
+
+80104ed0 <argfd.constprop.0>:
+argfd(int n, int *pfd, struct file **pf)
+80104ed0:	55                   	push   %ebp
+80104ed1:	89 e5                	mov    %esp,%ebp
+80104ed3:	56                   	push   %esi
+80104ed4:	89 d6                	mov    %edx,%esi
+80104ed6:	53                   	push   %ebx
+80104ed7:	89 c3                	mov    %eax,%ebx
+  if(argint(n, &fd) < 0)
+80104ed9:	8d 45 f4             	lea    -0xc(%ebp),%eax
+argfd(int n, int *pfd, struct file **pf)
+80104edc:	83 ec 18             	sub    $0x18,%esp
+  if(argint(n, &fd) < 0)
+80104edf:	50                   	push   %eax
+80104ee0:	6a 00                	push   $0x0
+80104ee2:	e8 e9 fc ff ff       	call   80104bd0 <argint>
+80104ee7:	83 c4 10             	add    $0x10,%esp
+80104eea:	85 c0                	test   %eax,%eax
+80104eec:	78 2a                	js     80104f18 <argfd.constprop.0+0x48>
+  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+80104eee:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
+80104ef2:	77 24                	ja     80104f18 <argfd.constprop.0+0x48>
+80104ef4:	e8 67 ea ff ff       	call   80103960 <myproc>
+80104ef9:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80104efc:	8b 44 90 28          	mov    0x28(%eax,%edx,4),%eax
+80104f00:	85 c0                	test   %eax,%eax
+80104f02:	74 14                	je     80104f18 <argfd.constprop.0+0x48>
+  if(pfd)
+80104f04:	85 db                	test   %ebx,%ebx
+80104f06:	74 02                	je     80104f0a <argfd.constprop.0+0x3a>
+    *pfd = fd;
+80104f08:	89 13                	mov    %edx,(%ebx)
+    *pf = f;
+80104f0a:	89 06                	mov    %eax,(%esi)
+  return 0;
+80104f0c:	31 c0                	xor    %eax,%eax
+}
+80104f0e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80104f11:	5b                   	pop    %ebx
+80104f12:	5e                   	pop    %esi
+80104f13:	5d                   	pop    %ebp
+80104f14:	c3                   	ret    
+80104f15:	8d 76 00             	lea    0x0(%esi),%esi
+    return -1;
+80104f18:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80104f1d:	eb ef                	jmp    80104f0e <argfd.constprop.0+0x3e>
+80104f1f:	90                   	nop
+
+80104f20 <sys_dup>:
+{
+80104f20:	f3 0f 1e fb          	endbr32 
+80104f24:	55                   	push   %ebp
+  if(argfd(0, 0, &f) < 0)
+80104f25:	31 c0                	xor    %eax,%eax
+{
+80104f27:	89 e5                	mov    %esp,%ebp
+80104f29:	56                   	push   %esi
+80104f2a:	53                   	push   %ebx
+  if(argfd(0, 0, &f) < 0)
+80104f2b:	8d 55 f4             	lea    -0xc(%ebp),%edx
+{
+80104f2e:	83 ec 10             	sub    $0x10,%esp
+  if(argfd(0, 0, &f) < 0)
+80104f31:	e8 9a ff ff ff       	call   80104ed0 <argfd.constprop.0>
+80104f36:	85 c0                	test   %eax,%eax
+80104f38:	78 1e                	js     80104f58 <sys_dup+0x38>
+  if((fd=fdalloc(f)) < 0)
+80104f3a:	8b 75 f4             	mov    -0xc(%ebp),%esi
+  for(fd = 0; fd < NOFILE; fd++){
+80104f3d:	31 db                	xor    %ebx,%ebx
+  struct proc *curproc = myproc();
+80104f3f:	e8 1c ea ff ff       	call   80103960 <myproc>
+  for(fd = 0; fd < NOFILE; fd++){
+80104f44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    if(curproc->ofile[fd] == 0){
+80104f48:	8b 54 98 28          	mov    0x28(%eax,%ebx,4),%edx
+80104f4c:	85 d2                	test   %edx,%edx
+80104f4e:	74 20                	je     80104f70 <sys_dup+0x50>
+  for(fd = 0; fd < NOFILE; fd++){
+80104f50:	83 c3 01             	add    $0x1,%ebx
+80104f53:	83 fb 10             	cmp    $0x10,%ebx
+80104f56:	75 f0                	jne    80104f48 <sys_dup+0x28>
+}
+80104f58:	8d 65 f8             	lea    -0x8(%ebp),%esp
+    return -1;
+80104f5b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
+}
+80104f60:	89 d8                	mov    %ebx,%eax
+80104f62:	5b                   	pop    %ebx
+80104f63:	5e                   	pop    %esi
+80104f64:	5d                   	pop    %ebp
+80104f65:	c3                   	ret    
+80104f66:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104f6d:	8d 76 00             	lea    0x0(%esi),%esi
+      curproc->ofile[fd] = f;
+80104f70:	89 74 98 28          	mov    %esi,0x28(%eax,%ebx,4)
+  filedup(f);
+80104f74:	83 ec 0c             	sub    $0xc,%esp
+80104f77:	ff 75 f4             	pushl  -0xc(%ebp)
+80104f7a:	e8 f1 be ff ff       	call   80100e70 <filedup>
+  return fd;
+80104f7f:	83 c4 10             	add    $0x10,%esp
+}
+80104f82:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80104f85:	89 d8                	mov    %ebx,%eax
+80104f87:	5b                   	pop    %ebx
+80104f88:	5e                   	pop    %esi
+80104f89:	5d                   	pop    %ebp
+80104f8a:	c3                   	ret    
+80104f8b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80104f8f:	90                   	nop
+
+80104f90 <sys_read>:
+{
+80104f90:	f3 0f 1e fb          	endbr32 
+80104f94:	55                   	push   %ebp
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+80104f95:	31 c0                	xor    %eax,%eax
+{
+80104f97:	89 e5                	mov    %esp,%ebp
+80104f99:	83 ec 18             	sub    $0x18,%esp
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+80104f9c:	8d 55 ec             	lea    -0x14(%ebp),%edx
+80104f9f:	e8 2c ff ff ff       	call   80104ed0 <argfd.constprop.0>
+80104fa4:	85 c0                	test   %eax,%eax
+80104fa6:	78 48                	js     80104ff0 <sys_read+0x60>
+80104fa8:	83 ec 08             	sub    $0x8,%esp
+80104fab:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80104fae:	50                   	push   %eax
+80104faf:	6a 02                	push   $0x2
+80104fb1:	e8 1a fc ff ff       	call   80104bd0 <argint>
+80104fb6:	83 c4 10             	add    $0x10,%esp
+80104fb9:	85 c0                	test   %eax,%eax
+80104fbb:	78 33                	js     80104ff0 <sys_read+0x60>
+80104fbd:	83 ec 04             	sub    $0x4,%esp
+80104fc0:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80104fc3:	ff 75 f0             	pushl  -0x10(%ebp)
+80104fc6:	50                   	push   %eax
+80104fc7:	6a 01                	push   $0x1
+80104fc9:	e8 52 fc ff ff       	call   80104c20 <argptr>
+80104fce:	83 c4 10             	add    $0x10,%esp
+80104fd1:	85 c0                	test   %eax,%eax
+80104fd3:	78 1b                	js     80104ff0 <sys_read+0x60>
+  return fileread(f, p, n);
+80104fd5:	83 ec 04             	sub    $0x4,%esp
+80104fd8:	ff 75 f0             	pushl  -0x10(%ebp)
+80104fdb:	ff 75 f4             	pushl  -0xc(%ebp)
+80104fde:	ff 75 ec             	pushl  -0x14(%ebp)
+80104fe1:	e8 0a c0 ff ff       	call   80100ff0 <fileread>
+80104fe6:	83 c4 10             	add    $0x10,%esp
+}
+80104fe9:	c9                   	leave  
+80104fea:	c3                   	ret    
+80104feb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80104fef:	90                   	nop
+80104ff0:	c9                   	leave  
+    return -1;
+80104ff1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80104ff6:	c3                   	ret    
+80104ff7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80104ffe:	66 90                	xchg   %ax,%ax
+
+80105000 <sys_write>:
+{
+80105000:	f3 0f 1e fb          	endbr32 
+80105004:	55                   	push   %ebp
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+80105005:	31 c0                	xor    %eax,%eax
+{
+80105007:	89 e5                	mov    %esp,%ebp
+80105009:	83 ec 18             	sub    $0x18,%esp
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+8010500c:	8d 55 ec             	lea    -0x14(%ebp),%edx
+8010500f:	e8 bc fe ff ff       	call   80104ed0 <argfd.constprop.0>
+80105014:	85 c0                	test   %eax,%eax
+80105016:	78 48                	js     80105060 <sys_write+0x60>
+80105018:	83 ec 08             	sub    $0x8,%esp
+8010501b:	8d 45 f0             	lea    -0x10(%ebp),%eax
+8010501e:	50                   	push   %eax
+8010501f:	6a 02                	push   $0x2
+80105021:	e8 aa fb ff ff       	call   80104bd0 <argint>
+80105026:	83 c4 10             	add    $0x10,%esp
+80105029:	85 c0                	test   %eax,%eax
+8010502b:	78 33                	js     80105060 <sys_write+0x60>
+8010502d:	83 ec 04             	sub    $0x4,%esp
+80105030:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80105033:	ff 75 f0             	pushl  -0x10(%ebp)
+80105036:	50                   	push   %eax
+80105037:	6a 01                	push   $0x1
+80105039:	e8 e2 fb ff ff       	call   80104c20 <argptr>
+8010503e:	83 c4 10             	add    $0x10,%esp
+80105041:	85 c0                	test   %eax,%eax
+80105043:	78 1b                	js     80105060 <sys_write+0x60>
+  return filewrite(f, p, n);
+80105045:	83 ec 04             	sub    $0x4,%esp
+80105048:	ff 75 f0             	pushl  -0x10(%ebp)
+8010504b:	ff 75 f4             	pushl  -0xc(%ebp)
+8010504e:	ff 75 ec             	pushl  -0x14(%ebp)
+80105051:	e8 3a c0 ff ff       	call   80101090 <filewrite>
+80105056:	83 c4 10             	add    $0x10,%esp
+}
+80105059:	c9                   	leave  
+8010505a:	c3                   	ret    
+8010505b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010505f:	90                   	nop
+80105060:	c9                   	leave  
+    return -1;
+80105061:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80105066:	c3                   	ret    
+80105067:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010506e:	66 90                	xchg   %ax,%ax
+
+80105070 <sys_close>:
+{
+80105070:	f3 0f 1e fb          	endbr32 
+80105074:	55                   	push   %ebp
+80105075:	89 e5                	mov    %esp,%ebp
+80105077:	83 ec 18             	sub    $0x18,%esp
+  if(argfd(0, &fd, &f) < 0)
+8010507a:	8d 55 f4             	lea    -0xc(%ebp),%edx
+8010507d:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80105080:	e8 4b fe ff ff       	call   80104ed0 <argfd.constprop.0>
+80105085:	85 c0                	test   %eax,%eax
+80105087:	78 27                	js     801050b0 <sys_close+0x40>
+  myproc()->ofile[fd] = 0;
+80105089:	e8 d2 e8 ff ff       	call   80103960 <myproc>
+8010508e:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  fileclose(f);
+80105091:	83 ec 0c             	sub    $0xc,%esp
+  myproc()->ofile[fd] = 0;
+80105094:	c7 44 90 28 00 00 00 	movl   $0x0,0x28(%eax,%edx,4)
+8010509b:	00 
+  fileclose(f);
+8010509c:	ff 75 f4             	pushl  -0xc(%ebp)
+8010509f:	e8 1c be ff ff       	call   80100ec0 <fileclose>
+  return 0;
+801050a4:	83 c4 10             	add    $0x10,%esp
+801050a7:	31 c0                	xor    %eax,%eax
+}
+801050a9:	c9                   	leave  
+801050aa:	c3                   	ret    
+801050ab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801050af:	90                   	nop
+801050b0:	c9                   	leave  
+    return -1;
+801050b1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+801050b6:	c3                   	ret    
+801050b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801050be:	66 90                	xchg   %ax,%ax
+
+801050c0 <sys_fstat>:
+{
+801050c0:	f3 0f 1e fb          	endbr32 
+801050c4:	55                   	push   %ebp
+  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
+801050c5:	31 c0                	xor    %eax,%eax
+{
+801050c7:	89 e5                	mov    %esp,%ebp
+801050c9:	83 ec 18             	sub    $0x18,%esp
+  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
+801050cc:	8d 55 f0             	lea    -0x10(%ebp),%edx
+801050cf:	e8 fc fd ff ff       	call   80104ed0 <argfd.constprop.0>
+801050d4:	85 c0                	test   %eax,%eax
+801050d6:	78 30                	js     80105108 <sys_fstat+0x48>
+801050d8:	83 ec 04             	sub    $0x4,%esp
+801050db:	8d 45 f4             	lea    -0xc(%ebp),%eax
+801050de:	6a 14                	push   $0x14
+801050e0:	50                   	push   %eax
+801050e1:	6a 01                	push   $0x1
+801050e3:	e8 38 fb ff ff       	call   80104c20 <argptr>
+801050e8:	83 c4 10             	add    $0x10,%esp
+801050eb:	85 c0                	test   %eax,%eax
+801050ed:	78 19                	js     80105108 <sys_fstat+0x48>
+  return filestat(f, st);
+801050ef:	83 ec 08             	sub    $0x8,%esp
+801050f2:	ff 75 f4             	pushl  -0xc(%ebp)
+801050f5:	ff 75 f0             	pushl  -0x10(%ebp)
+801050f8:	e8 a3 be ff ff       	call   80100fa0 <filestat>
+801050fd:	83 c4 10             	add    $0x10,%esp
+}
+80105100:	c9                   	leave  
+80105101:	c3                   	ret    
+80105102:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+80105108:	c9                   	leave  
+    return -1;
+80105109:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+8010510e:	c3                   	ret    
+8010510f:	90                   	nop
+
+80105110 <sys_link>:
+{
+80105110:	f3 0f 1e fb          	endbr32 
+80105114:	55                   	push   %ebp
+80105115:	89 e5                	mov    %esp,%ebp
+80105117:	57                   	push   %edi
+80105118:	56                   	push   %esi
+  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
+80105119:	8d 45 d4             	lea    -0x2c(%ebp),%eax
+{
+8010511c:	53                   	push   %ebx
+8010511d:	83 ec 34             	sub    $0x34,%esp
+  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
+80105120:	50                   	push   %eax
+80105121:	6a 00                	push   $0x0
+80105123:	e8 58 fb ff ff       	call   80104c80 <argstr>
+80105128:	83 c4 10             	add    $0x10,%esp
+8010512b:	85 c0                	test   %eax,%eax
+8010512d:	0f 88 ff 00 00 00    	js     80105232 <sys_link+0x122>
+80105133:	83 ec 08             	sub    $0x8,%esp
+80105136:	8d 45 d0             	lea    -0x30(%ebp),%eax
+80105139:	50                   	push   %eax
+8010513a:	6a 01                	push   $0x1
+8010513c:	e8 3f fb ff ff       	call   80104c80 <argstr>
+80105141:	83 c4 10             	add    $0x10,%esp
+80105144:	85 c0                	test   %eax,%eax
+80105146:	0f 88 e6 00 00 00    	js     80105232 <sys_link+0x122>
+  begin_op();
+8010514c:	e8 df db ff ff       	call   80102d30 <begin_op>
+  if((ip = namei(old)) == 0){
+80105151:	83 ec 0c             	sub    $0xc,%esp
+80105154:	ff 75 d4             	pushl  -0x2c(%ebp)
+80105157:	e8 d4 ce ff ff       	call   80102030 <namei>
+8010515c:	83 c4 10             	add    $0x10,%esp
+8010515f:	89 c3                	mov    %eax,%ebx
+80105161:	85 c0                	test   %eax,%eax
+80105163:	0f 84 e8 00 00 00    	je     80105251 <sys_link+0x141>
+  ilock(ip);
+80105169:	83 ec 0c             	sub    $0xc,%esp
+8010516c:	50                   	push   %eax
+8010516d:	e8 ee c5 ff ff       	call   80101760 <ilock>
+  if(ip->type == T_DIR){
+80105172:	83 c4 10             	add    $0x10,%esp
+80105175:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
+8010517a:	0f 84 b9 00 00 00    	je     80105239 <sys_link+0x129>
+  iupdate(ip);
+80105180:	83 ec 0c             	sub    $0xc,%esp
+  ip->nlink++;
+80105183:	66 83 43 56 01       	addw   $0x1,0x56(%ebx)
+  if((dp = nameiparent(new, name)) == 0)
+80105188:	8d 7d da             	lea    -0x26(%ebp),%edi
+  iupdate(ip);
+8010518b:	53                   	push   %ebx
+8010518c:	e8 0f c5 ff ff       	call   801016a0 <iupdate>
+  iunlock(ip);
+80105191:	89 1c 24             	mov    %ebx,(%esp)
+80105194:	e8 a7 c6 ff ff       	call   80101840 <iunlock>
+  if((dp = nameiparent(new, name)) == 0)
+80105199:	58                   	pop    %eax
+8010519a:	5a                   	pop    %edx
+8010519b:	57                   	push   %edi
+8010519c:	ff 75 d0             	pushl  -0x30(%ebp)
+8010519f:	e8 ac ce ff ff       	call   80102050 <nameiparent>
+801051a4:	83 c4 10             	add    $0x10,%esp
+801051a7:	89 c6                	mov    %eax,%esi
+801051a9:	85 c0                	test   %eax,%eax
+801051ab:	74 5f                	je     8010520c <sys_link+0xfc>
+  ilock(dp);
+801051ad:	83 ec 0c             	sub    $0xc,%esp
+801051b0:	50                   	push   %eax
+801051b1:	e8 aa c5 ff ff       	call   80101760 <ilock>
+  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+801051b6:	8b 03                	mov    (%ebx),%eax
+801051b8:	83 c4 10             	add    $0x10,%esp
+801051bb:	39 06                	cmp    %eax,(%esi)
+801051bd:	75 41                	jne    80105200 <sys_link+0xf0>
+801051bf:	83 ec 04             	sub    $0x4,%esp
+801051c2:	ff 73 04             	pushl  0x4(%ebx)
+801051c5:	57                   	push   %edi
+801051c6:	56                   	push   %esi
+801051c7:	e8 a4 cd ff ff       	call   80101f70 <dirlink>
+801051cc:	83 c4 10             	add    $0x10,%esp
+801051cf:	85 c0                	test   %eax,%eax
+801051d1:	78 2d                	js     80105200 <sys_link+0xf0>
+  iunlockput(dp);
+801051d3:	83 ec 0c             	sub    $0xc,%esp
+801051d6:	56                   	push   %esi
+801051d7:	e8 24 c8 ff ff       	call   80101a00 <iunlockput>
+  iput(ip);
+801051dc:	89 1c 24             	mov    %ebx,(%esp)
+801051df:	e8 ac c6 ff ff       	call   80101890 <iput>
+  end_op();
+801051e4:	e8 b7 db ff ff       	call   80102da0 <end_op>
+  return 0;
+801051e9:	83 c4 10             	add    $0x10,%esp
+801051ec:	31 c0                	xor    %eax,%eax
+}
+801051ee:	8d 65 f4             	lea    -0xc(%ebp),%esp
+801051f1:	5b                   	pop    %ebx
+801051f2:	5e                   	pop    %esi
+801051f3:	5f                   	pop    %edi
+801051f4:	5d                   	pop    %ebp
+801051f5:	c3                   	ret    
+801051f6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801051fd:	8d 76 00             	lea    0x0(%esi),%esi
+    iunlockput(dp);
+80105200:	83 ec 0c             	sub    $0xc,%esp
+80105203:	56                   	push   %esi
+80105204:	e8 f7 c7 ff ff       	call   80101a00 <iunlockput>
+    goto bad;
+80105209:	83 c4 10             	add    $0x10,%esp
+  ilock(ip);
+8010520c:	83 ec 0c             	sub    $0xc,%esp
+8010520f:	53                   	push   %ebx
+80105210:	e8 4b c5 ff ff       	call   80101760 <ilock>
+  ip->nlink--;
+80105215:	66 83 6b 56 01       	subw   $0x1,0x56(%ebx)
+  iupdate(ip);
+8010521a:	89 1c 24             	mov    %ebx,(%esp)
+8010521d:	e8 7e c4 ff ff       	call   801016a0 <iupdate>
+  iunlockput(ip);
+80105222:	89 1c 24             	mov    %ebx,(%esp)
+80105225:	e8 d6 c7 ff ff       	call   80101a00 <iunlockput>
+  end_op();
+8010522a:	e8 71 db ff ff       	call   80102da0 <end_op>
+  return -1;
+8010522f:	83 c4 10             	add    $0x10,%esp
+80105232:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105237:	eb b5                	jmp    801051ee <sys_link+0xde>
+    iunlockput(ip);
+80105239:	83 ec 0c             	sub    $0xc,%esp
+8010523c:	53                   	push   %ebx
+8010523d:	e8 be c7 ff ff       	call   80101a00 <iunlockput>
+    end_op();
+80105242:	e8 59 db ff ff       	call   80102da0 <end_op>
+    return -1;
+80105247:	83 c4 10             	add    $0x10,%esp
+8010524a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010524f:	eb 9d                	jmp    801051ee <sys_link+0xde>
+    end_op();
+80105251:	e8 4a db ff ff       	call   80102da0 <end_op>
+    return -1;
+80105256:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010525b:	eb 91                	jmp    801051ee <sys_link+0xde>
+8010525d:	8d 76 00             	lea    0x0(%esi),%esi
+
+80105260 <sys_unlink>:
+{
+80105260:	f3 0f 1e fb          	endbr32 
+80105264:	55                   	push   %ebp
+80105265:	89 e5                	mov    %esp,%ebp
+80105267:	57                   	push   %edi
+80105268:	56                   	push   %esi
+  if(argstr(0, &path) < 0)
+80105269:	8d 45 c0             	lea    -0x40(%ebp),%eax
+{
+8010526c:	53                   	push   %ebx
+8010526d:	83 ec 54             	sub    $0x54,%esp
+  if(argstr(0, &path) < 0)
+80105270:	50                   	push   %eax
+80105271:	6a 00                	push   $0x0
+80105273:	e8 08 fa ff ff       	call   80104c80 <argstr>
+80105278:	83 c4 10             	add    $0x10,%esp
+8010527b:	85 c0                	test   %eax,%eax
+8010527d:	0f 88 7d 01 00 00    	js     80105400 <sys_unlink+0x1a0>
+  begin_op();
+80105283:	e8 a8 da ff ff       	call   80102d30 <begin_op>
+  if((dp = nameiparent(path, name)) == 0){
+80105288:	8d 5d ca             	lea    -0x36(%ebp),%ebx
+8010528b:	83 ec 08             	sub    $0x8,%esp
+8010528e:	53                   	push   %ebx
+8010528f:	ff 75 c0             	pushl  -0x40(%ebp)
+80105292:	e8 b9 cd ff ff       	call   80102050 <nameiparent>
+80105297:	83 c4 10             	add    $0x10,%esp
+8010529a:	89 c6                	mov    %eax,%esi
+8010529c:	85 c0                	test   %eax,%eax
+8010529e:	0f 84 66 01 00 00    	je     8010540a <sys_unlink+0x1aa>
+  ilock(dp);
+801052a4:	83 ec 0c             	sub    $0xc,%esp
+801052a7:	50                   	push   %eax
+801052a8:	e8 b3 c4 ff ff       	call   80101760 <ilock>
+  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+801052ad:	58                   	pop    %eax
+801052ae:	5a                   	pop    %edx
+801052af:	68 04 7c 10 80       	push   $0x80107c04
+801052b4:	53                   	push   %ebx
+801052b5:	e8 d6 c9 ff ff       	call   80101c90 <namecmp>
+801052ba:	83 c4 10             	add    $0x10,%esp
+801052bd:	85 c0                	test   %eax,%eax
+801052bf:	0f 84 03 01 00 00    	je     801053c8 <sys_unlink+0x168>
+801052c5:	83 ec 08             	sub    $0x8,%esp
+801052c8:	68 03 7c 10 80       	push   $0x80107c03
+801052cd:	53                   	push   %ebx
+801052ce:	e8 bd c9 ff ff       	call   80101c90 <namecmp>
+801052d3:	83 c4 10             	add    $0x10,%esp
+801052d6:	85 c0                	test   %eax,%eax
+801052d8:	0f 84 ea 00 00 00    	je     801053c8 <sys_unlink+0x168>
+  if((ip = dirlookup(dp, name, &off)) == 0)
+801052de:	83 ec 04             	sub    $0x4,%esp
+801052e1:	8d 45 c4             	lea    -0x3c(%ebp),%eax
+801052e4:	50                   	push   %eax
+801052e5:	53                   	push   %ebx
+801052e6:	56                   	push   %esi
+801052e7:	e8 c4 c9 ff ff       	call   80101cb0 <dirlookup>
+801052ec:	83 c4 10             	add    $0x10,%esp
+801052ef:	89 c3                	mov    %eax,%ebx
+801052f1:	85 c0                	test   %eax,%eax
+801052f3:	0f 84 cf 00 00 00    	je     801053c8 <sys_unlink+0x168>
+  ilock(ip);
+801052f9:	83 ec 0c             	sub    $0xc,%esp
+801052fc:	50                   	push   %eax
+801052fd:	e8 5e c4 ff ff       	call   80101760 <ilock>
+  if(ip->nlink < 1)
+80105302:	83 c4 10             	add    $0x10,%esp
+80105305:	66 83 7b 56 00       	cmpw   $0x0,0x56(%ebx)
+8010530a:	0f 8e 23 01 00 00    	jle    80105433 <sys_unlink+0x1d3>
+  if(ip->type == T_DIR && !isdirempty(ip)){
+80105310:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
+80105315:	8d 7d d8             	lea    -0x28(%ebp),%edi
+80105318:	74 66                	je     80105380 <sys_unlink+0x120>
+  memset(&de, 0, sizeof(de));
+8010531a:	83 ec 04             	sub    $0x4,%esp
+8010531d:	6a 10                	push   $0x10
+8010531f:	6a 00                	push   $0x0
+80105321:	57                   	push   %edi
+80105322:	e8 c9 f5 ff ff       	call   801048f0 <memset>
+  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80105327:	6a 10                	push   $0x10
+80105329:	ff 75 c4             	pushl  -0x3c(%ebp)
+8010532c:	57                   	push   %edi
+8010532d:	56                   	push   %esi
+8010532e:	e8 2d c8 ff ff       	call   80101b60 <writei>
+80105333:	83 c4 20             	add    $0x20,%esp
+80105336:	83 f8 10             	cmp    $0x10,%eax
+80105339:	0f 85 e7 00 00 00    	jne    80105426 <sys_unlink+0x1c6>
+  if(ip->type == T_DIR){
+8010533f:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
+80105344:	0f 84 96 00 00 00    	je     801053e0 <sys_unlink+0x180>
+  iunlockput(dp);
+8010534a:	83 ec 0c             	sub    $0xc,%esp
+8010534d:	56                   	push   %esi
+8010534e:	e8 ad c6 ff ff       	call   80101a00 <iunlockput>
+  ip->nlink--;
+80105353:	66 83 6b 56 01       	subw   $0x1,0x56(%ebx)
+  iupdate(ip);
+80105358:	89 1c 24             	mov    %ebx,(%esp)
+8010535b:	e8 40 c3 ff ff       	call   801016a0 <iupdate>
+  iunlockput(ip);
+80105360:	89 1c 24             	mov    %ebx,(%esp)
+80105363:	e8 98 c6 ff ff       	call   80101a00 <iunlockput>
+  end_op();
+80105368:	e8 33 da ff ff       	call   80102da0 <end_op>
+  return 0;
+8010536d:	83 c4 10             	add    $0x10,%esp
+80105370:	31 c0                	xor    %eax,%eax
+}
+80105372:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80105375:	5b                   	pop    %ebx
+80105376:	5e                   	pop    %esi
+80105377:	5f                   	pop    %edi
+80105378:	5d                   	pop    %ebp
+80105379:	c3                   	ret    
+8010537a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+80105380:	83 7b 58 20          	cmpl   $0x20,0x58(%ebx)
+80105384:	76 94                	jbe    8010531a <sys_unlink+0xba>
+80105386:	ba 20 00 00 00       	mov    $0x20,%edx
+8010538b:	eb 0b                	jmp    80105398 <sys_unlink+0x138>
+8010538d:	8d 76 00             	lea    0x0(%esi),%esi
+80105390:	83 c2 10             	add    $0x10,%edx
+80105393:	39 53 58             	cmp    %edx,0x58(%ebx)
+80105396:	76 82                	jbe    8010531a <sys_unlink+0xba>
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80105398:	6a 10                	push   $0x10
+8010539a:	52                   	push   %edx
+8010539b:	57                   	push   %edi
+8010539c:	53                   	push   %ebx
+8010539d:	89 55 b4             	mov    %edx,-0x4c(%ebp)
+801053a0:	e8 bb c6 ff ff       	call   80101a60 <readi>
+801053a5:	83 c4 10             	add    $0x10,%esp
+801053a8:	8b 55 b4             	mov    -0x4c(%ebp),%edx
+801053ab:	83 f8 10             	cmp    $0x10,%eax
+801053ae:	75 69                	jne    80105419 <sys_unlink+0x1b9>
+    if(de.inum != 0)
+801053b0:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
+801053b5:	74 d9                	je     80105390 <sys_unlink+0x130>
+    iunlockput(ip);
+801053b7:	83 ec 0c             	sub    $0xc,%esp
+801053ba:	53                   	push   %ebx
+801053bb:	e8 40 c6 ff ff       	call   80101a00 <iunlockput>
+    goto bad;
+801053c0:	83 c4 10             	add    $0x10,%esp
+801053c3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801053c7:	90                   	nop
+  iunlockput(dp);
+801053c8:	83 ec 0c             	sub    $0xc,%esp
+801053cb:	56                   	push   %esi
+801053cc:	e8 2f c6 ff ff       	call   80101a00 <iunlockput>
+  end_op();
+801053d1:	e8 ca d9 ff ff       	call   80102da0 <end_op>
+  return -1;
+801053d6:	83 c4 10             	add    $0x10,%esp
+801053d9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801053de:	eb 92                	jmp    80105372 <sys_unlink+0x112>
+    iupdate(dp);
+801053e0:	83 ec 0c             	sub    $0xc,%esp
+    dp->nlink--;
+801053e3:	66 83 6e 56 01       	subw   $0x1,0x56(%esi)
+    iupdate(dp);
+801053e8:	56                   	push   %esi
+801053e9:	e8 b2 c2 ff ff       	call   801016a0 <iupdate>
+801053ee:	83 c4 10             	add    $0x10,%esp
+801053f1:	e9 54 ff ff ff       	jmp    8010534a <sys_unlink+0xea>
+801053f6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801053fd:	8d 76 00             	lea    0x0(%esi),%esi
+    return -1;
+80105400:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105405:	e9 68 ff ff ff       	jmp    80105372 <sys_unlink+0x112>
+    end_op();
+8010540a:	e8 91 d9 ff ff       	call   80102da0 <end_op>
+    return -1;
+8010540f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105414:	e9 59 ff ff ff       	jmp    80105372 <sys_unlink+0x112>
+      panic("isdirempty: readi");
+80105419:	83 ec 0c             	sub    $0xc,%esp
+8010541c:	68 28 7c 10 80       	push   $0x80107c28
+80105421:	e8 6a af ff ff       	call   80100390 <panic>
+    panic("unlink: writei");
+80105426:	83 ec 0c             	sub    $0xc,%esp
+80105429:	68 3a 7c 10 80       	push   $0x80107c3a
+8010542e:	e8 5d af ff ff       	call   80100390 <panic>
+    panic("unlink: nlink < 1");
+80105433:	83 ec 0c             	sub    $0xc,%esp
+80105436:	68 16 7c 10 80       	push   $0x80107c16
+8010543b:	e8 50 af ff ff       	call   80100390 <panic>
+
+80105440 <sys_open>:
+
+int
+sys_open(void)
+{
+80105440:	f3 0f 1e fb          	endbr32 
+80105444:	55                   	push   %ebp
+80105445:	89 e5                	mov    %esp,%ebp
+80105447:	57                   	push   %edi
+80105448:	56                   	push   %esi
+  char *path;
+  int fd, omode;
+  struct file *f;
+  struct inode *ip;
+
+  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
+80105449:	8d 45 e0             	lea    -0x20(%ebp),%eax
+{
+8010544c:	53                   	push   %ebx
+8010544d:	83 ec 24             	sub    $0x24,%esp
+  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
+80105450:	50                   	push   %eax
+80105451:	6a 00                	push   $0x0
+80105453:	e8 28 f8 ff ff       	call   80104c80 <argstr>
+80105458:	83 c4 10             	add    $0x10,%esp
+8010545b:	85 c0                	test   %eax,%eax
+8010545d:	0f 88 8a 00 00 00    	js     801054ed <sys_open+0xad>
+80105463:	83 ec 08             	sub    $0x8,%esp
+80105466:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+80105469:	50                   	push   %eax
+8010546a:	6a 01                	push   $0x1
+8010546c:	e8 5f f7 ff ff       	call   80104bd0 <argint>
+80105471:	83 c4 10             	add    $0x10,%esp
+80105474:	85 c0                	test   %eax,%eax
+80105476:	78 75                	js     801054ed <sys_open+0xad>
+    return -1;
+
+  begin_op();
+80105478:	e8 b3 d8 ff ff       	call   80102d30 <begin_op>
+
+  if(omode & O_CREATE){
+8010547d:	f6 45 e5 02          	testb  $0x2,-0x1b(%ebp)
+80105481:	75 75                	jne    801054f8 <sys_open+0xb8>
+    if(ip == 0){
+      end_op();
+      return -1;
+    }
+  } else {
+    if((ip = namei(path)) == 0){
+80105483:	83 ec 0c             	sub    $0xc,%esp
+80105486:	ff 75 e0             	pushl  -0x20(%ebp)
+80105489:	e8 a2 cb ff ff       	call   80102030 <namei>
+8010548e:	83 c4 10             	add    $0x10,%esp
+80105491:	89 c6                	mov    %eax,%esi
+80105493:	85 c0                	test   %eax,%eax
+80105495:	74 7e                	je     80105515 <sys_open+0xd5>
+      end_op();
+      return -1;
+    }
+    ilock(ip);
+80105497:	83 ec 0c             	sub    $0xc,%esp
+8010549a:	50                   	push   %eax
+8010549b:	e8 c0 c2 ff ff       	call   80101760 <ilock>
+    if(ip->type == T_DIR && omode != O_RDONLY){
+801054a0:	83 c4 10             	add    $0x10,%esp
+801054a3:	66 83 7e 50 01       	cmpw   $0x1,0x50(%esi)
+801054a8:	0f 84 c2 00 00 00    	je     80105570 <sys_open+0x130>
+      end_op();
+      return -1;
+    }
+  }
+
+  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
+801054ae:	e8 4d b9 ff ff       	call   80100e00 <filealloc>
+801054b3:	89 c7                	mov    %eax,%edi
+801054b5:	85 c0                	test   %eax,%eax
+801054b7:	74 23                	je     801054dc <sys_open+0x9c>
+  struct proc *curproc = myproc();
+801054b9:	e8 a2 e4 ff ff       	call   80103960 <myproc>
+  for(fd = 0; fd < NOFILE; fd++){
+801054be:	31 db                	xor    %ebx,%ebx
+    if(curproc->ofile[fd] == 0){
+801054c0:	8b 54 98 28          	mov    0x28(%eax,%ebx,4),%edx
+801054c4:	85 d2                	test   %edx,%edx
+801054c6:	74 60                	je     80105528 <sys_open+0xe8>
+  for(fd = 0; fd < NOFILE; fd++){
+801054c8:	83 c3 01             	add    $0x1,%ebx
+801054cb:	83 fb 10             	cmp    $0x10,%ebx
+801054ce:	75 f0                	jne    801054c0 <sys_open+0x80>
+    if(f)
+      fileclose(f);
+801054d0:	83 ec 0c             	sub    $0xc,%esp
+801054d3:	57                   	push   %edi
+801054d4:	e8 e7 b9 ff ff       	call   80100ec0 <fileclose>
+801054d9:	83 c4 10             	add    $0x10,%esp
+    iunlockput(ip);
+801054dc:	83 ec 0c             	sub    $0xc,%esp
+801054df:	56                   	push   %esi
+801054e0:	e8 1b c5 ff ff       	call   80101a00 <iunlockput>
+    end_op();
+801054e5:	e8 b6 d8 ff ff       	call   80102da0 <end_op>
+    return -1;
+801054ea:	83 c4 10             	add    $0x10,%esp
+801054ed:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
+801054f2:	eb 6d                	jmp    80105561 <sys_open+0x121>
+801054f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    ip = create(path, T_FILE, 0, 0);
+801054f8:	83 ec 0c             	sub    $0xc,%esp
+801054fb:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801054fe:	31 c9                	xor    %ecx,%ecx
+80105500:	ba 02 00 00 00       	mov    $0x2,%edx
+80105505:	6a 00                	push   $0x0
+80105507:	e8 24 f8 ff ff       	call   80104d30 <create>
+    if(ip == 0){
+8010550c:	83 c4 10             	add    $0x10,%esp
+    ip = create(path, T_FILE, 0, 0);
+8010550f:	89 c6                	mov    %eax,%esi
+    if(ip == 0){
+80105511:	85 c0                	test   %eax,%eax
+80105513:	75 99                	jne    801054ae <sys_open+0x6e>
+      end_op();
+80105515:	e8 86 d8 ff ff       	call   80102da0 <end_op>
+      return -1;
+8010551a:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
+8010551f:	eb 40                	jmp    80105561 <sys_open+0x121>
+80105521:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  }
+  iunlock(ip);
+80105528:	83 ec 0c             	sub    $0xc,%esp
+      curproc->ofile[fd] = f;
+8010552b:	89 7c 98 28          	mov    %edi,0x28(%eax,%ebx,4)
+  iunlock(ip);
+8010552f:	56                   	push   %esi
+80105530:	e8 0b c3 ff ff       	call   80101840 <iunlock>
+  end_op();
+80105535:	e8 66 d8 ff ff       	call   80102da0 <end_op>
+
+  f->type = FD_INODE;
+8010553a:	c7 07 02 00 00 00    	movl   $0x2,(%edi)
+  f->ip = ip;
+  f->off = 0;
+  f->readable = !(omode & O_WRONLY);
+80105540:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+80105543:	83 c4 10             	add    $0x10,%esp
+  f->ip = ip;
+80105546:	89 77 10             	mov    %esi,0x10(%edi)
+  f->readable = !(omode & O_WRONLY);
+80105549:	89 d0                	mov    %edx,%eax
+  f->off = 0;
+8010554b:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
+  f->readable = !(omode & O_WRONLY);
+80105552:	f7 d0                	not    %eax
+80105554:	83 e0 01             	and    $0x1,%eax
+  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+80105557:	83 e2 03             	and    $0x3,%edx
+  f->readable = !(omode & O_WRONLY);
+8010555a:	88 47 08             	mov    %al,0x8(%edi)
+  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+8010555d:	0f 95 47 09          	setne  0x9(%edi)
+  return fd;
+}
+80105561:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80105564:	89 d8                	mov    %ebx,%eax
+80105566:	5b                   	pop    %ebx
+80105567:	5e                   	pop    %esi
+80105568:	5f                   	pop    %edi
+80105569:	5d                   	pop    %ebp
+8010556a:	c3                   	ret    
+8010556b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010556f:	90                   	nop
+    if(ip->type == T_DIR && omode != O_RDONLY){
+80105570:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+80105573:	85 c9                	test   %ecx,%ecx
+80105575:	0f 84 33 ff ff ff    	je     801054ae <sys_open+0x6e>
+8010557b:	e9 5c ff ff ff       	jmp    801054dc <sys_open+0x9c>
+
+80105580 <sys_mkdir>:
+
+int
+sys_mkdir(void)
+{
+80105580:	f3 0f 1e fb          	endbr32 
+80105584:	55                   	push   %ebp
+80105585:	89 e5                	mov    %esp,%ebp
+80105587:	83 ec 18             	sub    $0x18,%esp
+  char *path;
+  struct inode *ip;
+
+  begin_op();
+8010558a:	e8 a1 d7 ff ff       	call   80102d30 <begin_op>
+  if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
+8010558f:	83 ec 08             	sub    $0x8,%esp
+80105592:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80105595:	50                   	push   %eax
+80105596:	6a 00                	push   $0x0
+80105598:	e8 e3 f6 ff ff       	call   80104c80 <argstr>
+8010559d:	83 c4 10             	add    $0x10,%esp
+801055a0:	85 c0                	test   %eax,%eax
+801055a2:	78 34                	js     801055d8 <sys_mkdir+0x58>
+801055a4:	83 ec 0c             	sub    $0xc,%esp
+801055a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801055aa:	31 c9                	xor    %ecx,%ecx
+801055ac:	ba 01 00 00 00       	mov    $0x1,%edx
+801055b1:	6a 00                	push   $0x0
+801055b3:	e8 78 f7 ff ff       	call   80104d30 <create>
+801055b8:	83 c4 10             	add    $0x10,%esp
+801055bb:	85 c0                	test   %eax,%eax
+801055bd:	74 19                	je     801055d8 <sys_mkdir+0x58>
+    end_op();
+    return -1;
+  }
+  iunlockput(ip);
+801055bf:	83 ec 0c             	sub    $0xc,%esp
+801055c2:	50                   	push   %eax
+801055c3:	e8 38 c4 ff ff       	call   80101a00 <iunlockput>
+  end_op();
+801055c8:	e8 d3 d7 ff ff       	call   80102da0 <end_op>
+  return 0;
+801055cd:	83 c4 10             	add    $0x10,%esp
+801055d0:	31 c0                	xor    %eax,%eax
+}
+801055d2:	c9                   	leave  
+801055d3:	c3                   	ret    
+801055d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    end_op();
+801055d8:	e8 c3 d7 ff ff       	call   80102da0 <end_op>
+    return -1;
+801055dd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+801055e2:	c9                   	leave  
+801055e3:	c3                   	ret    
+801055e4:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801055eb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801055ef:	90                   	nop
+
+801055f0 <sys_mknod>:
+
+int
+sys_mknod(void)
+{
+801055f0:	f3 0f 1e fb          	endbr32 
+801055f4:	55                   	push   %ebp
+801055f5:	89 e5                	mov    %esp,%ebp
+801055f7:	83 ec 18             	sub    $0x18,%esp
+  struct inode *ip;
+  char *path;
+  int major, minor;
+
+  begin_op();
+801055fa:	e8 31 d7 ff ff       	call   80102d30 <begin_op>
+  if((argstr(0, &path)) < 0 ||
+801055ff:	83 ec 08             	sub    $0x8,%esp
+80105602:	8d 45 ec             	lea    -0x14(%ebp),%eax
+80105605:	50                   	push   %eax
+80105606:	6a 00                	push   $0x0
+80105608:	e8 73 f6 ff ff       	call   80104c80 <argstr>
+8010560d:	83 c4 10             	add    $0x10,%esp
+80105610:	85 c0                	test   %eax,%eax
+80105612:	78 64                	js     80105678 <sys_mknod+0x88>
+     argint(1, &major) < 0 ||
+80105614:	83 ec 08             	sub    $0x8,%esp
+80105617:	8d 45 f0             	lea    -0x10(%ebp),%eax
+8010561a:	50                   	push   %eax
+8010561b:	6a 01                	push   $0x1
+8010561d:	e8 ae f5 ff ff       	call   80104bd0 <argint>
+  if((argstr(0, &path)) < 0 ||
+80105622:	83 c4 10             	add    $0x10,%esp
+80105625:	85 c0                	test   %eax,%eax
+80105627:	78 4f                	js     80105678 <sys_mknod+0x88>
+     argint(2, &minor) < 0 ||
+80105629:	83 ec 08             	sub    $0x8,%esp
+8010562c:	8d 45 f4             	lea    -0xc(%ebp),%eax
+8010562f:	50                   	push   %eax
+80105630:	6a 02                	push   $0x2
+80105632:	e8 99 f5 ff ff       	call   80104bd0 <argint>
+     argint(1, &major) < 0 ||
+80105637:	83 c4 10             	add    $0x10,%esp
+8010563a:	85 c0                	test   %eax,%eax
+8010563c:	78 3a                	js     80105678 <sys_mknod+0x88>
+     (ip = create(path, T_DEV, major, minor)) == 0){
+8010563e:	0f bf 45 f4          	movswl -0xc(%ebp),%eax
+80105642:	83 ec 0c             	sub    $0xc,%esp
+80105645:	0f bf 4d f0          	movswl -0x10(%ebp),%ecx
+80105649:	ba 03 00 00 00       	mov    $0x3,%edx
+8010564e:	50                   	push   %eax
+8010564f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80105652:	e8 d9 f6 ff ff       	call   80104d30 <create>
+     argint(2, &minor) < 0 ||
+80105657:	83 c4 10             	add    $0x10,%esp
+8010565a:	85 c0                	test   %eax,%eax
+8010565c:	74 1a                	je     80105678 <sys_mknod+0x88>
+    end_op();
+    return -1;
+  }
+  iunlockput(ip);
+8010565e:	83 ec 0c             	sub    $0xc,%esp
+80105661:	50                   	push   %eax
+80105662:	e8 99 c3 ff ff       	call   80101a00 <iunlockput>
+  end_op();
+80105667:	e8 34 d7 ff ff       	call   80102da0 <end_op>
+  return 0;
+8010566c:	83 c4 10             	add    $0x10,%esp
+8010566f:	31 c0                	xor    %eax,%eax
+}
+80105671:	c9                   	leave  
+80105672:	c3                   	ret    
+80105673:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80105677:	90                   	nop
+    end_op();
+80105678:	e8 23 d7 ff ff       	call   80102da0 <end_op>
+    return -1;
+8010567d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80105682:	c9                   	leave  
+80105683:	c3                   	ret    
+80105684:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010568b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010568f:	90                   	nop
+
+80105690 <sys_chdir>:
+
+int
+sys_chdir(void)
+{
+80105690:	f3 0f 1e fb          	endbr32 
+80105694:	55                   	push   %ebp
+80105695:	89 e5                	mov    %esp,%ebp
+80105697:	56                   	push   %esi
+80105698:	53                   	push   %ebx
+80105699:	83 ec 10             	sub    $0x10,%esp
+  char *path;
+  struct inode *ip;
+  struct proc *curproc = myproc();
+8010569c:	e8 bf e2 ff ff       	call   80103960 <myproc>
+801056a1:	89 c6                	mov    %eax,%esi
+  
+  begin_op();
+801056a3:	e8 88 d6 ff ff       	call   80102d30 <begin_op>
+  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
+801056a8:	83 ec 08             	sub    $0x8,%esp
+801056ab:	8d 45 f4             	lea    -0xc(%ebp),%eax
+801056ae:	50                   	push   %eax
+801056af:	6a 00                	push   $0x0
+801056b1:	e8 ca f5 ff ff       	call   80104c80 <argstr>
+801056b6:	83 c4 10             	add    $0x10,%esp
+801056b9:	85 c0                	test   %eax,%eax
+801056bb:	78 73                	js     80105730 <sys_chdir+0xa0>
+801056bd:	83 ec 0c             	sub    $0xc,%esp
+801056c0:	ff 75 f4             	pushl  -0xc(%ebp)
+801056c3:	e8 68 c9 ff ff       	call   80102030 <namei>
+801056c8:	83 c4 10             	add    $0x10,%esp
+801056cb:	89 c3                	mov    %eax,%ebx
+801056cd:	85 c0                	test   %eax,%eax
+801056cf:	74 5f                	je     80105730 <sys_chdir+0xa0>
+    end_op();
+    return -1;
+  }
+  ilock(ip);
+801056d1:	83 ec 0c             	sub    $0xc,%esp
+801056d4:	50                   	push   %eax
+801056d5:	e8 86 c0 ff ff       	call   80101760 <ilock>
+  if(ip->type != T_DIR){
+801056da:	83 c4 10             	add    $0x10,%esp
+801056dd:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
+801056e2:	75 2c                	jne    80105710 <sys_chdir+0x80>
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+  iunlock(ip);
+801056e4:	83 ec 0c             	sub    $0xc,%esp
+801056e7:	53                   	push   %ebx
+801056e8:	e8 53 c1 ff ff       	call   80101840 <iunlock>
+  iput(curproc->cwd);
+801056ed:	58                   	pop    %eax
+801056ee:	ff 76 68             	pushl  0x68(%esi)
+801056f1:	e8 9a c1 ff ff       	call   80101890 <iput>
+  end_op();
+801056f6:	e8 a5 d6 ff ff       	call   80102da0 <end_op>
+  curproc->cwd = ip;
+801056fb:	89 5e 68             	mov    %ebx,0x68(%esi)
+  return 0;
+801056fe:	83 c4 10             	add    $0x10,%esp
+80105701:	31 c0                	xor    %eax,%eax
+}
+80105703:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80105706:	5b                   	pop    %ebx
+80105707:	5e                   	pop    %esi
+80105708:	5d                   	pop    %ebp
+80105709:	c3                   	ret    
+8010570a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    iunlockput(ip);
+80105710:	83 ec 0c             	sub    $0xc,%esp
+80105713:	53                   	push   %ebx
+80105714:	e8 e7 c2 ff ff       	call   80101a00 <iunlockput>
+    end_op();
+80105719:	e8 82 d6 ff ff       	call   80102da0 <end_op>
+    return -1;
+8010571e:	83 c4 10             	add    $0x10,%esp
+80105721:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105726:	eb db                	jmp    80105703 <sys_chdir+0x73>
+80105728:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010572f:	90                   	nop
+    end_op();
+80105730:	e8 6b d6 ff ff       	call   80102da0 <end_op>
+    return -1;
+80105735:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010573a:	eb c7                	jmp    80105703 <sys_chdir+0x73>
+8010573c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80105740 <sys_exec>:
+
+int
+sys_exec(void)
+{
+80105740:	f3 0f 1e fb          	endbr32 
+80105744:	55                   	push   %ebp
+80105745:	89 e5                	mov    %esp,%ebp
+80105747:	57                   	push   %edi
+80105748:	56                   	push   %esi
+  char *path, *argv[MAXARG];
+  int i;
+  uint uargv, uarg;
+
+  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
+80105749:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
+{
+8010574f:	53                   	push   %ebx
+80105750:	81 ec a4 00 00 00    	sub    $0xa4,%esp
+  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
+80105756:	50                   	push   %eax
+80105757:	6a 00                	push   $0x0
+80105759:	e8 22 f5 ff ff       	call   80104c80 <argstr>
+8010575e:	83 c4 10             	add    $0x10,%esp
+80105761:	85 c0                	test   %eax,%eax
+80105763:	0f 88 8b 00 00 00    	js     801057f4 <sys_exec+0xb4>
+80105769:	83 ec 08             	sub    $0x8,%esp
+8010576c:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
+80105772:	50                   	push   %eax
+80105773:	6a 01                	push   $0x1
+80105775:	e8 56 f4 ff ff       	call   80104bd0 <argint>
+8010577a:	83 c4 10             	add    $0x10,%esp
+8010577d:	85 c0                	test   %eax,%eax
+8010577f:	78 73                	js     801057f4 <sys_exec+0xb4>
+    return -1;
+  }
+  memset(argv, 0, sizeof(argv));
+80105781:	83 ec 04             	sub    $0x4,%esp
+80105784:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
+  for(i=0;; i++){
+8010578a:	31 db                	xor    %ebx,%ebx
+  memset(argv, 0, sizeof(argv));
+8010578c:	68 80 00 00 00       	push   $0x80
+80105791:	8d bd 64 ff ff ff    	lea    -0x9c(%ebp),%edi
+80105797:	6a 00                	push   $0x0
+80105799:	50                   	push   %eax
+8010579a:	e8 51 f1 ff ff       	call   801048f0 <memset>
+8010579f:	83 c4 10             	add    $0x10,%esp
+801057a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    if(i >= NELEM(argv))
+      return -1;
+    if(fetchint(uargv+4*i, (int*)&uarg) < 0)
+801057a8:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
+801057ae:	8d 34 9d 00 00 00 00 	lea    0x0(,%ebx,4),%esi
+801057b5:	83 ec 08             	sub    $0x8,%esp
+801057b8:	57                   	push   %edi
+801057b9:	01 f0                	add    %esi,%eax
+801057bb:	50                   	push   %eax
+801057bc:	e8 6f f3 ff ff       	call   80104b30 <fetchint>
+801057c1:	83 c4 10             	add    $0x10,%esp
+801057c4:	85 c0                	test   %eax,%eax
+801057c6:	78 2c                	js     801057f4 <sys_exec+0xb4>
+      return -1;
+    if(uarg == 0){
+801057c8:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
+801057ce:	85 c0                	test   %eax,%eax
+801057d0:	74 36                	je     80105808 <sys_exec+0xc8>
+      argv[i] = 0;
+      break;
+    }
+    if(fetchstr(uarg, &argv[i]) < 0)
+801057d2:	8d 8d 68 ff ff ff    	lea    -0x98(%ebp),%ecx
+801057d8:	83 ec 08             	sub    $0x8,%esp
+801057db:	8d 14 31             	lea    (%ecx,%esi,1),%edx
+801057de:	52                   	push   %edx
+801057df:	50                   	push   %eax
+801057e0:	e8 8b f3 ff ff       	call   80104b70 <fetchstr>
+801057e5:	83 c4 10             	add    $0x10,%esp
+801057e8:	85 c0                	test   %eax,%eax
+801057ea:	78 08                	js     801057f4 <sys_exec+0xb4>
+  for(i=0;; i++){
+801057ec:	83 c3 01             	add    $0x1,%ebx
+    if(i >= NELEM(argv))
+801057ef:	83 fb 20             	cmp    $0x20,%ebx
+801057f2:	75 b4                	jne    801057a8 <sys_exec+0x68>
+      return -1;
+  }
+  return exec(path, argv);
+}
+801057f4:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    return -1;
+801057f7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+801057fc:	5b                   	pop    %ebx
+801057fd:	5e                   	pop    %esi
+801057fe:	5f                   	pop    %edi
+801057ff:	5d                   	pop    %ebp
+80105800:	c3                   	ret    
+80105801:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return exec(path, argv);
+80105808:	83 ec 08             	sub    $0x8,%esp
+8010580b:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
+      argv[i] = 0;
+80105811:	c7 84 9d 68 ff ff ff 	movl   $0x0,-0x98(%ebp,%ebx,4)
+80105818:	00 00 00 00 
+  return exec(path, argv);
+8010581c:	50                   	push   %eax
+8010581d:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
+80105823:	e8 58 b2 ff ff       	call   80100a80 <exec>
+80105828:	83 c4 10             	add    $0x10,%esp
+}
+8010582b:	8d 65 f4             	lea    -0xc(%ebp),%esp
+8010582e:	5b                   	pop    %ebx
+8010582f:	5e                   	pop    %esi
+80105830:	5f                   	pop    %edi
+80105831:	5d                   	pop    %ebp
+80105832:	c3                   	ret    
+80105833:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010583a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80105840 <sys_pipe>:
+
+int
+sys_pipe(void)
+{
+80105840:	f3 0f 1e fb          	endbr32 
+80105844:	55                   	push   %ebp
+80105845:	89 e5                	mov    %esp,%ebp
+80105847:	57                   	push   %edi
+80105848:	56                   	push   %esi
+  int *fd;
+  struct file *rf, *wf;
+  int fd0, fd1;
+
+  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
+80105849:	8d 45 dc             	lea    -0x24(%ebp),%eax
+{
+8010584c:	53                   	push   %ebx
+8010584d:	83 ec 20             	sub    $0x20,%esp
+  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
+80105850:	6a 08                	push   $0x8
+80105852:	50                   	push   %eax
+80105853:	6a 00                	push   $0x0
+80105855:	e8 c6 f3 ff ff       	call   80104c20 <argptr>
+8010585a:	83 c4 10             	add    $0x10,%esp
+8010585d:	85 c0                	test   %eax,%eax
+8010585f:	78 4e                	js     801058af <sys_pipe+0x6f>
+    return -1;
+  if(pipealloc(&rf, &wf) < 0)
+80105861:	83 ec 08             	sub    $0x8,%esp
+80105864:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+80105867:	50                   	push   %eax
+80105868:	8d 45 e0             	lea    -0x20(%ebp),%eax
+8010586b:	50                   	push   %eax
+8010586c:	e8 7f db ff ff       	call   801033f0 <pipealloc>
+80105871:	83 c4 10             	add    $0x10,%esp
+80105874:	85 c0                	test   %eax,%eax
+80105876:	78 37                	js     801058af <sys_pipe+0x6f>
+    return -1;
+  fd0 = -1;
+  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
+80105878:	8b 7d e0             	mov    -0x20(%ebp),%edi
+  for(fd = 0; fd < NOFILE; fd++){
+8010587b:	31 db                	xor    %ebx,%ebx
+  struct proc *curproc = myproc();
+8010587d:	e8 de e0 ff ff       	call   80103960 <myproc>
+  for(fd = 0; fd < NOFILE; fd++){
+80105882:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    if(curproc->ofile[fd] == 0){
+80105888:	8b 74 98 28          	mov    0x28(%eax,%ebx,4),%esi
+8010588c:	85 f6                	test   %esi,%esi
+8010588e:	74 30                	je     801058c0 <sys_pipe+0x80>
+  for(fd = 0; fd < NOFILE; fd++){
+80105890:	83 c3 01             	add    $0x1,%ebx
+80105893:	83 fb 10             	cmp    $0x10,%ebx
+80105896:	75 f0                	jne    80105888 <sys_pipe+0x48>
+    if(fd0 >= 0)
+      myproc()->ofile[fd0] = 0;
+    fileclose(rf);
+80105898:	83 ec 0c             	sub    $0xc,%esp
+8010589b:	ff 75 e0             	pushl  -0x20(%ebp)
+8010589e:	e8 1d b6 ff ff       	call   80100ec0 <fileclose>
+    fileclose(wf);
+801058a3:	58                   	pop    %eax
+801058a4:	ff 75 e4             	pushl  -0x1c(%ebp)
+801058a7:	e8 14 b6 ff ff       	call   80100ec0 <fileclose>
+    return -1;
+801058ac:	83 c4 10             	add    $0x10,%esp
+801058af:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801058b4:	eb 5b                	jmp    80105911 <sys_pipe+0xd1>
+801058b6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801058bd:	8d 76 00             	lea    0x0(%esi),%esi
+      curproc->ofile[fd] = f;
+801058c0:	8d 73 08             	lea    0x8(%ebx),%esi
+801058c3:	89 7c b0 08          	mov    %edi,0x8(%eax,%esi,4)
+  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
+801058c7:	8b 7d e4             	mov    -0x1c(%ebp),%edi
+  struct proc *curproc = myproc();
+801058ca:	e8 91 e0 ff ff       	call   80103960 <myproc>
+  for(fd = 0; fd < NOFILE; fd++){
+801058cf:	31 d2                	xor    %edx,%edx
+801058d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    if(curproc->ofile[fd] == 0){
+801058d8:	8b 4c 90 28          	mov    0x28(%eax,%edx,4),%ecx
+801058dc:	85 c9                	test   %ecx,%ecx
+801058de:	74 20                	je     80105900 <sys_pipe+0xc0>
+  for(fd = 0; fd < NOFILE; fd++){
+801058e0:	83 c2 01             	add    $0x1,%edx
+801058e3:	83 fa 10             	cmp    $0x10,%edx
+801058e6:	75 f0                	jne    801058d8 <sys_pipe+0x98>
+      myproc()->ofile[fd0] = 0;
+801058e8:	e8 73 e0 ff ff       	call   80103960 <myproc>
+801058ed:	c7 44 b0 08 00 00 00 	movl   $0x0,0x8(%eax,%esi,4)
+801058f4:	00 
+801058f5:	eb a1                	jmp    80105898 <sys_pipe+0x58>
+801058f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801058fe:	66 90                	xchg   %ax,%ax
+      curproc->ofile[fd] = f;
+80105900:	89 7c 90 28          	mov    %edi,0x28(%eax,%edx,4)
+  }
+  fd[0] = fd0;
+80105904:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80105907:	89 18                	mov    %ebx,(%eax)
+  fd[1] = fd1;
+80105909:	8b 45 dc             	mov    -0x24(%ebp),%eax
+8010590c:	89 50 04             	mov    %edx,0x4(%eax)
+  return 0;
+8010590f:	31 c0                	xor    %eax,%eax
+}
+80105911:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80105914:	5b                   	pop    %ebx
+80105915:	5e                   	pop    %esi
+80105916:	5f                   	pop    %edi
+80105917:	5d                   	pop    %ebp
+80105918:	c3                   	ret    
+80105919:	66 90                	xchg   %ax,%ax
+8010591b:	66 90                	xchg   %ax,%ax
+8010591d:	66 90                	xchg   %ax,%ax
+8010591f:	90                   	nop
+
+80105920 <sys_fork>:
+#include "proc.h"
+// #include "proc.c"
+
+int
+sys_fork(void)
+{
+80105920:	f3 0f 1e fb          	endbr32 
+  return fork();
+80105924:	e9 e7 e1 ff ff       	jmp    80103b10 <fork>
+80105929:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80105930 <sys_exit>:
+}
+
+int
+sys_exit(void)
+{
+80105930:	f3 0f 1e fb          	endbr32 
+80105934:	55                   	push   %ebp
+80105935:	89 e5                	mov    %esp,%ebp
+80105937:	83 ec 08             	sub    $0x8,%esp
+  exit();
+8010593a:	e8 51 e4 ff ff       	call   80103d90 <exit>
+  return 0;  // not reached
+}
+8010593f:	31 c0                	xor    %eax,%eax
+80105941:	c9                   	leave  
+80105942:	c3                   	ret    
+80105943:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010594a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80105950 <sys_wait>:
+
+int
+sys_wait(void)
+{
+80105950:	f3 0f 1e fb          	endbr32 
+  return wait();
+80105954:	e9 87 e6 ff ff       	jmp    80103fe0 <wait>
+80105959:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80105960 <sys_kill>:
+}
+
+int
+sys_kill(void)
+{
+80105960:	f3 0f 1e fb          	endbr32 
+80105964:	55                   	push   %ebp
+80105965:	89 e5                	mov    %esp,%ebp
+80105967:	83 ec 20             	sub    $0x20,%esp
+  int pid;
+
+  if(argint(0, &pid) < 0)
+8010596a:	8d 45 f4             	lea    -0xc(%ebp),%eax
+8010596d:	50                   	push   %eax
+8010596e:	6a 00                	push   $0x0
+80105970:	e8 5b f2 ff ff       	call   80104bd0 <argint>
+80105975:	83 c4 10             	add    $0x10,%esp
+80105978:	85 c0                	test   %eax,%eax
+8010597a:	78 14                	js     80105990 <sys_kill+0x30>
+    return -1;
+  return kill(pid);
+8010597c:	83 ec 0c             	sub    $0xc,%esp
+8010597f:	ff 75 f4             	pushl  -0xc(%ebp)
+80105982:	e8 b9 e7 ff ff       	call   80104140 <kill>
+80105987:	83 c4 10             	add    $0x10,%esp
+}
+8010598a:	c9                   	leave  
+8010598b:	c3                   	ret    
+8010598c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80105990:	c9                   	leave  
+    return -1;
+80105991:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80105996:	c3                   	ret    
+80105997:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010599e:	66 90                	xchg   %ax,%ax
+
+801059a0 <sys_getpid>:
+
+int
+sys_getpid(void)
+{
+801059a0:	f3 0f 1e fb          	endbr32 
+801059a4:	55                   	push   %ebp
+801059a5:	89 e5                	mov    %esp,%ebp
+801059a7:	83 ec 08             	sub    $0x8,%esp
+  return myproc()->pid;
+801059aa:	e8 b1 df ff ff       	call   80103960 <myproc>
+801059af:	8b 40 10             	mov    0x10(%eax),%eax
+}
+801059b2:	c9                   	leave  
+801059b3:	c3                   	ret    
+801059b4:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801059bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801059bf:	90                   	nop
+
+801059c0 <sys_sbrk>:
+
+int
+sys_sbrk(void)
+{
+801059c0:	f3 0f 1e fb          	endbr32 
+801059c4:	55                   	push   %ebp
+801059c5:	89 e5                	mov    %esp,%ebp
+801059c7:	53                   	push   %ebx
+  int addr;
+  int n;
+
+  if(argint(0, &n) < 0)
+801059c8:	8d 45 f4             	lea    -0xc(%ebp),%eax
+{
+801059cb:	83 ec 1c             	sub    $0x1c,%esp
+  if(argint(0, &n) < 0)
+801059ce:	50                   	push   %eax
+801059cf:	6a 00                	push   $0x0
+801059d1:	e8 fa f1 ff ff       	call   80104bd0 <argint>
+801059d6:	83 c4 10             	add    $0x10,%esp
+801059d9:	85 c0                	test   %eax,%eax
+801059db:	78 23                	js     80105a00 <sys_sbrk+0x40>
+    return -1;
+  addr = myproc()->sz;
+801059dd:	e8 7e df ff ff       	call   80103960 <myproc>
+  if(growproc(n) < 0)
+801059e2:	83 ec 0c             	sub    $0xc,%esp
+  addr = myproc()->sz;
+801059e5:	8b 18                	mov    (%eax),%ebx
+  if(growproc(n) < 0)
+801059e7:	ff 75 f4             	pushl  -0xc(%ebp)
+801059ea:	e8 a1 e0 ff ff       	call   80103a90 <growproc>
+801059ef:	83 c4 10             	add    $0x10,%esp
+801059f2:	85 c0                	test   %eax,%eax
+801059f4:	78 0a                	js     80105a00 <sys_sbrk+0x40>
+    return -1;
+  return addr;
+}
+801059f6:	89 d8                	mov    %ebx,%eax
+801059f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+801059fb:	c9                   	leave  
+801059fc:	c3                   	ret    
+801059fd:	8d 76 00             	lea    0x0(%esi),%esi
+    return -1;
+80105a00:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
+80105a05:	eb ef                	jmp    801059f6 <sys_sbrk+0x36>
+80105a07:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80105a0e:	66 90                	xchg   %ax,%ax
+
+80105a10 <sys_sleep>:
+
+int
+sys_sleep(void)
+{
+80105a10:	f3 0f 1e fb          	endbr32 
+80105a14:	55                   	push   %ebp
+80105a15:	89 e5                	mov    %esp,%ebp
+80105a17:	53                   	push   %ebx
+  int n;
+  uint ticks0;
+
+  if(argint(0, &n) < 0)
+80105a18:	8d 45 f4             	lea    -0xc(%ebp),%eax
+{
+80105a1b:	83 ec 1c             	sub    $0x1c,%esp
+  if(argint(0, &n) < 0)
+80105a1e:	50                   	push   %eax
+80105a1f:	6a 00                	push   $0x0
+80105a21:	e8 aa f1 ff ff       	call   80104bd0 <argint>
+80105a26:	83 c4 10             	add    $0x10,%esp
+80105a29:	85 c0                	test   %eax,%eax
+80105a2b:	0f 88 86 00 00 00    	js     80105ab7 <sys_sleep+0xa7>
+    return -1;
+  acquire(&tickslock);
+80105a31:	83 ec 0c             	sub    $0xc,%esp
+80105a34:	68 60 4d 11 80       	push   $0x80114d60
+80105a39:	e8 a2 ed ff ff       	call   801047e0 <acquire>
+  ticks0 = ticks;
+  while(ticks - ticks0 < n){
+80105a3e:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  ticks0 = ticks;
+80105a41:	8b 1d a0 55 11 80    	mov    0x801155a0,%ebx
+  while(ticks - ticks0 < n){
+80105a47:	83 c4 10             	add    $0x10,%esp
+80105a4a:	85 d2                	test   %edx,%edx
+80105a4c:	75 23                	jne    80105a71 <sys_sleep+0x61>
+80105a4e:	eb 50                	jmp    80105aa0 <sys_sleep+0x90>
+    if(myproc()->killed){
+      release(&tickslock);
+      return -1;
+    }
+    sleep(&ticks, &tickslock);
+80105a50:	83 ec 08             	sub    $0x8,%esp
+80105a53:	68 60 4d 11 80       	push   $0x80114d60
+80105a58:	68 a0 55 11 80       	push   $0x801155a0
+80105a5d:	e8 be e4 ff ff       	call   80103f20 <sleep>
+  while(ticks - ticks0 < n){
+80105a62:	a1 a0 55 11 80       	mov    0x801155a0,%eax
+80105a67:	83 c4 10             	add    $0x10,%esp
+80105a6a:	29 d8                	sub    %ebx,%eax
+80105a6c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+80105a6f:	73 2f                	jae    80105aa0 <sys_sleep+0x90>
+    if(myproc()->killed){
+80105a71:	e8 ea de ff ff       	call   80103960 <myproc>
+80105a76:	8b 40 24             	mov    0x24(%eax),%eax
+80105a79:	85 c0                	test   %eax,%eax
+80105a7b:	74 d3                	je     80105a50 <sys_sleep+0x40>
+      release(&tickslock);
+80105a7d:	83 ec 0c             	sub    $0xc,%esp
+80105a80:	68 60 4d 11 80       	push   $0x80114d60
+80105a85:	e8 16 ee ff ff       	call   801048a0 <release>
+  }
+  release(&tickslock);
+  return 0;
+}
+80105a8a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+      return -1;
+80105a8d:	83 c4 10             	add    $0x10,%esp
+80105a90:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80105a95:	c9                   	leave  
+80105a96:	c3                   	ret    
+80105a97:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80105a9e:	66 90                	xchg   %ax,%ax
+  release(&tickslock);
+80105aa0:	83 ec 0c             	sub    $0xc,%esp
+80105aa3:	68 60 4d 11 80       	push   $0x80114d60
+80105aa8:	e8 f3 ed ff ff       	call   801048a0 <release>
+  return 0;
+80105aad:	83 c4 10             	add    $0x10,%esp
+80105ab0:	31 c0                	xor    %eax,%eax
+}
+80105ab2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80105ab5:	c9                   	leave  
+80105ab6:	c3                   	ret    
+    return -1;
+80105ab7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105abc:	eb f4                	jmp    80105ab2 <sys_sleep+0xa2>
+80105abe:	66 90                	xchg   %ax,%ax
+
+80105ac0 <sys_uptime>:
+
+// return how many clock tick interrupts have occurred
+// since start.
+int
+sys_uptime(void)
+{
+80105ac0:	f3 0f 1e fb          	endbr32 
+80105ac4:	55                   	push   %ebp
+80105ac5:	89 e5                	mov    %esp,%ebp
+80105ac7:	53                   	push   %ebx
+80105ac8:	83 ec 10             	sub    $0x10,%esp
+  uint xticks;
+
+  acquire(&tickslock);
+80105acb:	68 60 4d 11 80       	push   $0x80114d60
+80105ad0:	e8 0b ed ff ff       	call   801047e0 <acquire>
+  xticks = ticks;
+80105ad5:	8b 1d a0 55 11 80    	mov    0x801155a0,%ebx
+  release(&tickslock);
+80105adb:	c7 04 24 60 4d 11 80 	movl   $0x80114d60,(%esp)
+80105ae2:	e8 b9 ed ff ff       	call   801048a0 <release>
+  return xticks;
+}
+80105ae7:	89 d8                	mov    %ebx,%eax
+80105ae9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80105aec:	c9                   	leave  
+80105aed:	c3                   	ret    
+80105aee:	66 90                	xchg   %ax,%ax
+
+80105af0 <sys_thread_create>:
+
+//
+int
+sys_thread_create(void) {
+80105af0:	f3 0f 1e fb          	endbr32 
+80105af4:	55                   	push   %ebp
+80105af5:	89 e5                	mov    %esp,%ebp
+80105af7:	83 ec 20             	sub    $0x20,%esp
+  int fcn;
+  char* arg;
+  char* stack;
+  if (argint(0, &fcn) < 0)
+80105afa:	8d 45 ec             	lea    -0x14(%ebp),%eax
+80105afd:	50                   	push   %eax
+80105afe:	6a 00                	push   $0x0
+80105b00:	e8 cb f0 ff ff       	call   80104bd0 <argint>
+80105b05:	83 c4 10             	add    $0x10,%esp
+80105b08:	85 c0                	test   %eax,%eax
+80105b0a:	78 44                	js     80105b50 <sys_thread_create+0x60>
+    return -1;
+  if (argstr(1, &arg) < 0)
+80105b0c:	83 ec 08             	sub    $0x8,%esp
+80105b0f:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80105b12:	50                   	push   %eax
+80105b13:	6a 01                	push   $0x1
+80105b15:	e8 66 f1 ff ff       	call   80104c80 <argstr>
+80105b1a:	83 c4 10             	add    $0x10,%esp
+80105b1d:	85 c0                	test   %eax,%eax
+80105b1f:	78 2f                	js     80105b50 <sys_thread_create+0x60>
+    return -1;
+  if (argstr(2, &stack) < 0)
+80105b21:	83 ec 08             	sub    $0x8,%esp
+80105b24:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80105b27:	50                   	push   %eax
+80105b28:	6a 02                	push   $0x2
+80105b2a:	e8 51 f1 ff ff       	call   80104c80 <argstr>
+80105b2f:	83 c4 10             	add    $0x10,%esp
+80105b32:	85 c0                	test   %eax,%eax
+80105b34:	78 1a                	js     80105b50 <sys_thread_create+0x60>
+    return -1;
+  // fcn make integer to void(*)(void*)
+  return thread_create((void(*)(void*))fcn, arg, stack);
+80105b36:	83 ec 04             	sub    $0x4,%esp
+80105b39:	ff 75 f4             	pushl  -0xc(%ebp)
+80105b3c:	ff 75 f0             	pushl  -0x10(%ebp)
+80105b3f:	ff 75 ec             	pushl  -0x14(%ebp)
+80105b42:	e8 59 e7 ff ff       	call   801042a0 <thread_create>
+80105b47:	83 c4 10             	add    $0x10,%esp
+}
+80105b4a:	c9                   	leave  
+80105b4b:	c3                   	ret    
+80105b4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80105b50:	c9                   	leave  
+    return -1;
+80105b51:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80105b56:	c3                   	ret    
+80105b57:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80105b5e:	66 90                	xchg   %ax,%ax
+
+80105b60 <sys_thread_exit>:
+int
+sys_thread_exit(void)
+{
+80105b60:	f3 0f 1e fb          	endbr32 
+80105b64:	55                   	push   %ebp
+80105b65:	89 e5                	mov    %esp,%ebp
+80105b67:	83 ec 08             	sub    $0x8,%esp
+  thread_exit();
+80105b6a:	e8 a1 e9 ff ff       	call   80104510 <thread_exit>
+  return 0;
+}
+80105b6f:	31 c0                	xor    %eax,%eax
+80105b71:	c9                   	leave  
+80105b72:	c3                   	ret    
+80105b73:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80105b7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80105b80 <sys_thread_join>:
+int
+sys_thread_join(void)
+{
+80105b80:	f3 0f 1e fb          	endbr32 
+  return thread_join();
+80105b84:	e9 77 e8 ff ff       	jmp    80104400 <thread_join>
+80105b89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80105b90 <sys_draw>:
+}
+
+int
+sys_draw(void)
+{
+80105b90:	f3 0f 1e fb          	endbr32 
+80105b94:	55                   	push   %ebp
+80105b95:	89 e5                	mov    %esp,%ebp
+80105b97:	83 ec 5c             	sub    $0x5c,%esp
+  void* buf;
+  uint size;
+  argptr(0, (void*)&buf, sizeof(buf));
+80105b9a:	8d 45 b4             	lea    -0x4c(%ebp),%eax
+80105b9d:	6a 04                	push   $0x4
+80105b9f:	50                   	push   %eax
+80105ba0:	6a 00                	push   $0x0
+80105ba2:	e8 79 f0 ff ff       	call   80104c20 <argptr>
+  argptr(1, (void*)&size, sizeof(size));
+80105ba7:	83 c4 0c             	add    $0xc,%esp
+80105baa:	8d 45 b8             	lea    -0x48(%ebp),%eax
+80105bad:	6a 04                	push   $0x4
+80105baf:	50                   	push   %eax
+80105bb0:	6a 01                	push   $0x1
+80105bb2:	e8 69 f0 ff ff       	call   80104c20 <argptr>
+
+  char text[] = R"(
+    Everyone Loves Mickey Mouse!
+                   >?>?>
+)";
+  if(sizeof(text)>size)
+80105bb7:	8b 45 b8             	mov    -0x48(%ebp),%eax
+80105bba:	83 c4 10             	add    $0x10,%esp
+  char text[] = R"(
+80105bbd:	c7 45 bc 0a 20 20 20 	movl   $0x2020200a,-0x44(%ebp)
+80105bc4:	c7 45 c0 20 45 76 65 	movl   $0x65764520,-0x40(%ebp)
+80105bcb:	c7 45 c4 72 79 6f 6e 	movl   $0x6e6f7972,-0x3c(%ebp)
+80105bd2:	c7 45 c8 65 20 4c 6f 	movl   $0x6f4c2065,-0x38(%ebp)
+80105bd9:	c7 45 cc 76 65 73 20 	movl   $0x20736576,-0x34(%ebp)
+80105be0:	c7 45 d0 4d 69 63 6b 	movl   $0x6b63694d,-0x30(%ebp)
+80105be7:	c7 45 d4 65 79 20 4d 	movl   $0x4d207965,-0x2c(%ebp)
+80105bee:	c7 45 d8 6f 75 73 65 	movl   $0x6573756f,-0x28(%ebp)
+80105bf5:	c7 45 dc 21 0a 20 20 	movl   $0x20200a21,-0x24(%ebp)
+80105bfc:	c7 45 e0 20 20 20 20 	movl   $0x20202020,-0x20(%ebp)
+80105c03:	c7 45 e4 20 20 20 20 	movl   $0x20202020,-0x1c(%ebp)
+80105c0a:	c7 45 e8 20 20 20 20 	movl   $0x20202020,-0x18(%ebp)
+80105c11:	c7 45 ec 20 20 20 20 	movl   $0x20202020,-0x14(%ebp)
+80105c18:	c7 45 f0 20 3e 3f 3e 	movl   $0x3e3f3e20,-0x10(%ebp)
+80105c1f:	c7 45 f4 3f 3e 0a 00 	movl   $0xa3e3f,-0xc(%ebp)
+  if(sizeof(text)>size)
+80105c26:	83 f8 3b             	cmp    $0x3b,%eax
+80105c29:	76 1d                	jbe    80105c48 <sys_draw+0xb8>
+    return -1;
+
+  strncpy((char *)buf, text, size);
+80105c2b:	83 ec 04             	sub    $0x4,%esp
+80105c2e:	50                   	push   %eax
+80105c2f:	8d 45 bc             	lea    -0x44(%ebp),%eax
+80105c32:	50                   	push   %eax
+80105c33:	ff 75 b4             	pushl  -0x4c(%ebp)
+80105c36:	e8 15 ee ff ff       	call   80104a50 <strncpy>
+  return sizeof(text);
+80105c3b:	83 c4 10             	add    $0x10,%esp
+80105c3e:	b8 3c 00 00 00       	mov    $0x3c,%eax
+}
+80105c43:	c9                   	leave  
+80105c44:	c3                   	ret    
+80105c45:	8d 76 00             	lea    0x0(%esi),%esi
+80105c48:	c9                   	leave  
+    return -1;
+80105c49:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80105c4e:	c3                   	ret    
+
+80105c4f <alltraps>:
+
+  # vectors.S sends all traps here.
+.globl alltraps
+alltraps:
+  # Build trap frame.
+  pushl %ds
+80105c4f:	1e                   	push   %ds
+  pushl %es
+80105c50:	06                   	push   %es
+  pushl %fs
+80105c51:	0f a0                	push   %fs
+  pushl %gs
+80105c53:	0f a8                	push   %gs
+  pushal
+80105c55:	60                   	pusha  
+  
+  # Set up data segments.
+  movw $(SEG_KDATA<<3), %ax
+80105c56:	66 b8 10 00          	mov    $0x10,%ax
+  movw %ax, %ds
+80105c5a:	8e d8                	mov    %eax,%ds
+  movw %ax, %es
+80105c5c:	8e c0                	mov    %eax,%es
+
+  # Call trap(tf), where tf=%esp
+  pushl %esp
+80105c5e:	54                   	push   %esp
+  call trap
+80105c5f:	e8 cc 00 00 00       	call   80105d30 <trap>
+  addl $4, %esp
+80105c64:	83 c4 04             	add    $0x4,%esp
+
+80105c67 <trapret>:
+
+  # Return falls through to trapret...
+.globl trapret
+trapret:
+  popal
+80105c67:	61                   	popa   
+  popl %gs
+80105c68:	0f a9                	pop    %gs
+  popl %fs
+80105c6a:	0f a1                	pop    %fs
+  popl %es
+80105c6c:	07                   	pop    %es
+  popl %ds
+80105c6d:	1f                   	pop    %ds
+  addl $0x8, %esp  # trapno and errcode
+80105c6e:	83 c4 08             	add    $0x8,%esp
+  iret
+80105c71:	cf                   	iret   
+80105c72:	66 90                	xchg   %ax,%ax
+80105c74:	66 90                	xchg   %ax,%ax
+80105c76:	66 90                	xchg   %ax,%ax
+80105c78:	66 90                	xchg   %ax,%ax
+80105c7a:	66 90                	xchg   %ax,%ax
+80105c7c:	66 90                	xchg   %ax,%ax
+80105c7e:	66 90                	xchg   %ax,%ax
+
+80105c80 <tvinit>:
+struct spinlock tickslock;
+uint ticks;
+
+void
+tvinit(void)
+{
+80105c80:	f3 0f 1e fb          	endbr32 
+80105c84:	55                   	push   %ebp
+  int i;
+
+  for(i = 0; i < 256; i++)
+80105c85:	31 c0                	xor    %eax,%eax
+{
+80105c87:	89 e5                	mov    %esp,%ebp
+80105c89:	83 ec 08             	sub    $0x8,%esp
+80105c8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
+80105c90:	8b 14 85 08 a0 10 80 	mov    -0x7fef5ff8(,%eax,4),%edx
+80105c97:	c7 04 c5 a2 4d 11 80 	movl   $0x8e000008,-0x7feeb25e(,%eax,8)
+80105c9e:	08 00 00 8e 
+80105ca2:	66 89 14 c5 a0 4d 11 	mov    %dx,-0x7feeb260(,%eax,8)
+80105ca9:	80 
+80105caa:	c1 ea 10             	shr    $0x10,%edx
+80105cad:	66 89 14 c5 a6 4d 11 	mov    %dx,-0x7feeb25a(,%eax,8)
+80105cb4:	80 
+  for(i = 0; i < 256; i++)
+80105cb5:	83 c0 01             	add    $0x1,%eax
+80105cb8:	3d 00 01 00 00       	cmp    $0x100,%eax
+80105cbd:	75 d1                	jne    80105c90 <tvinit+0x10>
+  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+
+  initlock(&tickslock, "time");
+80105cbf:	83 ec 08             	sub    $0x8,%esp
+  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+80105cc2:	a1 08 a1 10 80       	mov    0x8010a108,%eax
+80105cc7:	c7 05 a2 4f 11 80 08 	movl   $0xef000008,0x80114fa2
+80105cce:	00 00 ef 
+  initlock(&tickslock, "time");
+80105cd1:	68 49 7c 10 80       	push   $0x80107c49
+80105cd6:	68 60 4d 11 80       	push   $0x80114d60
+  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+80105cdb:	66 a3 a0 4f 11 80    	mov    %ax,0x80114fa0
+80105ce1:	c1 e8 10             	shr    $0x10,%eax
+80105ce4:	66 a3 a6 4f 11 80    	mov    %ax,0x80114fa6
+  initlock(&tickslock, "time");
+80105cea:	e8 71 e9 ff ff       	call   80104660 <initlock>
+}
+80105cef:	83 c4 10             	add    $0x10,%esp
+80105cf2:	c9                   	leave  
+80105cf3:	c3                   	ret    
+80105cf4:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80105cfb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80105cff:	90                   	nop
+
+80105d00 <idtinit>:
+
+void
+idtinit(void)
+{
+80105d00:	f3 0f 1e fb          	endbr32 
+80105d04:	55                   	push   %ebp
+  pd[0] = size-1;
+80105d05:	b8 ff 07 00 00       	mov    $0x7ff,%eax
+80105d0a:	89 e5                	mov    %esp,%ebp
+80105d0c:	83 ec 10             	sub    $0x10,%esp
+80105d0f:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
+  pd[1] = (uint)p;
+80105d13:	b8 a0 4d 11 80       	mov    $0x80114da0,%eax
+80105d18:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+  pd[2] = (uint)p >> 16;
+80105d1c:	c1 e8 10             	shr    $0x10,%eax
+80105d1f:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
+  asm volatile("lidt (%0)" : : "r" (pd));
+80105d23:	8d 45 fa             	lea    -0x6(%ebp),%eax
+80105d26:	0f 01 18             	lidtl  (%eax)
+  lidt(idt, sizeof(idt));
+}
+80105d29:	c9                   	leave  
+80105d2a:	c3                   	ret    
+80105d2b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80105d2f:	90                   	nop
+
+80105d30 <trap>:
+
+//PAGEBREAK: 41
+void
+trap(struct trapframe *tf)
+{
+80105d30:	f3 0f 1e fb          	endbr32 
+80105d34:	55                   	push   %ebp
+80105d35:	89 e5                	mov    %esp,%ebp
+80105d37:	57                   	push   %edi
+80105d38:	56                   	push   %esi
+80105d39:	53                   	push   %ebx
+80105d3a:	83 ec 1c             	sub    $0x1c,%esp
+80105d3d:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(tf->trapno == T_SYSCALL){
+80105d40:	8b 43 30             	mov    0x30(%ebx),%eax
+80105d43:	83 f8 40             	cmp    $0x40,%eax
+80105d46:	0f 84 bc 01 00 00    	je     80105f08 <trap+0x1d8>
+    if(myproc()->killed)
+      exit();
+    return;
+  }
+
+  switch(tf->trapno){
+80105d4c:	83 e8 20             	sub    $0x20,%eax
+80105d4f:	83 f8 1f             	cmp    $0x1f,%eax
+80105d52:	77 08                	ja     80105d5c <trap+0x2c>
+80105d54:	3e ff 24 85 f0 7c 10 	notrack jmp *-0x7fef8310(,%eax,4)
+80105d5b:	80 
+    lapiceoi();
+    break;
+
+  //PAGEBREAK: 13
+  default:
+    if(myproc() == 0 || (tf->cs&3) == 0){
+80105d5c:	e8 ff db ff ff       	call   80103960 <myproc>
+80105d61:	8b 7b 38             	mov    0x38(%ebx),%edi
+80105d64:	85 c0                	test   %eax,%eax
+80105d66:	0f 84 eb 01 00 00    	je     80105f57 <trap+0x227>
+80105d6c:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
+80105d70:	0f 84 e1 01 00 00    	je     80105f57 <trap+0x227>
+
+static inline uint
+rcr2(void)
+{
+  uint val;
+  asm volatile("movl %%cr2,%0" : "=r" (val));
+80105d76:	0f 20 d1             	mov    %cr2,%ecx
+80105d79:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+              tf->trapno, cpuid(), tf->eip, rcr2());
+      panic("trap");
+    }
+    // In user space, assume process misbehaved.
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+80105d7c:	e8 bf db ff ff       	call   80103940 <cpuid>
+80105d81:	8b 73 30             	mov    0x30(%ebx),%esi
+80105d84:	89 45 dc             	mov    %eax,-0x24(%ebp)
+80105d87:	8b 43 34             	mov    0x34(%ebx),%eax
+80105d8a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            "eip 0x%x addr 0x%x--kill proc\n",
+            myproc()->pid, myproc()->name, tf->trapno,
+80105d8d:	e8 ce db ff ff       	call   80103960 <myproc>
+80105d92:	89 45 e0             	mov    %eax,-0x20(%ebp)
+80105d95:	e8 c6 db ff ff       	call   80103960 <myproc>
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+80105d9a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+80105d9d:	8b 55 dc             	mov    -0x24(%ebp),%edx
+80105da0:	51                   	push   %ecx
+80105da1:	57                   	push   %edi
+80105da2:	52                   	push   %edx
+80105da3:	ff 75 e4             	pushl  -0x1c(%ebp)
+80105da6:	56                   	push   %esi
+            myproc()->pid, myproc()->name, tf->trapno,
+80105da7:	8b 75 e0             	mov    -0x20(%ebp),%esi
+80105daa:	83 c6 6c             	add    $0x6c,%esi
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+80105dad:	56                   	push   %esi
+80105dae:	ff 70 10             	pushl  0x10(%eax)
+80105db1:	68 ac 7c 10 80       	push   $0x80107cac
+80105db6:	e8 f5 a8 ff ff       	call   801006b0 <cprintf>
+            tf->err, cpuid(), tf->eip, rcr2());
+    myproc()->killed = 1;
+80105dbb:	83 c4 20             	add    $0x20,%esp
+80105dbe:	e8 9d db ff ff       	call   80103960 <myproc>
+80105dc3:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
+  }
+
+  // Force process exit if it has been killed and is in user space.
+  // (If it is still executing in the kernel, let it keep running
+  // until it gets to the regular system call return.)
+  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+80105dca:	e8 91 db ff ff       	call   80103960 <myproc>
+80105dcf:	85 c0                	test   %eax,%eax
+80105dd1:	74 1d                	je     80105df0 <trap+0xc0>
+80105dd3:	e8 88 db ff ff       	call   80103960 <myproc>
+80105dd8:	8b 50 24             	mov    0x24(%eax),%edx
+80105ddb:	85 d2                	test   %edx,%edx
+80105ddd:	74 11                	je     80105df0 <trap+0xc0>
+80105ddf:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
+80105de3:	83 e0 03             	and    $0x3,%eax
+80105de6:	66 83 f8 03          	cmp    $0x3,%ax
+80105dea:	0f 84 50 01 00 00    	je     80105f40 <trap+0x210>
+    exit();
+
+  // Force process to give up CPU on clock tick.
+  // If interrupts were on while locks held, would need to check nlock.
+  if(myproc() && myproc()->state == RUNNING &&
+80105df0:	e8 6b db ff ff       	call   80103960 <myproc>
+80105df5:	85 c0                	test   %eax,%eax
+80105df7:	74 0f                	je     80105e08 <trap+0xd8>
+80105df9:	e8 62 db ff ff       	call   80103960 <myproc>
+80105dfe:	83 78 0c 04          	cmpl   $0x4,0xc(%eax)
+80105e02:	0f 84 e8 00 00 00    	je     80105ef0 <trap+0x1c0>
+     tf->trapno == T_IRQ0+IRQ_TIMER)
+    yield();
+
+  // Check if the process has been killed since we yielded
+  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+80105e08:	e8 53 db ff ff       	call   80103960 <myproc>
+80105e0d:	85 c0                	test   %eax,%eax
+80105e0f:	74 1d                	je     80105e2e <trap+0xfe>
+80105e11:	e8 4a db ff ff       	call   80103960 <myproc>
+80105e16:	8b 40 24             	mov    0x24(%eax),%eax
+80105e19:	85 c0                	test   %eax,%eax
+80105e1b:	74 11                	je     80105e2e <trap+0xfe>
+80105e1d:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
+80105e21:	83 e0 03             	and    $0x3,%eax
+80105e24:	66 83 f8 03          	cmp    $0x3,%ax
+80105e28:	0f 84 03 01 00 00    	je     80105f31 <trap+0x201>
+    exit();
+}
+80105e2e:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80105e31:	5b                   	pop    %ebx
+80105e32:	5e                   	pop    %esi
+80105e33:	5f                   	pop    %edi
+80105e34:	5d                   	pop    %ebp
+80105e35:	c3                   	ret    
+    ideintr();
+80105e36:	e8 a5 c3 ff ff       	call   801021e0 <ideintr>
+    lapiceoi();
+80105e3b:	e8 80 ca ff ff       	call   801028c0 <lapiceoi>
+  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+80105e40:	e8 1b db ff ff       	call   80103960 <myproc>
+80105e45:	85 c0                	test   %eax,%eax
+80105e47:	75 8a                	jne    80105dd3 <trap+0xa3>
+80105e49:	eb a5                	jmp    80105df0 <trap+0xc0>
+    if(cpuid() == 0){
+80105e4b:	e8 f0 da ff ff       	call   80103940 <cpuid>
+80105e50:	85 c0                	test   %eax,%eax
+80105e52:	75 e7                	jne    80105e3b <trap+0x10b>
+      acquire(&tickslock);
+80105e54:	83 ec 0c             	sub    $0xc,%esp
+80105e57:	68 60 4d 11 80       	push   $0x80114d60
+80105e5c:	e8 7f e9 ff ff       	call   801047e0 <acquire>
+      wakeup(&ticks);
+80105e61:	c7 04 24 a0 55 11 80 	movl   $0x801155a0,(%esp)
+      ticks++;
+80105e68:	83 05 a0 55 11 80 01 	addl   $0x1,0x801155a0
+      wakeup(&ticks);
+80105e6f:	e8 6c e2 ff ff       	call   801040e0 <wakeup>
+      release(&tickslock);
+80105e74:	c7 04 24 60 4d 11 80 	movl   $0x80114d60,(%esp)
+80105e7b:	e8 20 ea ff ff       	call   801048a0 <release>
+80105e80:	83 c4 10             	add    $0x10,%esp
+    lapiceoi();
+80105e83:	eb b6                	jmp    80105e3b <trap+0x10b>
+    kbdintr();
+80105e85:	e8 f6 c8 ff ff       	call   80102780 <kbdintr>
+    lapiceoi();
+80105e8a:	e8 31 ca ff ff       	call   801028c0 <lapiceoi>
+  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+80105e8f:	e8 cc da ff ff       	call   80103960 <myproc>
+80105e94:	85 c0                	test   %eax,%eax
+80105e96:	0f 85 37 ff ff ff    	jne    80105dd3 <trap+0xa3>
+80105e9c:	e9 4f ff ff ff       	jmp    80105df0 <trap+0xc0>
+    uartintr();
+80105ea1:	e8 4a 02 00 00       	call   801060f0 <uartintr>
+    lapiceoi();
+80105ea6:	e8 15 ca ff ff       	call   801028c0 <lapiceoi>
+  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+80105eab:	e8 b0 da ff ff       	call   80103960 <myproc>
+80105eb0:	85 c0                	test   %eax,%eax
+80105eb2:	0f 85 1b ff ff ff    	jne    80105dd3 <trap+0xa3>
+80105eb8:	e9 33 ff ff ff       	jmp    80105df0 <trap+0xc0>
+    cprintf("cpu%d: spurious interrupt at %x:%x\n",
+80105ebd:	8b 7b 38             	mov    0x38(%ebx),%edi
+80105ec0:	0f b7 73 3c          	movzwl 0x3c(%ebx),%esi
+80105ec4:	e8 77 da ff ff       	call   80103940 <cpuid>
+80105ec9:	57                   	push   %edi
+80105eca:	56                   	push   %esi
+80105ecb:	50                   	push   %eax
+80105ecc:	68 54 7c 10 80       	push   $0x80107c54
+80105ed1:	e8 da a7 ff ff       	call   801006b0 <cprintf>
+    lapiceoi();
+80105ed6:	e8 e5 c9 ff ff       	call   801028c0 <lapiceoi>
+    break;
+80105edb:	83 c4 10             	add    $0x10,%esp
+  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+80105ede:	e8 7d da ff ff       	call   80103960 <myproc>
+80105ee3:	85 c0                	test   %eax,%eax
+80105ee5:	0f 85 e8 fe ff ff    	jne    80105dd3 <trap+0xa3>
+80105eeb:	e9 00 ff ff ff       	jmp    80105df0 <trap+0xc0>
+  if(myproc() && myproc()->state == RUNNING &&
+80105ef0:	83 7b 30 20          	cmpl   $0x20,0x30(%ebx)
+80105ef4:	0f 85 0e ff ff ff    	jne    80105e08 <trap+0xd8>
+    yield();
+80105efa:	e8 d1 df ff ff       	call   80103ed0 <yield>
+80105eff:	e9 04 ff ff ff       	jmp    80105e08 <trap+0xd8>
+80105f04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    if(myproc()->killed)
+80105f08:	e8 53 da ff ff       	call   80103960 <myproc>
+80105f0d:	8b 70 24             	mov    0x24(%eax),%esi
+80105f10:	85 f6                	test   %esi,%esi
+80105f12:	75 3c                	jne    80105f50 <trap+0x220>
+    myproc()->tf = tf;
+80105f14:	e8 47 da ff ff       	call   80103960 <myproc>
+80105f19:	89 58 18             	mov    %ebx,0x18(%eax)
+    syscall();
+80105f1c:	e8 9f ed ff ff       	call   80104cc0 <syscall>
+    if(myproc()->killed)
+80105f21:	e8 3a da ff ff       	call   80103960 <myproc>
+80105f26:	8b 48 24             	mov    0x24(%eax),%ecx
+80105f29:	85 c9                	test   %ecx,%ecx
+80105f2b:	0f 84 fd fe ff ff    	je     80105e2e <trap+0xfe>
+}
+80105f31:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80105f34:	5b                   	pop    %ebx
+80105f35:	5e                   	pop    %esi
+80105f36:	5f                   	pop    %edi
+80105f37:	5d                   	pop    %ebp
+      exit();
+80105f38:	e9 53 de ff ff       	jmp    80103d90 <exit>
+80105f3d:	8d 76 00             	lea    0x0(%esi),%esi
+    exit();
+80105f40:	e8 4b de ff ff       	call   80103d90 <exit>
+80105f45:	e9 a6 fe ff ff       	jmp    80105df0 <trap+0xc0>
+80105f4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      exit();
+80105f50:	e8 3b de ff ff       	call   80103d90 <exit>
+80105f55:	eb bd                	jmp    80105f14 <trap+0x1e4>
+80105f57:	0f 20 d6             	mov    %cr2,%esi
+      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+80105f5a:	e8 e1 d9 ff ff       	call   80103940 <cpuid>
+80105f5f:	83 ec 0c             	sub    $0xc,%esp
+80105f62:	56                   	push   %esi
+80105f63:	57                   	push   %edi
+80105f64:	50                   	push   %eax
+80105f65:	ff 73 30             	pushl  0x30(%ebx)
+80105f68:	68 78 7c 10 80       	push   $0x80107c78
+80105f6d:	e8 3e a7 ff ff       	call   801006b0 <cprintf>
+      panic("trap");
+80105f72:	83 c4 14             	add    $0x14,%esp
+80105f75:	68 4e 7c 10 80       	push   $0x80107c4e
+80105f7a:	e8 11 a4 ff ff       	call   80100390 <panic>
+80105f7f:	90                   	nop
+
+80105f80 <uartgetc>:
+  outb(COM1+0, c);
+}
+
+static int
+uartgetc(void)
+{
+80105f80:	f3 0f 1e fb          	endbr32 
+  if(!uart)
+80105f84:	a1 bc a5 10 80       	mov    0x8010a5bc,%eax
+80105f89:	85 c0                	test   %eax,%eax
+80105f8b:	74 1b                	je     80105fa8 <uartgetc+0x28>
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80105f8d:	ba fd 03 00 00       	mov    $0x3fd,%edx
+80105f92:	ec                   	in     (%dx),%al
+    return -1;
+  if(!(inb(COM1+5) & 0x01))
+80105f93:	a8 01                	test   $0x1,%al
+80105f95:	74 11                	je     80105fa8 <uartgetc+0x28>
+80105f97:	ba f8 03 00 00       	mov    $0x3f8,%edx
+80105f9c:	ec                   	in     (%dx),%al
+    return -1;
+  return inb(COM1+0);
+80105f9d:	0f b6 c0             	movzbl %al,%eax
+80105fa0:	c3                   	ret    
+80105fa1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+80105fa8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80105fad:	c3                   	ret    
+80105fae:	66 90                	xchg   %ax,%ax
+
+80105fb0 <uartputc.part.0>:
+uartputc(int c)
+80105fb0:	55                   	push   %ebp
+80105fb1:	89 e5                	mov    %esp,%ebp
+80105fb3:	57                   	push   %edi
+80105fb4:	89 c7                	mov    %eax,%edi
+80105fb6:	56                   	push   %esi
+80105fb7:	be fd 03 00 00       	mov    $0x3fd,%esi
+80105fbc:	53                   	push   %ebx
+80105fbd:	bb 80 00 00 00       	mov    $0x80,%ebx
+80105fc2:	83 ec 0c             	sub    $0xc,%esp
+80105fc5:	eb 1b                	jmp    80105fe2 <uartputc.part.0+0x32>
+80105fc7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80105fce:	66 90                	xchg   %ax,%ax
+    microdelay(10);
+80105fd0:	83 ec 0c             	sub    $0xc,%esp
+80105fd3:	6a 0a                	push   $0xa
+80105fd5:	e8 06 c9 ff ff       	call   801028e0 <microdelay>
+  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
+80105fda:	83 c4 10             	add    $0x10,%esp
+80105fdd:	83 eb 01             	sub    $0x1,%ebx
+80105fe0:	74 07                	je     80105fe9 <uartputc.part.0+0x39>
+80105fe2:	89 f2                	mov    %esi,%edx
+80105fe4:	ec                   	in     (%dx),%al
+80105fe5:	a8 20                	test   $0x20,%al
+80105fe7:	74 e7                	je     80105fd0 <uartputc.part.0+0x20>
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80105fe9:	ba f8 03 00 00       	mov    $0x3f8,%edx
+80105fee:	89 f8                	mov    %edi,%eax
+80105ff0:	ee                   	out    %al,(%dx)
+}
+80105ff1:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80105ff4:	5b                   	pop    %ebx
+80105ff5:	5e                   	pop    %esi
+80105ff6:	5f                   	pop    %edi
+80105ff7:	5d                   	pop    %ebp
+80105ff8:	c3                   	ret    
+80105ff9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80106000 <uartinit>:
+{
+80106000:	f3 0f 1e fb          	endbr32 
+80106004:	55                   	push   %ebp
+80106005:	31 c9                	xor    %ecx,%ecx
+80106007:	89 c8                	mov    %ecx,%eax
+80106009:	89 e5                	mov    %esp,%ebp
+8010600b:	57                   	push   %edi
+8010600c:	56                   	push   %esi
+8010600d:	53                   	push   %ebx
+8010600e:	bb fa 03 00 00       	mov    $0x3fa,%ebx
+80106013:	89 da                	mov    %ebx,%edx
+80106015:	83 ec 0c             	sub    $0xc,%esp
+80106018:	ee                   	out    %al,(%dx)
+80106019:	bf fb 03 00 00       	mov    $0x3fb,%edi
+8010601e:	b8 80 ff ff ff       	mov    $0xffffff80,%eax
+80106023:	89 fa                	mov    %edi,%edx
+80106025:	ee                   	out    %al,(%dx)
+80106026:	b8 0c 00 00 00       	mov    $0xc,%eax
+8010602b:	ba f8 03 00 00       	mov    $0x3f8,%edx
+80106030:	ee                   	out    %al,(%dx)
+80106031:	be f9 03 00 00       	mov    $0x3f9,%esi
+80106036:	89 c8                	mov    %ecx,%eax
+80106038:	89 f2                	mov    %esi,%edx
+8010603a:	ee                   	out    %al,(%dx)
+8010603b:	b8 03 00 00 00       	mov    $0x3,%eax
+80106040:	89 fa                	mov    %edi,%edx
+80106042:	ee                   	out    %al,(%dx)
+80106043:	ba fc 03 00 00       	mov    $0x3fc,%edx
+80106048:	89 c8                	mov    %ecx,%eax
+8010604a:	ee                   	out    %al,(%dx)
+8010604b:	b8 01 00 00 00       	mov    $0x1,%eax
+80106050:	89 f2                	mov    %esi,%edx
+80106052:	ee                   	out    %al,(%dx)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80106053:	ba fd 03 00 00       	mov    $0x3fd,%edx
+80106058:	ec                   	in     (%dx),%al
+  if(inb(COM1+5) == 0xFF)
+80106059:	3c ff                	cmp    $0xff,%al
+8010605b:	74 52                	je     801060af <uartinit+0xaf>
+  uart = 1;
+8010605d:	c7 05 bc a5 10 80 01 	movl   $0x1,0x8010a5bc
+80106064:	00 00 00 
+80106067:	89 da                	mov    %ebx,%edx
+80106069:	ec                   	in     (%dx),%al
+8010606a:	ba f8 03 00 00       	mov    $0x3f8,%edx
+8010606f:	ec                   	in     (%dx),%al
+  ioapicenable(IRQ_COM1, 0);
+80106070:	83 ec 08             	sub    $0x8,%esp
+80106073:	be 76 00 00 00       	mov    $0x76,%esi
+  for(p="xv6...\n"; *p; p++)
+80106078:	bb 70 7d 10 80       	mov    $0x80107d70,%ebx
+  ioapicenable(IRQ_COM1, 0);
+8010607d:	6a 00                	push   $0x0
+8010607f:	6a 04                	push   $0x4
+80106081:	e8 aa c3 ff ff       	call   80102430 <ioapicenable>
+80106086:	83 c4 10             	add    $0x10,%esp
+  for(p="xv6...\n"; *p; p++)
+80106089:	b8 78 00 00 00       	mov    $0x78,%eax
+8010608e:	eb 04                	jmp    80106094 <uartinit+0x94>
+80106090:	0f b6 73 01          	movzbl 0x1(%ebx),%esi
+  if(!uart)
+80106094:	8b 15 bc a5 10 80    	mov    0x8010a5bc,%edx
+8010609a:	85 d2                	test   %edx,%edx
+8010609c:	74 08                	je     801060a6 <uartinit+0xa6>
+    uartputc(*p);
+8010609e:	0f be c0             	movsbl %al,%eax
+801060a1:	e8 0a ff ff ff       	call   80105fb0 <uartputc.part.0>
+  for(p="xv6...\n"; *p; p++)
+801060a6:	89 f0                	mov    %esi,%eax
+801060a8:	83 c3 01             	add    $0x1,%ebx
+801060ab:	84 c0                	test   %al,%al
+801060ad:	75 e1                	jne    80106090 <uartinit+0x90>
+}
+801060af:	8d 65 f4             	lea    -0xc(%ebp),%esp
+801060b2:	5b                   	pop    %ebx
+801060b3:	5e                   	pop    %esi
+801060b4:	5f                   	pop    %edi
+801060b5:	5d                   	pop    %ebp
+801060b6:	c3                   	ret    
+801060b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801060be:	66 90                	xchg   %ax,%ax
+
+801060c0 <uartputc>:
+{
+801060c0:	f3 0f 1e fb          	endbr32 
+801060c4:	55                   	push   %ebp
+  if(!uart)
+801060c5:	8b 15 bc a5 10 80    	mov    0x8010a5bc,%edx
+{
+801060cb:	89 e5                	mov    %esp,%ebp
+801060cd:	8b 45 08             	mov    0x8(%ebp),%eax
+  if(!uart)
+801060d0:	85 d2                	test   %edx,%edx
+801060d2:	74 0c                	je     801060e0 <uartputc+0x20>
+}
+801060d4:	5d                   	pop    %ebp
+801060d5:	e9 d6 fe ff ff       	jmp    80105fb0 <uartputc.part.0>
+801060da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+801060e0:	5d                   	pop    %ebp
+801060e1:	c3                   	ret    
+801060e2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801060e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+801060f0 <uartintr>:
+
+void
+uartintr(void)
+{
+801060f0:	f3 0f 1e fb          	endbr32 
+801060f4:	55                   	push   %ebp
+801060f5:	89 e5                	mov    %esp,%ebp
+801060f7:	83 ec 14             	sub    $0x14,%esp
+  consoleintr(uartgetc);
+801060fa:	68 80 5f 10 80       	push   $0x80105f80
+801060ff:	e8 5c a7 ff ff       	call   80100860 <consoleintr>
+}
+80106104:	83 c4 10             	add    $0x10,%esp
+80106107:	c9                   	leave  
+80106108:	c3                   	ret    
+
+80106109 <vector0>:
+# generated by vectors.pl - do not edit
+# handlers
+.globl alltraps
+.globl vector0
+vector0:
+  pushl $0
+80106109:	6a 00                	push   $0x0
+  pushl $0
+8010610b:	6a 00                	push   $0x0
+  jmp alltraps
+8010610d:	e9 3d fb ff ff       	jmp    80105c4f <alltraps>
+
+80106112 <vector1>:
+.globl vector1
+vector1:
+  pushl $0
+80106112:	6a 00                	push   $0x0
+  pushl $1
+80106114:	6a 01                	push   $0x1
+  jmp alltraps
+80106116:	e9 34 fb ff ff       	jmp    80105c4f <alltraps>
+
+8010611b <vector2>:
+.globl vector2
+vector2:
+  pushl $0
+8010611b:	6a 00                	push   $0x0
+  pushl $2
+8010611d:	6a 02                	push   $0x2
+  jmp alltraps
+8010611f:	e9 2b fb ff ff       	jmp    80105c4f <alltraps>
+
+80106124 <vector3>:
+.globl vector3
+vector3:
+  pushl $0
+80106124:	6a 00                	push   $0x0
+  pushl $3
+80106126:	6a 03                	push   $0x3
+  jmp alltraps
+80106128:	e9 22 fb ff ff       	jmp    80105c4f <alltraps>
+
+8010612d <vector4>:
+.globl vector4
+vector4:
+  pushl $0
+8010612d:	6a 00                	push   $0x0
+  pushl $4
+8010612f:	6a 04                	push   $0x4
+  jmp alltraps
+80106131:	e9 19 fb ff ff       	jmp    80105c4f <alltraps>
+
+80106136 <vector5>:
+.globl vector5
+vector5:
+  pushl $0
+80106136:	6a 00                	push   $0x0
+  pushl $5
+80106138:	6a 05                	push   $0x5
+  jmp alltraps
+8010613a:	e9 10 fb ff ff       	jmp    80105c4f <alltraps>
+
+8010613f <vector6>:
+.globl vector6
+vector6:
+  pushl $0
+8010613f:	6a 00                	push   $0x0
+  pushl $6
+80106141:	6a 06                	push   $0x6
+  jmp alltraps
+80106143:	e9 07 fb ff ff       	jmp    80105c4f <alltraps>
+
+80106148 <vector7>:
+.globl vector7
+vector7:
+  pushl $0
+80106148:	6a 00                	push   $0x0
+  pushl $7
+8010614a:	6a 07                	push   $0x7
+  jmp alltraps
+8010614c:	e9 fe fa ff ff       	jmp    80105c4f <alltraps>
+
+80106151 <vector8>:
+.globl vector8
+vector8:
+  pushl $8
+80106151:	6a 08                	push   $0x8
+  jmp alltraps
+80106153:	e9 f7 fa ff ff       	jmp    80105c4f <alltraps>
+
+80106158 <vector9>:
+.globl vector9
+vector9:
+  pushl $0
+80106158:	6a 00                	push   $0x0
+  pushl $9
+8010615a:	6a 09                	push   $0x9
+  jmp alltraps
+8010615c:	e9 ee fa ff ff       	jmp    80105c4f <alltraps>
+
+80106161 <vector10>:
+.globl vector10
+vector10:
+  pushl $10
+80106161:	6a 0a                	push   $0xa
+  jmp alltraps
+80106163:	e9 e7 fa ff ff       	jmp    80105c4f <alltraps>
+
+80106168 <vector11>:
+.globl vector11
+vector11:
+  pushl $11
+80106168:	6a 0b                	push   $0xb
+  jmp alltraps
+8010616a:	e9 e0 fa ff ff       	jmp    80105c4f <alltraps>
+
+8010616f <vector12>:
+.globl vector12
+vector12:
+  pushl $12
+8010616f:	6a 0c                	push   $0xc
+  jmp alltraps
+80106171:	e9 d9 fa ff ff       	jmp    80105c4f <alltraps>
+
+80106176 <vector13>:
+.globl vector13
+vector13:
+  pushl $13
+80106176:	6a 0d                	push   $0xd
+  jmp alltraps
+80106178:	e9 d2 fa ff ff       	jmp    80105c4f <alltraps>
+
+8010617d <vector14>:
+.globl vector14
+vector14:
+  pushl $14
+8010617d:	6a 0e                	push   $0xe
+  jmp alltraps
+8010617f:	e9 cb fa ff ff       	jmp    80105c4f <alltraps>
+
+80106184 <vector15>:
+.globl vector15
+vector15:
+  pushl $0
+80106184:	6a 00                	push   $0x0
+  pushl $15
+80106186:	6a 0f                	push   $0xf
+  jmp alltraps
+80106188:	e9 c2 fa ff ff       	jmp    80105c4f <alltraps>
+
+8010618d <vector16>:
+.globl vector16
+vector16:
+  pushl $0
+8010618d:	6a 00                	push   $0x0
+  pushl $16
+8010618f:	6a 10                	push   $0x10
+  jmp alltraps
+80106191:	e9 b9 fa ff ff       	jmp    80105c4f <alltraps>
+
+80106196 <vector17>:
+.globl vector17
+vector17:
+  pushl $17
+80106196:	6a 11                	push   $0x11
+  jmp alltraps
+80106198:	e9 b2 fa ff ff       	jmp    80105c4f <alltraps>
+
+8010619d <vector18>:
+.globl vector18
+vector18:
+  pushl $0
+8010619d:	6a 00                	push   $0x0
+  pushl $18
+8010619f:	6a 12                	push   $0x12
+  jmp alltraps
+801061a1:	e9 a9 fa ff ff       	jmp    80105c4f <alltraps>
+
+801061a6 <vector19>:
+.globl vector19
+vector19:
+  pushl $0
+801061a6:	6a 00                	push   $0x0
+  pushl $19
+801061a8:	6a 13                	push   $0x13
+  jmp alltraps
+801061aa:	e9 a0 fa ff ff       	jmp    80105c4f <alltraps>
+
+801061af <vector20>:
+.globl vector20
+vector20:
+  pushl $0
+801061af:	6a 00                	push   $0x0
+  pushl $20
+801061b1:	6a 14                	push   $0x14
+  jmp alltraps
+801061b3:	e9 97 fa ff ff       	jmp    80105c4f <alltraps>
+
+801061b8 <vector21>:
+.globl vector21
+vector21:
+  pushl $0
+801061b8:	6a 00                	push   $0x0
+  pushl $21
+801061ba:	6a 15                	push   $0x15
+  jmp alltraps
+801061bc:	e9 8e fa ff ff       	jmp    80105c4f <alltraps>
+
+801061c1 <vector22>:
+.globl vector22
+vector22:
+  pushl $0
+801061c1:	6a 00                	push   $0x0
+  pushl $22
+801061c3:	6a 16                	push   $0x16
+  jmp alltraps
+801061c5:	e9 85 fa ff ff       	jmp    80105c4f <alltraps>
+
+801061ca <vector23>:
+.globl vector23
+vector23:
+  pushl $0
+801061ca:	6a 00                	push   $0x0
+  pushl $23
+801061cc:	6a 17                	push   $0x17
+  jmp alltraps
+801061ce:	e9 7c fa ff ff       	jmp    80105c4f <alltraps>
+
+801061d3 <vector24>:
+.globl vector24
+vector24:
+  pushl $0
+801061d3:	6a 00                	push   $0x0
+  pushl $24
+801061d5:	6a 18                	push   $0x18
+  jmp alltraps
+801061d7:	e9 73 fa ff ff       	jmp    80105c4f <alltraps>
+
+801061dc <vector25>:
+.globl vector25
+vector25:
+  pushl $0
+801061dc:	6a 00                	push   $0x0
+  pushl $25
+801061de:	6a 19                	push   $0x19
+  jmp alltraps
+801061e0:	e9 6a fa ff ff       	jmp    80105c4f <alltraps>
+
+801061e5 <vector26>:
+.globl vector26
+vector26:
+  pushl $0
+801061e5:	6a 00                	push   $0x0
+  pushl $26
+801061e7:	6a 1a                	push   $0x1a
+  jmp alltraps
+801061e9:	e9 61 fa ff ff       	jmp    80105c4f <alltraps>
+
+801061ee <vector27>:
+.globl vector27
+vector27:
+  pushl $0
+801061ee:	6a 00                	push   $0x0
+  pushl $27
+801061f0:	6a 1b                	push   $0x1b
+  jmp alltraps
+801061f2:	e9 58 fa ff ff       	jmp    80105c4f <alltraps>
+
+801061f7 <vector28>:
+.globl vector28
+vector28:
+  pushl $0
+801061f7:	6a 00                	push   $0x0
+  pushl $28
+801061f9:	6a 1c                	push   $0x1c
+  jmp alltraps
+801061fb:	e9 4f fa ff ff       	jmp    80105c4f <alltraps>
+
+80106200 <vector29>:
+.globl vector29
+vector29:
+  pushl $0
+80106200:	6a 00                	push   $0x0
+  pushl $29
+80106202:	6a 1d                	push   $0x1d
+  jmp alltraps
+80106204:	e9 46 fa ff ff       	jmp    80105c4f <alltraps>
+
+80106209 <vector30>:
+.globl vector30
+vector30:
+  pushl $0
+80106209:	6a 00                	push   $0x0
+  pushl $30
+8010620b:	6a 1e                	push   $0x1e
+  jmp alltraps
+8010620d:	e9 3d fa ff ff       	jmp    80105c4f <alltraps>
+
+80106212 <vector31>:
+.globl vector31
+vector31:
+  pushl $0
+80106212:	6a 00                	push   $0x0
+  pushl $31
+80106214:	6a 1f                	push   $0x1f
+  jmp alltraps
+80106216:	e9 34 fa ff ff       	jmp    80105c4f <alltraps>
+
+8010621b <vector32>:
+.globl vector32
+vector32:
+  pushl $0
+8010621b:	6a 00                	push   $0x0
+  pushl $32
+8010621d:	6a 20                	push   $0x20
+  jmp alltraps
+8010621f:	e9 2b fa ff ff       	jmp    80105c4f <alltraps>
+
+80106224 <vector33>:
+.globl vector33
+vector33:
+  pushl $0
+80106224:	6a 00                	push   $0x0
+  pushl $33
+80106226:	6a 21                	push   $0x21
+  jmp alltraps
+80106228:	e9 22 fa ff ff       	jmp    80105c4f <alltraps>
+
+8010622d <vector34>:
+.globl vector34
+vector34:
+  pushl $0
+8010622d:	6a 00                	push   $0x0
+  pushl $34
+8010622f:	6a 22                	push   $0x22
+  jmp alltraps
+80106231:	e9 19 fa ff ff       	jmp    80105c4f <alltraps>
+
+80106236 <vector35>:
+.globl vector35
+vector35:
+  pushl $0
+80106236:	6a 00                	push   $0x0
+  pushl $35
+80106238:	6a 23                	push   $0x23
+  jmp alltraps
+8010623a:	e9 10 fa ff ff       	jmp    80105c4f <alltraps>
+
+8010623f <vector36>:
+.globl vector36
+vector36:
+  pushl $0
+8010623f:	6a 00                	push   $0x0
+  pushl $36
+80106241:	6a 24                	push   $0x24
+  jmp alltraps
+80106243:	e9 07 fa ff ff       	jmp    80105c4f <alltraps>
+
+80106248 <vector37>:
+.globl vector37
+vector37:
+  pushl $0
+80106248:	6a 00                	push   $0x0
+  pushl $37
+8010624a:	6a 25                	push   $0x25
+  jmp alltraps
+8010624c:	e9 fe f9 ff ff       	jmp    80105c4f <alltraps>
+
+80106251 <vector38>:
+.globl vector38
+vector38:
+  pushl $0
+80106251:	6a 00                	push   $0x0
+  pushl $38
+80106253:	6a 26                	push   $0x26
+  jmp alltraps
+80106255:	e9 f5 f9 ff ff       	jmp    80105c4f <alltraps>
+
+8010625a <vector39>:
+.globl vector39
+vector39:
+  pushl $0
+8010625a:	6a 00                	push   $0x0
+  pushl $39
+8010625c:	6a 27                	push   $0x27
+  jmp alltraps
+8010625e:	e9 ec f9 ff ff       	jmp    80105c4f <alltraps>
+
+80106263 <vector40>:
+.globl vector40
+vector40:
+  pushl $0
+80106263:	6a 00                	push   $0x0
+  pushl $40
+80106265:	6a 28                	push   $0x28
+  jmp alltraps
+80106267:	e9 e3 f9 ff ff       	jmp    80105c4f <alltraps>
+
+8010626c <vector41>:
+.globl vector41
+vector41:
+  pushl $0
+8010626c:	6a 00                	push   $0x0
+  pushl $41
+8010626e:	6a 29                	push   $0x29
+  jmp alltraps
+80106270:	e9 da f9 ff ff       	jmp    80105c4f <alltraps>
+
+80106275 <vector42>:
+.globl vector42
+vector42:
+  pushl $0
+80106275:	6a 00                	push   $0x0
+  pushl $42
+80106277:	6a 2a                	push   $0x2a
+  jmp alltraps
+80106279:	e9 d1 f9 ff ff       	jmp    80105c4f <alltraps>
+
+8010627e <vector43>:
+.globl vector43
+vector43:
+  pushl $0
+8010627e:	6a 00                	push   $0x0
+  pushl $43
+80106280:	6a 2b                	push   $0x2b
+  jmp alltraps
+80106282:	e9 c8 f9 ff ff       	jmp    80105c4f <alltraps>
+
+80106287 <vector44>:
+.globl vector44
+vector44:
+  pushl $0
+80106287:	6a 00                	push   $0x0
+  pushl $44
+80106289:	6a 2c                	push   $0x2c
+  jmp alltraps
+8010628b:	e9 bf f9 ff ff       	jmp    80105c4f <alltraps>
+
+80106290 <vector45>:
+.globl vector45
+vector45:
+  pushl $0
+80106290:	6a 00                	push   $0x0
+  pushl $45
+80106292:	6a 2d                	push   $0x2d
+  jmp alltraps
+80106294:	e9 b6 f9 ff ff       	jmp    80105c4f <alltraps>
+
+80106299 <vector46>:
+.globl vector46
+vector46:
+  pushl $0
+80106299:	6a 00                	push   $0x0
+  pushl $46
+8010629b:	6a 2e                	push   $0x2e
+  jmp alltraps
+8010629d:	e9 ad f9 ff ff       	jmp    80105c4f <alltraps>
+
+801062a2 <vector47>:
+.globl vector47
+vector47:
+  pushl $0
+801062a2:	6a 00                	push   $0x0
+  pushl $47
+801062a4:	6a 2f                	push   $0x2f
+  jmp alltraps
+801062a6:	e9 a4 f9 ff ff       	jmp    80105c4f <alltraps>
+
+801062ab <vector48>:
+.globl vector48
+vector48:
+  pushl $0
+801062ab:	6a 00                	push   $0x0
+  pushl $48
+801062ad:	6a 30                	push   $0x30
+  jmp alltraps
+801062af:	e9 9b f9 ff ff       	jmp    80105c4f <alltraps>
+
+801062b4 <vector49>:
+.globl vector49
+vector49:
+  pushl $0
+801062b4:	6a 00                	push   $0x0
+  pushl $49
+801062b6:	6a 31                	push   $0x31
+  jmp alltraps
+801062b8:	e9 92 f9 ff ff       	jmp    80105c4f <alltraps>
+
+801062bd <vector50>:
+.globl vector50
+vector50:
+  pushl $0
+801062bd:	6a 00                	push   $0x0
+  pushl $50
+801062bf:	6a 32                	push   $0x32
+  jmp alltraps
+801062c1:	e9 89 f9 ff ff       	jmp    80105c4f <alltraps>
+
+801062c6 <vector51>:
+.globl vector51
+vector51:
+  pushl $0
+801062c6:	6a 00                	push   $0x0
+  pushl $51
+801062c8:	6a 33                	push   $0x33
+  jmp alltraps
+801062ca:	e9 80 f9 ff ff       	jmp    80105c4f <alltraps>
+
+801062cf <vector52>:
+.globl vector52
+vector52:
+  pushl $0
+801062cf:	6a 00                	push   $0x0
+  pushl $52
+801062d1:	6a 34                	push   $0x34
+  jmp alltraps
+801062d3:	e9 77 f9 ff ff       	jmp    80105c4f <alltraps>
+
+801062d8 <vector53>:
+.globl vector53
+vector53:
+  pushl $0
+801062d8:	6a 00                	push   $0x0
+  pushl $53
+801062da:	6a 35                	push   $0x35
+  jmp alltraps
+801062dc:	e9 6e f9 ff ff       	jmp    80105c4f <alltraps>
+
+801062e1 <vector54>:
+.globl vector54
+vector54:
+  pushl $0
+801062e1:	6a 00                	push   $0x0
+  pushl $54
+801062e3:	6a 36                	push   $0x36
+  jmp alltraps
+801062e5:	e9 65 f9 ff ff       	jmp    80105c4f <alltraps>
+
+801062ea <vector55>:
+.globl vector55
+vector55:
+  pushl $0
+801062ea:	6a 00                	push   $0x0
+  pushl $55
+801062ec:	6a 37                	push   $0x37
+  jmp alltraps
+801062ee:	e9 5c f9 ff ff       	jmp    80105c4f <alltraps>
+
+801062f3 <vector56>:
+.globl vector56
+vector56:
+  pushl $0
+801062f3:	6a 00                	push   $0x0
+  pushl $56
+801062f5:	6a 38                	push   $0x38
+  jmp alltraps
+801062f7:	e9 53 f9 ff ff       	jmp    80105c4f <alltraps>
+
+801062fc <vector57>:
+.globl vector57
+vector57:
+  pushl $0
+801062fc:	6a 00                	push   $0x0
+  pushl $57
+801062fe:	6a 39                	push   $0x39
+  jmp alltraps
+80106300:	e9 4a f9 ff ff       	jmp    80105c4f <alltraps>
+
+80106305 <vector58>:
+.globl vector58
+vector58:
+  pushl $0
+80106305:	6a 00                	push   $0x0
+  pushl $58
+80106307:	6a 3a                	push   $0x3a
+  jmp alltraps
+80106309:	e9 41 f9 ff ff       	jmp    80105c4f <alltraps>
+
+8010630e <vector59>:
+.globl vector59
+vector59:
+  pushl $0
+8010630e:	6a 00                	push   $0x0
+  pushl $59
+80106310:	6a 3b                	push   $0x3b
+  jmp alltraps
+80106312:	e9 38 f9 ff ff       	jmp    80105c4f <alltraps>
+
+80106317 <vector60>:
+.globl vector60
+vector60:
+  pushl $0
+80106317:	6a 00                	push   $0x0
+  pushl $60
+80106319:	6a 3c                	push   $0x3c
+  jmp alltraps
+8010631b:	e9 2f f9 ff ff       	jmp    80105c4f <alltraps>
+
+80106320 <vector61>:
+.globl vector61
+vector61:
+  pushl $0
+80106320:	6a 00                	push   $0x0
+  pushl $61
+80106322:	6a 3d                	push   $0x3d
+  jmp alltraps
+80106324:	e9 26 f9 ff ff       	jmp    80105c4f <alltraps>
+
+80106329 <vector62>:
+.globl vector62
+vector62:
+  pushl $0
+80106329:	6a 00                	push   $0x0
+  pushl $62
+8010632b:	6a 3e                	push   $0x3e
+  jmp alltraps
+8010632d:	e9 1d f9 ff ff       	jmp    80105c4f <alltraps>
+
+80106332 <vector63>:
+.globl vector63
+vector63:
+  pushl $0
+80106332:	6a 00                	push   $0x0
+  pushl $63
+80106334:	6a 3f                	push   $0x3f
+  jmp alltraps
+80106336:	e9 14 f9 ff ff       	jmp    80105c4f <alltraps>
+
+8010633b <vector64>:
+.globl vector64
+vector64:
+  pushl $0
+8010633b:	6a 00                	push   $0x0
+  pushl $64
+8010633d:	6a 40                	push   $0x40
+  jmp alltraps
+8010633f:	e9 0b f9 ff ff       	jmp    80105c4f <alltraps>
+
+80106344 <vector65>:
+.globl vector65
+vector65:
+  pushl $0
+80106344:	6a 00                	push   $0x0
+  pushl $65
+80106346:	6a 41                	push   $0x41
+  jmp alltraps
+80106348:	e9 02 f9 ff ff       	jmp    80105c4f <alltraps>
+
+8010634d <vector66>:
+.globl vector66
+vector66:
+  pushl $0
+8010634d:	6a 00                	push   $0x0
+  pushl $66
+8010634f:	6a 42                	push   $0x42
+  jmp alltraps
+80106351:	e9 f9 f8 ff ff       	jmp    80105c4f <alltraps>
+
+80106356 <vector67>:
+.globl vector67
+vector67:
+  pushl $0
+80106356:	6a 00                	push   $0x0
+  pushl $67
+80106358:	6a 43                	push   $0x43
+  jmp alltraps
+8010635a:	e9 f0 f8 ff ff       	jmp    80105c4f <alltraps>
+
+8010635f <vector68>:
+.globl vector68
+vector68:
+  pushl $0
+8010635f:	6a 00                	push   $0x0
+  pushl $68
+80106361:	6a 44                	push   $0x44
+  jmp alltraps
+80106363:	e9 e7 f8 ff ff       	jmp    80105c4f <alltraps>
+
+80106368 <vector69>:
+.globl vector69
+vector69:
+  pushl $0
+80106368:	6a 00                	push   $0x0
+  pushl $69
+8010636a:	6a 45                	push   $0x45
+  jmp alltraps
+8010636c:	e9 de f8 ff ff       	jmp    80105c4f <alltraps>
+
+80106371 <vector70>:
+.globl vector70
+vector70:
+  pushl $0
+80106371:	6a 00                	push   $0x0
+  pushl $70
+80106373:	6a 46                	push   $0x46
+  jmp alltraps
+80106375:	e9 d5 f8 ff ff       	jmp    80105c4f <alltraps>
+
+8010637a <vector71>:
+.globl vector71
+vector71:
+  pushl $0
+8010637a:	6a 00                	push   $0x0
+  pushl $71
+8010637c:	6a 47                	push   $0x47
+  jmp alltraps
+8010637e:	e9 cc f8 ff ff       	jmp    80105c4f <alltraps>
+
+80106383 <vector72>:
+.globl vector72
+vector72:
+  pushl $0
+80106383:	6a 00                	push   $0x0
+  pushl $72
+80106385:	6a 48                	push   $0x48
+  jmp alltraps
+80106387:	e9 c3 f8 ff ff       	jmp    80105c4f <alltraps>
+
+8010638c <vector73>:
+.globl vector73
+vector73:
+  pushl $0
+8010638c:	6a 00                	push   $0x0
+  pushl $73
+8010638e:	6a 49                	push   $0x49
+  jmp alltraps
+80106390:	e9 ba f8 ff ff       	jmp    80105c4f <alltraps>
+
+80106395 <vector74>:
+.globl vector74
+vector74:
+  pushl $0
+80106395:	6a 00                	push   $0x0
+  pushl $74
+80106397:	6a 4a                	push   $0x4a
+  jmp alltraps
+80106399:	e9 b1 f8 ff ff       	jmp    80105c4f <alltraps>
+
+8010639e <vector75>:
+.globl vector75
+vector75:
+  pushl $0
+8010639e:	6a 00                	push   $0x0
+  pushl $75
+801063a0:	6a 4b                	push   $0x4b
+  jmp alltraps
+801063a2:	e9 a8 f8 ff ff       	jmp    80105c4f <alltraps>
+
+801063a7 <vector76>:
+.globl vector76
+vector76:
+  pushl $0
+801063a7:	6a 00                	push   $0x0
+  pushl $76
+801063a9:	6a 4c                	push   $0x4c
+  jmp alltraps
+801063ab:	e9 9f f8 ff ff       	jmp    80105c4f <alltraps>
+
+801063b0 <vector77>:
+.globl vector77
+vector77:
+  pushl $0
+801063b0:	6a 00                	push   $0x0
+  pushl $77
+801063b2:	6a 4d                	push   $0x4d
+  jmp alltraps
+801063b4:	e9 96 f8 ff ff       	jmp    80105c4f <alltraps>
+
+801063b9 <vector78>:
+.globl vector78
+vector78:
+  pushl $0
+801063b9:	6a 00                	push   $0x0
+  pushl $78
+801063bb:	6a 4e                	push   $0x4e
+  jmp alltraps
+801063bd:	e9 8d f8 ff ff       	jmp    80105c4f <alltraps>
+
+801063c2 <vector79>:
+.globl vector79
+vector79:
+  pushl $0
+801063c2:	6a 00                	push   $0x0
+  pushl $79
+801063c4:	6a 4f                	push   $0x4f
+  jmp alltraps
+801063c6:	e9 84 f8 ff ff       	jmp    80105c4f <alltraps>
+
+801063cb <vector80>:
+.globl vector80
+vector80:
+  pushl $0
+801063cb:	6a 00                	push   $0x0
+  pushl $80
+801063cd:	6a 50                	push   $0x50
+  jmp alltraps
+801063cf:	e9 7b f8 ff ff       	jmp    80105c4f <alltraps>
+
+801063d4 <vector81>:
+.globl vector81
+vector81:
+  pushl $0
+801063d4:	6a 00                	push   $0x0
+  pushl $81
+801063d6:	6a 51                	push   $0x51
+  jmp alltraps
+801063d8:	e9 72 f8 ff ff       	jmp    80105c4f <alltraps>
+
+801063dd <vector82>:
+.globl vector82
+vector82:
+  pushl $0
+801063dd:	6a 00                	push   $0x0
+  pushl $82
+801063df:	6a 52                	push   $0x52
+  jmp alltraps
+801063e1:	e9 69 f8 ff ff       	jmp    80105c4f <alltraps>
+
+801063e6 <vector83>:
+.globl vector83
+vector83:
+  pushl $0
+801063e6:	6a 00                	push   $0x0
+  pushl $83
+801063e8:	6a 53                	push   $0x53
+  jmp alltraps
+801063ea:	e9 60 f8 ff ff       	jmp    80105c4f <alltraps>
+
+801063ef <vector84>:
+.globl vector84
+vector84:
+  pushl $0
+801063ef:	6a 00                	push   $0x0
+  pushl $84
+801063f1:	6a 54                	push   $0x54
+  jmp alltraps
+801063f3:	e9 57 f8 ff ff       	jmp    80105c4f <alltraps>
+
+801063f8 <vector85>:
+.globl vector85
+vector85:
+  pushl $0
+801063f8:	6a 00                	push   $0x0
+  pushl $85
+801063fa:	6a 55                	push   $0x55
+  jmp alltraps
+801063fc:	e9 4e f8 ff ff       	jmp    80105c4f <alltraps>
+
+80106401 <vector86>:
+.globl vector86
+vector86:
+  pushl $0
+80106401:	6a 00                	push   $0x0
+  pushl $86
+80106403:	6a 56                	push   $0x56
+  jmp alltraps
+80106405:	e9 45 f8 ff ff       	jmp    80105c4f <alltraps>
+
+8010640a <vector87>:
+.globl vector87
+vector87:
+  pushl $0
+8010640a:	6a 00                	push   $0x0
+  pushl $87
+8010640c:	6a 57                	push   $0x57
+  jmp alltraps
+8010640e:	e9 3c f8 ff ff       	jmp    80105c4f <alltraps>
+
+80106413 <vector88>:
+.globl vector88
+vector88:
+  pushl $0
+80106413:	6a 00                	push   $0x0
+  pushl $88
+80106415:	6a 58                	push   $0x58
+  jmp alltraps
+80106417:	e9 33 f8 ff ff       	jmp    80105c4f <alltraps>
+
+8010641c <vector89>:
+.globl vector89
+vector89:
+  pushl $0
+8010641c:	6a 00                	push   $0x0
+  pushl $89
+8010641e:	6a 59                	push   $0x59
+  jmp alltraps
+80106420:	e9 2a f8 ff ff       	jmp    80105c4f <alltraps>
+
+80106425 <vector90>:
+.globl vector90
+vector90:
+  pushl $0
+80106425:	6a 00                	push   $0x0
+  pushl $90
+80106427:	6a 5a                	push   $0x5a
+  jmp alltraps
+80106429:	e9 21 f8 ff ff       	jmp    80105c4f <alltraps>
+
+8010642e <vector91>:
+.globl vector91
+vector91:
+  pushl $0
+8010642e:	6a 00                	push   $0x0
+  pushl $91
+80106430:	6a 5b                	push   $0x5b
+  jmp alltraps
+80106432:	e9 18 f8 ff ff       	jmp    80105c4f <alltraps>
+
+80106437 <vector92>:
+.globl vector92
+vector92:
+  pushl $0
+80106437:	6a 00                	push   $0x0
+  pushl $92
+80106439:	6a 5c                	push   $0x5c
+  jmp alltraps
+8010643b:	e9 0f f8 ff ff       	jmp    80105c4f <alltraps>
+
+80106440 <vector93>:
+.globl vector93
+vector93:
+  pushl $0
+80106440:	6a 00                	push   $0x0
+  pushl $93
+80106442:	6a 5d                	push   $0x5d
+  jmp alltraps
+80106444:	e9 06 f8 ff ff       	jmp    80105c4f <alltraps>
+
+80106449 <vector94>:
+.globl vector94
+vector94:
+  pushl $0
+80106449:	6a 00                	push   $0x0
+  pushl $94
+8010644b:	6a 5e                	push   $0x5e
+  jmp alltraps
+8010644d:	e9 fd f7 ff ff       	jmp    80105c4f <alltraps>
+
+80106452 <vector95>:
+.globl vector95
+vector95:
+  pushl $0
+80106452:	6a 00                	push   $0x0
+  pushl $95
+80106454:	6a 5f                	push   $0x5f
+  jmp alltraps
+80106456:	e9 f4 f7 ff ff       	jmp    80105c4f <alltraps>
+
+8010645b <vector96>:
+.globl vector96
+vector96:
+  pushl $0
+8010645b:	6a 00                	push   $0x0
+  pushl $96
+8010645d:	6a 60                	push   $0x60
+  jmp alltraps
+8010645f:	e9 eb f7 ff ff       	jmp    80105c4f <alltraps>
+
+80106464 <vector97>:
+.globl vector97
+vector97:
+  pushl $0
+80106464:	6a 00                	push   $0x0
+  pushl $97
+80106466:	6a 61                	push   $0x61
+  jmp alltraps
+80106468:	e9 e2 f7 ff ff       	jmp    80105c4f <alltraps>
+
+8010646d <vector98>:
+.globl vector98
+vector98:
+  pushl $0
+8010646d:	6a 00                	push   $0x0
+  pushl $98
+8010646f:	6a 62                	push   $0x62
+  jmp alltraps
+80106471:	e9 d9 f7 ff ff       	jmp    80105c4f <alltraps>
+
+80106476 <vector99>:
+.globl vector99
+vector99:
+  pushl $0
+80106476:	6a 00                	push   $0x0
+  pushl $99
+80106478:	6a 63                	push   $0x63
+  jmp alltraps
+8010647a:	e9 d0 f7 ff ff       	jmp    80105c4f <alltraps>
+
+8010647f <vector100>:
+.globl vector100
+vector100:
+  pushl $0
+8010647f:	6a 00                	push   $0x0
+  pushl $100
+80106481:	6a 64                	push   $0x64
+  jmp alltraps
+80106483:	e9 c7 f7 ff ff       	jmp    80105c4f <alltraps>
+
+80106488 <vector101>:
+.globl vector101
+vector101:
+  pushl $0
+80106488:	6a 00                	push   $0x0
+  pushl $101
+8010648a:	6a 65                	push   $0x65
+  jmp alltraps
+8010648c:	e9 be f7 ff ff       	jmp    80105c4f <alltraps>
+
+80106491 <vector102>:
+.globl vector102
+vector102:
+  pushl $0
+80106491:	6a 00                	push   $0x0
+  pushl $102
+80106493:	6a 66                	push   $0x66
+  jmp alltraps
+80106495:	e9 b5 f7 ff ff       	jmp    80105c4f <alltraps>
+
+8010649a <vector103>:
+.globl vector103
+vector103:
+  pushl $0
+8010649a:	6a 00                	push   $0x0
+  pushl $103
+8010649c:	6a 67                	push   $0x67
+  jmp alltraps
+8010649e:	e9 ac f7 ff ff       	jmp    80105c4f <alltraps>
+
+801064a3 <vector104>:
+.globl vector104
+vector104:
+  pushl $0
+801064a3:	6a 00                	push   $0x0
+  pushl $104
+801064a5:	6a 68                	push   $0x68
+  jmp alltraps
+801064a7:	e9 a3 f7 ff ff       	jmp    80105c4f <alltraps>
+
+801064ac <vector105>:
+.globl vector105
+vector105:
+  pushl $0
+801064ac:	6a 00                	push   $0x0
+  pushl $105
+801064ae:	6a 69                	push   $0x69
+  jmp alltraps
+801064b0:	e9 9a f7 ff ff       	jmp    80105c4f <alltraps>
+
+801064b5 <vector106>:
+.globl vector106
+vector106:
+  pushl $0
+801064b5:	6a 00                	push   $0x0
+  pushl $106
+801064b7:	6a 6a                	push   $0x6a
+  jmp alltraps
+801064b9:	e9 91 f7 ff ff       	jmp    80105c4f <alltraps>
+
+801064be <vector107>:
+.globl vector107
+vector107:
+  pushl $0
+801064be:	6a 00                	push   $0x0
+  pushl $107
+801064c0:	6a 6b                	push   $0x6b
+  jmp alltraps
+801064c2:	e9 88 f7 ff ff       	jmp    80105c4f <alltraps>
+
+801064c7 <vector108>:
+.globl vector108
+vector108:
+  pushl $0
+801064c7:	6a 00                	push   $0x0
+  pushl $108
+801064c9:	6a 6c                	push   $0x6c
+  jmp alltraps
+801064cb:	e9 7f f7 ff ff       	jmp    80105c4f <alltraps>
+
+801064d0 <vector109>:
+.globl vector109
+vector109:
+  pushl $0
+801064d0:	6a 00                	push   $0x0
+  pushl $109
+801064d2:	6a 6d                	push   $0x6d
+  jmp alltraps
+801064d4:	e9 76 f7 ff ff       	jmp    80105c4f <alltraps>
+
+801064d9 <vector110>:
+.globl vector110
+vector110:
+  pushl $0
+801064d9:	6a 00                	push   $0x0
+  pushl $110
+801064db:	6a 6e                	push   $0x6e
+  jmp alltraps
+801064dd:	e9 6d f7 ff ff       	jmp    80105c4f <alltraps>
+
+801064e2 <vector111>:
+.globl vector111
+vector111:
+  pushl $0
+801064e2:	6a 00                	push   $0x0
+  pushl $111
+801064e4:	6a 6f                	push   $0x6f
+  jmp alltraps
+801064e6:	e9 64 f7 ff ff       	jmp    80105c4f <alltraps>
+
+801064eb <vector112>:
+.globl vector112
+vector112:
+  pushl $0
+801064eb:	6a 00                	push   $0x0
+  pushl $112
+801064ed:	6a 70                	push   $0x70
+  jmp alltraps
+801064ef:	e9 5b f7 ff ff       	jmp    80105c4f <alltraps>
+
+801064f4 <vector113>:
+.globl vector113
+vector113:
+  pushl $0
+801064f4:	6a 00                	push   $0x0
+  pushl $113
+801064f6:	6a 71                	push   $0x71
+  jmp alltraps
+801064f8:	e9 52 f7 ff ff       	jmp    80105c4f <alltraps>
+
+801064fd <vector114>:
+.globl vector114
+vector114:
+  pushl $0
+801064fd:	6a 00                	push   $0x0
+  pushl $114
+801064ff:	6a 72                	push   $0x72
+  jmp alltraps
+80106501:	e9 49 f7 ff ff       	jmp    80105c4f <alltraps>
+
+80106506 <vector115>:
+.globl vector115
+vector115:
+  pushl $0
+80106506:	6a 00                	push   $0x0
+  pushl $115
+80106508:	6a 73                	push   $0x73
+  jmp alltraps
+8010650a:	e9 40 f7 ff ff       	jmp    80105c4f <alltraps>
+
+8010650f <vector116>:
+.globl vector116
+vector116:
+  pushl $0
+8010650f:	6a 00                	push   $0x0
+  pushl $116
+80106511:	6a 74                	push   $0x74
+  jmp alltraps
+80106513:	e9 37 f7 ff ff       	jmp    80105c4f <alltraps>
+
+80106518 <vector117>:
+.globl vector117
+vector117:
+  pushl $0
+80106518:	6a 00                	push   $0x0
+  pushl $117
+8010651a:	6a 75                	push   $0x75
+  jmp alltraps
+8010651c:	e9 2e f7 ff ff       	jmp    80105c4f <alltraps>
+
+80106521 <vector118>:
+.globl vector118
+vector118:
+  pushl $0
+80106521:	6a 00                	push   $0x0
+  pushl $118
+80106523:	6a 76                	push   $0x76
+  jmp alltraps
+80106525:	e9 25 f7 ff ff       	jmp    80105c4f <alltraps>
+
+8010652a <vector119>:
+.globl vector119
+vector119:
+  pushl $0
+8010652a:	6a 00                	push   $0x0
+  pushl $119
+8010652c:	6a 77                	push   $0x77
+  jmp alltraps
+8010652e:	e9 1c f7 ff ff       	jmp    80105c4f <alltraps>
+
+80106533 <vector120>:
+.globl vector120
+vector120:
+  pushl $0
+80106533:	6a 00                	push   $0x0
+  pushl $120
+80106535:	6a 78                	push   $0x78
+  jmp alltraps
+80106537:	e9 13 f7 ff ff       	jmp    80105c4f <alltraps>
+
+8010653c <vector121>:
+.globl vector121
+vector121:
+  pushl $0
+8010653c:	6a 00                	push   $0x0
+  pushl $121
+8010653e:	6a 79                	push   $0x79
+  jmp alltraps
+80106540:	e9 0a f7 ff ff       	jmp    80105c4f <alltraps>
+
+80106545 <vector122>:
+.globl vector122
+vector122:
+  pushl $0
+80106545:	6a 00                	push   $0x0
+  pushl $122
+80106547:	6a 7a                	push   $0x7a
+  jmp alltraps
+80106549:	e9 01 f7 ff ff       	jmp    80105c4f <alltraps>
+
+8010654e <vector123>:
+.globl vector123
+vector123:
+  pushl $0
+8010654e:	6a 00                	push   $0x0
+  pushl $123
+80106550:	6a 7b                	push   $0x7b
+  jmp alltraps
+80106552:	e9 f8 f6 ff ff       	jmp    80105c4f <alltraps>
+
+80106557 <vector124>:
+.globl vector124
+vector124:
+  pushl $0
+80106557:	6a 00                	push   $0x0
+  pushl $124
+80106559:	6a 7c                	push   $0x7c
+  jmp alltraps
+8010655b:	e9 ef f6 ff ff       	jmp    80105c4f <alltraps>
+
+80106560 <vector125>:
+.globl vector125
+vector125:
+  pushl $0
+80106560:	6a 00                	push   $0x0
+  pushl $125
+80106562:	6a 7d                	push   $0x7d
+  jmp alltraps
+80106564:	e9 e6 f6 ff ff       	jmp    80105c4f <alltraps>
+
+80106569 <vector126>:
+.globl vector126
+vector126:
+  pushl $0
+80106569:	6a 00                	push   $0x0
+  pushl $126
+8010656b:	6a 7e                	push   $0x7e
+  jmp alltraps
+8010656d:	e9 dd f6 ff ff       	jmp    80105c4f <alltraps>
+
+80106572 <vector127>:
+.globl vector127
+vector127:
+  pushl $0
+80106572:	6a 00                	push   $0x0
+  pushl $127
+80106574:	6a 7f                	push   $0x7f
+  jmp alltraps
+80106576:	e9 d4 f6 ff ff       	jmp    80105c4f <alltraps>
+
+8010657b <vector128>:
+.globl vector128
+vector128:
+  pushl $0
+8010657b:	6a 00                	push   $0x0
+  pushl $128
+8010657d:	68 80 00 00 00       	push   $0x80
+  jmp alltraps
+80106582:	e9 c8 f6 ff ff       	jmp    80105c4f <alltraps>
+
+80106587 <vector129>:
+.globl vector129
+vector129:
+  pushl $0
+80106587:	6a 00                	push   $0x0
+  pushl $129
+80106589:	68 81 00 00 00       	push   $0x81
+  jmp alltraps
+8010658e:	e9 bc f6 ff ff       	jmp    80105c4f <alltraps>
+
+80106593 <vector130>:
+.globl vector130
+vector130:
+  pushl $0
+80106593:	6a 00                	push   $0x0
+  pushl $130
+80106595:	68 82 00 00 00       	push   $0x82
+  jmp alltraps
+8010659a:	e9 b0 f6 ff ff       	jmp    80105c4f <alltraps>
+
+8010659f <vector131>:
+.globl vector131
+vector131:
+  pushl $0
+8010659f:	6a 00                	push   $0x0
+  pushl $131
+801065a1:	68 83 00 00 00       	push   $0x83
+  jmp alltraps
+801065a6:	e9 a4 f6 ff ff       	jmp    80105c4f <alltraps>
+
+801065ab <vector132>:
+.globl vector132
+vector132:
+  pushl $0
+801065ab:	6a 00                	push   $0x0
+  pushl $132
+801065ad:	68 84 00 00 00       	push   $0x84
+  jmp alltraps
+801065b2:	e9 98 f6 ff ff       	jmp    80105c4f <alltraps>
+
+801065b7 <vector133>:
+.globl vector133
+vector133:
+  pushl $0
+801065b7:	6a 00                	push   $0x0
+  pushl $133
+801065b9:	68 85 00 00 00       	push   $0x85
+  jmp alltraps
+801065be:	e9 8c f6 ff ff       	jmp    80105c4f <alltraps>
+
+801065c3 <vector134>:
+.globl vector134
+vector134:
+  pushl $0
+801065c3:	6a 00                	push   $0x0
+  pushl $134
+801065c5:	68 86 00 00 00       	push   $0x86
+  jmp alltraps
+801065ca:	e9 80 f6 ff ff       	jmp    80105c4f <alltraps>
+
+801065cf <vector135>:
+.globl vector135
+vector135:
+  pushl $0
+801065cf:	6a 00                	push   $0x0
+  pushl $135
+801065d1:	68 87 00 00 00       	push   $0x87
+  jmp alltraps
+801065d6:	e9 74 f6 ff ff       	jmp    80105c4f <alltraps>
+
+801065db <vector136>:
+.globl vector136
+vector136:
+  pushl $0
+801065db:	6a 00                	push   $0x0
+  pushl $136
+801065dd:	68 88 00 00 00       	push   $0x88
+  jmp alltraps
+801065e2:	e9 68 f6 ff ff       	jmp    80105c4f <alltraps>
+
+801065e7 <vector137>:
+.globl vector137
+vector137:
+  pushl $0
+801065e7:	6a 00                	push   $0x0
+  pushl $137
+801065e9:	68 89 00 00 00       	push   $0x89
+  jmp alltraps
+801065ee:	e9 5c f6 ff ff       	jmp    80105c4f <alltraps>
+
+801065f3 <vector138>:
+.globl vector138
+vector138:
+  pushl $0
+801065f3:	6a 00                	push   $0x0
+  pushl $138
+801065f5:	68 8a 00 00 00       	push   $0x8a
+  jmp alltraps
+801065fa:	e9 50 f6 ff ff       	jmp    80105c4f <alltraps>
+
+801065ff <vector139>:
+.globl vector139
+vector139:
+  pushl $0
+801065ff:	6a 00                	push   $0x0
+  pushl $139
+80106601:	68 8b 00 00 00       	push   $0x8b
+  jmp alltraps
+80106606:	e9 44 f6 ff ff       	jmp    80105c4f <alltraps>
+
+8010660b <vector140>:
+.globl vector140
+vector140:
+  pushl $0
+8010660b:	6a 00                	push   $0x0
+  pushl $140
+8010660d:	68 8c 00 00 00       	push   $0x8c
+  jmp alltraps
+80106612:	e9 38 f6 ff ff       	jmp    80105c4f <alltraps>
+
+80106617 <vector141>:
+.globl vector141
+vector141:
+  pushl $0
+80106617:	6a 00                	push   $0x0
+  pushl $141
+80106619:	68 8d 00 00 00       	push   $0x8d
+  jmp alltraps
+8010661e:	e9 2c f6 ff ff       	jmp    80105c4f <alltraps>
+
+80106623 <vector142>:
+.globl vector142
+vector142:
+  pushl $0
+80106623:	6a 00                	push   $0x0
+  pushl $142
+80106625:	68 8e 00 00 00       	push   $0x8e
+  jmp alltraps
+8010662a:	e9 20 f6 ff ff       	jmp    80105c4f <alltraps>
+
+8010662f <vector143>:
+.globl vector143
+vector143:
+  pushl $0
+8010662f:	6a 00                	push   $0x0
+  pushl $143
+80106631:	68 8f 00 00 00       	push   $0x8f
+  jmp alltraps
+80106636:	e9 14 f6 ff ff       	jmp    80105c4f <alltraps>
+
+8010663b <vector144>:
+.globl vector144
+vector144:
+  pushl $0
+8010663b:	6a 00                	push   $0x0
+  pushl $144
+8010663d:	68 90 00 00 00       	push   $0x90
+  jmp alltraps
+80106642:	e9 08 f6 ff ff       	jmp    80105c4f <alltraps>
+
+80106647 <vector145>:
+.globl vector145
+vector145:
+  pushl $0
+80106647:	6a 00                	push   $0x0
+  pushl $145
+80106649:	68 91 00 00 00       	push   $0x91
+  jmp alltraps
+8010664e:	e9 fc f5 ff ff       	jmp    80105c4f <alltraps>
+
+80106653 <vector146>:
+.globl vector146
+vector146:
+  pushl $0
+80106653:	6a 00                	push   $0x0
+  pushl $146
+80106655:	68 92 00 00 00       	push   $0x92
+  jmp alltraps
+8010665a:	e9 f0 f5 ff ff       	jmp    80105c4f <alltraps>
+
+8010665f <vector147>:
+.globl vector147
+vector147:
+  pushl $0
+8010665f:	6a 00                	push   $0x0
+  pushl $147
+80106661:	68 93 00 00 00       	push   $0x93
+  jmp alltraps
+80106666:	e9 e4 f5 ff ff       	jmp    80105c4f <alltraps>
+
+8010666b <vector148>:
+.globl vector148
+vector148:
+  pushl $0
+8010666b:	6a 00                	push   $0x0
+  pushl $148
+8010666d:	68 94 00 00 00       	push   $0x94
+  jmp alltraps
+80106672:	e9 d8 f5 ff ff       	jmp    80105c4f <alltraps>
+
+80106677 <vector149>:
+.globl vector149
+vector149:
+  pushl $0
+80106677:	6a 00                	push   $0x0
+  pushl $149
+80106679:	68 95 00 00 00       	push   $0x95
+  jmp alltraps
+8010667e:	e9 cc f5 ff ff       	jmp    80105c4f <alltraps>
+
+80106683 <vector150>:
+.globl vector150
+vector150:
+  pushl $0
+80106683:	6a 00                	push   $0x0
+  pushl $150
+80106685:	68 96 00 00 00       	push   $0x96
+  jmp alltraps
+8010668a:	e9 c0 f5 ff ff       	jmp    80105c4f <alltraps>
+
+8010668f <vector151>:
+.globl vector151
+vector151:
+  pushl $0
+8010668f:	6a 00                	push   $0x0
+  pushl $151
+80106691:	68 97 00 00 00       	push   $0x97
+  jmp alltraps
+80106696:	e9 b4 f5 ff ff       	jmp    80105c4f <alltraps>
+
+8010669b <vector152>:
+.globl vector152
+vector152:
+  pushl $0
+8010669b:	6a 00                	push   $0x0
+  pushl $152
+8010669d:	68 98 00 00 00       	push   $0x98
+  jmp alltraps
+801066a2:	e9 a8 f5 ff ff       	jmp    80105c4f <alltraps>
+
+801066a7 <vector153>:
+.globl vector153
+vector153:
+  pushl $0
+801066a7:	6a 00                	push   $0x0
+  pushl $153
+801066a9:	68 99 00 00 00       	push   $0x99
+  jmp alltraps
+801066ae:	e9 9c f5 ff ff       	jmp    80105c4f <alltraps>
+
+801066b3 <vector154>:
+.globl vector154
+vector154:
+  pushl $0
+801066b3:	6a 00                	push   $0x0
+  pushl $154
+801066b5:	68 9a 00 00 00       	push   $0x9a
+  jmp alltraps
+801066ba:	e9 90 f5 ff ff       	jmp    80105c4f <alltraps>
+
+801066bf <vector155>:
+.globl vector155
+vector155:
+  pushl $0
+801066bf:	6a 00                	push   $0x0
+  pushl $155
+801066c1:	68 9b 00 00 00       	push   $0x9b
+  jmp alltraps
+801066c6:	e9 84 f5 ff ff       	jmp    80105c4f <alltraps>
+
+801066cb <vector156>:
+.globl vector156
+vector156:
+  pushl $0
+801066cb:	6a 00                	push   $0x0
+  pushl $156
+801066cd:	68 9c 00 00 00       	push   $0x9c
+  jmp alltraps
+801066d2:	e9 78 f5 ff ff       	jmp    80105c4f <alltraps>
+
+801066d7 <vector157>:
+.globl vector157
+vector157:
+  pushl $0
+801066d7:	6a 00                	push   $0x0
+  pushl $157
+801066d9:	68 9d 00 00 00       	push   $0x9d
+  jmp alltraps
+801066de:	e9 6c f5 ff ff       	jmp    80105c4f <alltraps>
+
+801066e3 <vector158>:
+.globl vector158
+vector158:
+  pushl $0
+801066e3:	6a 00                	push   $0x0
+  pushl $158
+801066e5:	68 9e 00 00 00       	push   $0x9e
+  jmp alltraps
+801066ea:	e9 60 f5 ff ff       	jmp    80105c4f <alltraps>
+
+801066ef <vector159>:
+.globl vector159
+vector159:
+  pushl $0
+801066ef:	6a 00                	push   $0x0
+  pushl $159
+801066f1:	68 9f 00 00 00       	push   $0x9f
+  jmp alltraps
+801066f6:	e9 54 f5 ff ff       	jmp    80105c4f <alltraps>
+
+801066fb <vector160>:
+.globl vector160
+vector160:
+  pushl $0
+801066fb:	6a 00                	push   $0x0
+  pushl $160
+801066fd:	68 a0 00 00 00       	push   $0xa0
+  jmp alltraps
+80106702:	e9 48 f5 ff ff       	jmp    80105c4f <alltraps>
+
+80106707 <vector161>:
+.globl vector161
+vector161:
+  pushl $0
+80106707:	6a 00                	push   $0x0
+  pushl $161
+80106709:	68 a1 00 00 00       	push   $0xa1
+  jmp alltraps
+8010670e:	e9 3c f5 ff ff       	jmp    80105c4f <alltraps>
+
+80106713 <vector162>:
+.globl vector162
+vector162:
+  pushl $0
+80106713:	6a 00                	push   $0x0
+  pushl $162
+80106715:	68 a2 00 00 00       	push   $0xa2
+  jmp alltraps
+8010671a:	e9 30 f5 ff ff       	jmp    80105c4f <alltraps>
+
+8010671f <vector163>:
+.globl vector163
+vector163:
+  pushl $0
+8010671f:	6a 00                	push   $0x0
+  pushl $163
+80106721:	68 a3 00 00 00       	push   $0xa3
+  jmp alltraps
+80106726:	e9 24 f5 ff ff       	jmp    80105c4f <alltraps>
+
+8010672b <vector164>:
+.globl vector164
+vector164:
+  pushl $0
+8010672b:	6a 00                	push   $0x0
+  pushl $164
+8010672d:	68 a4 00 00 00       	push   $0xa4
+  jmp alltraps
+80106732:	e9 18 f5 ff ff       	jmp    80105c4f <alltraps>
+
+80106737 <vector165>:
+.globl vector165
+vector165:
+  pushl $0
+80106737:	6a 00                	push   $0x0
+  pushl $165
+80106739:	68 a5 00 00 00       	push   $0xa5
+  jmp alltraps
+8010673e:	e9 0c f5 ff ff       	jmp    80105c4f <alltraps>
+
+80106743 <vector166>:
+.globl vector166
+vector166:
+  pushl $0
+80106743:	6a 00                	push   $0x0
+  pushl $166
+80106745:	68 a6 00 00 00       	push   $0xa6
+  jmp alltraps
+8010674a:	e9 00 f5 ff ff       	jmp    80105c4f <alltraps>
+
+8010674f <vector167>:
+.globl vector167
+vector167:
+  pushl $0
+8010674f:	6a 00                	push   $0x0
+  pushl $167
+80106751:	68 a7 00 00 00       	push   $0xa7
+  jmp alltraps
+80106756:	e9 f4 f4 ff ff       	jmp    80105c4f <alltraps>
+
+8010675b <vector168>:
+.globl vector168
+vector168:
+  pushl $0
+8010675b:	6a 00                	push   $0x0
+  pushl $168
+8010675d:	68 a8 00 00 00       	push   $0xa8
+  jmp alltraps
+80106762:	e9 e8 f4 ff ff       	jmp    80105c4f <alltraps>
+
+80106767 <vector169>:
+.globl vector169
+vector169:
+  pushl $0
+80106767:	6a 00                	push   $0x0
+  pushl $169
+80106769:	68 a9 00 00 00       	push   $0xa9
+  jmp alltraps
+8010676e:	e9 dc f4 ff ff       	jmp    80105c4f <alltraps>
+
+80106773 <vector170>:
+.globl vector170
+vector170:
+  pushl $0
+80106773:	6a 00                	push   $0x0
+  pushl $170
+80106775:	68 aa 00 00 00       	push   $0xaa
+  jmp alltraps
+8010677a:	e9 d0 f4 ff ff       	jmp    80105c4f <alltraps>
+
+8010677f <vector171>:
+.globl vector171
+vector171:
+  pushl $0
+8010677f:	6a 00                	push   $0x0
+  pushl $171
+80106781:	68 ab 00 00 00       	push   $0xab
+  jmp alltraps
+80106786:	e9 c4 f4 ff ff       	jmp    80105c4f <alltraps>
+
+8010678b <vector172>:
+.globl vector172
+vector172:
+  pushl $0
+8010678b:	6a 00                	push   $0x0
+  pushl $172
+8010678d:	68 ac 00 00 00       	push   $0xac
+  jmp alltraps
+80106792:	e9 b8 f4 ff ff       	jmp    80105c4f <alltraps>
+
+80106797 <vector173>:
+.globl vector173
+vector173:
+  pushl $0
+80106797:	6a 00                	push   $0x0
+  pushl $173
+80106799:	68 ad 00 00 00       	push   $0xad
+  jmp alltraps
+8010679e:	e9 ac f4 ff ff       	jmp    80105c4f <alltraps>
+
+801067a3 <vector174>:
+.globl vector174
+vector174:
+  pushl $0
+801067a3:	6a 00                	push   $0x0
+  pushl $174
+801067a5:	68 ae 00 00 00       	push   $0xae
+  jmp alltraps
+801067aa:	e9 a0 f4 ff ff       	jmp    80105c4f <alltraps>
+
+801067af <vector175>:
+.globl vector175
+vector175:
+  pushl $0
+801067af:	6a 00                	push   $0x0
+  pushl $175
+801067b1:	68 af 00 00 00       	push   $0xaf
+  jmp alltraps
+801067b6:	e9 94 f4 ff ff       	jmp    80105c4f <alltraps>
+
+801067bb <vector176>:
+.globl vector176
+vector176:
+  pushl $0
+801067bb:	6a 00                	push   $0x0
+  pushl $176
+801067bd:	68 b0 00 00 00       	push   $0xb0
+  jmp alltraps
+801067c2:	e9 88 f4 ff ff       	jmp    80105c4f <alltraps>
+
+801067c7 <vector177>:
+.globl vector177
+vector177:
+  pushl $0
+801067c7:	6a 00                	push   $0x0
+  pushl $177
+801067c9:	68 b1 00 00 00       	push   $0xb1
+  jmp alltraps
+801067ce:	e9 7c f4 ff ff       	jmp    80105c4f <alltraps>
+
+801067d3 <vector178>:
+.globl vector178
+vector178:
+  pushl $0
+801067d3:	6a 00                	push   $0x0
+  pushl $178
+801067d5:	68 b2 00 00 00       	push   $0xb2
+  jmp alltraps
+801067da:	e9 70 f4 ff ff       	jmp    80105c4f <alltraps>
+
+801067df <vector179>:
+.globl vector179
+vector179:
+  pushl $0
+801067df:	6a 00                	push   $0x0
+  pushl $179
+801067e1:	68 b3 00 00 00       	push   $0xb3
+  jmp alltraps
+801067e6:	e9 64 f4 ff ff       	jmp    80105c4f <alltraps>
+
+801067eb <vector180>:
+.globl vector180
+vector180:
+  pushl $0
+801067eb:	6a 00                	push   $0x0
+  pushl $180
+801067ed:	68 b4 00 00 00       	push   $0xb4
+  jmp alltraps
+801067f2:	e9 58 f4 ff ff       	jmp    80105c4f <alltraps>
+
+801067f7 <vector181>:
+.globl vector181
+vector181:
+  pushl $0
+801067f7:	6a 00                	push   $0x0
+  pushl $181
+801067f9:	68 b5 00 00 00       	push   $0xb5
+  jmp alltraps
+801067fe:	e9 4c f4 ff ff       	jmp    80105c4f <alltraps>
+
+80106803 <vector182>:
+.globl vector182
+vector182:
+  pushl $0
+80106803:	6a 00                	push   $0x0
+  pushl $182
+80106805:	68 b6 00 00 00       	push   $0xb6
+  jmp alltraps
+8010680a:	e9 40 f4 ff ff       	jmp    80105c4f <alltraps>
+
+8010680f <vector183>:
+.globl vector183
+vector183:
+  pushl $0
+8010680f:	6a 00                	push   $0x0
+  pushl $183
+80106811:	68 b7 00 00 00       	push   $0xb7
+  jmp alltraps
+80106816:	e9 34 f4 ff ff       	jmp    80105c4f <alltraps>
+
+8010681b <vector184>:
+.globl vector184
+vector184:
+  pushl $0
+8010681b:	6a 00                	push   $0x0
+  pushl $184
+8010681d:	68 b8 00 00 00       	push   $0xb8
+  jmp alltraps
+80106822:	e9 28 f4 ff ff       	jmp    80105c4f <alltraps>
+
+80106827 <vector185>:
+.globl vector185
+vector185:
+  pushl $0
+80106827:	6a 00                	push   $0x0
+  pushl $185
+80106829:	68 b9 00 00 00       	push   $0xb9
+  jmp alltraps
+8010682e:	e9 1c f4 ff ff       	jmp    80105c4f <alltraps>
+
+80106833 <vector186>:
+.globl vector186
+vector186:
+  pushl $0
+80106833:	6a 00                	push   $0x0
+  pushl $186
+80106835:	68 ba 00 00 00       	push   $0xba
+  jmp alltraps
+8010683a:	e9 10 f4 ff ff       	jmp    80105c4f <alltraps>
+
+8010683f <vector187>:
+.globl vector187
+vector187:
+  pushl $0
+8010683f:	6a 00                	push   $0x0
+  pushl $187
+80106841:	68 bb 00 00 00       	push   $0xbb
+  jmp alltraps
+80106846:	e9 04 f4 ff ff       	jmp    80105c4f <alltraps>
+
+8010684b <vector188>:
+.globl vector188
+vector188:
+  pushl $0
+8010684b:	6a 00                	push   $0x0
+  pushl $188
+8010684d:	68 bc 00 00 00       	push   $0xbc
+  jmp alltraps
+80106852:	e9 f8 f3 ff ff       	jmp    80105c4f <alltraps>
+
+80106857 <vector189>:
+.globl vector189
+vector189:
+  pushl $0
+80106857:	6a 00                	push   $0x0
+  pushl $189
+80106859:	68 bd 00 00 00       	push   $0xbd
+  jmp alltraps
+8010685e:	e9 ec f3 ff ff       	jmp    80105c4f <alltraps>
+
+80106863 <vector190>:
+.globl vector190
+vector190:
+  pushl $0
+80106863:	6a 00                	push   $0x0
+  pushl $190
+80106865:	68 be 00 00 00       	push   $0xbe
+  jmp alltraps
+8010686a:	e9 e0 f3 ff ff       	jmp    80105c4f <alltraps>
+
+8010686f <vector191>:
+.globl vector191
+vector191:
+  pushl $0
+8010686f:	6a 00                	push   $0x0
+  pushl $191
+80106871:	68 bf 00 00 00       	push   $0xbf
+  jmp alltraps
+80106876:	e9 d4 f3 ff ff       	jmp    80105c4f <alltraps>
+
+8010687b <vector192>:
+.globl vector192
+vector192:
+  pushl $0
+8010687b:	6a 00                	push   $0x0
+  pushl $192
+8010687d:	68 c0 00 00 00       	push   $0xc0
+  jmp alltraps
+80106882:	e9 c8 f3 ff ff       	jmp    80105c4f <alltraps>
+
+80106887 <vector193>:
+.globl vector193
+vector193:
+  pushl $0
+80106887:	6a 00                	push   $0x0
+  pushl $193
+80106889:	68 c1 00 00 00       	push   $0xc1
+  jmp alltraps
+8010688e:	e9 bc f3 ff ff       	jmp    80105c4f <alltraps>
+
+80106893 <vector194>:
+.globl vector194
+vector194:
+  pushl $0
+80106893:	6a 00                	push   $0x0
+  pushl $194
+80106895:	68 c2 00 00 00       	push   $0xc2
+  jmp alltraps
+8010689a:	e9 b0 f3 ff ff       	jmp    80105c4f <alltraps>
+
+8010689f <vector195>:
+.globl vector195
+vector195:
+  pushl $0
+8010689f:	6a 00                	push   $0x0
+  pushl $195
+801068a1:	68 c3 00 00 00       	push   $0xc3
+  jmp alltraps
+801068a6:	e9 a4 f3 ff ff       	jmp    80105c4f <alltraps>
+
+801068ab <vector196>:
+.globl vector196
+vector196:
+  pushl $0
+801068ab:	6a 00                	push   $0x0
+  pushl $196
+801068ad:	68 c4 00 00 00       	push   $0xc4
+  jmp alltraps
+801068b2:	e9 98 f3 ff ff       	jmp    80105c4f <alltraps>
+
+801068b7 <vector197>:
+.globl vector197
+vector197:
+  pushl $0
+801068b7:	6a 00                	push   $0x0
+  pushl $197
+801068b9:	68 c5 00 00 00       	push   $0xc5
+  jmp alltraps
+801068be:	e9 8c f3 ff ff       	jmp    80105c4f <alltraps>
+
+801068c3 <vector198>:
+.globl vector198
+vector198:
+  pushl $0
+801068c3:	6a 00                	push   $0x0
+  pushl $198
+801068c5:	68 c6 00 00 00       	push   $0xc6
+  jmp alltraps
+801068ca:	e9 80 f3 ff ff       	jmp    80105c4f <alltraps>
+
+801068cf <vector199>:
+.globl vector199
+vector199:
+  pushl $0
+801068cf:	6a 00                	push   $0x0
+  pushl $199
+801068d1:	68 c7 00 00 00       	push   $0xc7
+  jmp alltraps
+801068d6:	e9 74 f3 ff ff       	jmp    80105c4f <alltraps>
+
+801068db <vector200>:
+.globl vector200
+vector200:
+  pushl $0
+801068db:	6a 00                	push   $0x0
+  pushl $200
+801068dd:	68 c8 00 00 00       	push   $0xc8
+  jmp alltraps
+801068e2:	e9 68 f3 ff ff       	jmp    80105c4f <alltraps>
+
+801068e7 <vector201>:
+.globl vector201
+vector201:
+  pushl $0
+801068e7:	6a 00                	push   $0x0
+  pushl $201
+801068e9:	68 c9 00 00 00       	push   $0xc9
+  jmp alltraps
+801068ee:	e9 5c f3 ff ff       	jmp    80105c4f <alltraps>
+
+801068f3 <vector202>:
+.globl vector202
+vector202:
+  pushl $0
+801068f3:	6a 00                	push   $0x0
+  pushl $202
+801068f5:	68 ca 00 00 00       	push   $0xca
+  jmp alltraps
+801068fa:	e9 50 f3 ff ff       	jmp    80105c4f <alltraps>
+
+801068ff <vector203>:
+.globl vector203
+vector203:
+  pushl $0
+801068ff:	6a 00                	push   $0x0
+  pushl $203
+80106901:	68 cb 00 00 00       	push   $0xcb
+  jmp alltraps
+80106906:	e9 44 f3 ff ff       	jmp    80105c4f <alltraps>
+
+8010690b <vector204>:
+.globl vector204
+vector204:
+  pushl $0
+8010690b:	6a 00                	push   $0x0
+  pushl $204
+8010690d:	68 cc 00 00 00       	push   $0xcc
+  jmp alltraps
+80106912:	e9 38 f3 ff ff       	jmp    80105c4f <alltraps>
+
+80106917 <vector205>:
+.globl vector205
+vector205:
+  pushl $0
+80106917:	6a 00                	push   $0x0
+  pushl $205
+80106919:	68 cd 00 00 00       	push   $0xcd
+  jmp alltraps
+8010691e:	e9 2c f3 ff ff       	jmp    80105c4f <alltraps>
+
+80106923 <vector206>:
+.globl vector206
+vector206:
+  pushl $0
+80106923:	6a 00                	push   $0x0
+  pushl $206
+80106925:	68 ce 00 00 00       	push   $0xce
+  jmp alltraps
+8010692a:	e9 20 f3 ff ff       	jmp    80105c4f <alltraps>
+
+8010692f <vector207>:
+.globl vector207
+vector207:
+  pushl $0
+8010692f:	6a 00                	push   $0x0
+  pushl $207
+80106931:	68 cf 00 00 00       	push   $0xcf
+  jmp alltraps
+80106936:	e9 14 f3 ff ff       	jmp    80105c4f <alltraps>
+
+8010693b <vector208>:
+.globl vector208
+vector208:
+  pushl $0
+8010693b:	6a 00                	push   $0x0
+  pushl $208
+8010693d:	68 d0 00 00 00       	push   $0xd0
+  jmp alltraps
+80106942:	e9 08 f3 ff ff       	jmp    80105c4f <alltraps>
+
+80106947 <vector209>:
+.globl vector209
+vector209:
+  pushl $0
+80106947:	6a 00                	push   $0x0
+  pushl $209
+80106949:	68 d1 00 00 00       	push   $0xd1
+  jmp alltraps
+8010694e:	e9 fc f2 ff ff       	jmp    80105c4f <alltraps>
+
+80106953 <vector210>:
+.globl vector210
+vector210:
+  pushl $0
+80106953:	6a 00                	push   $0x0
+  pushl $210
+80106955:	68 d2 00 00 00       	push   $0xd2
+  jmp alltraps
+8010695a:	e9 f0 f2 ff ff       	jmp    80105c4f <alltraps>
+
+8010695f <vector211>:
+.globl vector211
+vector211:
+  pushl $0
+8010695f:	6a 00                	push   $0x0
+  pushl $211
+80106961:	68 d3 00 00 00       	push   $0xd3
+  jmp alltraps
+80106966:	e9 e4 f2 ff ff       	jmp    80105c4f <alltraps>
+
+8010696b <vector212>:
+.globl vector212
+vector212:
+  pushl $0
+8010696b:	6a 00                	push   $0x0
+  pushl $212
+8010696d:	68 d4 00 00 00       	push   $0xd4
+  jmp alltraps
+80106972:	e9 d8 f2 ff ff       	jmp    80105c4f <alltraps>
+
+80106977 <vector213>:
+.globl vector213
+vector213:
+  pushl $0
+80106977:	6a 00                	push   $0x0
+  pushl $213
+80106979:	68 d5 00 00 00       	push   $0xd5
+  jmp alltraps
+8010697e:	e9 cc f2 ff ff       	jmp    80105c4f <alltraps>
+
+80106983 <vector214>:
+.globl vector214
+vector214:
+  pushl $0
+80106983:	6a 00                	push   $0x0
+  pushl $214
+80106985:	68 d6 00 00 00       	push   $0xd6
+  jmp alltraps
+8010698a:	e9 c0 f2 ff ff       	jmp    80105c4f <alltraps>
+
+8010698f <vector215>:
+.globl vector215
+vector215:
+  pushl $0
+8010698f:	6a 00                	push   $0x0
+  pushl $215
+80106991:	68 d7 00 00 00       	push   $0xd7
+  jmp alltraps
+80106996:	e9 b4 f2 ff ff       	jmp    80105c4f <alltraps>
+
+8010699b <vector216>:
+.globl vector216
+vector216:
+  pushl $0
+8010699b:	6a 00                	push   $0x0
+  pushl $216
+8010699d:	68 d8 00 00 00       	push   $0xd8
+  jmp alltraps
+801069a2:	e9 a8 f2 ff ff       	jmp    80105c4f <alltraps>
+
+801069a7 <vector217>:
+.globl vector217
+vector217:
+  pushl $0
+801069a7:	6a 00                	push   $0x0
+  pushl $217
+801069a9:	68 d9 00 00 00       	push   $0xd9
+  jmp alltraps
+801069ae:	e9 9c f2 ff ff       	jmp    80105c4f <alltraps>
+
+801069b3 <vector218>:
+.globl vector218
+vector218:
+  pushl $0
+801069b3:	6a 00                	push   $0x0
+  pushl $218
+801069b5:	68 da 00 00 00       	push   $0xda
+  jmp alltraps
+801069ba:	e9 90 f2 ff ff       	jmp    80105c4f <alltraps>
+
+801069bf <vector219>:
+.globl vector219
+vector219:
+  pushl $0
+801069bf:	6a 00                	push   $0x0
+  pushl $219
+801069c1:	68 db 00 00 00       	push   $0xdb
+  jmp alltraps
+801069c6:	e9 84 f2 ff ff       	jmp    80105c4f <alltraps>
+
+801069cb <vector220>:
+.globl vector220
+vector220:
+  pushl $0
+801069cb:	6a 00                	push   $0x0
+  pushl $220
+801069cd:	68 dc 00 00 00       	push   $0xdc
+  jmp alltraps
+801069d2:	e9 78 f2 ff ff       	jmp    80105c4f <alltraps>
+
+801069d7 <vector221>:
+.globl vector221
+vector221:
+  pushl $0
+801069d7:	6a 00                	push   $0x0
+  pushl $221
+801069d9:	68 dd 00 00 00       	push   $0xdd
+  jmp alltraps
+801069de:	e9 6c f2 ff ff       	jmp    80105c4f <alltraps>
+
+801069e3 <vector222>:
+.globl vector222
+vector222:
+  pushl $0
+801069e3:	6a 00                	push   $0x0
+  pushl $222
+801069e5:	68 de 00 00 00       	push   $0xde
+  jmp alltraps
+801069ea:	e9 60 f2 ff ff       	jmp    80105c4f <alltraps>
+
+801069ef <vector223>:
+.globl vector223
+vector223:
+  pushl $0
+801069ef:	6a 00                	push   $0x0
+  pushl $223
+801069f1:	68 df 00 00 00       	push   $0xdf
+  jmp alltraps
+801069f6:	e9 54 f2 ff ff       	jmp    80105c4f <alltraps>
+
+801069fb <vector224>:
+.globl vector224
+vector224:
+  pushl $0
+801069fb:	6a 00                	push   $0x0
+  pushl $224
+801069fd:	68 e0 00 00 00       	push   $0xe0
+  jmp alltraps
+80106a02:	e9 48 f2 ff ff       	jmp    80105c4f <alltraps>
+
+80106a07 <vector225>:
+.globl vector225
+vector225:
+  pushl $0
+80106a07:	6a 00                	push   $0x0
+  pushl $225
+80106a09:	68 e1 00 00 00       	push   $0xe1
+  jmp alltraps
+80106a0e:	e9 3c f2 ff ff       	jmp    80105c4f <alltraps>
+
+80106a13 <vector226>:
+.globl vector226
+vector226:
+  pushl $0
+80106a13:	6a 00                	push   $0x0
+  pushl $226
+80106a15:	68 e2 00 00 00       	push   $0xe2
+  jmp alltraps
+80106a1a:	e9 30 f2 ff ff       	jmp    80105c4f <alltraps>
+
+80106a1f <vector227>:
+.globl vector227
+vector227:
+  pushl $0
+80106a1f:	6a 00                	push   $0x0
+  pushl $227
+80106a21:	68 e3 00 00 00       	push   $0xe3
+  jmp alltraps
+80106a26:	e9 24 f2 ff ff       	jmp    80105c4f <alltraps>
+
+80106a2b <vector228>:
+.globl vector228
+vector228:
+  pushl $0
+80106a2b:	6a 00                	push   $0x0
+  pushl $228
+80106a2d:	68 e4 00 00 00       	push   $0xe4
+  jmp alltraps
+80106a32:	e9 18 f2 ff ff       	jmp    80105c4f <alltraps>
+
+80106a37 <vector229>:
+.globl vector229
+vector229:
+  pushl $0
+80106a37:	6a 00                	push   $0x0
+  pushl $229
+80106a39:	68 e5 00 00 00       	push   $0xe5
+  jmp alltraps
+80106a3e:	e9 0c f2 ff ff       	jmp    80105c4f <alltraps>
+
+80106a43 <vector230>:
+.globl vector230
+vector230:
+  pushl $0
+80106a43:	6a 00                	push   $0x0
+  pushl $230
+80106a45:	68 e6 00 00 00       	push   $0xe6
+  jmp alltraps
+80106a4a:	e9 00 f2 ff ff       	jmp    80105c4f <alltraps>
+
+80106a4f <vector231>:
+.globl vector231
+vector231:
+  pushl $0
+80106a4f:	6a 00                	push   $0x0
+  pushl $231
+80106a51:	68 e7 00 00 00       	push   $0xe7
+  jmp alltraps
+80106a56:	e9 f4 f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106a5b <vector232>:
+.globl vector232
+vector232:
+  pushl $0
+80106a5b:	6a 00                	push   $0x0
+  pushl $232
+80106a5d:	68 e8 00 00 00       	push   $0xe8
+  jmp alltraps
+80106a62:	e9 e8 f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106a67 <vector233>:
+.globl vector233
+vector233:
+  pushl $0
+80106a67:	6a 00                	push   $0x0
+  pushl $233
+80106a69:	68 e9 00 00 00       	push   $0xe9
+  jmp alltraps
+80106a6e:	e9 dc f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106a73 <vector234>:
+.globl vector234
+vector234:
+  pushl $0
+80106a73:	6a 00                	push   $0x0
+  pushl $234
+80106a75:	68 ea 00 00 00       	push   $0xea
+  jmp alltraps
+80106a7a:	e9 d0 f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106a7f <vector235>:
+.globl vector235
+vector235:
+  pushl $0
+80106a7f:	6a 00                	push   $0x0
+  pushl $235
+80106a81:	68 eb 00 00 00       	push   $0xeb
+  jmp alltraps
+80106a86:	e9 c4 f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106a8b <vector236>:
+.globl vector236
+vector236:
+  pushl $0
+80106a8b:	6a 00                	push   $0x0
+  pushl $236
+80106a8d:	68 ec 00 00 00       	push   $0xec
+  jmp alltraps
+80106a92:	e9 b8 f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106a97 <vector237>:
+.globl vector237
+vector237:
+  pushl $0
+80106a97:	6a 00                	push   $0x0
+  pushl $237
+80106a99:	68 ed 00 00 00       	push   $0xed
+  jmp alltraps
+80106a9e:	e9 ac f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106aa3 <vector238>:
+.globl vector238
+vector238:
+  pushl $0
+80106aa3:	6a 00                	push   $0x0
+  pushl $238
+80106aa5:	68 ee 00 00 00       	push   $0xee
+  jmp alltraps
+80106aaa:	e9 a0 f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106aaf <vector239>:
+.globl vector239
+vector239:
+  pushl $0
+80106aaf:	6a 00                	push   $0x0
+  pushl $239
+80106ab1:	68 ef 00 00 00       	push   $0xef
+  jmp alltraps
+80106ab6:	e9 94 f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106abb <vector240>:
+.globl vector240
+vector240:
+  pushl $0
+80106abb:	6a 00                	push   $0x0
+  pushl $240
+80106abd:	68 f0 00 00 00       	push   $0xf0
+  jmp alltraps
+80106ac2:	e9 88 f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106ac7 <vector241>:
+.globl vector241
+vector241:
+  pushl $0
+80106ac7:	6a 00                	push   $0x0
+  pushl $241
+80106ac9:	68 f1 00 00 00       	push   $0xf1
+  jmp alltraps
+80106ace:	e9 7c f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106ad3 <vector242>:
+.globl vector242
+vector242:
+  pushl $0
+80106ad3:	6a 00                	push   $0x0
+  pushl $242
+80106ad5:	68 f2 00 00 00       	push   $0xf2
+  jmp alltraps
+80106ada:	e9 70 f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106adf <vector243>:
+.globl vector243
+vector243:
+  pushl $0
+80106adf:	6a 00                	push   $0x0
+  pushl $243
+80106ae1:	68 f3 00 00 00       	push   $0xf3
+  jmp alltraps
+80106ae6:	e9 64 f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106aeb <vector244>:
+.globl vector244
+vector244:
+  pushl $0
+80106aeb:	6a 00                	push   $0x0
+  pushl $244
+80106aed:	68 f4 00 00 00       	push   $0xf4
+  jmp alltraps
+80106af2:	e9 58 f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106af7 <vector245>:
+.globl vector245
+vector245:
+  pushl $0
+80106af7:	6a 00                	push   $0x0
+  pushl $245
+80106af9:	68 f5 00 00 00       	push   $0xf5
+  jmp alltraps
+80106afe:	e9 4c f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106b03 <vector246>:
+.globl vector246
+vector246:
+  pushl $0
+80106b03:	6a 00                	push   $0x0
+  pushl $246
+80106b05:	68 f6 00 00 00       	push   $0xf6
+  jmp alltraps
+80106b0a:	e9 40 f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106b0f <vector247>:
+.globl vector247
+vector247:
+  pushl $0
+80106b0f:	6a 00                	push   $0x0
+  pushl $247
+80106b11:	68 f7 00 00 00       	push   $0xf7
+  jmp alltraps
+80106b16:	e9 34 f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106b1b <vector248>:
+.globl vector248
+vector248:
+  pushl $0
+80106b1b:	6a 00                	push   $0x0
+  pushl $248
+80106b1d:	68 f8 00 00 00       	push   $0xf8
+  jmp alltraps
+80106b22:	e9 28 f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106b27 <vector249>:
+.globl vector249
+vector249:
+  pushl $0
+80106b27:	6a 00                	push   $0x0
+  pushl $249
+80106b29:	68 f9 00 00 00       	push   $0xf9
+  jmp alltraps
+80106b2e:	e9 1c f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106b33 <vector250>:
+.globl vector250
+vector250:
+  pushl $0
+80106b33:	6a 00                	push   $0x0
+  pushl $250
+80106b35:	68 fa 00 00 00       	push   $0xfa
+  jmp alltraps
+80106b3a:	e9 10 f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106b3f <vector251>:
+.globl vector251
+vector251:
+  pushl $0
+80106b3f:	6a 00                	push   $0x0
+  pushl $251
+80106b41:	68 fb 00 00 00       	push   $0xfb
+  jmp alltraps
+80106b46:	e9 04 f1 ff ff       	jmp    80105c4f <alltraps>
+
+80106b4b <vector252>:
+.globl vector252
+vector252:
+  pushl $0
+80106b4b:	6a 00                	push   $0x0
+  pushl $252
+80106b4d:	68 fc 00 00 00       	push   $0xfc
+  jmp alltraps
+80106b52:	e9 f8 f0 ff ff       	jmp    80105c4f <alltraps>
+
+80106b57 <vector253>:
+.globl vector253
+vector253:
+  pushl $0
+80106b57:	6a 00                	push   $0x0
+  pushl $253
+80106b59:	68 fd 00 00 00       	push   $0xfd
+  jmp alltraps
+80106b5e:	e9 ec f0 ff ff       	jmp    80105c4f <alltraps>
+
+80106b63 <vector254>:
+.globl vector254
+vector254:
+  pushl $0
+80106b63:	6a 00                	push   $0x0
+  pushl $254
+80106b65:	68 fe 00 00 00       	push   $0xfe
+  jmp alltraps
+80106b6a:	e9 e0 f0 ff ff       	jmp    80105c4f <alltraps>
+
+80106b6f <vector255>:
+.globl vector255
+vector255:
+  pushl $0
+80106b6f:	6a 00                	push   $0x0
+  pushl $255
+80106b71:	68 ff 00 00 00       	push   $0xff
+  jmp alltraps
+80106b76:	e9 d4 f0 ff ff       	jmp    80105c4f <alltraps>
+80106b7b:	66 90                	xchg   %ax,%ax
+80106b7d:	66 90                	xchg   %ax,%ax
+80106b7f:	90                   	nop
+
+80106b80 <walkpgdir>:
+// Return the address of the PTE in page table pgdir
+// that corresponds to virtual address va.  If alloc!=0,
+// create any required page table pages.
+static pte_t *
+walkpgdir(pde_t *pgdir, const void *va, int alloc)
+{
+80106b80:	55                   	push   %ebp
+80106b81:	89 e5                	mov    %esp,%ebp
+80106b83:	57                   	push   %edi
+80106b84:	56                   	push   %esi
+80106b85:	89 d6                	mov    %edx,%esi
+  pde_t *pde;
+  pte_t *pgtab;
+
+  pde = &pgdir[PDX(va)];
+80106b87:	c1 ea 16             	shr    $0x16,%edx
+{
+80106b8a:	53                   	push   %ebx
+  pde = &pgdir[PDX(va)];
+80106b8b:	8d 3c 90             	lea    (%eax,%edx,4),%edi
+{
+80106b8e:	83 ec 0c             	sub    $0xc,%esp
+  if(*pde & PTE_P){
+80106b91:	8b 1f                	mov    (%edi),%ebx
+80106b93:	f6 c3 01             	test   $0x1,%bl
+80106b96:	74 28                	je     80106bc0 <walkpgdir+0x40>
+    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+80106b98:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
+80106b9e:	81 c3 00 00 00 80    	add    $0x80000000,%ebx
+    // The permissions here are overly generous, but they can
+    // be further restricted by the permissions in the page table
+    // entries, if necessary.
+    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+  }
+  return &pgtab[PTX(va)];
+80106ba4:	89 f0                	mov    %esi,%eax
+}
+80106ba6:	8d 65 f4             	lea    -0xc(%ebp),%esp
+  return &pgtab[PTX(va)];
+80106ba9:	c1 e8 0a             	shr    $0xa,%eax
+80106bac:	25 fc 0f 00 00       	and    $0xffc,%eax
+80106bb1:	01 d8                	add    %ebx,%eax
+}
+80106bb3:	5b                   	pop    %ebx
+80106bb4:	5e                   	pop    %esi
+80106bb5:	5f                   	pop    %edi
+80106bb6:	5d                   	pop    %ebp
+80106bb7:	c3                   	ret    
+80106bb8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80106bbf:	90                   	nop
+    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+80106bc0:	85 c9                	test   %ecx,%ecx
+80106bc2:	74 2c                	je     80106bf0 <walkpgdir+0x70>
+80106bc4:	e8 67 ba ff ff       	call   80102630 <kalloc>
+80106bc9:	89 c3                	mov    %eax,%ebx
+80106bcb:	85 c0                	test   %eax,%eax
+80106bcd:	74 21                	je     80106bf0 <walkpgdir+0x70>
+    memset(pgtab, 0, PGSIZE);
+80106bcf:	83 ec 04             	sub    $0x4,%esp
+80106bd2:	68 00 10 00 00       	push   $0x1000
+80106bd7:	6a 00                	push   $0x0
+80106bd9:	50                   	push   %eax
+80106bda:	e8 11 dd ff ff       	call   801048f0 <memset>
+    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+80106bdf:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
+80106be5:	83 c4 10             	add    $0x10,%esp
+80106be8:	83 c8 07             	or     $0x7,%eax
+80106beb:	89 07                	mov    %eax,(%edi)
+80106bed:	eb b5                	jmp    80106ba4 <walkpgdir+0x24>
+80106bef:	90                   	nop
+}
+80106bf0:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return 0;
+80106bf3:	31 c0                	xor    %eax,%eax
+}
+80106bf5:	5b                   	pop    %ebx
+80106bf6:	5e                   	pop    %esi
+80106bf7:	5f                   	pop    %edi
+80106bf8:	5d                   	pop    %ebp
+80106bf9:	c3                   	ret    
+80106bfa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80106c00 <mappages>:
+// Create PTEs for virtual addresses starting at va that refer to
+// physical addresses starting at pa. va and size might not
+// be page-aligned.
+static int
+mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
+{
+80106c00:	55                   	push   %ebp
+80106c01:	89 e5                	mov    %esp,%ebp
+80106c03:	57                   	push   %edi
+80106c04:	89 c7                	mov    %eax,%edi
+  char *a, *last;
+  pte_t *pte;
+
+  a = (char*)PGROUNDDOWN((uint)va);
+  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+80106c06:	8d 44 0a ff          	lea    -0x1(%edx,%ecx,1),%eax
+{
+80106c0a:	56                   	push   %esi
+  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+80106c0b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+  a = (char*)PGROUNDDOWN((uint)va);
+80106c10:	89 d6                	mov    %edx,%esi
+{
+80106c12:	53                   	push   %ebx
+  a = (char*)PGROUNDDOWN((uint)va);
+80106c13:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
+{
+80106c19:	83 ec 1c             	sub    $0x1c,%esp
+  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+80106c1c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+80106c1f:	8b 45 08             	mov    0x8(%ebp),%eax
+80106c22:	29 f0                	sub    %esi,%eax
+80106c24:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+80106c27:	eb 1f                	jmp    80106c48 <mappages+0x48>
+80106c29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  for(;;){
+    if((pte = walkpgdir(pgdir, a, 1)) == 0)
+      return -1;
+    if(*pte & PTE_P)
+80106c30:	f6 00 01             	testb  $0x1,(%eax)
+80106c33:	75 45                	jne    80106c7a <mappages+0x7a>
+      panic("remap");
+    *pte = pa | perm | PTE_P;
+80106c35:	0b 5d 0c             	or     0xc(%ebp),%ebx
+80106c38:	83 cb 01             	or     $0x1,%ebx
+80106c3b:	89 18                	mov    %ebx,(%eax)
+    if(a == last)
+80106c3d:	3b 75 e0             	cmp    -0x20(%ebp),%esi
+80106c40:	74 2e                	je     80106c70 <mappages+0x70>
+      break;
+    a += PGSIZE;
+80106c42:	81 c6 00 10 00 00    	add    $0x1000,%esi
+  for(;;){
+80106c48:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    if((pte = walkpgdir(pgdir, a, 1)) == 0)
+80106c4b:	b9 01 00 00 00       	mov    $0x1,%ecx
+80106c50:	89 f2                	mov    %esi,%edx
+80106c52:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
+80106c55:	89 f8                	mov    %edi,%eax
+80106c57:	e8 24 ff ff ff       	call   80106b80 <walkpgdir>
+80106c5c:	85 c0                	test   %eax,%eax
+80106c5e:	75 d0                	jne    80106c30 <mappages+0x30>
+    pa += PGSIZE;
+  }
+  return 0;
+}
+80106c60:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return -1;
+80106c63:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80106c68:	5b                   	pop    %ebx
+80106c69:	5e                   	pop    %esi
+80106c6a:	5f                   	pop    %edi
+80106c6b:	5d                   	pop    %ebp
+80106c6c:	c3                   	ret    
+80106c6d:	8d 76 00             	lea    0x0(%esi),%esi
+80106c70:	8d 65 f4             	lea    -0xc(%ebp),%esp
+  return 0;
+80106c73:	31 c0                	xor    %eax,%eax
+}
+80106c75:	5b                   	pop    %ebx
+80106c76:	5e                   	pop    %esi
+80106c77:	5f                   	pop    %edi
+80106c78:	5d                   	pop    %ebp
+80106c79:	c3                   	ret    
+      panic("remap");
+80106c7a:	83 ec 0c             	sub    $0xc,%esp
+80106c7d:	68 78 7d 10 80       	push   $0x80107d78
+80106c82:	e8 09 97 ff ff       	call   80100390 <panic>
+80106c87:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80106c8e:	66 90                	xchg   %ax,%ax
+
+80106c90 <deallocuvm.part.0>:
+// Deallocate user pages to bring the process size from oldsz to
+// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+// need to be less than oldsz.  oldsz can be larger than the actual
+// process size.  Returns the new process size.
+int
+deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+80106c90:	55                   	push   %ebp
+80106c91:	89 e5                	mov    %esp,%ebp
+80106c93:	57                   	push   %edi
+80106c94:	56                   	push   %esi
+80106c95:	89 c6                	mov    %eax,%esi
+80106c97:	53                   	push   %ebx
+80106c98:	89 d3                	mov    %edx,%ebx
+  uint a, pa;
+
+  if(newsz >= oldsz)
+    return oldsz;
+
+  a = PGROUNDUP(newsz);
+80106c9a:	8d 91 ff 0f 00 00    	lea    0xfff(%ecx),%edx
+80106ca0:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
+deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+80106ca6:	83 ec 1c             	sub    $0x1c,%esp
+80106ca9:	89 4d e0             	mov    %ecx,-0x20(%ebp)
+  for(; a  < oldsz; a += PGSIZE){
+80106cac:	39 da                	cmp    %ebx,%edx
+80106cae:	73 5b                	jae    80106d0b <deallocuvm.part.0+0x7b>
+80106cb0:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
+80106cb3:	89 d7                	mov    %edx,%edi
+80106cb5:	eb 14                	jmp    80106ccb <deallocuvm.part.0+0x3b>
+80106cb7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80106cbe:	66 90                	xchg   %ax,%ax
+80106cc0:	81 c7 00 10 00 00    	add    $0x1000,%edi
+80106cc6:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
+80106cc9:	76 40                	jbe    80106d0b <deallocuvm.part.0+0x7b>
+    pte = walkpgdir(pgdir, (char*)a, 0);
+80106ccb:	31 c9                	xor    %ecx,%ecx
+80106ccd:	89 fa                	mov    %edi,%edx
+80106ccf:	89 f0                	mov    %esi,%eax
+80106cd1:	e8 aa fe ff ff       	call   80106b80 <walkpgdir>
+80106cd6:	89 c3                	mov    %eax,%ebx
+    if(!pte)
+80106cd8:	85 c0                	test   %eax,%eax
+80106cda:	74 44                	je     80106d20 <deallocuvm.part.0+0x90>
+      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+    else if((*pte & PTE_P) != 0){
+80106cdc:	8b 00                	mov    (%eax),%eax
+80106cde:	a8 01                	test   $0x1,%al
+80106ce0:	74 de                	je     80106cc0 <deallocuvm.part.0+0x30>
+      pa = PTE_ADDR(*pte);
+      if(pa == 0)
+80106ce2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80106ce7:	74 47                	je     80106d30 <deallocuvm.part.0+0xa0>
+        panic("kfree");
+      char *v = P2V(pa);
+      kfree(v);
+80106ce9:	83 ec 0c             	sub    $0xc,%esp
+      char *v = P2V(pa);
+80106cec:	05 00 00 00 80       	add    $0x80000000,%eax
+80106cf1:	81 c7 00 10 00 00    	add    $0x1000,%edi
+      kfree(v);
+80106cf7:	50                   	push   %eax
+80106cf8:	e8 73 b7 ff ff       	call   80102470 <kfree>
+      *pte = 0;
+80106cfd:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
+80106d03:	83 c4 10             	add    $0x10,%esp
+  for(; a  < oldsz; a += PGSIZE){
+80106d06:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
+80106d09:	77 c0                	ja     80106ccb <deallocuvm.part.0+0x3b>
+    }
+  }
+  return newsz;
+}
+80106d0b:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80106d0e:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80106d11:	5b                   	pop    %ebx
+80106d12:	5e                   	pop    %esi
+80106d13:	5f                   	pop    %edi
+80106d14:	5d                   	pop    %ebp
+80106d15:	c3                   	ret    
+80106d16:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80106d1d:	8d 76 00             	lea    0x0(%esi),%esi
+      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+80106d20:	89 fa                	mov    %edi,%edx
+80106d22:	81 e2 00 00 c0 ff    	and    $0xffc00000,%edx
+80106d28:	8d ba 00 00 40 00    	lea    0x400000(%edx),%edi
+80106d2e:	eb 96                	jmp    80106cc6 <deallocuvm.part.0+0x36>
+        panic("kfree");
+80106d30:	83 ec 0c             	sub    $0xc,%esp
+80106d33:	68 26 77 10 80       	push   $0x80107726
+80106d38:	e8 53 96 ff ff       	call   80100390 <panic>
+80106d3d:	8d 76 00             	lea    0x0(%esi),%esi
+
+80106d40 <seginit>:
+{
+80106d40:	f3 0f 1e fb          	endbr32 
+80106d44:	55                   	push   %ebp
+80106d45:	89 e5                	mov    %esp,%ebp
+80106d47:	83 ec 18             	sub    $0x18,%esp
+  c = &cpus[cpuid()];
+80106d4a:	e8 f1 cb ff ff       	call   80103940 <cpuid>
+  pd[0] = size-1;
+80106d4f:	ba 2f 00 00 00       	mov    $0x2f,%edx
+80106d54:	69 c0 b0 00 00 00    	imul   $0xb0,%eax,%eax
+80106d5a:	66 89 55 f2          	mov    %dx,-0xe(%ebp)
+  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+80106d5e:	c7 80 f8 27 11 80 ff 	movl   $0xffff,-0x7feed808(%eax)
+80106d65:	ff 00 00 
+80106d68:	c7 80 fc 27 11 80 00 	movl   $0xcf9a00,-0x7feed804(%eax)
+80106d6f:	9a cf 00 
+  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+80106d72:	c7 80 00 28 11 80 ff 	movl   $0xffff,-0x7feed800(%eax)
+80106d79:	ff 00 00 
+80106d7c:	c7 80 04 28 11 80 00 	movl   $0xcf9200,-0x7feed7fc(%eax)
+80106d83:	92 cf 00 
+  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+80106d86:	c7 80 08 28 11 80 ff 	movl   $0xffff,-0x7feed7f8(%eax)
+80106d8d:	ff 00 00 
+80106d90:	c7 80 0c 28 11 80 00 	movl   $0xcffa00,-0x7feed7f4(%eax)
+80106d97:	fa cf 00 
+  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+80106d9a:	c7 80 10 28 11 80 ff 	movl   $0xffff,-0x7feed7f0(%eax)
+80106da1:	ff 00 00 
+80106da4:	c7 80 14 28 11 80 00 	movl   $0xcff200,-0x7feed7ec(%eax)
+80106dab:	f2 cf 00 
+  lgdt(c->gdt, sizeof(c->gdt));
+80106dae:	05 f0 27 11 80       	add    $0x801127f0,%eax
+  pd[1] = (uint)p;
+80106db3:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
+  pd[2] = (uint)p >> 16;
+80106db7:	c1 e8 10             	shr    $0x10,%eax
+80106dba:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
+  asm volatile("lgdt (%0)" : : "r" (pd));
+80106dbe:	8d 45 f2             	lea    -0xe(%ebp),%eax
+80106dc1:	0f 01 10             	lgdtl  (%eax)
+}
+80106dc4:	c9                   	leave  
+80106dc5:	c3                   	ret    
+80106dc6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80106dcd:	8d 76 00             	lea    0x0(%esi),%esi
+
+80106dd0 <switchkvm>:
+{
+80106dd0:	f3 0f 1e fb          	endbr32 
+  lcr3(V2P(kpgdir));   // switch to the kernel page table
+80106dd4:	a1 a4 55 11 80       	mov    0x801155a4,%eax
+80106dd9:	05 00 00 00 80       	add    $0x80000000,%eax
+}
+
+static inline void
+lcr3(uint val)
+{
+  asm volatile("movl %0,%%cr3" : : "r" (val));
+80106dde:	0f 22 d8             	mov    %eax,%cr3
+}
+80106de1:	c3                   	ret    
+80106de2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+80106de9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80106df0 <switchuvm>:
+{
+80106df0:	f3 0f 1e fb          	endbr32 
+80106df4:	55                   	push   %ebp
+80106df5:	89 e5                	mov    %esp,%ebp
+80106df7:	57                   	push   %edi
+80106df8:	56                   	push   %esi
+80106df9:	53                   	push   %ebx
+80106dfa:	83 ec 1c             	sub    $0x1c,%esp
+80106dfd:	8b 75 08             	mov    0x8(%ebp),%esi
+  if(p == 0)
+80106e00:	85 f6                	test   %esi,%esi
+80106e02:	0f 84 cb 00 00 00    	je     80106ed3 <switchuvm+0xe3>
+  if(p->kstack == 0)
+80106e08:	8b 46 08             	mov    0x8(%esi),%eax
+80106e0b:	85 c0                	test   %eax,%eax
+80106e0d:	0f 84 da 00 00 00    	je     80106eed <switchuvm+0xfd>
+  if(p->pgdir == 0)
+80106e13:	8b 46 04             	mov    0x4(%esi),%eax
+80106e16:	85 c0                	test   %eax,%eax
+80106e18:	0f 84 c2 00 00 00    	je     80106ee0 <switchuvm+0xf0>
+  pushcli();
+80106e1e:	e8 bd d8 ff ff       	call   801046e0 <pushcli>
+  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
+80106e23:	e8 a8 ca ff ff       	call   801038d0 <mycpu>
+80106e28:	89 c3                	mov    %eax,%ebx
+80106e2a:	e8 a1 ca ff ff       	call   801038d0 <mycpu>
+80106e2f:	89 c7                	mov    %eax,%edi
+80106e31:	e8 9a ca ff ff       	call   801038d0 <mycpu>
+80106e36:	83 c7 08             	add    $0x8,%edi
+80106e39:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+80106e3c:	e8 8f ca ff ff       	call   801038d0 <mycpu>
+80106e41:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+80106e44:	ba 67 00 00 00       	mov    $0x67,%edx
+80106e49:	66 89 bb 9a 00 00 00 	mov    %di,0x9a(%ebx)
+80106e50:	83 c0 08             	add    $0x8,%eax
+80106e53:	66 89 93 98 00 00 00 	mov    %dx,0x98(%ebx)
+  mycpu()->ts.iomb = (ushort) 0xFFFF;
+80106e5a:	bf ff ff ff ff       	mov    $0xffffffff,%edi
+  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
+80106e5f:	83 c1 08             	add    $0x8,%ecx
+80106e62:	c1 e8 18             	shr    $0x18,%eax
+80106e65:	c1 e9 10             	shr    $0x10,%ecx
+80106e68:	88 83 9f 00 00 00    	mov    %al,0x9f(%ebx)
+80106e6e:	88 8b 9c 00 00 00    	mov    %cl,0x9c(%ebx)
+80106e74:	b9 99 40 00 00       	mov    $0x4099,%ecx
+80106e79:	66 89 8b 9d 00 00 00 	mov    %cx,0x9d(%ebx)
+  mycpu()->ts.ss0 = SEG_KDATA << 3;
+80106e80:	bb 10 00 00 00       	mov    $0x10,%ebx
+  mycpu()->gdt[SEG_TSS].s = 0;
+80106e85:	e8 46 ca ff ff       	call   801038d0 <mycpu>
+80106e8a:	80 a0 9d 00 00 00 ef 	andb   $0xef,0x9d(%eax)
+  mycpu()->ts.ss0 = SEG_KDATA << 3;
+80106e91:	e8 3a ca ff ff       	call   801038d0 <mycpu>
+80106e96:	66 89 58 10          	mov    %bx,0x10(%eax)
+  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
+80106e9a:	8b 5e 08             	mov    0x8(%esi),%ebx
+80106e9d:	81 c3 00 10 00 00    	add    $0x1000,%ebx
+80106ea3:	e8 28 ca ff ff       	call   801038d0 <mycpu>
+80106ea8:	89 58 0c             	mov    %ebx,0xc(%eax)
+  mycpu()->ts.iomb = (ushort) 0xFFFF;
+80106eab:	e8 20 ca ff ff       	call   801038d0 <mycpu>
+80106eb0:	66 89 78 6e          	mov    %di,0x6e(%eax)
+  asm volatile("ltr %0" : : "r" (sel));
+80106eb4:	b8 28 00 00 00       	mov    $0x28,%eax
+80106eb9:	0f 00 d8             	ltr    %ax
+  lcr3(V2P(p->pgdir));  // switch to process's address space
+80106ebc:	8b 46 04             	mov    0x4(%esi),%eax
+80106ebf:	05 00 00 00 80       	add    $0x80000000,%eax
+  asm volatile("movl %0,%%cr3" : : "r" (val));
+80106ec4:	0f 22 d8             	mov    %eax,%cr3
+}
+80106ec7:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80106eca:	5b                   	pop    %ebx
+80106ecb:	5e                   	pop    %esi
+80106ecc:	5f                   	pop    %edi
+80106ecd:	5d                   	pop    %ebp
+  popcli();
+80106ece:	e9 5d d8 ff ff       	jmp    80104730 <popcli>
+    panic("switchuvm: no process");
+80106ed3:	83 ec 0c             	sub    $0xc,%esp
+80106ed6:	68 7e 7d 10 80       	push   $0x80107d7e
+80106edb:	e8 b0 94 ff ff       	call   80100390 <panic>
+    panic("switchuvm: no pgdir");
+80106ee0:	83 ec 0c             	sub    $0xc,%esp
+80106ee3:	68 a9 7d 10 80       	push   $0x80107da9
+80106ee8:	e8 a3 94 ff ff       	call   80100390 <panic>
+    panic("switchuvm: no kstack");
+80106eed:	83 ec 0c             	sub    $0xc,%esp
+80106ef0:	68 94 7d 10 80       	push   $0x80107d94
+80106ef5:	e8 96 94 ff ff       	call   80100390 <panic>
+80106efa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80106f00 <inituvm>:
+{
+80106f00:	f3 0f 1e fb          	endbr32 
+80106f04:	55                   	push   %ebp
+80106f05:	89 e5                	mov    %esp,%ebp
+80106f07:	57                   	push   %edi
+80106f08:	56                   	push   %esi
+80106f09:	53                   	push   %ebx
+80106f0a:	83 ec 1c             	sub    $0x1c,%esp
+80106f0d:	8b 45 0c             	mov    0xc(%ebp),%eax
+80106f10:	8b 75 10             	mov    0x10(%ebp),%esi
+80106f13:	8b 7d 08             	mov    0x8(%ebp),%edi
+80106f16:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  if(sz >= PGSIZE)
+80106f19:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
+80106f1f:	77 4b                	ja     80106f6c <inituvm+0x6c>
+  mem = kalloc();
+80106f21:	e8 0a b7 ff ff       	call   80102630 <kalloc>
+  memset(mem, 0, PGSIZE);
+80106f26:	83 ec 04             	sub    $0x4,%esp
+80106f29:	68 00 10 00 00       	push   $0x1000
+  mem = kalloc();
+80106f2e:	89 c3                	mov    %eax,%ebx
+  memset(mem, 0, PGSIZE);
+80106f30:	6a 00                	push   $0x0
+80106f32:	50                   	push   %eax
+80106f33:	e8 b8 d9 ff ff       	call   801048f0 <memset>
+  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
+80106f38:	58                   	pop    %eax
+80106f39:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
+80106f3f:	5a                   	pop    %edx
+80106f40:	6a 06                	push   $0x6
+80106f42:	b9 00 10 00 00       	mov    $0x1000,%ecx
+80106f47:	31 d2                	xor    %edx,%edx
+80106f49:	50                   	push   %eax
+80106f4a:	89 f8                	mov    %edi,%eax
+80106f4c:	e8 af fc ff ff       	call   80106c00 <mappages>
+  memmove(mem, init, sz);
+80106f51:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80106f54:	89 75 10             	mov    %esi,0x10(%ebp)
+80106f57:	83 c4 10             	add    $0x10,%esp
+80106f5a:	89 5d 08             	mov    %ebx,0x8(%ebp)
+80106f5d:	89 45 0c             	mov    %eax,0xc(%ebp)
+}
+80106f60:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80106f63:	5b                   	pop    %ebx
+80106f64:	5e                   	pop    %esi
+80106f65:	5f                   	pop    %edi
+80106f66:	5d                   	pop    %ebp
+  memmove(mem, init, sz);
+80106f67:	e9 24 da ff ff       	jmp    80104990 <memmove>
+    panic("inituvm: more than a page");
+80106f6c:	83 ec 0c             	sub    $0xc,%esp
+80106f6f:	68 bd 7d 10 80       	push   $0x80107dbd
+80106f74:	e8 17 94 ff ff       	call   80100390 <panic>
+80106f79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+80106f80 <loaduvm>:
+{
+80106f80:	f3 0f 1e fb          	endbr32 
+80106f84:	55                   	push   %ebp
+80106f85:	89 e5                	mov    %esp,%ebp
+80106f87:	57                   	push   %edi
+80106f88:	56                   	push   %esi
+80106f89:	53                   	push   %ebx
+80106f8a:	83 ec 1c             	sub    $0x1c,%esp
+80106f8d:	8b 45 0c             	mov    0xc(%ebp),%eax
+80106f90:	8b 75 18             	mov    0x18(%ebp),%esi
+  if((uint) addr % PGSIZE != 0)
+80106f93:	a9 ff 0f 00 00       	test   $0xfff,%eax
+80106f98:	0f 85 99 00 00 00    	jne    80107037 <loaduvm+0xb7>
+  for(i = 0; i < sz; i += PGSIZE){
+80106f9e:	01 f0                	add    %esi,%eax
+80106fa0:	89 f3                	mov    %esi,%ebx
+80106fa2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(readi(ip, P2V(pa), offset+i, n) != n)
+80106fa5:	8b 45 14             	mov    0x14(%ebp),%eax
+80106fa8:	01 f0                	add    %esi,%eax
+80106faa:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  for(i = 0; i < sz; i += PGSIZE){
+80106fad:	85 f6                	test   %esi,%esi
+80106faf:	75 15                	jne    80106fc6 <loaduvm+0x46>
+80106fb1:	eb 6d                	jmp    80107020 <loaduvm+0xa0>
+80106fb3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+80106fb7:	90                   	nop
+80106fb8:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
+80106fbe:	89 f0                	mov    %esi,%eax
+80106fc0:	29 d8                	sub    %ebx,%eax
+80106fc2:	39 c6                	cmp    %eax,%esi
+80106fc4:	76 5a                	jbe    80107020 <loaduvm+0xa0>
+    if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
+80106fc6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+80106fc9:	8b 45 08             	mov    0x8(%ebp),%eax
+80106fcc:	31 c9                	xor    %ecx,%ecx
+80106fce:	29 da                	sub    %ebx,%edx
+80106fd0:	e8 ab fb ff ff       	call   80106b80 <walkpgdir>
+80106fd5:	85 c0                	test   %eax,%eax
+80106fd7:	74 51                	je     8010702a <loaduvm+0xaa>
+    pa = PTE_ADDR(*pte);
+80106fd9:	8b 00                	mov    (%eax),%eax
+    if(readi(ip, P2V(pa), offset+i, n) != n)
+80106fdb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
+    if(sz - i < PGSIZE)
+80106fde:	bf 00 10 00 00       	mov    $0x1000,%edi
+    pa = PTE_ADDR(*pte);
+80106fe3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+    if(sz - i < PGSIZE)
+80106fe8:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
+80106fee:	0f 46 fb             	cmovbe %ebx,%edi
+    if(readi(ip, P2V(pa), offset+i, n) != n)
+80106ff1:	29 d9                	sub    %ebx,%ecx
+80106ff3:	05 00 00 00 80       	add    $0x80000000,%eax
+80106ff8:	57                   	push   %edi
+80106ff9:	51                   	push   %ecx
+80106ffa:	50                   	push   %eax
+80106ffb:	ff 75 10             	pushl  0x10(%ebp)
+80106ffe:	e8 5d aa ff ff       	call   80101a60 <readi>
+80107003:	83 c4 10             	add    $0x10,%esp
+80107006:	39 f8                	cmp    %edi,%eax
+80107008:	74 ae                	je     80106fb8 <loaduvm+0x38>
+}
+8010700a:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return -1;
+8010700d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80107012:	5b                   	pop    %ebx
+80107013:	5e                   	pop    %esi
+80107014:	5f                   	pop    %edi
+80107015:	5d                   	pop    %ebp
+80107016:	c3                   	ret    
+80107017:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010701e:	66 90                	xchg   %ax,%ax
+80107020:	8d 65 f4             	lea    -0xc(%ebp),%esp
+  return 0;
+80107023:	31 c0                	xor    %eax,%eax
+}
+80107025:	5b                   	pop    %ebx
+80107026:	5e                   	pop    %esi
+80107027:	5f                   	pop    %edi
+80107028:	5d                   	pop    %ebp
+80107029:	c3                   	ret    
+      panic("loaduvm: address should exist");
+8010702a:	83 ec 0c             	sub    $0xc,%esp
+8010702d:	68 d7 7d 10 80       	push   $0x80107dd7
+80107032:	e8 59 93 ff ff       	call   80100390 <panic>
+    panic("loaduvm: addr must be page aligned");
+80107037:	83 ec 0c             	sub    $0xc,%esp
+8010703a:	68 78 7e 10 80       	push   $0x80107e78
+8010703f:	e8 4c 93 ff ff       	call   80100390 <panic>
+80107044:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010704b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+8010704f:	90                   	nop
+
+80107050 <allocuvm>:
+{
+80107050:	f3 0f 1e fb          	endbr32 
+80107054:	55                   	push   %ebp
+80107055:	89 e5                	mov    %esp,%ebp
+80107057:	57                   	push   %edi
+80107058:	56                   	push   %esi
+80107059:	53                   	push   %ebx
+8010705a:	83 ec 1c             	sub    $0x1c,%esp
+  if(newsz >= KERNBASE)
+8010705d:	8b 45 10             	mov    0x10(%ebp),%eax
+{
+80107060:	8b 7d 08             	mov    0x8(%ebp),%edi
+  if(newsz >= KERNBASE)
+80107063:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+80107066:	85 c0                	test   %eax,%eax
+80107068:	0f 88 b2 00 00 00    	js     80107120 <allocuvm+0xd0>
+  if(newsz < oldsz)
+8010706e:	3b 45 0c             	cmp    0xc(%ebp),%eax
+    return oldsz;
+80107071:	8b 45 0c             	mov    0xc(%ebp),%eax
+  if(newsz < oldsz)
+80107074:	0f 82 96 00 00 00    	jb     80107110 <allocuvm+0xc0>
+  a = PGROUNDUP(oldsz);
+8010707a:	8d b0 ff 0f 00 00    	lea    0xfff(%eax),%esi
+80107080:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
+  for(; a < newsz; a += PGSIZE){
+80107086:	39 75 10             	cmp    %esi,0x10(%ebp)
+80107089:	77 40                	ja     801070cb <allocuvm+0x7b>
+8010708b:	e9 83 00 00 00       	jmp    80107113 <allocuvm+0xc3>
+    memset(mem, 0, PGSIZE);
+80107090:	83 ec 04             	sub    $0x4,%esp
+80107093:	68 00 10 00 00       	push   $0x1000
+80107098:	6a 00                	push   $0x0
+8010709a:	50                   	push   %eax
+8010709b:	e8 50 d8 ff ff       	call   801048f0 <memset>
+    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
+801070a0:	58                   	pop    %eax
+801070a1:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
+801070a7:	5a                   	pop    %edx
+801070a8:	6a 06                	push   $0x6
+801070aa:	b9 00 10 00 00       	mov    $0x1000,%ecx
+801070af:	89 f2                	mov    %esi,%edx
+801070b1:	50                   	push   %eax
+801070b2:	89 f8                	mov    %edi,%eax
+801070b4:	e8 47 fb ff ff       	call   80106c00 <mappages>
+801070b9:	83 c4 10             	add    $0x10,%esp
+801070bc:	85 c0                	test   %eax,%eax
+801070be:	78 78                	js     80107138 <allocuvm+0xe8>
+  for(; a < newsz; a += PGSIZE){
+801070c0:	81 c6 00 10 00 00    	add    $0x1000,%esi
+801070c6:	39 75 10             	cmp    %esi,0x10(%ebp)
+801070c9:	76 48                	jbe    80107113 <allocuvm+0xc3>
+    mem = kalloc();
+801070cb:	e8 60 b5 ff ff       	call   80102630 <kalloc>
+801070d0:	89 c3                	mov    %eax,%ebx
+    if(mem == 0){
+801070d2:	85 c0                	test   %eax,%eax
+801070d4:	75 ba                	jne    80107090 <allocuvm+0x40>
+      cprintf("allocuvm out of memory\n");
+801070d6:	83 ec 0c             	sub    $0xc,%esp
+801070d9:	68 f5 7d 10 80       	push   $0x80107df5
+801070de:	e8 cd 95 ff ff       	call   801006b0 <cprintf>
+  if(newsz >= oldsz)
+801070e3:	8b 45 0c             	mov    0xc(%ebp),%eax
+801070e6:	83 c4 10             	add    $0x10,%esp
+801070e9:	39 45 10             	cmp    %eax,0x10(%ebp)
+801070ec:	74 32                	je     80107120 <allocuvm+0xd0>
+801070ee:	8b 55 10             	mov    0x10(%ebp),%edx
+801070f1:	89 c1                	mov    %eax,%ecx
+801070f3:	89 f8                	mov    %edi,%eax
+801070f5:	e8 96 fb ff ff       	call   80106c90 <deallocuvm.part.0>
+      return 0;
+801070fa:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+}
+80107101:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80107104:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80107107:	5b                   	pop    %ebx
+80107108:	5e                   	pop    %esi
+80107109:	5f                   	pop    %edi
+8010710a:	5d                   	pop    %ebp
+8010710b:	c3                   	ret    
+8010710c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    return oldsz;
+80107110:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+}
+80107113:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80107116:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80107119:	5b                   	pop    %ebx
+8010711a:	5e                   	pop    %esi
+8010711b:	5f                   	pop    %edi
+8010711c:	5d                   	pop    %ebp
+8010711d:	c3                   	ret    
+8010711e:	66 90                	xchg   %ax,%ax
+    return 0;
+80107120:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+}
+80107127:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+8010712a:	8d 65 f4             	lea    -0xc(%ebp),%esp
+8010712d:	5b                   	pop    %ebx
+8010712e:	5e                   	pop    %esi
+8010712f:	5f                   	pop    %edi
+80107130:	5d                   	pop    %ebp
+80107131:	c3                   	ret    
+80107132:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      cprintf("allocuvm out of memory (2)\n");
+80107138:	83 ec 0c             	sub    $0xc,%esp
+8010713b:	68 0d 7e 10 80       	push   $0x80107e0d
+80107140:	e8 6b 95 ff ff       	call   801006b0 <cprintf>
+  if(newsz >= oldsz)
+80107145:	8b 45 0c             	mov    0xc(%ebp),%eax
+80107148:	83 c4 10             	add    $0x10,%esp
+8010714b:	39 45 10             	cmp    %eax,0x10(%ebp)
+8010714e:	74 0c                	je     8010715c <allocuvm+0x10c>
+80107150:	8b 55 10             	mov    0x10(%ebp),%edx
+80107153:	89 c1                	mov    %eax,%ecx
+80107155:	89 f8                	mov    %edi,%eax
+80107157:	e8 34 fb ff ff       	call   80106c90 <deallocuvm.part.0>
+      kfree(mem);
+8010715c:	83 ec 0c             	sub    $0xc,%esp
+8010715f:	53                   	push   %ebx
+80107160:	e8 0b b3 ff ff       	call   80102470 <kfree>
+      return 0;
+80107165:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+8010716c:	83 c4 10             	add    $0x10,%esp
+}
+8010716f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80107172:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80107175:	5b                   	pop    %ebx
+80107176:	5e                   	pop    %esi
+80107177:	5f                   	pop    %edi
+80107178:	5d                   	pop    %ebp
+80107179:	c3                   	ret    
+8010717a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+80107180 <deallocuvm>:
+{
+80107180:	f3 0f 1e fb          	endbr32 
+80107184:	55                   	push   %ebp
+80107185:	89 e5                	mov    %esp,%ebp
+80107187:	8b 55 0c             	mov    0xc(%ebp),%edx
+8010718a:	8b 4d 10             	mov    0x10(%ebp),%ecx
+8010718d:	8b 45 08             	mov    0x8(%ebp),%eax
+  if(newsz >= oldsz)
+80107190:	39 d1                	cmp    %edx,%ecx
+80107192:	73 0c                	jae    801071a0 <deallocuvm+0x20>
+}
+80107194:	5d                   	pop    %ebp
+80107195:	e9 f6 fa ff ff       	jmp    80106c90 <deallocuvm.part.0>
+8010719a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+801071a0:	89 d0                	mov    %edx,%eax
+801071a2:	5d                   	pop    %ebp
+801071a3:	c3                   	ret    
+801071a4:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801071ab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801071af:	90                   	nop
+
+801071b0 <freevm>:
+
+// Free a page table and all the physical memory pages
+// in the user part.
+void
+freevm(pde_t *pgdir)
+{
+801071b0:	f3 0f 1e fb          	endbr32 
+801071b4:	55                   	push   %ebp
+801071b5:	89 e5                	mov    %esp,%ebp
+801071b7:	57                   	push   %edi
+801071b8:	56                   	push   %esi
+801071b9:	53                   	push   %ebx
+801071ba:	83 ec 0c             	sub    $0xc,%esp
+801071bd:	8b 75 08             	mov    0x8(%ebp),%esi
+  uint i;
+
+  if(pgdir == 0)
+801071c0:	85 f6                	test   %esi,%esi
+801071c2:	74 55                	je     80107219 <freevm+0x69>
+  if(newsz >= oldsz)
+801071c4:	31 c9                	xor    %ecx,%ecx
+801071c6:	ba 00 00 00 80       	mov    $0x80000000,%edx
+801071cb:	89 f0                	mov    %esi,%eax
+801071cd:	89 f3                	mov    %esi,%ebx
+801071cf:	e8 bc fa ff ff       	call   80106c90 <deallocuvm.part.0>
+    panic("freevm: no pgdir");
+  deallocuvm(pgdir, KERNBASE, 0);
+  for(i = 0; i < NPDENTRIES; i++){
+801071d4:	8d be 00 10 00 00    	lea    0x1000(%esi),%edi
+801071da:	eb 0b                	jmp    801071e7 <freevm+0x37>
+801071dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801071e0:	83 c3 04             	add    $0x4,%ebx
+801071e3:	39 df                	cmp    %ebx,%edi
+801071e5:	74 23                	je     8010720a <freevm+0x5a>
+    if(pgdir[i] & PTE_P){
+801071e7:	8b 03                	mov    (%ebx),%eax
+801071e9:	a8 01                	test   $0x1,%al
+801071eb:	74 f3                	je     801071e0 <freevm+0x30>
+      char * v = P2V(PTE_ADDR(pgdir[i]));
+801071ed:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+      kfree(v);
+801071f2:	83 ec 0c             	sub    $0xc,%esp
+801071f5:	83 c3 04             	add    $0x4,%ebx
+      char * v = P2V(PTE_ADDR(pgdir[i]));
+801071f8:	05 00 00 00 80       	add    $0x80000000,%eax
+      kfree(v);
+801071fd:	50                   	push   %eax
+801071fe:	e8 6d b2 ff ff       	call   80102470 <kfree>
+80107203:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < NPDENTRIES; i++){
+80107206:	39 df                	cmp    %ebx,%edi
+80107208:	75 dd                	jne    801071e7 <freevm+0x37>
+    }
+  }
+  kfree((char*)pgdir);
+8010720a:	89 75 08             	mov    %esi,0x8(%ebp)
+}
+8010720d:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80107210:	5b                   	pop    %ebx
+80107211:	5e                   	pop    %esi
+80107212:	5f                   	pop    %edi
+80107213:	5d                   	pop    %ebp
+  kfree((char*)pgdir);
+80107214:	e9 57 b2 ff ff       	jmp    80102470 <kfree>
+    panic("freevm: no pgdir");
+80107219:	83 ec 0c             	sub    $0xc,%esp
+8010721c:	68 29 7e 10 80       	push   $0x80107e29
+80107221:	e8 6a 91 ff ff       	call   80100390 <panic>
+80107226:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010722d:	8d 76 00             	lea    0x0(%esi),%esi
+
+80107230 <setupkvm>:
+{
+80107230:	f3 0f 1e fb          	endbr32 
+80107234:	55                   	push   %ebp
+80107235:	89 e5                	mov    %esp,%ebp
+80107237:	56                   	push   %esi
+80107238:	53                   	push   %ebx
+  if((pgdir = (pde_t*)kalloc()) == 0)
+80107239:	e8 f2 b3 ff ff       	call   80102630 <kalloc>
+8010723e:	89 c6                	mov    %eax,%esi
+80107240:	85 c0                	test   %eax,%eax
+80107242:	74 42                	je     80107286 <setupkvm+0x56>
+  memset(pgdir, 0, PGSIZE);
+80107244:	83 ec 04             	sub    $0x4,%esp
+  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
+80107247:	bb 20 a4 10 80       	mov    $0x8010a420,%ebx
+  memset(pgdir, 0, PGSIZE);
+8010724c:	68 00 10 00 00       	push   $0x1000
+80107251:	6a 00                	push   $0x0
+80107253:	50                   	push   %eax
+80107254:	e8 97 d6 ff ff       	call   801048f0 <memset>
+80107259:	83 c4 10             	add    $0x10,%esp
+                (uint)k->phys_start, k->perm) < 0) {
+8010725c:	8b 43 04             	mov    0x4(%ebx),%eax
+    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
+8010725f:	83 ec 08             	sub    $0x8,%esp
+80107262:	8b 4b 08             	mov    0x8(%ebx),%ecx
+80107265:	ff 73 0c             	pushl  0xc(%ebx)
+80107268:	8b 13                	mov    (%ebx),%edx
+8010726a:	50                   	push   %eax
+8010726b:	29 c1                	sub    %eax,%ecx
+8010726d:	89 f0                	mov    %esi,%eax
+8010726f:	e8 8c f9 ff ff       	call   80106c00 <mappages>
+80107274:	83 c4 10             	add    $0x10,%esp
+80107277:	85 c0                	test   %eax,%eax
+80107279:	78 15                	js     80107290 <setupkvm+0x60>
+  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
+8010727b:	83 c3 10             	add    $0x10,%ebx
+8010727e:	81 fb 60 a4 10 80    	cmp    $0x8010a460,%ebx
+80107284:	75 d6                	jne    8010725c <setupkvm+0x2c>
+}
+80107286:	8d 65 f8             	lea    -0x8(%ebp),%esp
+80107289:	89 f0                	mov    %esi,%eax
+8010728b:	5b                   	pop    %ebx
+8010728c:	5e                   	pop    %esi
+8010728d:	5d                   	pop    %ebp
+8010728e:	c3                   	ret    
+8010728f:	90                   	nop
+      freevm(pgdir);
+80107290:	83 ec 0c             	sub    $0xc,%esp
+80107293:	56                   	push   %esi
+      return 0;
+80107294:	31 f6                	xor    %esi,%esi
+      freevm(pgdir);
+80107296:	e8 15 ff ff ff       	call   801071b0 <freevm>
+      return 0;
+8010729b:	83 c4 10             	add    $0x10,%esp
+}
+8010729e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+801072a1:	89 f0                	mov    %esi,%eax
+801072a3:	5b                   	pop    %ebx
+801072a4:	5e                   	pop    %esi
+801072a5:	5d                   	pop    %ebp
+801072a6:	c3                   	ret    
+801072a7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+801072ae:	66 90                	xchg   %ax,%ax
+
+801072b0 <kvmalloc>:
+{
+801072b0:	f3 0f 1e fb          	endbr32 
+801072b4:	55                   	push   %ebp
+801072b5:	89 e5                	mov    %esp,%ebp
+801072b7:	83 ec 08             	sub    $0x8,%esp
+  kpgdir = setupkvm();
+801072ba:	e8 71 ff ff ff       	call   80107230 <setupkvm>
+801072bf:	a3 a4 55 11 80       	mov    %eax,0x801155a4
+  lcr3(V2P(kpgdir));   // switch to the kernel page table
+801072c4:	05 00 00 00 80       	add    $0x80000000,%eax
+801072c9:	0f 22 d8             	mov    %eax,%cr3
+}
+801072cc:	c9                   	leave  
+801072cd:	c3                   	ret    
+801072ce:	66 90                	xchg   %ax,%ax
+
+801072d0 <clearpteu>:
+
+// Clear PTE_U on a page. Used to create an inaccessible
+// page beneath the user stack.
+void
+clearpteu(pde_t *pgdir, char *uva)
+{
+801072d0:	f3 0f 1e fb          	endbr32 
+801072d4:	55                   	push   %ebp
+  pte_t *pte;
+
+  pte = walkpgdir(pgdir, uva, 0);
+801072d5:	31 c9                	xor    %ecx,%ecx
+{
+801072d7:	89 e5                	mov    %esp,%ebp
+801072d9:	83 ec 08             	sub    $0x8,%esp
+  pte = walkpgdir(pgdir, uva, 0);
+801072dc:	8b 55 0c             	mov    0xc(%ebp),%edx
+801072df:	8b 45 08             	mov    0x8(%ebp),%eax
+801072e2:	e8 99 f8 ff ff       	call   80106b80 <walkpgdir>
+  if(pte == 0)
+801072e7:	85 c0                	test   %eax,%eax
+801072e9:	74 05                	je     801072f0 <clearpteu+0x20>
+    panic("clearpteu");
+  *pte &= ~PTE_U;
+801072eb:	83 20 fb             	andl   $0xfffffffb,(%eax)
+}
+801072ee:	c9                   	leave  
+801072ef:	c3                   	ret    
+    panic("clearpteu");
+801072f0:	83 ec 0c             	sub    $0xc,%esp
+801072f3:	68 3a 7e 10 80       	push   $0x80107e3a
+801072f8:	e8 93 90 ff ff       	call   80100390 <panic>
+801072fd:	8d 76 00             	lea    0x0(%esi),%esi
+
+80107300 <copyuvm>:
+
+// Given a parent process's page table, create a copy
+// of it for a child.
+pde_t*
+copyuvm(pde_t *pgdir, uint sz)
+{
+80107300:	f3 0f 1e fb          	endbr32 
+80107304:	55                   	push   %ebp
+80107305:	89 e5                	mov    %esp,%ebp
+80107307:	57                   	push   %edi
+80107308:	56                   	push   %esi
+80107309:	53                   	push   %ebx
+8010730a:	83 ec 1c             	sub    $0x1c,%esp
+  pde_t *d;
+  pte_t *pte;
+  uint pa, i, flags;
+  char *mem;
+
+  if((d = setupkvm()) == 0)
+8010730d:	e8 1e ff ff ff       	call   80107230 <setupkvm>
+80107312:	89 45 e0             	mov    %eax,-0x20(%ebp)
+80107315:	85 c0                	test   %eax,%eax
+80107317:	0f 84 9b 00 00 00    	je     801073b8 <copyuvm+0xb8>
+    return 0;
+  for(i = 0; i < sz; i += PGSIZE){
+8010731d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+80107320:	85 c9                	test   %ecx,%ecx
+80107322:	0f 84 90 00 00 00    	je     801073b8 <copyuvm+0xb8>
+80107328:	31 f6                	xor    %esi,%esi
+8010732a:	eb 46                	jmp    80107372 <copyuvm+0x72>
+8010732c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      panic("copyuvm: page not present");
+    pa = PTE_ADDR(*pte);
+    flags = PTE_FLAGS(*pte);
+    if((mem = kalloc()) == 0)
+      goto bad;
+    memmove(mem, (char*)P2V(pa), PGSIZE);
+80107330:	83 ec 04             	sub    $0x4,%esp
+80107333:	81 c7 00 00 00 80    	add    $0x80000000,%edi
+80107339:	68 00 10 00 00       	push   $0x1000
+8010733e:	57                   	push   %edi
+8010733f:	50                   	push   %eax
+80107340:	e8 4b d6 ff ff       	call   80104990 <memmove>
+    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
+80107345:	58                   	pop    %eax
+80107346:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
+8010734c:	5a                   	pop    %edx
+8010734d:	ff 75 e4             	pushl  -0x1c(%ebp)
+80107350:	b9 00 10 00 00       	mov    $0x1000,%ecx
+80107355:	89 f2                	mov    %esi,%edx
+80107357:	50                   	push   %eax
+80107358:	8b 45 e0             	mov    -0x20(%ebp),%eax
+8010735b:	e8 a0 f8 ff ff       	call   80106c00 <mappages>
+80107360:	83 c4 10             	add    $0x10,%esp
+80107363:	85 c0                	test   %eax,%eax
+80107365:	78 61                	js     801073c8 <copyuvm+0xc8>
+  for(i = 0; i < sz; i += PGSIZE){
+80107367:	81 c6 00 10 00 00    	add    $0x1000,%esi
+8010736d:	39 75 0c             	cmp    %esi,0xc(%ebp)
+80107370:	76 46                	jbe    801073b8 <copyuvm+0xb8>
+    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
+80107372:	8b 45 08             	mov    0x8(%ebp),%eax
+80107375:	31 c9                	xor    %ecx,%ecx
+80107377:	89 f2                	mov    %esi,%edx
+80107379:	e8 02 f8 ff ff       	call   80106b80 <walkpgdir>
+8010737e:	85 c0                	test   %eax,%eax
+80107380:	74 61                	je     801073e3 <copyuvm+0xe3>
+    if(!(*pte & PTE_P))
+80107382:	8b 00                	mov    (%eax),%eax
+80107384:	a8 01                	test   $0x1,%al
+80107386:	74 4e                	je     801073d6 <copyuvm+0xd6>
+    pa = PTE_ADDR(*pte);
+80107388:	89 c7                	mov    %eax,%edi
+    flags = PTE_FLAGS(*pte);
+8010738a:	25 ff 0f 00 00       	and    $0xfff,%eax
+8010738f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    pa = PTE_ADDR(*pte);
+80107392:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
+    if((mem = kalloc()) == 0)
+80107398:	e8 93 b2 ff ff       	call   80102630 <kalloc>
+8010739d:	89 c3                	mov    %eax,%ebx
+8010739f:	85 c0                	test   %eax,%eax
+801073a1:	75 8d                	jne    80107330 <copyuvm+0x30>
+    }
+  }
+  return d;
+
+bad:
+  freevm(d);
+801073a3:	83 ec 0c             	sub    $0xc,%esp
+801073a6:	ff 75 e0             	pushl  -0x20(%ebp)
+801073a9:	e8 02 fe ff ff       	call   801071b0 <freevm>
+  return 0;
+801073ae:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+801073b5:	83 c4 10             	add    $0x10,%esp
+}
+801073b8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801073bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
+801073be:	5b                   	pop    %ebx
+801073bf:	5e                   	pop    %esi
+801073c0:	5f                   	pop    %edi
+801073c1:	5d                   	pop    %ebp
+801073c2:	c3                   	ret    
+801073c3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+801073c7:	90                   	nop
+      kfree(mem);
+801073c8:	83 ec 0c             	sub    $0xc,%esp
+801073cb:	53                   	push   %ebx
+801073cc:	e8 9f b0 ff ff       	call   80102470 <kfree>
+      goto bad;
+801073d1:	83 c4 10             	add    $0x10,%esp
+801073d4:	eb cd                	jmp    801073a3 <copyuvm+0xa3>
+      panic("copyuvm: page not present");
+801073d6:	83 ec 0c             	sub    $0xc,%esp
+801073d9:	68 5e 7e 10 80       	push   $0x80107e5e
+801073de:	e8 ad 8f ff ff       	call   80100390 <panic>
+      panic("copyuvm: pte should exist");
+801073e3:	83 ec 0c             	sub    $0xc,%esp
+801073e6:	68 44 7e 10 80       	push   $0x80107e44
+801073eb:	e8 a0 8f ff ff       	call   80100390 <panic>
+
+801073f0 <uva2ka>:
+
+//PAGEBREAK!
+// Map user virtual address to kernel address.
+char*
+uva2ka(pde_t *pgdir, char *uva)
+{
+801073f0:	f3 0f 1e fb          	endbr32 
+801073f4:	55                   	push   %ebp
+  pte_t *pte;
+
+  pte = walkpgdir(pgdir, uva, 0);
+801073f5:	31 c9                	xor    %ecx,%ecx
+{
+801073f7:	89 e5                	mov    %esp,%ebp
+801073f9:	83 ec 08             	sub    $0x8,%esp
+  pte = walkpgdir(pgdir, uva, 0);
+801073fc:	8b 55 0c             	mov    0xc(%ebp),%edx
+801073ff:	8b 45 08             	mov    0x8(%ebp),%eax
+80107402:	e8 79 f7 ff ff       	call   80106b80 <walkpgdir>
+  if((*pte & PTE_P) == 0)
+80107407:	8b 00                	mov    (%eax),%eax
+    return 0;
+  if((*pte & PTE_U) == 0)
+    return 0;
+  return (char*)P2V(PTE_ADDR(*pte));
+}
+80107409:	c9                   	leave  
+  if((*pte & PTE_U) == 0)
+8010740a:	89 c2                	mov    %eax,%edx
+  return (char*)P2V(PTE_ADDR(*pte));
+8010740c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+  if((*pte & PTE_U) == 0)
+80107411:	83 e2 05             	and    $0x5,%edx
+  return (char*)P2V(PTE_ADDR(*pte));
+80107414:	05 00 00 00 80       	add    $0x80000000,%eax
+80107419:	83 fa 05             	cmp    $0x5,%edx
+8010741c:	ba 00 00 00 00       	mov    $0x0,%edx
+80107421:	0f 45 c2             	cmovne %edx,%eax
+}
+80107424:	c3                   	ret    
+80107425:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+8010742c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+80107430 <copyout>:
+// Copy len bytes from p to user address va in page table pgdir.
+// Most useful when pgdir is not the current page table.
+// uva2ka ensures this only works for PTE_U pages.
+int
+copyout(pde_t *pgdir, uint va, void *p, uint len)
+{
+80107430:	f3 0f 1e fb          	endbr32 
+80107434:	55                   	push   %ebp
+80107435:	89 e5                	mov    %esp,%ebp
+80107437:	57                   	push   %edi
+80107438:	56                   	push   %esi
+80107439:	53                   	push   %ebx
+8010743a:	83 ec 0c             	sub    $0xc,%esp
+8010743d:	8b 75 14             	mov    0x14(%ebp),%esi
+80107440:	8b 55 0c             	mov    0xc(%ebp),%edx
+  char *buf, *pa0;
+  uint n, va0;
+
+  buf = (char*)p;
+  while(len > 0){
+80107443:	85 f6                	test   %esi,%esi
+80107445:	75 3c                	jne    80107483 <copyout+0x53>
+80107447:	eb 67                	jmp    801074b0 <copyout+0x80>
+80107449:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    va0 = (uint)PGROUNDDOWN(va);
+    pa0 = uva2ka(pgdir, (char*)va0);
+    if(pa0 == 0)
+      return -1;
+    n = PGSIZE - (va - va0);
+80107450:	8b 55 0c             	mov    0xc(%ebp),%edx
+80107453:	89 fb                	mov    %edi,%ebx
+80107455:	29 d3                	sub    %edx,%ebx
+80107457:	81 c3 00 10 00 00    	add    $0x1000,%ebx
+    if(n > len)
+8010745d:	39 f3                	cmp    %esi,%ebx
+8010745f:	0f 47 de             	cmova  %esi,%ebx
+      n = len;
+    memmove(pa0 + (va - va0), buf, n);
+80107462:	29 fa                	sub    %edi,%edx
+80107464:	83 ec 04             	sub    $0x4,%esp
+80107467:	01 c2                	add    %eax,%edx
+80107469:	53                   	push   %ebx
+8010746a:	ff 75 10             	pushl  0x10(%ebp)
+8010746d:	52                   	push   %edx
+8010746e:	e8 1d d5 ff ff       	call   80104990 <memmove>
+    len -= n;
+    buf += n;
+80107473:	01 5d 10             	add    %ebx,0x10(%ebp)
+    va = va0 + PGSIZE;
+80107476:	8d 97 00 10 00 00    	lea    0x1000(%edi),%edx
+  while(len > 0){
+8010747c:	83 c4 10             	add    $0x10,%esp
+8010747f:	29 de                	sub    %ebx,%esi
+80107481:	74 2d                	je     801074b0 <copyout+0x80>
+    va0 = (uint)PGROUNDDOWN(va);
+80107483:	89 d7                	mov    %edx,%edi
+    pa0 = uva2ka(pgdir, (char*)va0);
+80107485:	83 ec 08             	sub    $0x8,%esp
+    va0 = (uint)PGROUNDDOWN(va);
+80107488:	89 55 0c             	mov    %edx,0xc(%ebp)
+8010748b:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
+    pa0 = uva2ka(pgdir, (char*)va0);
+80107491:	57                   	push   %edi
+80107492:	ff 75 08             	pushl  0x8(%ebp)
+80107495:	e8 56 ff ff ff       	call   801073f0 <uva2ka>
+    if(pa0 == 0)
+8010749a:	83 c4 10             	add    $0x10,%esp
+8010749d:	85 c0                	test   %eax,%eax
+8010749f:	75 af                	jne    80107450 <copyout+0x20>
+  }
+  return 0;
+}
+801074a1:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return -1;
+801074a4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+801074a9:	5b                   	pop    %ebx
+801074aa:	5e                   	pop    %esi
+801074ab:	5f                   	pop    %edi
+801074ac:	5d                   	pop    %ebp
+801074ad:	c3                   	ret    
+801074ae:	66 90                	xchg   %ax,%ax
+801074b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
+  return 0;
+801074b3:	31 c0                	xor    %eax,%eax
+}
+801074b5:	5b                   	pop    %ebx
+801074b6:	5e                   	pop    %esi
+801074b7:	5f                   	pop    %edi
+801074b8:	5d                   	pop    %ebp
+801074b9:	c3                   	ret    
diff -ruN xv6-public/kernel.sym copy-xv6/kernel.sym
--- xv6-public/kernel.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/kernel.sym	2022-09-05 23:26:13.892781048 +0530
@@ -0,0 +1,523 @@
+80100000 .text
+801074c0 .rodata
+80108000 .data
+8010a520 .bss
+00000000 .debug_line
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_aranges
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 .comment
+00000000 bio.c
+00000000 console.c
+8010a520 cons
+8010a558 panicked
+80100410 consputc.part.0
+801005a0 printint
+80107530 digits.1587
+00000000 exec.c
+00000000 file.c
+00000000 fs.c
+801011b0 bfree
+80101230 balloc
+80101340 iget
+80101430 bmap
+80101d70 namex
+00000000 ide.c
+80102070 idestart
+8010a580 idelock
+8010a560 havedisk1
+8010a564 idequeue
+00000000 ioapic.c
+00000000 kalloc.c
+00000000 kbd.c
+8010a5b4 shift.1427
+80107860 shiftcode
+80107760 togglecode
+80107740 charcode.1428
+80108200 normalmap
+80108100 shiftmap
+80108000 ctlmap
+00000000 lapic.c
+00000000 log.c
+80102b90 install_trans
+80102c30 write_head
+00000000 main.c
+80102fe0 mpmain
+80103020 mpenter
+00000000 mp.c
+80103170 mpsearch1
+00000000 picirq.c
+00000000 pipe.c
+00000000 proc.c
+80103790 allocproc
+8010a000 first.1629
+8010a5b8 initproc
+80107b0c states.1655
+00000000 sleeplock.c
+00000000 spinlock.c
+00000000 string.c
+00000000 syscall.c
+80107b80 syscalls
+00000000 sysfile.c
+80104d30 create
+80104ed0 argfd.constprop.0
+00000000 sysproc.c
+00000000 trap.c
+00000000 uart.c
+80105f80 uartgetc
+8010a5bc uart
+80105fb0 uartputc.part.0
+00000000 vm.c
+80106b80 walkpgdir
+80106c00 mappages
+80106c90 deallocuvm.part.0
+8010a420 kmap
+80100290 consoleread
+80106ad3 vector242
+8010652a vector119
+8010000c entry
+8010640a vector87
+80106401 vector86
+80104ab0 safestrcpy
+80105070 sys_close
+80106b3f vector251
+8010642e vector91
+80106224 vector33
+80106713 vector162
+80103ed0 yield
+80112680 log
+80112640 kmem
+80106977 vector213
+801064c7 vector108
+80106000 uartinit
+8010627e vector43
+801028c0 lapiceoi
+80106737 vector165
+80106827 vector185
+80102380 ioapicinit
+80106506 vector115
+80100ff0 fileread
+80106545 vector122
+801059c0 sys_sbrk
+80112760 ioapicid
+80104510 thread_exit
+801066cb vector156
+80106af7 vector245
+80112634 ioapic
+80106857 vector189
+80106148 vector7
+80106320 vector61
+801061d3 vector24
+801064e2 vector111
+801068db vector200
+80106356 vector67
+801065f3 vector138
+80106395 vector74
+80103cd0 sched
+80104990 memmove
+801062fc vector57
+80104cc0 syscall
+80106983 vector214
+80106476 vector99
+80103940 cpuid
+80101b60 writei
+80106617 vector141
+80105920 sys_fork
+8010b5c0 bcache
+8010678b vector172
+80106ac7 vector241
+80104680 getcallerpcs
+80105580 sys_mkdir
+80106b57 vector253
+80106124 vector3
+8010611b vector2
+80101c90 namecmp
+80106a1f vector227
+80106953 vector210
+80104c80 argstr
+801069fb vector224
+8010626c vector41
+801006b0 cprintf
+80100e70 filedup
+80102030 namei
+801061b8 vector21
+80100040 binit
+801067c7 vector177
+80106521 vector118
+80106371 vector70
+80106368 vector69
+80106a97 vector237
+8010633b vector64
+801061ee vector27
+801065ab vector132
+80106833 vector186
+80104f90 sys_read
+801069a7 vector217
+80104b30 fetchint
+80107230 setupkvm
+801049f0 memcpy
+801071b0 freevm
+80106112 vector1
+801067d3 vector178
+80106251 vector38
+80102470 kfree
+80106aa3 vector238
+801038d0 mycpu
+80101890 iput
+801065b7 vector133
+8010638c vector73
+8010663b vector144
+80106b63 vector254
+80101500 readsb
+8010a004 nextpid
+80106488 vector101
+8010695f vector211
+801031f0 mpinit
+801067a3 vector174
+80106adf vector243
+80100de0 fileinit
+80104660 initlock
+8010657b vector128
+80107430 copyout
+801063d4 vector81
+80103f20 sleep
+801028e0 microdelay
+80106176 vector13
+801062c6 vector51
+8010618d vector16
+8010ff20 input
+80106abb vector240
+801062e1 vector54
+801061a6 vector19
+80106437 vector92
+80106aeb vector244
+80101a30 stati
+8010660b vector140
+80105960 sys_kill
+80106290 vector45
+801063c2 vector79
+80103500 pipeclose
+80106a37 vector229
+801066e3 vector158
+801050c0 sys_fstat
+80100640 consolewrite
+8010625a vector39
+8010675b vector168
+80105af0 sys_thread_create
+80102da0 end_op
+80106236 vector35
+801064f4 vector113
+80102510 freerange
+80106560 vector125
+80107050 allocuvm
+80105c67 trapret
+8010699b vector216
+80106332 vector63
+801061e5 vector26
+80106887 vector193
+801027a0 lapicinit
+801068ab vector196
+80106947 vector209
+8010612d vector4
+80106773 vector170
+8010a5c0 stack
+801065db vector136
+80106161 vector10
+80106923 vector206
+80101840 iunlock
+80105a10 sys_sleep
+80106b6f vector255
+801067f7 vector181
+8010630e vector59
+801063f8 vector85
+801063ef vector84
+8010680f vector183
+801066ef vector159
+8010696b vector212
+80105110 sys_link
+801062a2 vector47
+80106a2b vector228
+80106275 vector42
+801064fd vector114
+801073f0 uva2ka
+801067af vector175
+8010662f vector143
+80100e00 filealloc
+801040e0 wakeup
+80106593 vector130
+80106b03 vector246
+80106158 vector9
+80106623 vector142
+8010647f vector100
+801068e7 vector201
+801072d0 clearpteu
+80103960 myproc
+80105c80 tvinit
+80106317 vector60
+801061ca vector23
+80101730 idup
+80106a8b vector236
+80102780 kbdintr
+80105440 sys_open
+80106a4f vector231
+8010634d vector66
+80106200 vector29
+80101a60 readi
+801065cf vector135
+80100860 consoleintr
+80104140 kill
+801063b0 vector77
+801015e0 ialloc
+801067eb vector180
+801155a4 kpgdir
+8010693b vector208
+80102990 cmostime
+801060f0 uartintr
+8010646d vector98
+80106464 vector97
+801067bb vector176
+80106893 vector194
+8010621b vector32
+801155a8 end
+801068cf vector199
+8010659f vector131
+80106b4b vector252
+80101090 filewrite
+80106109 vector0
+80104bd0 argint
+80100a80 exec
+80106647 vector145
+80105000 sys_write
+801048a0 release
+80104b70 fetchstr
+801064be vector107
+80106263 vector40
+80103fe0 wait
+80106491 vector102
+80109000 entrypgdir
+0010000c _start
+801062f3 vector56
+8010635f vector68
+8010613f vector6
+8010a48c _binary_initcode_end
+80100000 multiboot_header
+80106587 vector129
+80103c30 scheduler
+80101cb0 dirlookup
+801068b7 vector197
+80100ec0 fileclose
+80102d30 begin_op
+8010669b vector152
+801072b0 kvmalloc
+80106a43 vector230
+80104a00 strncmp
+80106248 vector37
+80106917 vector205
+80106707 vector161
+80114d60 tickslock
+801035a0 pipewrite
+80104a50 strncpy
+8010637a vector71
+80107300 copyuvm
+8010ffc0 ftable
+801066fb vector160
+80104c20 argptr
+8010698f vector215
+801066d7 vector157
+80104f20 sys_dup
+801064eb vector112
+80100390 panic
+80103860 forkret
+80106803 vector182
+8010616f vector12
+80104940 memcmp
+801026a0 kbdgetc
+801064d0 vector109
+801061af vector20
+80103b10 fork
+801062d8 vector53
+8010619d vector18
+0000008a _binary_entryother_size
+80112780 cpus
+801045c0 releasesleep
+80106452 vector95
+80104790 holding
+801109c0 sb
+801047e0 acquire
+80106a13 vector226
+80102050 nameiparent
+801062b4 vector49
+80106287 vector44
+8011267c lapic
+801063b9 vector78
+80105c4f alltraps
+80106797 vector173
+80106518 vector117
+801063dd vector82
+801069e3 vector222
+80106151 vector8
+80106677 vector149
+801016a0 iupdate
+80108000 data
+801048f0 memset
+80106a5b vector232
+80103040 main
+80106dd0 switchkvm
+801064b5 vector106
+801069cb vector220
+80106425 vector90
+8010671f vector163
+80106a73 vector234
+80102f10 log_write
+80104560 acquiresleep
+80105260 sys_unlink
+80106329 vector62
+801061dc vector25
+801068c3 vector198
+80106533 vector120
+8010a48c _binary_entryother_start
+80102560 kinit1
+801062bd vector50
+80106184 vector15
+8010668f vector151
+801063e6 vector83
+8010641c vector89
+80106413 vector88
+80105d30 trap
+80105ac0 sys_uptime
+801067df vector179
+8010622d vector34
+80106299 vector46
+801065c3 vector134
+801069ef vector223
+80114da0 idt
+801069b3 vector218
+801038b0 pinit
+80107180 deallocuvm
+80106a07 vector225
+801028a0 lapicid
+8010683f vector187
+80103a90 growproc
+80104600 holdingsleep
+80112d00 ncpu
+80106209 vector30
+80103990 userinit
+801000d0 bread
+80106572 vector127
+801036a0 piperead
+801155a0 ticks
+8010687b vector192
+80106743 vector166
+80100a30 consoleinit
+801063a7 vector76
+8010639e vector75
+801021e0 ideintr
+8010689f vector195
+80106683 vector150
+80106305 vector58
+80106b1b vector248
+8010654e vector123
+8010645b vector96
+80106212 vector31
+801068ff vector203
+801065ff vector139
+801066a7 vector153
+8010672b vector164
+801041d0 procdump
+8010653c vector121
+801060c0 uartputc
+80106136 vector5
+8010674f vector167
+801066bf vector155
+80106b27 vector249
+801001f0 brelse
+80106b33 vector250
+80106557 vector124
+801064d9 vector110
+8010690b vector204
+80101760 ilock
+80105740 sys_exec
+801065e7 vector137
+8010a460 _binary_initcode_start
+80104b13 swtch
+80106b0f vector247
+801061c1 vector22
+801068f3 vector202
+80106d40 seginit
+80101a00 iunlockput
+80106383 vector72
+801062ea vector55
+80106569 vector126
+80106344 vector65
+801061f7 vector28
+8010a516 _binary_entryother_end
+80106767 vector169
+801001b0 bwrite
+80106a67 vector233
+80105d00 idtinit
+80103d90 exit
+80105950 sys_wait
+80105930 sys_exit
+80101f70 dirlink
+0000002c _binary_initcode_size
+8010665f vector147
+80104520 initsleeplock
+80102150 ideinit
+80106f80 loaduvm
+801064a3 vector104
+8010650f vector116
+80112d20 ptable
+80102430 ioapicenable
+80104730 popcli
+8010a008 vectors
+801062cf vector52
+80106196 vector17
+8010681b vector184
+80104af0 strlen
+80105840 sys_pipe
+80101540 iinit
+801033d0 picinit
+8010692f vector207
+80106f00 inituvm
+80106863 vector190
+80105b80 sys_thread_join
+80106aaf vector239
+80106449 vector94
+80106440 vector93
+80102c90 initlog
+8010684b vector188
+801042a0 thread_create
+801062ab vector48
+80102280 iderw
+80105b60 sys_thread_exit
+801069bf vector219
+8010666b vector148
+801069d7 vector221
+80102630 kalloc
+80110960 devsw
+801059a0 sys_getpid
+80105b90 sys_draw
+801063cb vector80
+8010677f vector171
+801066b3 vector154
+8010623f vector36
+801033f0 pipealloc
+80106a7f vector235
+801064ac vector105
+80105690 sys_chdir
+801109e0 icache
+80106653 vector146
+8010686f vector191
+8010649a vector103
+80104400 thread_join
+801055f0 sys_mknod
+801028f0 lapicstartap
+80106df0 switchuvm
+801046e0 pushcli
+801025d0 kinit2
+80106168 vector11
+8010617d vector14
+80100fa0 filestat
Binary files xv6-public/_kill and copy-xv6/_kill differ
diff -ruN xv6-public/kill.asm copy-xv6/kill.asm
--- xv6-public/kill.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/kill.asm	2022-09-05 23:26:11.980781091 +0530
@@ -0,0 +1,1223 @@
+
+_kill:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char **argv)
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	56                   	push   %esi
+  12:	53                   	push   %ebx
+  13:	51                   	push   %ecx
+  14:	83 ec 0c             	sub    $0xc,%esp
+  17:	8b 01                	mov    (%ecx),%eax
+  19:	8b 51 04             	mov    0x4(%ecx),%edx
+  int i;
+
+  if(argc < 2){
+  1c:	83 f8 01             	cmp    $0x1,%eax
+  1f:	7e 30                	jle    51 <main+0x51>
+  21:	8d 5a 04             	lea    0x4(%edx),%ebx
+  24:	8d 34 82             	lea    (%edx,%eax,4),%esi
+  27:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  2e:	66 90                	xchg   %ax,%ax
+    printf(2, "usage: kill pid...\n");
+    exit();
+  }
+  for(i=1; i<argc; i++)
+    kill(atoi(argv[i]));
+  30:	83 ec 0c             	sub    $0xc,%esp
+  33:	ff 33                	pushl  (%ebx)
+  35:	83 c3 04             	add    $0x4,%ebx
+  38:	e8 23 02 00 00       	call   260 <atoi>
+  3d:	89 04 24             	mov    %eax,(%esp)
+  40:	e8 be 02 00 00       	call   303 <kill>
+  for(i=1; i<argc; i++)
+  45:	83 c4 10             	add    $0x10,%esp
+  48:	39 f3                	cmp    %esi,%ebx
+  4a:	75 e4                	jne    30 <main+0x30>
+  exit();
+  4c:	e8 82 02 00 00       	call   2d3 <exit>
+    printf(2, "usage: kill pid...\n");
+  51:	50                   	push   %eax
+  52:	50                   	push   %eax
+  53:	68 b8 07 00 00       	push   $0x7b8
+  58:	6a 02                	push   $0x2
+  5a:	e8 f1 03 00 00       	call   450 <printf>
+    exit();
+  5f:	e8 6f 02 00 00       	call   2d3 <exit>
+  64:	66 90                	xchg   %ax,%ax
+  66:	66 90                	xchg   %ax,%ax
+  68:	66 90                	xchg   %ax,%ax
+  6a:	66 90                	xchg   %ax,%ax
+  6c:	66 90                	xchg   %ax,%ax
+  6e:	66 90                	xchg   %ax,%ax
+
+00000070 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+  70:	f3 0f 1e fb          	endbr32 
+  74:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  75:	31 c0                	xor    %eax,%eax
+{
+  77:	89 e5                	mov    %esp,%ebp
+  79:	53                   	push   %ebx
+  7a:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  7d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+  80:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+  84:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+  87:	83 c0 01             	add    $0x1,%eax
+  8a:	84 d2                	test   %dl,%dl
+  8c:	75 f2                	jne    80 <strcpy+0x10>
+    ;
+  return os;
+}
+  8e:	89 c8                	mov    %ecx,%eax
+  90:	5b                   	pop    %ebx
+  91:	5d                   	pop    %ebp
+  92:	c3                   	ret    
+  93:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000000a0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  a0:	f3 0f 1e fb          	endbr32 
+  a4:	55                   	push   %ebp
+  a5:	89 e5                	mov    %esp,%ebp
+  a7:	53                   	push   %ebx
+  a8:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  ab:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+  ae:	0f b6 01             	movzbl (%ecx),%eax
+  b1:	0f b6 1a             	movzbl (%edx),%ebx
+  b4:	84 c0                	test   %al,%al
+  b6:	75 19                	jne    d1 <strcmp+0x31>
+  b8:	eb 26                	jmp    e0 <strcmp+0x40>
+  ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  c0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+  c4:	83 c1 01             	add    $0x1,%ecx
+  c7:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+  ca:	0f b6 1a             	movzbl (%edx),%ebx
+  cd:	84 c0                	test   %al,%al
+  cf:	74 0f                	je     e0 <strcmp+0x40>
+  d1:	38 d8                	cmp    %bl,%al
+  d3:	74 eb                	je     c0 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+  d5:	29 d8                	sub    %ebx,%eax
+}
+  d7:	5b                   	pop    %ebx
+  d8:	5d                   	pop    %ebp
+  d9:	c3                   	ret    
+  da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  e0:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+  e2:	29 d8                	sub    %ebx,%eax
+}
+  e4:	5b                   	pop    %ebx
+  e5:	5d                   	pop    %ebp
+  e6:	c3                   	ret    
+  e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  ee:	66 90                	xchg   %ax,%ax
+
+000000f0 <strlen>:
+
+uint
+strlen(const char *s)
+{
+  f0:	f3 0f 1e fb          	endbr32 
+  f4:	55                   	push   %ebp
+  f5:	89 e5                	mov    %esp,%ebp
+  f7:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+  fa:	80 3a 00             	cmpb   $0x0,(%edx)
+  fd:	74 21                	je     120 <strlen+0x30>
+  ff:	31 c0                	xor    %eax,%eax
+ 101:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 108:	83 c0 01             	add    $0x1,%eax
+ 10b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+ 10f:	89 c1                	mov    %eax,%ecx
+ 111:	75 f5                	jne    108 <strlen+0x18>
+    ;
+  return n;
+}
+ 113:	89 c8                	mov    %ecx,%eax
+ 115:	5d                   	pop    %ebp
+ 116:	c3                   	ret    
+ 117:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 11e:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+ 120:	31 c9                	xor    %ecx,%ecx
+}
+ 122:	5d                   	pop    %ebp
+ 123:	89 c8                	mov    %ecx,%eax
+ 125:	c3                   	ret    
+ 126:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 12d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000130 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 130:	f3 0f 1e fb          	endbr32 
+ 134:	55                   	push   %ebp
+ 135:	89 e5                	mov    %esp,%ebp
+ 137:	57                   	push   %edi
+ 138:	8b 55 08             	mov    0x8(%ebp),%edx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+ 13b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 13e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 141:	89 d7                	mov    %edx,%edi
+ 143:	fc                   	cld    
+ 144:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+ 146:	89 d0                	mov    %edx,%eax
+ 148:	5f                   	pop    %edi
+ 149:	5d                   	pop    %ebp
+ 14a:	c3                   	ret    
+ 14b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 14f:	90                   	nop
+
+00000150 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 150:	f3 0f 1e fb          	endbr32 
+ 154:	55                   	push   %ebp
+ 155:	89 e5                	mov    %esp,%ebp
+ 157:	8b 45 08             	mov    0x8(%ebp),%eax
+ 15a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+ 15e:	0f b6 10             	movzbl (%eax),%edx
+ 161:	84 d2                	test   %dl,%dl
+ 163:	75 16                	jne    17b <strchr+0x2b>
+ 165:	eb 21                	jmp    188 <strchr+0x38>
+ 167:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 16e:	66 90                	xchg   %ax,%ax
+ 170:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+ 174:	83 c0 01             	add    $0x1,%eax
+ 177:	84 d2                	test   %dl,%dl
+ 179:	74 0d                	je     188 <strchr+0x38>
+    if(*s == c)
+ 17b:	38 d1                	cmp    %dl,%cl
+ 17d:	75 f1                	jne    170 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+ 17f:	5d                   	pop    %ebp
+ 180:	c3                   	ret    
+ 181:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+ 188:	31 c0                	xor    %eax,%eax
+}
+ 18a:	5d                   	pop    %ebp
+ 18b:	c3                   	ret    
+ 18c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000190 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 190:	f3 0f 1e fb          	endbr32 
+ 194:	55                   	push   %ebp
+ 195:	89 e5                	mov    %esp,%ebp
+ 197:	57                   	push   %edi
+ 198:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 199:	31 f6                	xor    %esi,%esi
+{
+ 19b:	53                   	push   %ebx
+ 19c:	89 f3                	mov    %esi,%ebx
+ 19e:	83 ec 1c             	sub    $0x1c,%esp
+ 1a1:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+ 1a4:	eb 33                	jmp    1d9 <gets+0x49>
+ 1a6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1ad:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+ 1b0:	83 ec 04             	sub    $0x4,%esp
+ 1b3:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ 1b6:	6a 01                	push   $0x1
+ 1b8:	50                   	push   %eax
+ 1b9:	6a 00                	push   $0x0
+ 1bb:	e8 2b 01 00 00       	call   2eb <read>
+    if(cc < 1)
+ 1c0:	83 c4 10             	add    $0x10,%esp
+ 1c3:	85 c0                	test   %eax,%eax
+ 1c5:	7e 1c                	jle    1e3 <gets+0x53>
+      break;
+    buf[i++] = c;
+ 1c7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ 1cb:	83 c7 01             	add    $0x1,%edi
+ 1ce:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+ 1d1:	3c 0a                	cmp    $0xa,%al
+ 1d3:	74 23                	je     1f8 <gets+0x68>
+ 1d5:	3c 0d                	cmp    $0xd,%al
+ 1d7:	74 1f                	je     1f8 <gets+0x68>
+  for(i=0; i+1 < max; ){
+ 1d9:	83 c3 01             	add    $0x1,%ebx
+ 1dc:	89 fe                	mov    %edi,%esi
+ 1de:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+ 1e1:	7c cd                	jl     1b0 <gets+0x20>
+ 1e3:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+ 1e5:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+ 1e8:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 1eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 1ee:	5b                   	pop    %ebx
+ 1ef:	5e                   	pop    %esi
+ 1f0:	5f                   	pop    %edi
+ 1f1:	5d                   	pop    %ebp
+ 1f2:	c3                   	ret    
+ 1f3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 1f7:	90                   	nop
+ 1f8:	8b 75 08             	mov    0x8(%ebp),%esi
+ 1fb:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1fe:	01 de                	add    %ebx,%esi
+ 200:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+ 202:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 205:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 208:	5b                   	pop    %ebx
+ 209:	5e                   	pop    %esi
+ 20a:	5f                   	pop    %edi
+ 20b:	5d                   	pop    %ebp
+ 20c:	c3                   	ret    
+ 20d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000210 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 210:	f3 0f 1e fb          	endbr32 
+ 214:	55                   	push   %ebp
+ 215:	89 e5                	mov    %esp,%ebp
+ 217:	56                   	push   %esi
+ 218:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 219:	83 ec 08             	sub    $0x8,%esp
+ 21c:	6a 00                	push   $0x0
+ 21e:	ff 75 08             	pushl  0x8(%ebp)
+ 221:	e8 ed 00 00 00       	call   313 <open>
+  if(fd < 0)
+ 226:	83 c4 10             	add    $0x10,%esp
+ 229:	85 c0                	test   %eax,%eax
+ 22b:	78 2b                	js     258 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+ 22d:	83 ec 08             	sub    $0x8,%esp
+ 230:	ff 75 0c             	pushl  0xc(%ebp)
+ 233:	89 c3                	mov    %eax,%ebx
+ 235:	50                   	push   %eax
+ 236:	e8 f0 00 00 00       	call   32b <fstat>
+  close(fd);
+ 23b:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+ 23e:	89 c6                	mov    %eax,%esi
+  close(fd);
+ 240:	e8 b6 00 00 00       	call   2fb <close>
+  return r;
+ 245:	83 c4 10             	add    $0x10,%esp
+}
+ 248:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 24b:	89 f0                	mov    %esi,%eax
+ 24d:	5b                   	pop    %ebx
+ 24e:	5e                   	pop    %esi
+ 24f:	5d                   	pop    %ebp
+ 250:	c3                   	ret    
+ 251:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+ 258:	be ff ff ff ff       	mov    $0xffffffff,%esi
+ 25d:	eb e9                	jmp    248 <stat+0x38>
+ 25f:	90                   	nop
+
+00000260 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 260:	f3 0f 1e fb          	endbr32 
+ 264:	55                   	push   %ebp
+ 265:	89 e5                	mov    %esp,%ebp
+ 267:	53                   	push   %ebx
+ 268:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 26b:	0f be 02             	movsbl (%edx),%eax
+ 26e:	8d 48 d0             	lea    -0x30(%eax),%ecx
+ 271:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+ 274:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+ 279:	77 1a                	ja     295 <atoi+0x35>
+ 27b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 27f:	90                   	nop
+    n = n*10 + *s++ - '0';
+ 280:	83 c2 01             	add    $0x1,%edx
+ 283:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+ 286:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+ 28a:	0f be 02             	movsbl (%edx),%eax
+ 28d:	8d 58 d0             	lea    -0x30(%eax),%ebx
+ 290:	80 fb 09             	cmp    $0x9,%bl
+ 293:	76 eb                	jbe    280 <atoi+0x20>
+  return n;
+}
+ 295:	89 c8                	mov    %ecx,%eax
+ 297:	5b                   	pop    %ebx
+ 298:	5d                   	pop    %ebp
+ 299:	c3                   	ret    
+ 29a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000002a0 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 2a0:	f3 0f 1e fb          	endbr32 
+ 2a4:	55                   	push   %ebp
+ 2a5:	89 e5                	mov    %esp,%ebp
+ 2a7:	57                   	push   %edi
+ 2a8:	8b 45 10             	mov    0x10(%ebp),%eax
+ 2ab:	8b 55 08             	mov    0x8(%ebp),%edx
+ 2ae:	56                   	push   %esi
+ 2af:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 2b2:	85 c0                	test   %eax,%eax
+ 2b4:	7e 0f                	jle    2c5 <memmove+0x25>
+ 2b6:	01 d0                	add    %edx,%eax
+  dst = vdst;
+ 2b8:	89 d7                	mov    %edx,%edi
+ 2ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+ 2c0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+ 2c1:	39 f8                	cmp    %edi,%eax
+ 2c3:	75 fb                	jne    2c0 <memmove+0x20>
+  return vdst;
+}
+ 2c5:	5e                   	pop    %esi
+ 2c6:	89 d0                	mov    %edx,%eax
+ 2c8:	5f                   	pop    %edi
+ 2c9:	5d                   	pop    %ebp
+ 2ca:	c3                   	ret    
+
+000002cb <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 2cb:	b8 01 00 00 00       	mov    $0x1,%eax
+ 2d0:	cd 40                	int    $0x40
+ 2d2:	c3                   	ret    
+
+000002d3 <exit>:
+SYSCALL(exit)
+ 2d3:	b8 02 00 00 00       	mov    $0x2,%eax
+ 2d8:	cd 40                	int    $0x40
+ 2da:	c3                   	ret    
+
+000002db <wait>:
+SYSCALL(wait)
+ 2db:	b8 03 00 00 00       	mov    $0x3,%eax
+ 2e0:	cd 40                	int    $0x40
+ 2e2:	c3                   	ret    
+
+000002e3 <pipe>:
+SYSCALL(pipe)
+ 2e3:	b8 04 00 00 00       	mov    $0x4,%eax
+ 2e8:	cd 40                	int    $0x40
+ 2ea:	c3                   	ret    
+
+000002eb <read>:
+SYSCALL(read)
+ 2eb:	b8 05 00 00 00       	mov    $0x5,%eax
+ 2f0:	cd 40                	int    $0x40
+ 2f2:	c3                   	ret    
+
+000002f3 <write>:
+SYSCALL(write)
+ 2f3:	b8 10 00 00 00       	mov    $0x10,%eax
+ 2f8:	cd 40                	int    $0x40
+ 2fa:	c3                   	ret    
+
+000002fb <close>:
+SYSCALL(close)
+ 2fb:	b8 15 00 00 00       	mov    $0x15,%eax
+ 300:	cd 40                	int    $0x40
+ 302:	c3                   	ret    
+
+00000303 <kill>:
+SYSCALL(kill)
+ 303:	b8 06 00 00 00       	mov    $0x6,%eax
+ 308:	cd 40                	int    $0x40
+ 30a:	c3                   	ret    
+
+0000030b <exec>:
+SYSCALL(exec)
+ 30b:	b8 07 00 00 00       	mov    $0x7,%eax
+ 310:	cd 40                	int    $0x40
+ 312:	c3                   	ret    
+
+00000313 <open>:
+SYSCALL(open)
+ 313:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 318:	cd 40                	int    $0x40
+ 31a:	c3                   	ret    
+
+0000031b <mknod>:
+SYSCALL(mknod)
+ 31b:	b8 11 00 00 00       	mov    $0x11,%eax
+ 320:	cd 40                	int    $0x40
+ 322:	c3                   	ret    
+
+00000323 <unlink>:
+SYSCALL(unlink)
+ 323:	b8 12 00 00 00       	mov    $0x12,%eax
+ 328:	cd 40                	int    $0x40
+ 32a:	c3                   	ret    
+
+0000032b <fstat>:
+SYSCALL(fstat)
+ 32b:	b8 08 00 00 00       	mov    $0x8,%eax
+ 330:	cd 40                	int    $0x40
+ 332:	c3                   	ret    
+
+00000333 <link>:
+SYSCALL(link)
+ 333:	b8 13 00 00 00       	mov    $0x13,%eax
+ 338:	cd 40                	int    $0x40
+ 33a:	c3                   	ret    
+
+0000033b <mkdir>:
+SYSCALL(mkdir)
+ 33b:	b8 14 00 00 00       	mov    $0x14,%eax
+ 340:	cd 40                	int    $0x40
+ 342:	c3                   	ret    
+
+00000343 <chdir>:
+SYSCALL(chdir)
+ 343:	b8 09 00 00 00       	mov    $0x9,%eax
+ 348:	cd 40                	int    $0x40
+ 34a:	c3                   	ret    
+
+0000034b <dup>:
+SYSCALL(dup)
+ 34b:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 350:	cd 40                	int    $0x40
+ 352:	c3                   	ret    
+
+00000353 <getpid>:
+SYSCALL(getpid)
+ 353:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 358:	cd 40                	int    $0x40
+ 35a:	c3                   	ret    
+
+0000035b <sbrk>:
+SYSCALL(sbrk)
+ 35b:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 360:	cd 40                	int    $0x40
+ 362:	c3                   	ret    
+
+00000363 <sleep>:
+SYSCALL(sleep)
+ 363:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 368:	cd 40                	int    $0x40
+ 36a:	c3                   	ret    
+
+0000036b <uptime>:
+SYSCALL(uptime)
+ 36b:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 370:	cd 40                	int    $0x40
+ 372:	c3                   	ret    
+
+00000373 <draw>:
+SYSCALL(draw)
+ 373:	b8 16 00 00 00       	mov    $0x16,%eax
+ 378:	cd 40                	int    $0x40
+ 37a:	c3                   	ret    
+
+0000037b <thread_create>:
+
+SYSCALL(thread_create)
+ 37b:	b8 17 00 00 00       	mov    $0x17,%eax
+ 380:	cd 40                	int    $0x40
+ 382:	c3                   	ret    
+
+00000383 <thread_join>:
+SYSCALL(thread_join)
+ 383:	b8 18 00 00 00       	mov    $0x18,%eax
+ 388:	cd 40                	int    $0x40
+ 38a:	c3                   	ret    
+
+0000038b <thread_exit>:
+SYSCALL(thread_exit)
+ 38b:	b8 19 00 00 00       	mov    $0x19,%eax
+ 390:	cd 40                	int    $0x40
+ 392:	c3                   	ret    
+ 393:	66 90                	xchg   %ax,%ax
+ 395:	66 90                	xchg   %ax,%ax
+ 397:	66 90                	xchg   %ax,%ax
+ 399:	66 90                	xchg   %ax,%ax
+ 39b:	66 90                	xchg   %ax,%ax
+ 39d:	66 90                	xchg   %ax,%ax
+ 39f:	90                   	nop
+
+000003a0 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 3a0:	55                   	push   %ebp
+ 3a1:	89 e5                	mov    %esp,%ebp
+ 3a3:	57                   	push   %edi
+ 3a4:	56                   	push   %esi
+ 3a5:	53                   	push   %ebx
+ 3a6:	83 ec 3c             	sub    $0x3c,%esp
+ 3a9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+ 3ac:	89 d1                	mov    %edx,%ecx
+{
+ 3ae:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  if(sgn && xx < 0){
+ 3b1:	85 d2                	test   %edx,%edx
+ 3b3:	0f 89 7f 00 00 00    	jns    438 <printint+0x98>
+ 3b9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
+ 3bd:	74 79                	je     438 <printint+0x98>
+    neg = 1;
+ 3bf:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+    x = -xx;
+ 3c6:	f7 d9                	neg    %ecx
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 3c8:	31 db                	xor    %ebx,%ebx
+ 3ca:	8d 75 d7             	lea    -0x29(%ebp),%esi
+ 3cd:	8d 76 00             	lea    0x0(%esi),%esi
+  do{
+    buf[i++] = digits[x % base];
+ 3d0:	89 c8                	mov    %ecx,%eax
+ 3d2:	31 d2                	xor    %edx,%edx
+ 3d4:	89 cf                	mov    %ecx,%edi
+ 3d6:	f7 75 c4             	divl   -0x3c(%ebp)
+ 3d9:	0f b6 92 d4 07 00 00 	movzbl 0x7d4(%edx),%edx
+ 3e0:	89 45 c0             	mov    %eax,-0x40(%ebp)
+ 3e3:	89 d8                	mov    %ebx,%eax
+ 3e5:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+ 3e8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+    buf[i++] = digits[x % base];
+ 3eb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
+  }while((x /= base) != 0);
+ 3ee:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
+ 3f1:	76 dd                	jbe    3d0 <printint+0x30>
+  if(neg)
+ 3f3:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+ 3f6:	85 c9                	test   %ecx,%ecx
+ 3f8:	74 0c                	je     406 <printint+0x66>
+    buf[i++] = '-';
+ 3fa:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+ 3ff:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+ 401:	ba 2d 00 00 00       	mov    $0x2d,%edx
+
+  while(--i >= 0)
+ 406:	8b 7d b8             	mov    -0x48(%ebp),%edi
+ 409:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+ 40d:	eb 07                	jmp    416 <printint+0x76>
+ 40f:	90                   	nop
+ 410:	0f b6 13             	movzbl (%ebx),%edx
+ 413:	83 eb 01             	sub    $0x1,%ebx
+  write(fd, &c, 1);
+ 416:	83 ec 04             	sub    $0x4,%esp
+ 419:	88 55 d7             	mov    %dl,-0x29(%ebp)
+ 41c:	6a 01                	push   $0x1
+ 41e:	56                   	push   %esi
+ 41f:	57                   	push   %edi
+ 420:	e8 ce fe ff ff       	call   2f3 <write>
+  while(--i >= 0)
+ 425:	83 c4 10             	add    $0x10,%esp
+ 428:	39 de                	cmp    %ebx,%esi
+ 42a:	75 e4                	jne    410 <printint+0x70>
+    putc(fd, buf[i]);
+}
+ 42c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 42f:	5b                   	pop    %ebx
+ 430:	5e                   	pop    %esi
+ 431:	5f                   	pop    %edi
+ 432:	5d                   	pop    %ebp
+ 433:	c3                   	ret    
+ 434:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  neg = 0;
+ 438:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+ 43f:	eb 87                	jmp    3c8 <printint+0x28>
+ 441:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 448:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 44f:	90                   	nop
+
+00000450 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 450:	f3 0f 1e fb          	endbr32 
+ 454:	55                   	push   %ebp
+ 455:	89 e5                	mov    %esp,%ebp
+ 457:	57                   	push   %edi
+ 458:	56                   	push   %esi
+ 459:	53                   	push   %ebx
+ 45a:	83 ec 2c             	sub    $0x2c,%esp
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 45d:	8b 75 0c             	mov    0xc(%ebp),%esi
+ 460:	0f b6 1e             	movzbl (%esi),%ebx
+ 463:	84 db                	test   %bl,%bl
+ 465:	0f 84 b4 00 00 00    	je     51f <printf+0xcf>
+  ap = (uint*)(void*)&fmt + 1;
+ 46b:	8d 45 10             	lea    0x10(%ebp),%eax
+ 46e:	83 c6 01             	add    $0x1,%esi
+  write(fd, &c, 1);
+ 471:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  state = 0;
+ 474:	31 d2                	xor    %edx,%edx
+  ap = (uint*)(void*)&fmt + 1;
+ 476:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 479:	eb 33                	jmp    4ae <printf+0x5e>
+ 47b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 47f:	90                   	nop
+ 480:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+ 483:	ba 25 00 00 00       	mov    $0x25,%edx
+      if(c == '%'){
+ 488:	83 f8 25             	cmp    $0x25,%eax
+ 48b:	74 17                	je     4a4 <printf+0x54>
+  write(fd, &c, 1);
+ 48d:	83 ec 04             	sub    $0x4,%esp
+ 490:	88 5d e7             	mov    %bl,-0x19(%ebp)
+ 493:	6a 01                	push   $0x1
+ 495:	57                   	push   %edi
+ 496:	ff 75 08             	pushl  0x8(%ebp)
+ 499:	e8 55 fe ff ff       	call   2f3 <write>
+ 49e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+      } else {
+        putc(fd, c);
+ 4a1:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; fmt[i]; i++){
+ 4a4:	0f b6 1e             	movzbl (%esi),%ebx
+ 4a7:	83 c6 01             	add    $0x1,%esi
+ 4aa:	84 db                	test   %bl,%bl
+ 4ac:	74 71                	je     51f <printf+0xcf>
+    c = fmt[i] & 0xff;
+ 4ae:	0f be cb             	movsbl %bl,%ecx
+ 4b1:	0f b6 c3             	movzbl %bl,%eax
+    if(state == 0){
+ 4b4:	85 d2                	test   %edx,%edx
+ 4b6:	74 c8                	je     480 <printf+0x30>
+      }
+    } else if(state == '%'){
+ 4b8:	83 fa 25             	cmp    $0x25,%edx
+ 4bb:	75 e7                	jne    4a4 <printf+0x54>
+      if(c == 'd'){
+ 4bd:	83 f8 64             	cmp    $0x64,%eax
+ 4c0:	0f 84 9a 00 00 00    	je     560 <printf+0x110>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+ 4c6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
+ 4cc:	83 f9 70             	cmp    $0x70,%ecx
+ 4cf:	74 5f                	je     530 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+ 4d1:	83 f8 73             	cmp    $0x73,%eax
+ 4d4:	0f 84 d6 00 00 00    	je     5b0 <printf+0x160>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 4da:	83 f8 63             	cmp    $0x63,%eax
+ 4dd:	0f 84 8d 00 00 00    	je     570 <printf+0x120>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+ 4e3:	83 f8 25             	cmp    $0x25,%eax
+ 4e6:	0f 84 b4 00 00 00    	je     5a0 <printf+0x150>
+  write(fd, &c, 1);
+ 4ec:	83 ec 04             	sub    $0x4,%esp
+ 4ef:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
+ 4f3:	6a 01                	push   $0x1
+ 4f5:	57                   	push   %edi
+ 4f6:	ff 75 08             	pushl  0x8(%ebp)
+ 4f9:	e8 f5 fd ff ff       	call   2f3 <write>
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+ 4fe:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 501:	83 c4 0c             	add    $0xc,%esp
+ 504:	6a 01                	push   $0x1
+ 506:	83 c6 01             	add    $0x1,%esi
+ 509:	57                   	push   %edi
+ 50a:	ff 75 08             	pushl  0x8(%ebp)
+ 50d:	e8 e1 fd ff ff       	call   2f3 <write>
+  for(i = 0; fmt[i]; i++){
+ 512:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
+        putc(fd, c);
+ 516:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 519:	31 d2                	xor    %edx,%edx
+  for(i = 0; fmt[i]; i++){
+ 51b:	84 db                	test   %bl,%bl
+ 51d:	75 8f                	jne    4ae <printf+0x5e>
+    }
+  }
+}
+ 51f:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 522:	5b                   	pop    %ebx
+ 523:	5e                   	pop    %esi
+ 524:	5f                   	pop    %edi
+ 525:	5d                   	pop    %ebp
+ 526:	c3                   	ret    
+ 527:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 52e:	66 90                	xchg   %ax,%ax
+        printint(fd, *ap, 16, 0);
+ 530:	83 ec 0c             	sub    $0xc,%esp
+ 533:	b9 10 00 00 00       	mov    $0x10,%ecx
+ 538:	6a 00                	push   $0x0
+ 53a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+ 53d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 540:	8b 13                	mov    (%ebx),%edx
+ 542:	e8 59 fe ff ff       	call   3a0 <printint>
+        ap++;
+ 547:	89 d8                	mov    %ebx,%eax
+ 549:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 54c:	31 d2                	xor    %edx,%edx
+        ap++;
+ 54e:	83 c0 04             	add    $0x4,%eax
+ 551:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 554:	e9 4b ff ff ff       	jmp    4a4 <printf+0x54>
+ 559:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        printint(fd, *ap, 10, 1);
+ 560:	83 ec 0c             	sub    $0xc,%esp
+ 563:	b9 0a 00 00 00       	mov    $0xa,%ecx
+ 568:	6a 01                	push   $0x1
+ 56a:	eb ce                	jmp    53a <printf+0xea>
+ 56c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        putc(fd, *ap);
+ 570:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+  write(fd, &c, 1);
+ 573:	83 ec 04             	sub    $0x4,%esp
+        putc(fd, *ap);
+ 576:	8b 03                	mov    (%ebx),%eax
+  write(fd, &c, 1);
+ 578:	6a 01                	push   $0x1
+        ap++;
+ 57a:	83 c3 04             	add    $0x4,%ebx
+  write(fd, &c, 1);
+ 57d:	57                   	push   %edi
+ 57e:	ff 75 08             	pushl  0x8(%ebp)
+        putc(fd, *ap);
+ 581:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 584:	e8 6a fd ff ff       	call   2f3 <write>
+        ap++;
+ 589:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+ 58c:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 58f:	31 d2                	xor    %edx,%edx
+ 591:	e9 0e ff ff ff       	jmp    4a4 <printf+0x54>
+ 596:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 59d:	8d 76 00             	lea    0x0(%esi),%esi
+        putc(fd, c);
+ 5a0:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 5a3:	83 ec 04             	sub    $0x4,%esp
+ 5a6:	e9 59 ff ff ff       	jmp    504 <printf+0xb4>
+ 5ab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 5af:	90                   	nop
+        s = (char*)*ap;
+ 5b0:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 5b3:	8b 18                	mov    (%eax),%ebx
+        ap++;
+ 5b5:	83 c0 04             	add    $0x4,%eax
+ 5b8:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        if(s == 0)
+ 5bb:	85 db                	test   %ebx,%ebx
+ 5bd:	74 17                	je     5d6 <printf+0x186>
+        while(*s != 0){
+ 5bf:	0f b6 03             	movzbl (%ebx),%eax
+      state = 0;
+ 5c2:	31 d2                	xor    %edx,%edx
+        while(*s != 0){
+ 5c4:	84 c0                	test   %al,%al
+ 5c6:	0f 84 d8 fe ff ff    	je     4a4 <printf+0x54>
+ 5cc:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 5cf:	89 de                	mov    %ebx,%esi
+ 5d1:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 5d4:	eb 1a                	jmp    5f0 <printf+0x1a0>
+          s = "(null)";
+ 5d6:	bb cc 07 00 00       	mov    $0x7cc,%ebx
+        while(*s != 0){
+ 5db:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 5de:	b8 28 00 00 00       	mov    $0x28,%eax
+ 5e3:	89 de                	mov    %ebx,%esi
+ 5e5:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 5e8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 5ef:	90                   	nop
+  write(fd, &c, 1);
+ 5f0:	83 ec 04             	sub    $0x4,%esp
+          s++;
+ 5f3:	83 c6 01             	add    $0x1,%esi
+ 5f6:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 5f9:	6a 01                	push   $0x1
+ 5fb:	57                   	push   %edi
+ 5fc:	53                   	push   %ebx
+ 5fd:	e8 f1 fc ff ff       	call   2f3 <write>
+        while(*s != 0){
+ 602:	0f b6 06             	movzbl (%esi),%eax
+ 605:	83 c4 10             	add    $0x10,%esp
+ 608:	84 c0                	test   %al,%al
+ 60a:	75 e4                	jne    5f0 <printf+0x1a0>
+ 60c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+      state = 0;
+ 60f:	31 d2                	xor    %edx,%edx
+ 611:	e9 8e fe ff ff       	jmp    4a4 <printf+0x54>
+ 616:	66 90                	xchg   %ax,%ax
+ 618:	66 90                	xchg   %ax,%ax
+ 61a:	66 90                	xchg   %ax,%ax
+ 61c:	66 90                	xchg   %ax,%ax
+ 61e:	66 90                	xchg   %ax,%ax
+
+00000620 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 620:	f3 0f 1e fb          	endbr32 
+ 624:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 625:	a1 84 0a 00 00       	mov    0xa84,%eax
+{
+ 62a:	89 e5                	mov    %esp,%ebp
+ 62c:	57                   	push   %edi
+ 62d:	56                   	push   %esi
+ 62e:	53                   	push   %ebx
+ 62f:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 632:	8b 10                	mov    (%eax),%edx
+  bp = (Header*)ap - 1;
+ 634:	8d 4b f8             	lea    -0x8(%ebx),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 637:	39 c8                	cmp    %ecx,%eax
+ 639:	73 15                	jae    650 <free+0x30>
+ 63b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 63f:	90                   	nop
+ 640:	39 d1                	cmp    %edx,%ecx
+ 642:	72 14                	jb     658 <free+0x38>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 644:	39 d0                	cmp    %edx,%eax
+ 646:	73 10                	jae    658 <free+0x38>
+{
+ 648:	89 d0                	mov    %edx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 64a:	8b 10                	mov    (%eax),%edx
+ 64c:	39 c8                	cmp    %ecx,%eax
+ 64e:	72 f0                	jb     640 <free+0x20>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 650:	39 d0                	cmp    %edx,%eax
+ 652:	72 f4                	jb     648 <free+0x28>
+ 654:	39 d1                	cmp    %edx,%ecx
+ 656:	73 f0                	jae    648 <free+0x28>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 658:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ 65b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
+ 65e:	39 fa                	cmp    %edi,%edx
+ 660:	74 1e                	je     680 <free+0x60>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+ 662:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 665:	8b 50 04             	mov    0x4(%eax),%edx
+ 668:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 66b:	39 f1                	cmp    %esi,%ecx
+ 66d:	74 28                	je     697 <free+0x77>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+ 66f:	89 08                	mov    %ecx,(%eax)
+  freep = p;
+}
+ 671:	5b                   	pop    %ebx
+  freep = p;
+ 672:	a3 84 0a 00 00       	mov    %eax,0xa84
+}
+ 677:	5e                   	pop    %esi
+ 678:	5f                   	pop    %edi
+ 679:	5d                   	pop    %ebp
+ 67a:	c3                   	ret    
+ 67b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 67f:	90                   	nop
+    bp->s.size += p->s.ptr->s.size;
+ 680:	03 72 04             	add    0x4(%edx),%esi
+ 683:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 686:	8b 10                	mov    (%eax),%edx
+ 688:	8b 12                	mov    (%edx),%edx
+ 68a:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 68d:	8b 50 04             	mov    0x4(%eax),%edx
+ 690:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 693:	39 f1                	cmp    %esi,%ecx
+ 695:	75 d8                	jne    66f <free+0x4f>
+    p->s.size += bp->s.size;
+ 697:	03 53 fc             	add    -0x4(%ebx),%edx
+  freep = p;
+ 69a:	a3 84 0a 00 00       	mov    %eax,0xa84
+    p->s.size += bp->s.size;
+ 69f:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 6a2:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ 6a5:	89 10                	mov    %edx,(%eax)
+}
+ 6a7:	5b                   	pop    %ebx
+ 6a8:	5e                   	pop    %esi
+ 6a9:	5f                   	pop    %edi
+ 6aa:	5d                   	pop    %ebp
+ 6ab:	c3                   	ret    
+ 6ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000006b0 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 6b0:	f3 0f 1e fb          	endbr32 
+ 6b4:	55                   	push   %ebp
+ 6b5:	89 e5                	mov    %esp,%ebp
+ 6b7:	57                   	push   %edi
+ 6b8:	56                   	push   %esi
+ 6b9:	53                   	push   %ebx
+ 6ba:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 6bd:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+ 6c0:	8b 3d 84 0a 00 00    	mov    0xa84,%edi
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 6c6:	8d 70 07             	lea    0x7(%eax),%esi
+ 6c9:	c1 ee 03             	shr    $0x3,%esi
+ 6cc:	83 c6 01             	add    $0x1,%esi
+  if((prevp = freep) == 0){
+ 6cf:	85 ff                	test   %edi,%edi
+ 6d1:	0f 84 a9 00 00 00    	je     780 <malloc+0xd0>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 6d7:	8b 07                	mov    (%edi),%eax
+    if(p->s.size >= nunits){
+ 6d9:	8b 48 04             	mov    0x4(%eax),%ecx
+ 6dc:	39 f1                	cmp    %esi,%ecx
+ 6de:	73 6d                	jae    74d <malloc+0x9d>
+ 6e0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+ 6e6:	bb 00 10 00 00       	mov    $0x1000,%ebx
+ 6eb:	0f 43 de             	cmovae %esi,%ebx
+  p = sbrk(nu * sizeof(Header));
+ 6ee:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
+ 6f5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+ 6f8:	eb 17                	jmp    711 <malloc+0x61>
+ 6fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 700:	8b 10                	mov    (%eax),%edx
+    if(p->s.size >= nunits){
+ 702:	8b 4a 04             	mov    0x4(%edx),%ecx
+ 705:	39 f1                	cmp    %esi,%ecx
+ 707:	73 4f                	jae    758 <malloc+0xa8>
+ 709:	8b 3d 84 0a 00 00    	mov    0xa84,%edi
+ 70f:	89 d0                	mov    %edx,%eax
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 711:	39 c7                	cmp    %eax,%edi
+ 713:	75 eb                	jne    700 <malloc+0x50>
+  p = sbrk(nu * sizeof(Header));
+ 715:	83 ec 0c             	sub    $0xc,%esp
+ 718:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 71b:	e8 3b fc ff ff       	call   35b <sbrk>
+  if(p == (char*)-1)
+ 720:	83 c4 10             	add    $0x10,%esp
+ 723:	83 f8 ff             	cmp    $0xffffffff,%eax
+ 726:	74 1b                	je     743 <malloc+0x93>
+  hp->s.size = nu;
+ 728:	89 58 04             	mov    %ebx,0x4(%eax)
+  free((void*)(hp + 1));
+ 72b:	83 ec 0c             	sub    $0xc,%esp
+ 72e:	83 c0 08             	add    $0x8,%eax
+ 731:	50                   	push   %eax
+ 732:	e8 e9 fe ff ff       	call   620 <free>
+  return freep;
+ 737:	a1 84 0a 00 00       	mov    0xa84,%eax
+      if((p = morecore(nunits)) == 0)
+ 73c:	83 c4 10             	add    $0x10,%esp
+ 73f:	85 c0                	test   %eax,%eax
+ 741:	75 bd                	jne    700 <malloc+0x50>
+        return 0;
+  }
+}
+ 743:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return 0;
+ 746:	31 c0                	xor    %eax,%eax
+}
+ 748:	5b                   	pop    %ebx
+ 749:	5e                   	pop    %esi
+ 74a:	5f                   	pop    %edi
+ 74b:	5d                   	pop    %ebp
+ 74c:	c3                   	ret    
+    if(p->s.size >= nunits){
+ 74d:	89 c2                	mov    %eax,%edx
+ 74f:	89 f8                	mov    %edi,%eax
+ 751:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+ 758:	39 ce                	cmp    %ecx,%esi
+ 75a:	74 54                	je     7b0 <malloc+0x100>
+        p->s.size -= nunits;
+ 75c:	29 f1                	sub    %esi,%ecx
+ 75e:	89 4a 04             	mov    %ecx,0x4(%edx)
+        p += p->s.size;
+ 761:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
+        p->s.size = nunits;
+ 764:	89 72 04             	mov    %esi,0x4(%edx)
+      freep = prevp;
+ 767:	a3 84 0a 00 00       	mov    %eax,0xa84
+}
+ 76c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return (void*)(p + 1);
+ 76f:	8d 42 08             	lea    0x8(%edx),%eax
+}
+ 772:	5b                   	pop    %ebx
+ 773:	5e                   	pop    %esi
+ 774:	5f                   	pop    %edi
+ 775:	5d                   	pop    %ebp
+ 776:	c3                   	ret    
+ 777:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 77e:	66 90                	xchg   %ax,%ax
+    base.s.ptr = freep = prevp = &base;
+ 780:	c7 05 84 0a 00 00 88 	movl   $0xa88,0xa84
+ 787:	0a 00 00 
+    base.s.size = 0;
+ 78a:	bf 88 0a 00 00       	mov    $0xa88,%edi
+    base.s.ptr = freep = prevp = &base;
+ 78f:	c7 05 88 0a 00 00 88 	movl   $0xa88,0xa88
+ 796:	0a 00 00 
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 799:	89 f8                	mov    %edi,%eax
+    base.s.size = 0;
+ 79b:	c7 05 8c 0a 00 00 00 	movl   $0x0,0xa8c
+ 7a2:	00 00 00 
+    if(p->s.size >= nunits){
+ 7a5:	e9 36 ff ff ff       	jmp    6e0 <malloc+0x30>
+ 7aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        prevp->s.ptr = p->s.ptr;
+ 7b0:	8b 0a                	mov    (%edx),%ecx
+ 7b2:	89 08                	mov    %ecx,(%eax)
+ 7b4:	eb b1                	jmp    767 <malloc+0xb7>
diff -ruN xv6-public/kill.d copy-xv6/kill.d
--- xv6-public/kill.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/kill.d	2022-09-05 23:26:11.960781092 +0530
@@ -0,0 +1 @@
+kill.o: kill.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/kill.o and copy-xv6/kill.o differ
diff -ruN xv6-public/kill.sym copy-xv6/kill.sym
--- xv6-public/kill.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/kill.sym	2022-09-05 23:26:11.984781091 +0530
@@ -0,0 +1,61 @@
+00000000 .text
+000007b8 .rodata
+000007e8 .eh_frame
+00000a84 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 kill.c
+00000000 ulib.c
+00000000 printf.c
+000003a0 printint
+000007d4 digits.1097
+00000000 umalloc.c
+00000a84 freep
+00000a88 base
+00000070 strcpy
+00000450 printf
+0000038b thread_exit
+000002a0 memmove
+0000031b mknod
+00000190 gets
+00000353 getpid
+000006b0 malloc
+00000363 sleep
+000002e3 pipe
+000002f3 write
+0000032b fstat
+00000303 kill
+00000343 chdir
+0000030b exec
+000002db wait
+000002eb read
+00000323 unlink
+000002cb fork
+0000035b sbrk
+0000036b uptime
+00000a84 __bss_start
+00000130 memset
+00000000 main
+000000a0 strcmp
+0000034b dup
+00000210 stat
+00000a84 _edata
+00000a90 _end
+00000333 link
+000002d3 exit
+00000260 atoi
+00000373 draw
+000000f0 strlen
+00000313 open
+00000150 strchr
+0000037b thread_create
+0000033b mkdir
+000002fb close
+00000383 thread_join
+00000620 free
diff -ruN xv6-public/lapic.d copy-xv6/lapic.d
--- xv6-public/lapic.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/lapic.d	2022-09-05 23:26:13.152781067 +0530
@@ -0,0 +1,2 @@
+lapic.o: lapic.c /usr/include/stdc-predef.h param.h types.h defs.h date.h \
+ memlayout.h traps.h mmu.h x86.h
Binary files xv6-public/lapic.o and copy-xv6/lapic.o differ
Binary files xv6-public/_ln and copy-xv6/_ln differ
diff -ruN xv6-public/ln.asm copy-xv6/ln.asm
--- xv6-public/ln.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/ln.asm	2022-09-05 23:26:12.008781091 +0530
@@ -0,0 +1,1215 @@
+
+_ln:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+  if(argc != 3){
+   e:	83 39 03             	cmpl   $0x3,(%ecx)
+{
+  11:	55                   	push   %ebp
+  12:	89 e5                	mov    %esp,%ebp
+  14:	53                   	push   %ebx
+  15:	51                   	push   %ecx
+  16:	8b 59 04             	mov    0x4(%ecx),%ebx
+  if(argc != 3){
+  19:	74 13                	je     2e <main+0x2e>
+    printf(2, "Usage: ln old new\n");
+  1b:	52                   	push   %edx
+  1c:	52                   	push   %edx
+  1d:	68 a8 07 00 00       	push   $0x7a8
+  22:	6a 02                	push   $0x2
+  24:	e8 17 04 00 00       	call   440 <printf>
+    exit();
+  29:	e8 95 02 00 00       	call   2c3 <exit>
+  }
+  if(link(argv[1], argv[2]) < 0)
+  2e:	50                   	push   %eax
+  2f:	50                   	push   %eax
+  30:	ff 73 08             	pushl  0x8(%ebx)
+  33:	ff 73 04             	pushl  0x4(%ebx)
+  36:	e8 e8 02 00 00       	call   323 <link>
+  3b:	83 c4 10             	add    $0x10,%esp
+  3e:	85 c0                	test   %eax,%eax
+  40:	78 05                	js     47 <main+0x47>
+    printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+  exit();
+  42:	e8 7c 02 00 00       	call   2c3 <exit>
+    printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+  47:	ff 73 08             	pushl  0x8(%ebx)
+  4a:	ff 73 04             	pushl  0x4(%ebx)
+  4d:	68 bb 07 00 00       	push   $0x7bb
+  52:	6a 02                	push   $0x2
+  54:	e8 e7 03 00 00       	call   440 <printf>
+  59:	83 c4 10             	add    $0x10,%esp
+  5c:	eb e4                	jmp    42 <main+0x42>
+  5e:	66 90                	xchg   %ax,%ax
+
+00000060 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+  60:	f3 0f 1e fb          	endbr32 
+  64:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  65:	31 c0                	xor    %eax,%eax
+{
+  67:	89 e5                	mov    %esp,%ebp
+  69:	53                   	push   %ebx
+  6a:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  6d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+  70:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+  74:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+  77:	83 c0 01             	add    $0x1,%eax
+  7a:	84 d2                	test   %dl,%dl
+  7c:	75 f2                	jne    70 <strcpy+0x10>
+    ;
+  return os;
+}
+  7e:	89 c8                	mov    %ecx,%eax
+  80:	5b                   	pop    %ebx
+  81:	5d                   	pop    %ebp
+  82:	c3                   	ret    
+  83:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000090 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  90:	f3 0f 1e fb          	endbr32 
+  94:	55                   	push   %ebp
+  95:	89 e5                	mov    %esp,%ebp
+  97:	53                   	push   %ebx
+  98:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  9b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+  9e:	0f b6 01             	movzbl (%ecx),%eax
+  a1:	0f b6 1a             	movzbl (%edx),%ebx
+  a4:	84 c0                	test   %al,%al
+  a6:	75 19                	jne    c1 <strcmp+0x31>
+  a8:	eb 26                	jmp    d0 <strcmp+0x40>
+  aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  b0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+  b4:	83 c1 01             	add    $0x1,%ecx
+  b7:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+  ba:	0f b6 1a             	movzbl (%edx),%ebx
+  bd:	84 c0                	test   %al,%al
+  bf:	74 0f                	je     d0 <strcmp+0x40>
+  c1:	38 d8                	cmp    %bl,%al
+  c3:	74 eb                	je     b0 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+  c5:	29 d8                	sub    %ebx,%eax
+}
+  c7:	5b                   	pop    %ebx
+  c8:	5d                   	pop    %ebp
+  c9:	c3                   	ret    
+  ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  d0:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+  d2:	29 d8                	sub    %ebx,%eax
+}
+  d4:	5b                   	pop    %ebx
+  d5:	5d                   	pop    %ebp
+  d6:	c3                   	ret    
+  d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  de:	66 90                	xchg   %ax,%ax
+
+000000e0 <strlen>:
+
+uint
+strlen(const char *s)
+{
+  e0:	f3 0f 1e fb          	endbr32 
+  e4:	55                   	push   %ebp
+  e5:	89 e5                	mov    %esp,%ebp
+  e7:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+  ea:	80 3a 00             	cmpb   $0x0,(%edx)
+  ed:	74 21                	je     110 <strlen+0x30>
+  ef:	31 c0                	xor    %eax,%eax
+  f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  f8:	83 c0 01             	add    $0x1,%eax
+  fb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+  ff:	89 c1                	mov    %eax,%ecx
+ 101:	75 f5                	jne    f8 <strlen+0x18>
+    ;
+  return n;
+}
+ 103:	89 c8                	mov    %ecx,%eax
+ 105:	5d                   	pop    %ebp
+ 106:	c3                   	ret    
+ 107:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 10e:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+ 110:	31 c9                	xor    %ecx,%ecx
+}
+ 112:	5d                   	pop    %ebp
+ 113:	89 c8                	mov    %ecx,%eax
+ 115:	c3                   	ret    
+ 116:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 11d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000120 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 120:	f3 0f 1e fb          	endbr32 
+ 124:	55                   	push   %ebp
+ 125:	89 e5                	mov    %esp,%ebp
+ 127:	57                   	push   %edi
+ 128:	8b 55 08             	mov    0x8(%ebp),%edx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+ 12b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 12e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 131:	89 d7                	mov    %edx,%edi
+ 133:	fc                   	cld    
+ 134:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+ 136:	89 d0                	mov    %edx,%eax
+ 138:	5f                   	pop    %edi
+ 139:	5d                   	pop    %ebp
+ 13a:	c3                   	ret    
+ 13b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 13f:	90                   	nop
+
+00000140 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 140:	f3 0f 1e fb          	endbr32 
+ 144:	55                   	push   %ebp
+ 145:	89 e5                	mov    %esp,%ebp
+ 147:	8b 45 08             	mov    0x8(%ebp),%eax
+ 14a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+ 14e:	0f b6 10             	movzbl (%eax),%edx
+ 151:	84 d2                	test   %dl,%dl
+ 153:	75 16                	jne    16b <strchr+0x2b>
+ 155:	eb 21                	jmp    178 <strchr+0x38>
+ 157:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 15e:	66 90                	xchg   %ax,%ax
+ 160:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+ 164:	83 c0 01             	add    $0x1,%eax
+ 167:	84 d2                	test   %dl,%dl
+ 169:	74 0d                	je     178 <strchr+0x38>
+    if(*s == c)
+ 16b:	38 d1                	cmp    %dl,%cl
+ 16d:	75 f1                	jne    160 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+ 16f:	5d                   	pop    %ebp
+ 170:	c3                   	ret    
+ 171:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+ 178:	31 c0                	xor    %eax,%eax
+}
+ 17a:	5d                   	pop    %ebp
+ 17b:	c3                   	ret    
+ 17c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000180 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 180:	f3 0f 1e fb          	endbr32 
+ 184:	55                   	push   %ebp
+ 185:	89 e5                	mov    %esp,%ebp
+ 187:	57                   	push   %edi
+ 188:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 189:	31 f6                	xor    %esi,%esi
+{
+ 18b:	53                   	push   %ebx
+ 18c:	89 f3                	mov    %esi,%ebx
+ 18e:	83 ec 1c             	sub    $0x1c,%esp
+ 191:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+ 194:	eb 33                	jmp    1c9 <gets+0x49>
+ 196:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 19d:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+ 1a0:	83 ec 04             	sub    $0x4,%esp
+ 1a3:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ 1a6:	6a 01                	push   $0x1
+ 1a8:	50                   	push   %eax
+ 1a9:	6a 00                	push   $0x0
+ 1ab:	e8 2b 01 00 00       	call   2db <read>
+    if(cc < 1)
+ 1b0:	83 c4 10             	add    $0x10,%esp
+ 1b3:	85 c0                	test   %eax,%eax
+ 1b5:	7e 1c                	jle    1d3 <gets+0x53>
+      break;
+    buf[i++] = c;
+ 1b7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ 1bb:	83 c7 01             	add    $0x1,%edi
+ 1be:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+ 1c1:	3c 0a                	cmp    $0xa,%al
+ 1c3:	74 23                	je     1e8 <gets+0x68>
+ 1c5:	3c 0d                	cmp    $0xd,%al
+ 1c7:	74 1f                	je     1e8 <gets+0x68>
+  for(i=0; i+1 < max; ){
+ 1c9:	83 c3 01             	add    $0x1,%ebx
+ 1cc:	89 fe                	mov    %edi,%esi
+ 1ce:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+ 1d1:	7c cd                	jl     1a0 <gets+0x20>
+ 1d3:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+ 1d5:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+ 1d8:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 1db:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 1de:	5b                   	pop    %ebx
+ 1df:	5e                   	pop    %esi
+ 1e0:	5f                   	pop    %edi
+ 1e1:	5d                   	pop    %ebp
+ 1e2:	c3                   	ret    
+ 1e3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 1e7:	90                   	nop
+ 1e8:	8b 75 08             	mov    0x8(%ebp),%esi
+ 1eb:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1ee:	01 de                	add    %ebx,%esi
+ 1f0:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+ 1f2:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 1f5:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 1f8:	5b                   	pop    %ebx
+ 1f9:	5e                   	pop    %esi
+ 1fa:	5f                   	pop    %edi
+ 1fb:	5d                   	pop    %ebp
+ 1fc:	c3                   	ret    
+ 1fd:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000200 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 200:	f3 0f 1e fb          	endbr32 
+ 204:	55                   	push   %ebp
+ 205:	89 e5                	mov    %esp,%ebp
+ 207:	56                   	push   %esi
+ 208:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 209:	83 ec 08             	sub    $0x8,%esp
+ 20c:	6a 00                	push   $0x0
+ 20e:	ff 75 08             	pushl  0x8(%ebp)
+ 211:	e8 ed 00 00 00       	call   303 <open>
+  if(fd < 0)
+ 216:	83 c4 10             	add    $0x10,%esp
+ 219:	85 c0                	test   %eax,%eax
+ 21b:	78 2b                	js     248 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+ 21d:	83 ec 08             	sub    $0x8,%esp
+ 220:	ff 75 0c             	pushl  0xc(%ebp)
+ 223:	89 c3                	mov    %eax,%ebx
+ 225:	50                   	push   %eax
+ 226:	e8 f0 00 00 00       	call   31b <fstat>
+  close(fd);
+ 22b:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+ 22e:	89 c6                	mov    %eax,%esi
+  close(fd);
+ 230:	e8 b6 00 00 00       	call   2eb <close>
+  return r;
+ 235:	83 c4 10             	add    $0x10,%esp
+}
+ 238:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 23b:	89 f0                	mov    %esi,%eax
+ 23d:	5b                   	pop    %ebx
+ 23e:	5e                   	pop    %esi
+ 23f:	5d                   	pop    %ebp
+ 240:	c3                   	ret    
+ 241:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+ 248:	be ff ff ff ff       	mov    $0xffffffff,%esi
+ 24d:	eb e9                	jmp    238 <stat+0x38>
+ 24f:	90                   	nop
+
+00000250 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 250:	f3 0f 1e fb          	endbr32 
+ 254:	55                   	push   %ebp
+ 255:	89 e5                	mov    %esp,%ebp
+ 257:	53                   	push   %ebx
+ 258:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 25b:	0f be 02             	movsbl (%edx),%eax
+ 25e:	8d 48 d0             	lea    -0x30(%eax),%ecx
+ 261:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+ 264:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+ 269:	77 1a                	ja     285 <atoi+0x35>
+ 26b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 26f:	90                   	nop
+    n = n*10 + *s++ - '0';
+ 270:	83 c2 01             	add    $0x1,%edx
+ 273:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+ 276:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+ 27a:	0f be 02             	movsbl (%edx),%eax
+ 27d:	8d 58 d0             	lea    -0x30(%eax),%ebx
+ 280:	80 fb 09             	cmp    $0x9,%bl
+ 283:	76 eb                	jbe    270 <atoi+0x20>
+  return n;
+}
+ 285:	89 c8                	mov    %ecx,%eax
+ 287:	5b                   	pop    %ebx
+ 288:	5d                   	pop    %ebp
+ 289:	c3                   	ret    
+ 28a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000290 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 290:	f3 0f 1e fb          	endbr32 
+ 294:	55                   	push   %ebp
+ 295:	89 e5                	mov    %esp,%ebp
+ 297:	57                   	push   %edi
+ 298:	8b 45 10             	mov    0x10(%ebp),%eax
+ 29b:	8b 55 08             	mov    0x8(%ebp),%edx
+ 29e:	56                   	push   %esi
+ 29f:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 2a2:	85 c0                	test   %eax,%eax
+ 2a4:	7e 0f                	jle    2b5 <memmove+0x25>
+ 2a6:	01 d0                	add    %edx,%eax
+  dst = vdst;
+ 2a8:	89 d7                	mov    %edx,%edi
+ 2aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+ 2b0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+ 2b1:	39 f8                	cmp    %edi,%eax
+ 2b3:	75 fb                	jne    2b0 <memmove+0x20>
+  return vdst;
+}
+ 2b5:	5e                   	pop    %esi
+ 2b6:	89 d0                	mov    %edx,%eax
+ 2b8:	5f                   	pop    %edi
+ 2b9:	5d                   	pop    %ebp
+ 2ba:	c3                   	ret    
+
+000002bb <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 2bb:	b8 01 00 00 00       	mov    $0x1,%eax
+ 2c0:	cd 40                	int    $0x40
+ 2c2:	c3                   	ret    
+
+000002c3 <exit>:
+SYSCALL(exit)
+ 2c3:	b8 02 00 00 00       	mov    $0x2,%eax
+ 2c8:	cd 40                	int    $0x40
+ 2ca:	c3                   	ret    
+
+000002cb <wait>:
+SYSCALL(wait)
+ 2cb:	b8 03 00 00 00       	mov    $0x3,%eax
+ 2d0:	cd 40                	int    $0x40
+ 2d2:	c3                   	ret    
+
+000002d3 <pipe>:
+SYSCALL(pipe)
+ 2d3:	b8 04 00 00 00       	mov    $0x4,%eax
+ 2d8:	cd 40                	int    $0x40
+ 2da:	c3                   	ret    
+
+000002db <read>:
+SYSCALL(read)
+ 2db:	b8 05 00 00 00       	mov    $0x5,%eax
+ 2e0:	cd 40                	int    $0x40
+ 2e2:	c3                   	ret    
+
+000002e3 <write>:
+SYSCALL(write)
+ 2e3:	b8 10 00 00 00       	mov    $0x10,%eax
+ 2e8:	cd 40                	int    $0x40
+ 2ea:	c3                   	ret    
+
+000002eb <close>:
+SYSCALL(close)
+ 2eb:	b8 15 00 00 00       	mov    $0x15,%eax
+ 2f0:	cd 40                	int    $0x40
+ 2f2:	c3                   	ret    
+
+000002f3 <kill>:
+SYSCALL(kill)
+ 2f3:	b8 06 00 00 00       	mov    $0x6,%eax
+ 2f8:	cd 40                	int    $0x40
+ 2fa:	c3                   	ret    
+
+000002fb <exec>:
+SYSCALL(exec)
+ 2fb:	b8 07 00 00 00       	mov    $0x7,%eax
+ 300:	cd 40                	int    $0x40
+ 302:	c3                   	ret    
+
+00000303 <open>:
+SYSCALL(open)
+ 303:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 308:	cd 40                	int    $0x40
+ 30a:	c3                   	ret    
+
+0000030b <mknod>:
+SYSCALL(mknod)
+ 30b:	b8 11 00 00 00       	mov    $0x11,%eax
+ 310:	cd 40                	int    $0x40
+ 312:	c3                   	ret    
+
+00000313 <unlink>:
+SYSCALL(unlink)
+ 313:	b8 12 00 00 00       	mov    $0x12,%eax
+ 318:	cd 40                	int    $0x40
+ 31a:	c3                   	ret    
+
+0000031b <fstat>:
+SYSCALL(fstat)
+ 31b:	b8 08 00 00 00       	mov    $0x8,%eax
+ 320:	cd 40                	int    $0x40
+ 322:	c3                   	ret    
+
+00000323 <link>:
+SYSCALL(link)
+ 323:	b8 13 00 00 00       	mov    $0x13,%eax
+ 328:	cd 40                	int    $0x40
+ 32a:	c3                   	ret    
+
+0000032b <mkdir>:
+SYSCALL(mkdir)
+ 32b:	b8 14 00 00 00       	mov    $0x14,%eax
+ 330:	cd 40                	int    $0x40
+ 332:	c3                   	ret    
+
+00000333 <chdir>:
+SYSCALL(chdir)
+ 333:	b8 09 00 00 00       	mov    $0x9,%eax
+ 338:	cd 40                	int    $0x40
+ 33a:	c3                   	ret    
+
+0000033b <dup>:
+SYSCALL(dup)
+ 33b:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 340:	cd 40                	int    $0x40
+ 342:	c3                   	ret    
+
+00000343 <getpid>:
+SYSCALL(getpid)
+ 343:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 348:	cd 40                	int    $0x40
+ 34a:	c3                   	ret    
+
+0000034b <sbrk>:
+SYSCALL(sbrk)
+ 34b:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 350:	cd 40                	int    $0x40
+ 352:	c3                   	ret    
+
+00000353 <sleep>:
+SYSCALL(sleep)
+ 353:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 358:	cd 40                	int    $0x40
+ 35a:	c3                   	ret    
+
+0000035b <uptime>:
+SYSCALL(uptime)
+ 35b:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 360:	cd 40                	int    $0x40
+ 362:	c3                   	ret    
+
+00000363 <draw>:
+SYSCALL(draw)
+ 363:	b8 16 00 00 00       	mov    $0x16,%eax
+ 368:	cd 40                	int    $0x40
+ 36a:	c3                   	ret    
+
+0000036b <thread_create>:
+
+SYSCALL(thread_create)
+ 36b:	b8 17 00 00 00       	mov    $0x17,%eax
+ 370:	cd 40                	int    $0x40
+ 372:	c3                   	ret    
+
+00000373 <thread_join>:
+SYSCALL(thread_join)
+ 373:	b8 18 00 00 00       	mov    $0x18,%eax
+ 378:	cd 40                	int    $0x40
+ 37a:	c3                   	ret    
+
+0000037b <thread_exit>:
+SYSCALL(thread_exit)
+ 37b:	b8 19 00 00 00       	mov    $0x19,%eax
+ 380:	cd 40                	int    $0x40
+ 382:	c3                   	ret    
+ 383:	66 90                	xchg   %ax,%ax
+ 385:	66 90                	xchg   %ax,%ax
+ 387:	66 90                	xchg   %ax,%ax
+ 389:	66 90                	xchg   %ax,%ax
+ 38b:	66 90                	xchg   %ax,%ax
+ 38d:	66 90                	xchg   %ax,%ax
+ 38f:	90                   	nop
+
+00000390 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 390:	55                   	push   %ebp
+ 391:	89 e5                	mov    %esp,%ebp
+ 393:	57                   	push   %edi
+ 394:	56                   	push   %esi
+ 395:	53                   	push   %ebx
+ 396:	83 ec 3c             	sub    $0x3c,%esp
+ 399:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+ 39c:	89 d1                	mov    %edx,%ecx
+{
+ 39e:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  if(sgn && xx < 0){
+ 3a1:	85 d2                	test   %edx,%edx
+ 3a3:	0f 89 7f 00 00 00    	jns    428 <printint+0x98>
+ 3a9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
+ 3ad:	74 79                	je     428 <printint+0x98>
+    neg = 1;
+ 3af:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+    x = -xx;
+ 3b6:	f7 d9                	neg    %ecx
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 3b8:	31 db                	xor    %ebx,%ebx
+ 3ba:	8d 75 d7             	lea    -0x29(%ebp),%esi
+ 3bd:	8d 76 00             	lea    0x0(%esi),%esi
+  do{
+    buf[i++] = digits[x % base];
+ 3c0:	89 c8                	mov    %ecx,%eax
+ 3c2:	31 d2                	xor    %edx,%edx
+ 3c4:	89 cf                	mov    %ecx,%edi
+ 3c6:	f7 75 c4             	divl   -0x3c(%ebp)
+ 3c9:	0f b6 92 d8 07 00 00 	movzbl 0x7d8(%edx),%edx
+ 3d0:	89 45 c0             	mov    %eax,-0x40(%ebp)
+ 3d3:	89 d8                	mov    %ebx,%eax
+ 3d5:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+ 3d8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+    buf[i++] = digits[x % base];
+ 3db:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
+  }while((x /= base) != 0);
+ 3de:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
+ 3e1:	76 dd                	jbe    3c0 <printint+0x30>
+  if(neg)
+ 3e3:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+ 3e6:	85 c9                	test   %ecx,%ecx
+ 3e8:	74 0c                	je     3f6 <printint+0x66>
+    buf[i++] = '-';
+ 3ea:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+ 3ef:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+ 3f1:	ba 2d 00 00 00       	mov    $0x2d,%edx
+
+  while(--i >= 0)
+ 3f6:	8b 7d b8             	mov    -0x48(%ebp),%edi
+ 3f9:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+ 3fd:	eb 07                	jmp    406 <printint+0x76>
+ 3ff:	90                   	nop
+ 400:	0f b6 13             	movzbl (%ebx),%edx
+ 403:	83 eb 01             	sub    $0x1,%ebx
+  write(fd, &c, 1);
+ 406:	83 ec 04             	sub    $0x4,%esp
+ 409:	88 55 d7             	mov    %dl,-0x29(%ebp)
+ 40c:	6a 01                	push   $0x1
+ 40e:	56                   	push   %esi
+ 40f:	57                   	push   %edi
+ 410:	e8 ce fe ff ff       	call   2e3 <write>
+  while(--i >= 0)
+ 415:	83 c4 10             	add    $0x10,%esp
+ 418:	39 de                	cmp    %ebx,%esi
+ 41a:	75 e4                	jne    400 <printint+0x70>
+    putc(fd, buf[i]);
+}
+ 41c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 41f:	5b                   	pop    %ebx
+ 420:	5e                   	pop    %esi
+ 421:	5f                   	pop    %edi
+ 422:	5d                   	pop    %ebp
+ 423:	c3                   	ret    
+ 424:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  neg = 0;
+ 428:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+ 42f:	eb 87                	jmp    3b8 <printint+0x28>
+ 431:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 438:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 43f:	90                   	nop
+
+00000440 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 440:	f3 0f 1e fb          	endbr32 
+ 444:	55                   	push   %ebp
+ 445:	89 e5                	mov    %esp,%ebp
+ 447:	57                   	push   %edi
+ 448:	56                   	push   %esi
+ 449:	53                   	push   %ebx
+ 44a:	83 ec 2c             	sub    $0x2c,%esp
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 44d:	8b 75 0c             	mov    0xc(%ebp),%esi
+ 450:	0f b6 1e             	movzbl (%esi),%ebx
+ 453:	84 db                	test   %bl,%bl
+ 455:	0f 84 b4 00 00 00    	je     50f <printf+0xcf>
+  ap = (uint*)(void*)&fmt + 1;
+ 45b:	8d 45 10             	lea    0x10(%ebp),%eax
+ 45e:	83 c6 01             	add    $0x1,%esi
+  write(fd, &c, 1);
+ 461:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  state = 0;
+ 464:	31 d2                	xor    %edx,%edx
+  ap = (uint*)(void*)&fmt + 1;
+ 466:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 469:	eb 33                	jmp    49e <printf+0x5e>
+ 46b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 46f:	90                   	nop
+ 470:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+ 473:	ba 25 00 00 00       	mov    $0x25,%edx
+      if(c == '%'){
+ 478:	83 f8 25             	cmp    $0x25,%eax
+ 47b:	74 17                	je     494 <printf+0x54>
+  write(fd, &c, 1);
+ 47d:	83 ec 04             	sub    $0x4,%esp
+ 480:	88 5d e7             	mov    %bl,-0x19(%ebp)
+ 483:	6a 01                	push   $0x1
+ 485:	57                   	push   %edi
+ 486:	ff 75 08             	pushl  0x8(%ebp)
+ 489:	e8 55 fe ff ff       	call   2e3 <write>
+ 48e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+      } else {
+        putc(fd, c);
+ 491:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; fmt[i]; i++){
+ 494:	0f b6 1e             	movzbl (%esi),%ebx
+ 497:	83 c6 01             	add    $0x1,%esi
+ 49a:	84 db                	test   %bl,%bl
+ 49c:	74 71                	je     50f <printf+0xcf>
+    c = fmt[i] & 0xff;
+ 49e:	0f be cb             	movsbl %bl,%ecx
+ 4a1:	0f b6 c3             	movzbl %bl,%eax
+    if(state == 0){
+ 4a4:	85 d2                	test   %edx,%edx
+ 4a6:	74 c8                	je     470 <printf+0x30>
+      }
+    } else if(state == '%'){
+ 4a8:	83 fa 25             	cmp    $0x25,%edx
+ 4ab:	75 e7                	jne    494 <printf+0x54>
+      if(c == 'd'){
+ 4ad:	83 f8 64             	cmp    $0x64,%eax
+ 4b0:	0f 84 9a 00 00 00    	je     550 <printf+0x110>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+ 4b6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
+ 4bc:	83 f9 70             	cmp    $0x70,%ecx
+ 4bf:	74 5f                	je     520 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+ 4c1:	83 f8 73             	cmp    $0x73,%eax
+ 4c4:	0f 84 d6 00 00 00    	je     5a0 <printf+0x160>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 4ca:	83 f8 63             	cmp    $0x63,%eax
+ 4cd:	0f 84 8d 00 00 00    	je     560 <printf+0x120>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+ 4d3:	83 f8 25             	cmp    $0x25,%eax
+ 4d6:	0f 84 b4 00 00 00    	je     590 <printf+0x150>
+  write(fd, &c, 1);
+ 4dc:	83 ec 04             	sub    $0x4,%esp
+ 4df:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
+ 4e3:	6a 01                	push   $0x1
+ 4e5:	57                   	push   %edi
+ 4e6:	ff 75 08             	pushl  0x8(%ebp)
+ 4e9:	e8 f5 fd ff ff       	call   2e3 <write>
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+ 4ee:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 4f1:	83 c4 0c             	add    $0xc,%esp
+ 4f4:	6a 01                	push   $0x1
+ 4f6:	83 c6 01             	add    $0x1,%esi
+ 4f9:	57                   	push   %edi
+ 4fa:	ff 75 08             	pushl  0x8(%ebp)
+ 4fd:	e8 e1 fd ff ff       	call   2e3 <write>
+  for(i = 0; fmt[i]; i++){
+ 502:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
+        putc(fd, c);
+ 506:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 509:	31 d2                	xor    %edx,%edx
+  for(i = 0; fmt[i]; i++){
+ 50b:	84 db                	test   %bl,%bl
+ 50d:	75 8f                	jne    49e <printf+0x5e>
+    }
+  }
+}
+ 50f:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 512:	5b                   	pop    %ebx
+ 513:	5e                   	pop    %esi
+ 514:	5f                   	pop    %edi
+ 515:	5d                   	pop    %ebp
+ 516:	c3                   	ret    
+ 517:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 51e:	66 90                	xchg   %ax,%ax
+        printint(fd, *ap, 16, 0);
+ 520:	83 ec 0c             	sub    $0xc,%esp
+ 523:	b9 10 00 00 00       	mov    $0x10,%ecx
+ 528:	6a 00                	push   $0x0
+ 52a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+ 52d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 530:	8b 13                	mov    (%ebx),%edx
+ 532:	e8 59 fe ff ff       	call   390 <printint>
+        ap++;
+ 537:	89 d8                	mov    %ebx,%eax
+ 539:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 53c:	31 d2                	xor    %edx,%edx
+        ap++;
+ 53e:	83 c0 04             	add    $0x4,%eax
+ 541:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 544:	e9 4b ff ff ff       	jmp    494 <printf+0x54>
+ 549:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        printint(fd, *ap, 10, 1);
+ 550:	83 ec 0c             	sub    $0xc,%esp
+ 553:	b9 0a 00 00 00       	mov    $0xa,%ecx
+ 558:	6a 01                	push   $0x1
+ 55a:	eb ce                	jmp    52a <printf+0xea>
+ 55c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        putc(fd, *ap);
+ 560:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+  write(fd, &c, 1);
+ 563:	83 ec 04             	sub    $0x4,%esp
+        putc(fd, *ap);
+ 566:	8b 03                	mov    (%ebx),%eax
+  write(fd, &c, 1);
+ 568:	6a 01                	push   $0x1
+        ap++;
+ 56a:	83 c3 04             	add    $0x4,%ebx
+  write(fd, &c, 1);
+ 56d:	57                   	push   %edi
+ 56e:	ff 75 08             	pushl  0x8(%ebp)
+        putc(fd, *ap);
+ 571:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 574:	e8 6a fd ff ff       	call   2e3 <write>
+        ap++;
+ 579:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+ 57c:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 57f:	31 d2                	xor    %edx,%edx
+ 581:	e9 0e ff ff ff       	jmp    494 <printf+0x54>
+ 586:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 58d:	8d 76 00             	lea    0x0(%esi),%esi
+        putc(fd, c);
+ 590:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 593:	83 ec 04             	sub    $0x4,%esp
+ 596:	e9 59 ff ff ff       	jmp    4f4 <printf+0xb4>
+ 59b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 59f:	90                   	nop
+        s = (char*)*ap;
+ 5a0:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 5a3:	8b 18                	mov    (%eax),%ebx
+        ap++;
+ 5a5:	83 c0 04             	add    $0x4,%eax
+ 5a8:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        if(s == 0)
+ 5ab:	85 db                	test   %ebx,%ebx
+ 5ad:	74 17                	je     5c6 <printf+0x186>
+        while(*s != 0){
+ 5af:	0f b6 03             	movzbl (%ebx),%eax
+      state = 0;
+ 5b2:	31 d2                	xor    %edx,%edx
+        while(*s != 0){
+ 5b4:	84 c0                	test   %al,%al
+ 5b6:	0f 84 d8 fe ff ff    	je     494 <printf+0x54>
+ 5bc:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 5bf:	89 de                	mov    %ebx,%esi
+ 5c1:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 5c4:	eb 1a                	jmp    5e0 <printf+0x1a0>
+          s = "(null)";
+ 5c6:	bb cf 07 00 00       	mov    $0x7cf,%ebx
+        while(*s != 0){
+ 5cb:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 5ce:	b8 28 00 00 00       	mov    $0x28,%eax
+ 5d3:	89 de                	mov    %ebx,%esi
+ 5d5:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 5d8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 5df:	90                   	nop
+  write(fd, &c, 1);
+ 5e0:	83 ec 04             	sub    $0x4,%esp
+          s++;
+ 5e3:	83 c6 01             	add    $0x1,%esi
+ 5e6:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 5e9:	6a 01                	push   $0x1
+ 5eb:	57                   	push   %edi
+ 5ec:	53                   	push   %ebx
+ 5ed:	e8 f1 fc ff ff       	call   2e3 <write>
+        while(*s != 0){
+ 5f2:	0f b6 06             	movzbl (%esi),%eax
+ 5f5:	83 c4 10             	add    $0x10,%esp
+ 5f8:	84 c0                	test   %al,%al
+ 5fa:	75 e4                	jne    5e0 <printf+0x1a0>
+ 5fc:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+      state = 0;
+ 5ff:	31 d2                	xor    %edx,%edx
+ 601:	e9 8e fe ff ff       	jmp    494 <printf+0x54>
+ 606:	66 90                	xchg   %ax,%ax
+ 608:	66 90                	xchg   %ax,%ax
+ 60a:	66 90                	xchg   %ax,%ax
+ 60c:	66 90                	xchg   %ax,%ax
+ 60e:	66 90                	xchg   %ax,%ax
+
+00000610 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 610:	f3 0f 1e fb          	endbr32 
+ 614:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 615:	a1 84 0a 00 00       	mov    0xa84,%eax
+{
+ 61a:	89 e5                	mov    %esp,%ebp
+ 61c:	57                   	push   %edi
+ 61d:	56                   	push   %esi
+ 61e:	53                   	push   %ebx
+ 61f:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 622:	8b 10                	mov    (%eax),%edx
+  bp = (Header*)ap - 1;
+ 624:	8d 4b f8             	lea    -0x8(%ebx),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 627:	39 c8                	cmp    %ecx,%eax
+ 629:	73 15                	jae    640 <free+0x30>
+ 62b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 62f:	90                   	nop
+ 630:	39 d1                	cmp    %edx,%ecx
+ 632:	72 14                	jb     648 <free+0x38>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 634:	39 d0                	cmp    %edx,%eax
+ 636:	73 10                	jae    648 <free+0x38>
+{
+ 638:	89 d0                	mov    %edx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 63a:	8b 10                	mov    (%eax),%edx
+ 63c:	39 c8                	cmp    %ecx,%eax
+ 63e:	72 f0                	jb     630 <free+0x20>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 640:	39 d0                	cmp    %edx,%eax
+ 642:	72 f4                	jb     638 <free+0x28>
+ 644:	39 d1                	cmp    %edx,%ecx
+ 646:	73 f0                	jae    638 <free+0x28>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 648:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ 64b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
+ 64e:	39 fa                	cmp    %edi,%edx
+ 650:	74 1e                	je     670 <free+0x60>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+ 652:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 655:	8b 50 04             	mov    0x4(%eax),%edx
+ 658:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 65b:	39 f1                	cmp    %esi,%ecx
+ 65d:	74 28                	je     687 <free+0x77>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+ 65f:	89 08                	mov    %ecx,(%eax)
+  freep = p;
+}
+ 661:	5b                   	pop    %ebx
+  freep = p;
+ 662:	a3 84 0a 00 00       	mov    %eax,0xa84
+}
+ 667:	5e                   	pop    %esi
+ 668:	5f                   	pop    %edi
+ 669:	5d                   	pop    %ebp
+ 66a:	c3                   	ret    
+ 66b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 66f:	90                   	nop
+    bp->s.size += p->s.ptr->s.size;
+ 670:	03 72 04             	add    0x4(%edx),%esi
+ 673:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 676:	8b 10                	mov    (%eax),%edx
+ 678:	8b 12                	mov    (%edx),%edx
+ 67a:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 67d:	8b 50 04             	mov    0x4(%eax),%edx
+ 680:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 683:	39 f1                	cmp    %esi,%ecx
+ 685:	75 d8                	jne    65f <free+0x4f>
+    p->s.size += bp->s.size;
+ 687:	03 53 fc             	add    -0x4(%ebx),%edx
+  freep = p;
+ 68a:	a3 84 0a 00 00       	mov    %eax,0xa84
+    p->s.size += bp->s.size;
+ 68f:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 692:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ 695:	89 10                	mov    %edx,(%eax)
+}
+ 697:	5b                   	pop    %ebx
+ 698:	5e                   	pop    %esi
+ 699:	5f                   	pop    %edi
+ 69a:	5d                   	pop    %ebp
+ 69b:	c3                   	ret    
+ 69c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000006a0 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 6a0:	f3 0f 1e fb          	endbr32 
+ 6a4:	55                   	push   %ebp
+ 6a5:	89 e5                	mov    %esp,%ebp
+ 6a7:	57                   	push   %edi
+ 6a8:	56                   	push   %esi
+ 6a9:	53                   	push   %ebx
+ 6aa:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 6ad:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+ 6b0:	8b 3d 84 0a 00 00    	mov    0xa84,%edi
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 6b6:	8d 70 07             	lea    0x7(%eax),%esi
+ 6b9:	c1 ee 03             	shr    $0x3,%esi
+ 6bc:	83 c6 01             	add    $0x1,%esi
+  if((prevp = freep) == 0){
+ 6bf:	85 ff                	test   %edi,%edi
+ 6c1:	0f 84 a9 00 00 00    	je     770 <malloc+0xd0>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 6c7:	8b 07                	mov    (%edi),%eax
+    if(p->s.size >= nunits){
+ 6c9:	8b 48 04             	mov    0x4(%eax),%ecx
+ 6cc:	39 f1                	cmp    %esi,%ecx
+ 6ce:	73 6d                	jae    73d <malloc+0x9d>
+ 6d0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+ 6d6:	bb 00 10 00 00       	mov    $0x1000,%ebx
+ 6db:	0f 43 de             	cmovae %esi,%ebx
+  p = sbrk(nu * sizeof(Header));
+ 6de:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
+ 6e5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+ 6e8:	eb 17                	jmp    701 <malloc+0x61>
+ 6ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 6f0:	8b 10                	mov    (%eax),%edx
+    if(p->s.size >= nunits){
+ 6f2:	8b 4a 04             	mov    0x4(%edx),%ecx
+ 6f5:	39 f1                	cmp    %esi,%ecx
+ 6f7:	73 4f                	jae    748 <malloc+0xa8>
+ 6f9:	8b 3d 84 0a 00 00    	mov    0xa84,%edi
+ 6ff:	89 d0                	mov    %edx,%eax
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 701:	39 c7                	cmp    %eax,%edi
+ 703:	75 eb                	jne    6f0 <malloc+0x50>
+  p = sbrk(nu * sizeof(Header));
+ 705:	83 ec 0c             	sub    $0xc,%esp
+ 708:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 70b:	e8 3b fc ff ff       	call   34b <sbrk>
+  if(p == (char*)-1)
+ 710:	83 c4 10             	add    $0x10,%esp
+ 713:	83 f8 ff             	cmp    $0xffffffff,%eax
+ 716:	74 1b                	je     733 <malloc+0x93>
+  hp->s.size = nu;
+ 718:	89 58 04             	mov    %ebx,0x4(%eax)
+  free((void*)(hp + 1));
+ 71b:	83 ec 0c             	sub    $0xc,%esp
+ 71e:	83 c0 08             	add    $0x8,%eax
+ 721:	50                   	push   %eax
+ 722:	e8 e9 fe ff ff       	call   610 <free>
+  return freep;
+ 727:	a1 84 0a 00 00       	mov    0xa84,%eax
+      if((p = morecore(nunits)) == 0)
+ 72c:	83 c4 10             	add    $0x10,%esp
+ 72f:	85 c0                	test   %eax,%eax
+ 731:	75 bd                	jne    6f0 <malloc+0x50>
+        return 0;
+  }
+}
+ 733:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return 0;
+ 736:	31 c0                	xor    %eax,%eax
+}
+ 738:	5b                   	pop    %ebx
+ 739:	5e                   	pop    %esi
+ 73a:	5f                   	pop    %edi
+ 73b:	5d                   	pop    %ebp
+ 73c:	c3                   	ret    
+    if(p->s.size >= nunits){
+ 73d:	89 c2                	mov    %eax,%edx
+ 73f:	89 f8                	mov    %edi,%eax
+ 741:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+ 748:	39 ce                	cmp    %ecx,%esi
+ 74a:	74 54                	je     7a0 <malloc+0x100>
+        p->s.size -= nunits;
+ 74c:	29 f1                	sub    %esi,%ecx
+ 74e:	89 4a 04             	mov    %ecx,0x4(%edx)
+        p += p->s.size;
+ 751:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
+        p->s.size = nunits;
+ 754:	89 72 04             	mov    %esi,0x4(%edx)
+      freep = prevp;
+ 757:	a3 84 0a 00 00       	mov    %eax,0xa84
+}
+ 75c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return (void*)(p + 1);
+ 75f:	8d 42 08             	lea    0x8(%edx),%eax
+}
+ 762:	5b                   	pop    %ebx
+ 763:	5e                   	pop    %esi
+ 764:	5f                   	pop    %edi
+ 765:	5d                   	pop    %ebp
+ 766:	c3                   	ret    
+ 767:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 76e:	66 90                	xchg   %ax,%ax
+    base.s.ptr = freep = prevp = &base;
+ 770:	c7 05 84 0a 00 00 88 	movl   $0xa88,0xa84
+ 777:	0a 00 00 
+    base.s.size = 0;
+ 77a:	bf 88 0a 00 00       	mov    $0xa88,%edi
+    base.s.ptr = freep = prevp = &base;
+ 77f:	c7 05 88 0a 00 00 88 	movl   $0xa88,0xa88
+ 786:	0a 00 00 
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 789:	89 f8                	mov    %edi,%eax
+    base.s.size = 0;
+ 78b:	c7 05 8c 0a 00 00 00 	movl   $0x0,0xa8c
+ 792:	00 00 00 
+    if(p->s.size >= nunits){
+ 795:	e9 36 ff ff ff       	jmp    6d0 <malloc+0x30>
+ 79a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        prevp->s.ptr = p->s.ptr;
+ 7a0:	8b 0a                	mov    (%edx),%ecx
+ 7a2:	89 08                	mov    %ecx,(%eax)
+ 7a4:	eb b1                	jmp    757 <malloc+0xb7>
diff -ruN xv6-public/ln.d copy-xv6/ln.d
--- xv6-public/ln.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/ln.d	2022-09-05 23:26:11.996781090 +0530
@@ -0,0 +1 @@
+ln.o: ln.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/ln.o and copy-xv6/ln.o differ
diff -ruN xv6-public/ln.sym copy-xv6/ln.sym
--- xv6-public/ln.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/ln.sym	2022-09-05 23:26:12.008781091 +0530
@@ -0,0 +1,61 @@
+00000000 .text
+000007a8 .rodata
+000007ec .eh_frame
+00000a84 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 ln.c
+00000000 ulib.c
+00000000 printf.c
+00000390 printint
+000007d8 digits.1097
+00000000 umalloc.c
+00000a84 freep
+00000a88 base
+00000060 strcpy
+00000440 printf
+0000037b thread_exit
+00000290 memmove
+0000030b mknod
+00000180 gets
+00000343 getpid
+000006a0 malloc
+00000353 sleep
+000002d3 pipe
+000002e3 write
+0000031b fstat
+000002f3 kill
+00000333 chdir
+000002fb exec
+000002cb wait
+000002db read
+00000313 unlink
+000002bb fork
+0000034b sbrk
+0000035b uptime
+00000a84 __bss_start
+00000120 memset
+00000000 main
+00000090 strcmp
+0000033b dup
+00000200 stat
+00000a84 _edata
+00000a90 _end
+00000323 link
+000002c3 exit
+00000250 atoi
+00000363 draw
+000000e0 strlen
+00000303 open
+00000140 strchr
+0000036b thread_create
+0000032b mkdir
+000002eb close
+00000373 thread_join
+00000610 free
diff -ruN xv6-public/log.d copy-xv6/log.d
--- xv6-public/log.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/log.d	2022-09-05 23:26:13.196781066 +0530
@@ -0,0 +1,2 @@
+log.o: log.c /usr/include/stdc-predef.h types.h defs.h param.h spinlock.h \
+ sleeplock.h fs.h buf.h
Binary files xv6-public/log.o and copy-xv6/log.o differ
Binary files xv6-public/_ls and copy-xv6/_ls differ
diff -ruN xv6-public/ls.asm copy-xv6/ls.asm
--- xv6-public/ls.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/ls.asm	2022-09-05 23:26:12.048781090 +0530
@@ -0,0 +1,1496 @@
+
+_ls:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+  close(fd);
+}
+
+int
+main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	56                   	push   %esi
+  12:	53                   	push   %ebx
+  13:	51                   	push   %ecx
+  14:	83 ec 0c             	sub    $0xc,%esp
+  17:	8b 01                	mov    (%ecx),%eax
+  19:	8b 51 04             	mov    0x4(%ecx),%edx
+  int i;
+
+  if(argc < 2){
+  1c:	83 f8 01             	cmp    $0x1,%eax
+  1f:	7e 28                	jle    49 <main+0x49>
+  21:	8d 5a 04             	lea    0x4(%edx),%ebx
+  24:	8d 34 82             	lea    (%edx,%eax,4),%esi
+  27:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  2e:	66 90                	xchg   %ax,%ax
+    ls(".");
+    exit();
+  }
+  for(i=1; i<argc; i++)
+    ls(argv[i]);
+  30:	83 ec 0c             	sub    $0xc,%esp
+  33:	ff 33                	pushl  (%ebx)
+  35:	83 c3 04             	add    $0x4,%ebx
+  38:	e8 c3 00 00 00       	call   100 <ls>
+  for(i=1; i<argc; i++)
+  3d:	83 c4 10             	add    $0x10,%esp
+  40:	39 f3                	cmp    %esi,%ebx
+  42:	75 ec                	jne    30 <main+0x30>
+  exit();
+  44:	e8 5a 05 00 00       	call   5a3 <exit>
+    ls(".");
+  49:	83 ec 0c             	sub    $0xc,%esp
+  4c:	68 d0 0a 00 00       	push   $0xad0
+  51:	e8 aa 00 00 00       	call   100 <ls>
+    exit();
+  56:	e8 48 05 00 00       	call   5a3 <exit>
+  5b:	66 90                	xchg   %ax,%ax
+  5d:	66 90                	xchg   %ax,%ax
+  5f:	90                   	nop
+
+00000060 <fmtname>:
+{
+  60:	f3 0f 1e fb          	endbr32 
+  64:	55                   	push   %ebp
+  65:	89 e5                	mov    %esp,%ebp
+  67:	56                   	push   %esi
+  68:	53                   	push   %ebx
+  69:	8b 75 08             	mov    0x8(%ebp),%esi
+  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+  6c:	83 ec 0c             	sub    $0xc,%esp
+  6f:	56                   	push   %esi
+  70:	e8 4b 03 00 00       	call   3c0 <strlen>
+  75:	83 c4 10             	add    $0x10,%esp
+  78:	01 f0                	add    %esi,%eax
+  7a:	89 c3                	mov    %eax,%ebx
+  7c:	73 0b                	jae    89 <fmtname+0x29>
+  7e:	eb 0e                	jmp    8e <fmtname+0x2e>
+  80:	8d 43 ff             	lea    -0x1(%ebx),%eax
+  83:	39 c6                	cmp    %eax,%esi
+  85:	77 0a                	ja     91 <fmtname+0x31>
+  87:	89 c3                	mov    %eax,%ebx
+  89:	80 3b 2f             	cmpb   $0x2f,(%ebx)
+  8c:	75 f2                	jne    80 <fmtname+0x20>
+  8e:	83 c3 01             	add    $0x1,%ebx
+  if(strlen(p) >= DIRSIZ)
+  91:	83 ec 0c             	sub    $0xc,%esp
+  94:	53                   	push   %ebx
+  95:	e8 26 03 00 00       	call   3c0 <strlen>
+  9a:	83 c4 10             	add    $0x10,%esp
+  9d:	83 f8 0d             	cmp    $0xd,%eax
+  a0:	77 4a                	ja     ec <fmtname+0x8c>
+  memmove(buf, p, strlen(p));
+  a2:	83 ec 0c             	sub    $0xc,%esp
+  a5:	53                   	push   %ebx
+  a6:	e8 15 03 00 00       	call   3c0 <strlen>
+  ab:	83 c4 0c             	add    $0xc,%esp
+  ae:	50                   	push   %eax
+  af:	53                   	push   %ebx
+  b0:	68 04 0e 00 00       	push   $0xe04
+  b5:	e8 b6 04 00 00       	call   570 <memmove>
+  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
+  ba:	89 1c 24             	mov    %ebx,(%esp)
+  bd:	e8 fe 02 00 00       	call   3c0 <strlen>
+  c2:	89 1c 24             	mov    %ebx,(%esp)
+  return buf;
+  c5:	bb 04 0e 00 00       	mov    $0xe04,%ebx
+  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
+  ca:	89 c6                	mov    %eax,%esi
+  cc:	e8 ef 02 00 00       	call   3c0 <strlen>
+  d1:	ba 0e 00 00 00       	mov    $0xe,%edx
+  d6:	83 c4 0c             	add    $0xc,%esp
+  d9:	29 f2                	sub    %esi,%edx
+  db:	05 04 0e 00 00       	add    $0xe04,%eax
+  e0:	52                   	push   %edx
+  e1:	6a 20                	push   $0x20
+  e3:	50                   	push   %eax
+  e4:	e8 17 03 00 00       	call   400 <memset>
+  return buf;
+  e9:	83 c4 10             	add    $0x10,%esp
+}
+  ec:	8d 65 f8             	lea    -0x8(%ebp),%esp
+  ef:	89 d8                	mov    %ebx,%eax
+  f1:	5b                   	pop    %ebx
+  f2:	5e                   	pop    %esi
+  f3:	5d                   	pop    %ebp
+  f4:	c3                   	ret    
+  f5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000100 <ls>:
+{
+ 100:	f3 0f 1e fb          	endbr32 
+ 104:	55                   	push   %ebp
+ 105:	89 e5                	mov    %esp,%ebp
+ 107:	57                   	push   %edi
+ 108:	56                   	push   %esi
+ 109:	53                   	push   %ebx
+ 10a:	81 ec 64 02 00 00    	sub    $0x264,%esp
+ 110:	8b 7d 08             	mov    0x8(%ebp),%edi
+  if((fd = open(path, 0)) < 0){
+ 113:	6a 00                	push   $0x0
+ 115:	57                   	push   %edi
+ 116:	e8 c8 04 00 00       	call   5e3 <open>
+ 11b:	83 c4 10             	add    $0x10,%esp
+ 11e:	85 c0                	test   %eax,%eax
+ 120:	0f 88 9a 01 00 00    	js     2c0 <ls+0x1c0>
+  if(fstat(fd, &st) < 0){
+ 126:	83 ec 08             	sub    $0x8,%esp
+ 129:	8d b5 d4 fd ff ff    	lea    -0x22c(%ebp),%esi
+ 12f:	89 c3                	mov    %eax,%ebx
+ 131:	56                   	push   %esi
+ 132:	50                   	push   %eax
+ 133:	e8 c3 04 00 00       	call   5fb <fstat>
+ 138:	83 c4 10             	add    $0x10,%esp
+ 13b:	85 c0                	test   %eax,%eax
+ 13d:	0f 88 bd 01 00 00    	js     300 <ls+0x200>
+  switch(st.type){
+ 143:	0f b7 85 d4 fd ff ff 	movzwl -0x22c(%ebp),%eax
+ 14a:	66 83 f8 01          	cmp    $0x1,%ax
+ 14e:	74 60                	je     1b0 <ls+0xb0>
+ 150:	66 83 f8 02          	cmp    $0x2,%ax
+ 154:	74 1a                	je     170 <ls+0x70>
+  close(fd);
+ 156:	83 ec 0c             	sub    $0xc,%esp
+ 159:	53                   	push   %ebx
+ 15a:	e8 6c 04 00 00       	call   5cb <close>
+ 15f:	83 c4 10             	add    $0x10,%esp
+}
+ 162:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 165:	5b                   	pop    %ebx
+ 166:	5e                   	pop    %esi
+ 167:	5f                   	pop    %edi
+ 168:	5d                   	pop    %ebp
+ 169:	c3                   	ret    
+ 16a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
+ 170:	83 ec 0c             	sub    $0xc,%esp
+ 173:	8b 95 e4 fd ff ff    	mov    -0x21c(%ebp),%edx
+ 179:	8b b5 dc fd ff ff    	mov    -0x224(%ebp),%esi
+ 17f:	57                   	push   %edi
+ 180:	89 95 b4 fd ff ff    	mov    %edx,-0x24c(%ebp)
+ 186:	e8 d5 fe ff ff       	call   60 <fmtname>
+ 18b:	8b 95 b4 fd ff ff    	mov    -0x24c(%ebp),%edx
+ 191:	59                   	pop    %ecx
+ 192:	5f                   	pop    %edi
+ 193:	52                   	push   %edx
+ 194:	56                   	push   %esi
+ 195:	6a 02                	push   $0x2
+ 197:	50                   	push   %eax
+ 198:	68 b0 0a 00 00       	push   $0xab0
+ 19d:	6a 01                	push   $0x1
+ 19f:	e8 7c 05 00 00       	call   720 <printf>
+    break;
+ 1a4:	83 c4 20             	add    $0x20,%esp
+ 1a7:	eb ad                	jmp    156 <ls+0x56>
+ 1a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+ 1b0:	83 ec 0c             	sub    $0xc,%esp
+ 1b3:	57                   	push   %edi
+ 1b4:	e8 07 02 00 00       	call   3c0 <strlen>
+ 1b9:	83 c4 10             	add    $0x10,%esp
+ 1bc:	83 c0 10             	add    $0x10,%eax
+ 1bf:	3d 00 02 00 00       	cmp    $0x200,%eax
+ 1c4:	0f 87 16 01 00 00    	ja     2e0 <ls+0x1e0>
+    strcpy(buf, path);
+ 1ca:	83 ec 08             	sub    $0x8,%esp
+ 1cd:	57                   	push   %edi
+ 1ce:	8d bd e8 fd ff ff    	lea    -0x218(%ebp),%edi
+ 1d4:	57                   	push   %edi
+ 1d5:	e8 66 01 00 00       	call   340 <strcpy>
+    p = buf+strlen(buf);
+ 1da:	89 3c 24             	mov    %edi,(%esp)
+ 1dd:	e8 de 01 00 00       	call   3c0 <strlen>
+    while(read(fd, &de, sizeof(de)) == sizeof(de)){
+ 1e2:	83 c4 10             	add    $0x10,%esp
+    p = buf+strlen(buf);
+ 1e5:	01 f8                	add    %edi,%eax
+    *p++ = '/';
+ 1e7:	8d 48 01             	lea    0x1(%eax),%ecx
+    p = buf+strlen(buf);
+ 1ea:	89 85 a8 fd ff ff    	mov    %eax,-0x258(%ebp)
+    *p++ = '/';
+ 1f0:	89 8d a4 fd ff ff    	mov    %ecx,-0x25c(%ebp)
+ 1f6:	c6 00 2f             	movb   $0x2f,(%eax)
+    while(read(fd, &de, sizeof(de)) == sizeof(de)){
+ 1f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 200:	83 ec 04             	sub    $0x4,%esp
+ 203:	8d 85 c4 fd ff ff    	lea    -0x23c(%ebp),%eax
+ 209:	6a 10                	push   $0x10
+ 20b:	50                   	push   %eax
+ 20c:	53                   	push   %ebx
+ 20d:	e8 a9 03 00 00       	call   5bb <read>
+ 212:	83 c4 10             	add    $0x10,%esp
+ 215:	83 f8 10             	cmp    $0x10,%eax
+ 218:	0f 85 38 ff ff ff    	jne    156 <ls+0x56>
+      if(de.inum == 0)
+ 21e:	66 83 bd c4 fd ff ff 	cmpw   $0x0,-0x23c(%ebp)
+ 225:	00 
+ 226:	74 d8                	je     200 <ls+0x100>
+      memmove(p, de.name, DIRSIZ);
+ 228:	83 ec 04             	sub    $0x4,%esp
+ 22b:	8d 85 c6 fd ff ff    	lea    -0x23a(%ebp),%eax
+ 231:	6a 0e                	push   $0xe
+ 233:	50                   	push   %eax
+ 234:	ff b5 a4 fd ff ff    	pushl  -0x25c(%ebp)
+ 23a:	e8 31 03 00 00       	call   570 <memmove>
+      p[DIRSIZ] = 0;
+ 23f:	8b 85 a8 fd ff ff    	mov    -0x258(%ebp),%eax
+ 245:	c6 40 0f 00          	movb   $0x0,0xf(%eax)
+      if(stat(buf, &st) < 0){
+ 249:	58                   	pop    %eax
+ 24a:	5a                   	pop    %edx
+ 24b:	56                   	push   %esi
+ 24c:	57                   	push   %edi
+ 24d:	e8 8e 02 00 00       	call   4e0 <stat>
+ 252:	83 c4 10             	add    $0x10,%esp
+ 255:	85 c0                	test   %eax,%eax
+ 257:	0f 88 cb 00 00 00    	js     328 <ls+0x228>
+      printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
+ 25d:	83 ec 0c             	sub    $0xc,%esp
+ 260:	8b 8d e4 fd ff ff    	mov    -0x21c(%ebp),%ecx
+ 266:	8b 95 dc fd ff ff    	mov    -0x224(%ebp),%edx
+ 26c:	57                   	push   %edi
+ 26d:	0f bf 85 d4 fd ff ff 	movswl -0x22c(%ebp),%eax
+ 274:	89 8d ac fd ff ff    	mov    %ecx,-0x254(%ebp)
+ 27a:	89 95 b0 fd ff ff    	mov    %edx,-0x250(%ebp)
+ 280:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
+ 286:	e8 d5 fd ff ff       	call   60 <fmtname>
+ 28b:	5a                   	pop    %edx
+ 28c:	8b 95 b0 fd ff ff    	mov    -0x250(%ebp),%edx
+ 292:	59                   	pop    %ecx
+ 293:	8b 8d ac fd ff ff    	mov    -0x254(%ebp),%ecx
+ 299:	51                   	push   %ecx
+ 29a:	52                   	push   %edx
+ 29b:	ff b5 b4 fd ff ff    	pushl  -0x24c(%ebp)
+ 2a1:	50                   	push   %eax
+ 2a2:	68 b0 0a 00 00       	push   $0xab0
+ 2a7:	6a 01                	push   $0x1
+ 2a9:	e8 72 04 00 00       	call   720 <printf>
+ 2ae:	83 c4 20             	add    $0x20,%esp
+ 2b1:	e9 4a ff ff ff       	jmp    200 <ls+0x100>
+ 2b6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 2bd:	8d 76 00             	lea    0x0(%esi),%esi
+    printf(2, "ls: cannot open %s\n", path);
+ 2c0:	83 ec 04             	sub    $0x4,%esp
+ 2c3:	57                   	push   %edi
+ 2c4:	68 88 0a 00 00       	push   $0xa88
+ 2c9:	6a 02                	push   $0x2
+ 2cb:	e8 50 04 00 00       	call   720 <printf>
+    return;
+ 2d0:	83 c4 10             	add    $0x10,%esp
+}
+ 2d3:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 2d6:	5b                   	pop    %ebx
+ 2d7:	5e                   	pop    %esi
+ 2d8:	5f                   	pop    %edi
+ 2d9:	5d                   	pop    %ebp
+ 2da:	c3                   	ret    
+ 2db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 2df:	90                   	nop
+      printf(1, "ls: path too long\n");
+ 2e0:	83 ec 08             	sub    $0x8,%esp
+ 2e3:	68 bd 0a 00 00       	push   $0xabd
+ 2e8:	6a 01                	push   $0x1
+ 2ea:	e8 31 04 00 00       	call   720 <printf>
+      break;
+ 2ef:	83 c4 10             	add    $0x10,%esp
+ 2f2:	e9 5f fe ff ff       	jmp    156 <ls+0x56>
+ 2f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 2fe:	66 90                	xchg   %ax,%ax
+    printf(2, "ls: cannot stat %s\n", path);
+ 300:	83 ec 04             	sub    $0x4,%esp
+ 303:	57                   	push   %edi
+ 304:	68 9c 0a 00 00       	push   $0xa9c
+ 309:	6a 02                	push   $0x2
+ 30b:	e8 10 04 00 00       	call   720 <printf>
+    close(fd);
+ 310:	89 1c 24             	mov    %ebx,(%esp)
+ 313:	e8 b3 02 00 00       	call   5cb <close>
+    return;
+ 318:	83 c4 10             	add    $0x10,%esp
+}
+ 31b:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 31e:	5b                   	pop    %ebx
+ 31f:	5e                   	pop    %esi
+ 320:	5f                   	pop    %edi
+ 321:	5d                   	pop    %ebp
+ 322:	c3                   	ret    
+ 323:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 327:	90                   	nop
+        printf(1, "ls: cannot stat %s\n", buf);
+ 328:	83 ec 04             	sub    $0x4,%esp
+ 32b:	57                   	push   %edi
+ 32c:	68 9c 0a 00 00       	push   $0xa9c
+ 331:	6a 01                	push   $0x1
+ 333:	e8 e8 03 00 00       	call   720 <printf>
+        continue;
+ 338:	83 c4 10             	add    $0x10,%esp
+ 33b:	e9 c0 fe ff ff       	jmp    200 <ls+0x100>
+
+00000340 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 340:	f3 0f 1e fb          	endbr32 
+ 344:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+ 345:	31 c0                	xor    %eax,%eax
+{
+ 347:	89 e5                	mov    %esp,%ebp
+ 349:	53                   	push   %ebx
+ 34a:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 34d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+ 350:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+ 354:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+ 357:	83 c0 01             	add    $0x1,%eax
+ 35a:	84 d2                	test   %dl,%dl
+ 35c:	75 f2                	jne    350 <strcpy+0x10>
+    ;
+  return os;
+}
+ 35e:	89 c8                	mov    %ecx,%eax
+ 360:	5b                   	pop    %ebx
+ 361:	5d                   	pop    %ebp
+ 362:	c3                   	ret    
+ 363:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 36a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000370 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 370:	f3 0f 1e fb          	endbr32 
+ 374:	55                   	push   %ebp
+ 375:	89 e5                	mov    %esp,%ebp
+ 377:	53                   	push   %ebx
+ 378:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 37b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+ 37e:	0f b6 01             	movzbl (%ecx),%eax
+ 381:	0f b6 1a             	movzbl (%edx),%ebx
+ 384:	84 c0                	test   %al,%al
+ 386:	75 19                	jne    3a1 <strcmp+0x31>
+ 388:	eb 26                	jmp    3b0 <strcmp+0x40>
+ 38a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 390:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+ 394:	83 c1 01             	add    $0x1,%ecx
+ 397:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+ 39a:	0f b6 1a             	movzbl (%edx),%ebx
+ 39d:	84 c0                	test   %al,%al
+ 39f:	74 0f                	je     3b0 <strcmp+0x40>
+ 3a1:	38 d8                	cmp    %bl,%al
+ 3a3:	74 eb                	je     390 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+ 3a5:	29 d8                	sub    %ebx,%eax
+}
+ 3a7:	5b                   	pop    %ebx
+ 3a8:	5d                   	pop    %ebp
+ 3a9:	c3                   	ret    
+ 3aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 3b0:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+ 3b2:	29 d8                	sub    %ebx,%eax
+}
+ 3b4:	5b                   	pop    %ebx
+ 3b5:	5d                   	pop    %ebp
+ 3b6:	c3                   	ret    
+ 3b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 3be:	66 90                	xchg   %ax,%ax
+
+000003c0 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 3c0:	f3 0f 1e fb          	endbr32 
+ 3c4:	55                   	push   %ebp
+ 3c5:	89 e5                	mov    %esp,%ebp
+ 3c7:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 3ca:	80 3a 00             	cmpb   $0x0,(%edx)
+ 3cd:	74 21                	je     3f0 <strlen+0x30>
+ 3cf:	31 c0                	xor    %eax,%eax
+ 3d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 3d8:	83 c0 01             	add    $0x1,%eax
+ 3db:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+ 3df:	89 c1                	mov    %eax,%ecx
+ 3e1:	75 f5                	jne    3d8 <strlen+0x18>
+    ;
+  return n;
+}
+ 3e3:	89 c8                	mov    %ecx,%eax
+ 3e5:	5d                   	pop    %ebp
+ 3e6:	c3                   	ret    
+ 3e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 3ee:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+ 3f0:	31 c9                	xor    %ecx,%ecx
+}
+ 3f2:	5d                   	pop    %ebp
+ 3f3:	89 c8                	mov    %ecx,%eax
+ 3f5:	c3                   	ret    
+ 3f6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 3fd:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000400 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 400:	f3 0f 1e fb          	endbr32 
+ 404:	55                   	push   %ebp
+ 405:	89 e5                	mov    %esp,%ebp
+ 407:	57                   	push   %edi
+ 408:	8b 55 08             	mov    0x8(%ebp),%edx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+ 40b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 40e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 411:	89 d7                	mov    %edx,%edi
+ 413:	fc                   	cld    
+ 414:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+ 416:	89 d0                	mov    %edx,%eax
+ 418:	5f                   	pop    %edi
+ 419:	5d                   	pop    %ebp
+ 41a:	c3                   	ret    
+ 41b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 41f:	90                   	nop
+
+00000420 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 420:	f3 0f 1e fb          	endbr32 
+ 424:	55                   	push   %ebp
+ 425:	89 e5                	mov    %esp,%ebp
+ 427:	8b 45 08             	mov    0x8(%ebp),%eax
+ 42a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+ 42e:	0f b6 10             	movzbl (%eax),%edx
+ 431:	84 d2                	test   %dl,%dl
+ 433:	75 16                	jne    44b <strchr+0x2b>
+ 435:	eb 21                	jmp    458 <strchr+0x38>
+ 437:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 43e:	66 90                	xchg   %ax,%ax
+ 440:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+ 444:	83 c0 01             	add    $0x1,%eax
+ 447:	84 d2                	test   %dl,%dl
+ 449:	74 0d                	je     458 <strchr+0x38>
+    if(*s == c)
+ 44b:	38 d1                	cmp    %dl,%cl
+ 44d:	75 f1                	jne    440 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+ 44f:	5d                   	pop    %ebp
+ 450:	c3                   	ret    
+ 451:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+ 458:	31 c0                	xor    %eax,%eax
+}
+ 45a:	5d                   	pop    %ebp
+ 45b:	c3                   	ret    
+ 45c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000460 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 460:	f3 0f 1e fb          	endbr32 
+ 464:	55                   	push   %ebp
+ 465:	89 e5                	mov    %esp,%ebp
+ 467:	57                   	push   %edi
+ 468:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 469:	31 f6                	xor    %esi,%esi
+{
+ 46b:	53                   	push   %ebx
+ 46c:	89 f3                	mov    %esi,%ebx
+ 46e:	83 ec 1c             	sub    $0x1c,%esp
+ 471:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+ 474:	eb 33                	jmp    4a9 <gets+0x49>
+ 476:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 47d:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+ 480:	83 ec 04             	sub    $0x4,%esp
+ 483:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ 486:	6a 01                	push   $0x1
+ 488:	50                   	push   %eax
+ 489:	6a 00                	push   $0x0
+ 48b:	e8 2b 01 00 00       	call   5bb <read>
+    if(cc < 1)
+ 490:	83 c4 10             	add    $0x10,%esp
+ 493:	85 c0                	test   %eax,%eax
+ 495:	7e 1c                	jle    4b3 <gets+0x53>
+      break;
+    buf[i++] = c;
+ 497:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ 49b:	83 c7 01             	add    $0x1,%edi
+ 49e:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+ 4a1:	3c 0a                	cmp    $0xa,%al
+ 4a3:	74 23                	je     4c8 <gets+0x68>
+ 4a5:	3c 0d                	cmp    $0xd,%al
+ 4a7:	74 1f                	je     4c8 <gets+0x68>
+  for(i=0; i+1 < max; ){
+ 4a9:	83 c3 01             	add    $0x1,%ebx
+ 4ac:	89 fe                	mov    %edi,%esi
+ 4ae:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+ 4b1:	7c cd                	jl     480 <gets+0x20>
+ 4b3:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+ 4b5:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+ 4b8:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 4bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 4be:	5b                   	pop    %ebx
+ 4bf:	5e                   	pop    %esi
+ 4c0:	5f                   	pop    %edi
+ 4c1:	5d                   	pop    %ebp
+ 4c2:	c3                   	ret    
+ 4c3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 4c7:	90                   	nop
+ 4c8:	8b 75 08             	mov    0x8(%ebp),%esi
+ 4cb:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4ce:	01 de                	add    %ebx,%esi
+ 4d0:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+ 4d2:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 4d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 4d8:	5b                   	pop    %ebx
+ 4d9:	5e                   	pop    %esi
+ 4da:	5f                   	pop    %edi
+ 4db:	5d                   	pop    %ebp
+ 4dc:	c3                   	ret    
+ 4dd:	8d 76 00             	lea    0x0(%esi),%esi
+
+000004e0 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 4e0:	f3 0f 1e fb          	endbr32 
+ 4e4:	55                   	push   %ebp
+ 4e5:	89 e5                	mov    %esp,%ebp
+ 4e7:	56                   	push   %esi
+ 4e8:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 4e9:	83 ec 08             	sub    $0x8,%esp
+ 4ec:	6a 00                	push   $0x0
+ 4ee:	ff 75 08             	pushl  0x8(%ebp)
+ 4f1:	e8 ed 00 00 00       	call   5e3 <open>
+  if(fd < 0)
+ 4f6:	83 c4 10             	add    $0x10,%esp
+ 4f9:	85 c0                	test   %eax,%eax
+ 4fb:	78 2b                	js     528 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+ 4fd:	83 ec 08             	sub    $0x8,%esp
+ 500:	ff 75 0c             	pushl  0xc(%ebp)
+ 503:	89 c3                	mov    %eax,%ebx
+ 505:	50                   	push   %eax
+ 506:	e8 f0 00 00 00       	call   5fb <fstat>
+  close(fd);
+ 50b:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+ 50e:	89 c6                	mov    %eax,%esi
+  close(fd);
+ 510:	e8 b6 00 00 00       	call   5cb <close>
+  return r;
+ 515:	83 c4 10             	add    $0x10,%esp
+}
+ 518:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 51b:	89 f0                	mov    %esi,%eax
+ 51d:	5b                   	pop    %ebx
+ 51e:	5e                   	pop    %esi
+ 51f:	5d                   	pop    %ebp
+ 520:	c3                   	ret    
+ 521:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+ 528:	be ff ff ff ff       	mov    $0xffffffff,%esi
+ 52d:	eb e9                	jmp    518 <stat+0x38>
+ 52f:	90                   	nop
+
+00000530 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 530:	f3 0f 1e fb          	endbr32 
+ 534:	55                   	push   %ebp
+ 535:	89 e5                	mov    %esp,%ebp
+ 537:	53                   	push   %ebx
+ 538:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 53b:	0f be 02             	movsbl (%edx),%eax
+ 53e:	8d 48 d0             	lea    -0x30(%eax),%ecx
+ 541:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+ 544:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+ 549:	77 1a                	ja     565 <atoi+0x35>
+ 54b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 54f:	90                   	nop
+    n = n*10 + *s++ - '0';
+ 550:	83 c2 01             	add    $0x1,%edx
+ 553:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+ 556:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+ 55a:	0f be 02             	movsbl (%edx),%eax
+ 55d:	8d 58 d0             	lea    -0x30(%eax),%ebx
+ 560:	80 fb 09             	cmp    $0x9,%bl
+ 563:	76 eb                	jbe    550 <atoi+0x20>
+  return n;
+}
+ 565:	89 c8                	mov    %ecx,%eax
+ 567:	5b                   	pop    %ebx
+ 568:	5d                   	pop    %ebp
+ 569:	c3                   	ret    
+ 56a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000570 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 570:	f3 0f 1e fb          	endbr32 
+ 574:	55                   	push   %ebp
+ 575:	89 e5                	mov    %esp,%ebp
+ 577:	57                   	push   %edi
+ 578:	8b 45 10             	mov    0x10(%ebp),%eax
+ 57b:	8b 55 08             	mov    0x8(%ebp),%edx
+ 57e:	56                   	push   %esi
+ 57f:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 582:	85 c0                	test   %eax,%eax
+ 584:	7e 0f                	jle    595 <memmove+0x25>
+ 586:	01 d0                	add    %edx,%eax
+  dst = vdst;
+ 588:	89 d7                	mov    %edx,%edi
+ 58a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+ 590:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+ 591:	39 f8                	cmp    %edi,%eax
+ 593:	75 fb                	jne    590 <memmove+0x20>
+  return vdst;
+}
+ 595:	5e                   	pop    %esi
+ 596:	89 d0                	mov    %edx,%eax
+ 598:	5f                   	pop    %edi
+ 599:	5d                   	pop    %ebp
+ 59a:	c3                   	ret    
+
+0000059b <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 59b:	b8 01 00 00 00       	mov    $0x1,%eax
+ 5a0:	cd 40                	int    $0x40
+ 5a2:	c3                   	ret    
+
+000005a3 <exit>:
+SYSCALL(exit)
+ 5a3:	b8 02 00 00 00       	mov    $0x2,%eax
+ 5a8:	cd 40                	int    $0x40
+ 5aa:	c3                   	ret    
+
+000005ab <wait>:
+SYSCALL(wait)
+ 5ab:	b8 03 00 00 00       	mov    $0x3,%eax
+ 5b0:	cd 40                	int    $0x40
+ 5b2:	c3                   	ret    
+
+000005b3 <pipe>:
+SYSCALL(pipe)
+ 5b3:	b8 04 00 00 00       	mov    $0x4,%eax
+ 5b8:	cd 40                	int    $0x40
+ 5ba:	c3                   	ret    
+
+000005bb <read>:
+SYSCALL(read)
+ 5bb:	b8 05 00 00 00       	mov    $0x5,%eax
+ 5c0:	cd 40                	int    $0x40
+ 5c2:	c3                   	ret    
+
+000005c3 <write>:
+SYSCALL(write)
+ 5c3:	b8 10 00 00 00       	mov    $0x10,%eax
+ 5c8:	cd 40                	int    $0x40
+ 5ca:	c3                   	ret    
+
+000005cb <close>:
+SYSCALL(close)
+ 5cb:	b8 15 00 00 00       	mov    $0x15,%eax
+ 5d0:	cd 40                	int    $0x40
+ 5d2:	c3                   	ret    
+
+000005d3 <kill>:
+SYSCALL(kill)
+ 5d3:	b8 06 00 00 00       	mov    $0x6,%eax
+ 5d8:	cd 40                	int    $0x40
+ 5da:	c3                   	ret    
+
+000005db <exec>:
+SYSCALL(exec)
+ 5db:	b8 07 00 00 00       	mov    $0x7,%eax
+ 5e0:	cd 40                	int    $0x40
+ 5e2:	c3                   	ret    
+
+000005e3 <open>:
+SYSCALL(open)
+ 5e3:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 5e8:	cd 40                	int    $0x40
+ 5ea:	c3                   	ret    
+
+000005eb <mknod>:
+SYSCALL(mknod)
+ 5eb:	b8 11 00 00 00       	mov    $0x11,%eax
+ 5f0:	cd 40                	int    $0x40
+ 5f2:	c3                   	ret    
+
+000005f3 <unlink>:
+SYSCALL(unlink)
+ 5f3:	b8 12 00 00 00       	mov    $0x12,%eax
+ 5f8:	cd 40                	int    $0x40
+ 5fa:	c3                   	ret    
+
+000005fb <fstat>:
+SYSCALL(fstat)
+ 5fb:	b8 08 00 00 00       	mov    $0x8,%eax
+ 600:	cd 40                	int    $0x40
+ 602:	c3                   	ret    
+
+00000603 <link>:
+SYSCALL(link)
+ 603:	b8 13 00 00 00       	mov    $0x13,%eax
+ 608:	cd 40                	int    $0x40
+ 60a:	c3                   	ret    
+
+0000060b <mkdir>:
+SYSCALL(mkdir)
+ 60b:	b8 14 00 00 00       	mov    $0x14,%eax
+ 610:	cd 40                	int    $0x40
+ 612:	c3                   	ret    
+
+00000613 <chdir>:
+SYSCALL(chdir)
+ 613:	b8 09 00 00 00       	mov    $0x9,%eax
+ 618:	cd 40                	int    $0x40
+ 61a:	c3                   	ret    
+
+0000061b <dup>:
+SYSCALL(dup)
+ 61b:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 620:	cd 40                	int    $0x40
+ 622:	c3                   	ret    
+
+00000623 <getpid>:
+SYSCALL(getpid)
+ 623:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 628:	cd 40                	int    $0x40
+ 62a:	c3                   	ret    
+
+0000062b <sbrk>:
+SYSCALL(sbrk)
+ 62b:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 630:	cd 40                	int    $0x40
+ 632:	c3                   	ret    
+
+00000633 <sleep>:
+SYSCALL(sleep)
+ 633:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 638:	cd 40                	int    $0x40
+ 63a:	c3                   	ret    
+
+0000063b <uptime>:
+SYSCALL(uptime)
+ 63b:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 640:	cd 40                	int    $0x40
+ 642:	c3                   	ret    
+
+00000643 <draw>:
+SYSCALL(draw)
+ 643:	b8 16 00 00 00       	mov    $0x16,%eax
+ 648:	cd 40                	int    $0x40
+ 64a:	c3                   	ret    
+
+0000064b <thread_create>:
+
+SYSCALL(thread_create)
+ 64b:	b8 17 00 00 00       	mov    $0x17,%eax
+ 650:	cd 40                	int    $0x40
+ 652:	c3                   	ret    
+
+00000653 <thread_join>:
+SYSCALL(thread_join)
+ 653:	b8 18 00 00 00       	mov    $0x18,%eax
+ 658:	cd 40                	int    $0x40
+ 65a:	c3                   	ret    
+
+0000065b <thread_exit>:
+SYSCALL(thread_exit)
+ 65b:	b8 19 00 00 00       	mov    $0x19,%eax
+ 660:	cd 40                	int    $0x40
+ 662:	c3                   	ret    
+ 663:	66 90                	xchg   %ax,%ax
+ 665:	66 90                	xchg   %ax,%ax
+ 667:	66 90                	xchg   %ax,%ax
+ 669:	66 90                	xchg   %ax,%ax
+ 66b:	66 90                	xchg   %ax,%ax
+ 66d:	66 90                	xchg   %ax,%ax
+ 66f:	90                   	nop
+
+00000670 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 670:	55                   	push   %ebp
+ 671:	89 e5                	mov    %esp,%ebp
+ 673:	57                   	push   %edi
+ 674:	56                   	push   %esi
+ 675:	53                   	push   %ebx
+ 676:	83 ec 3c             	sub    $0x3c,%esp
+ 679:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+ 67c:	89 d1                	mov    %edx,%ecx
+{
+ 67e:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  if(sgn && xx < 0){
+ 681:	85 d2                	test   %edx,%edx
+ 683:	0f 89 7f 00 00 00    	jns    708 <printint+0x98>
+ 689:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
+ 68d:	74 79                	je     708 <printint+0x98>
+    neg = 1;
+ 68f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+    x = -xx;
+ 696:	f7 d9                	neg    %ecx
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 698:	31 db                	xor    %ebx,%ebx
+ 69a:	8d 75 d7             	lea    -0x29(%ebp),%esi
+ 69d:	8d 76 00             	lea    0x0(%esi),%esi
+  do{
+    buf[i++] = digits[x % base];
+ 6a0:	89 c8                	mov    %ecx,%eax
+ 6a2:	31 d2                	xor    %edx,%edx
+ 6a4:	89 cf                	mov    %ecx,%edi
+ 6a6:	f7 75 c4             	divl   -0x3c(%ebp)
+ 6a9:	0f b6 92 dc 0a 00 00 	movzbl 0xadc(%edx),%edx
+ 6b0:	89 45 c0             	mov    %eax,-0x40(%ebp)
+ 6b3:	89 d8                	mov    %ebx,%eax
+ 6b5:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+ 6b8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+    buf[i++] = digits[x % base];
+ 6bb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
+  }while((x /= base) != 0);
+ 6be:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
+ 6c1:	76 dd                	jbe    6a0 <printint+0x30>
+  if(neg)
+ 6c3:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+ 6c6:	85 c9                	test   %ecx,%ecx
+ 6c8:	74 0c                	je     6d6 <printint+0x66>
+    buf[i++] = '-';
+ 6ca:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+ 6cf:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+ 6d1:	ba 2d 00 00 00       	mov    $0x2d,%edx
+
+  while(--i >= 0)
+ 6d6:	8b 7d b8             	mov    -0x48(%ebp),%edi
+ 6d9:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+ 6dd:	eb 07                	jmp    6e6 <printint+0x76>
+ 6df:	90                   	nop
+ 6e0:	0f b6 13             	movzbl (%ebx),%edx
+ 6e3:	83 eb 01             	sub    $0x1,%ebx
+  write(fd, &c, 1);
+ 6e6:	83 ec 04             	sub    $0x4,%esp
+ 6e9:	88 55 d7             	mov    %dl,-0x29(%ebp)
+ 6ec:	6a 01                	push   $0x1
+ 6ee:	56                   	push   %esi
+ 6ef:	57                   	push   %edi
+ 6f0:	e8 ce fe ff ff       	call   5c3 <write>
+  while(--i >= 0)
+ 6f5:	83 c4 10             	add    $0x10,%esp
+ 6f8:	39 de                	cmp    %ebx,%esi
+ 6fa:	75 e4                	jne    6e0 <printint+0x70>
+    putc(fd, buf[i]);
+}
+ 6fc:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 6ff:	5b                   	pop    %ebx
+ 700:	5e                   	pop    %esi
+ 701:	5f                   	pop    %edi
+ 702:	5d                   	pop    %ebp
+ 703:	c3                   	ret    
+ 704:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  neg = 0;
+ 708:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+ 70f:	eb 87                	jmp    698 <printint+0x28>
+ 711:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 718:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 71f:	90                   	nop
+
+00000720 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 720:	f3 0f 1e fb          	endbr32 
+ 724:	55                   	push   %ebp
+ 725:	89 e5                	mov    %esp,%ebp
+ 727:	57                   	push   %edi
+ 728:	56                   	push   %esi
+ 729:	53                   	push   %ebx
+ 72a:	83 ec 2c             	sub    $0x2c,%esp
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 72d:	8b 75 0c             	mov    0xc(%ebp),%esi
+ 730:	0f b6 1e             	movzbl (%esi),%ebx
+ 733:	84 db                	test   %bl,%bl
+ 735:	0f 84 b4 00 00 00    	je     7ef <printf+0xcf>
+  ap = (uint*)(void*)&fmt + 1;
+ 73b:	8d 45 10             	lea    0x10(%ebp),%eax
+ 73e:	83 c6 01             	add    $0x1,%esi
+  write(fd, &c, 1);
+ 741:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  state = 0;
+ 744:	31 d2                	xor    %edx,%edx
+  ap = (uint*)(void*)&fmt + 1;
+ 746:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 749:	eb 33                	jmp    77e <printf+0x5e>
+ 74b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 74f:	90                   	nop
+ 750:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+ 753:	ba 25 00 00 00       	mov    $0x25,%edx
+      if(c == '%'){
+ 758:	83 f8 25             	cmp    $0x25,%eax
+ 75b:	74 17                	je     774 <printf+0x54>
+  write(fd, &c, 1);
+ 75d:	83 ec 04             	sub    $0x4,%esp
+ 760:	88 5d e7             	mov    %bl,-0x19(%ebp)
+ 763:	6a 01                	push   $0x1
+ 765:	57                   	push   %edi
+ 766:	ff 75 08             	pushl  0x8(%ebp)
+ 769:	e8 55 fe ff ff       	call   5c3 <write>
+ 76e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+      } else {
+        putc(fd, c);
+ 771:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; fmt[i]; i++){
+ 774:	0f b6 1e             	movzbl (%esi),%ebx
+ 777:	83 c6 01             	add    $0x1,%esi
+ 77a:	84 db                	test   %bl,%bl
+ 77c:	74 71                	je     7ef <printf+0xcf>
+    c = fmt[i] & 0xff;
+ 77e:	0f be cb             	movsbl %bl,%ecx
+ 781:	0f b6 c3             	movzbl %bl,%eax
+    if(state == 0){
+ 784:	85 d2                	test   %edx,%edx
+ 786:	74 c8                	je     750 <printf+0x30>
+      }
+    } else if(state == '%'){
+ 788:	83 fa 25             	cmp    $0x25,%edx
+ 78b:	75 e7                	jne    774 <printf+0x54>
+      if(c == 'd'){
+ 78d:	83 f8 64             	cmp    $0x64,%eax
+ 790:	0f 84 9a 00 00 00    	je     830 <printf+0x110>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+ 796:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
+ 79c:	83 f9 70             	cmp    $0x70,%ecx
+ 79f:	74 5f                	je     800 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+ 7a1:	83 f8 73             	cmp    $0x73,%eax
+ 7a4:	0f 84 d6 00 00 00    	je     880 <printf+0x160>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 7aa:	83 f8 63             	cmp    $0x63,%eax
+ 7ad:	0f 84 8d 00 00 00    	je     840 <printf+0x120>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+ 7b3:	83 f8 25             	cmp    $0x25,%eax
+ 7b6:	0f 84 b4 00 00 00    	je     870 <printf+0x150>
+  write(fd, &c, 1);
+ 7bc:	83 ec 04             	sub    $0x4,%esp
+ 7bf:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
+ 7c3:	6a 01                	push   $0x1
+ 7c5:	57                   	push   %edi
+ 7c6:	ff 75 08             	pushl  0x8(%ebp)
+ 7c9:	e8 f5 fd ff ff       	call   5c3 <write>
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+ 7ce:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 7d1:	83 c4 0c             	add    $0xc,%esp
+ 7d4:	6a 01                	push   $0x1
+ 7d6:	83 c6 01             	add    $0x1,%esi
+ 7d9:	57                   	push   %edi
+ 7da:	ff 75 08             	pushl  0x8(%ebp)
+ 7dd:	e8 e1 fd ff ff       	call   5c3 <write>
+  for(i = 0; fmt[i]; i++){
+ 7e2:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
+        putc(fd, c);
+ 7e6:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 7e9:	31 d2                	xor    %edx,%edx
+  for(i = 0; fmt[i]; i++){
+ 7eb:	84 db                	test   %bl,%bl
+ 7ed:	75 8f                	jne    77e <printf+0x5e>
+    }
+  }
+}
+ 7ef:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 7f2:	5b                   	pop    %ebx
+ 7f3:	5e                   	pop    %esi
+ 7f4:	5f                   	pop    %edi
+ 7f5:	5d                   	pop    %ebp
+ 7f6:	c3                   	ret    
+ 7f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 7fe:	66 90                	xchg   %ax,%ax
+        printint(fd, *ap, 16, 0);
+ 800:	83 ec 0c             	sub    $0xc,%esp
+ 803:	b9 10 00 00 00       	mov    $0x10,%ecx
+ 808:	6a 00                	push   $0x0
+ 80a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+ 80d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 810:	8b 13                	mov    (%ebx),%edx
+ 812:	e8 59 fe ff ff       	call   670 <printint>
+        ap++;
+ 817:	89 d8                	mov    %ebx,%eax
+ 819:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 81c:	31 d2                	xor    %edx,%edx
+        ap++;
+ 81e:	83 c0 04             	add    $0x4,%eax
+ 821:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 824:	e9 4b ff ff ff       	jmp    774 <printf+0x54>
+ 829:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        printint(fd, *ap, 10, 1);
+ 830:	83 ec 0c             	sub    $0xc,%esp
+ 833:	b9 0a 00 00 00       	mov    $0xa,%ecx
+ 838:	6a 01                	push   $0x1
+ 83a:	eb ce                	jmp    80a <printf+0xea>
+ 83c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        putc(fd, *ap);
+ 840:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+  write(fd, &c, 1);
+ 843:	83 ec 04             	sub    $0x4,%esp
+        putc(fd, *ap);
+ 846:	8b 03                	mov    (%ebx),%eax
+  write(fd, &c, 1);
+ 848:	6a 01                	push   $0x1
+        ap++;
+ 84a:	83 c3 04             	add    $0x4,%ebx
+  write(fd, &c, 1);
+ 84d:	57                   	push   %edi
+ 84e:	ff 75 08             	pushl  0x8(%ebp)
+        putc(fd, *ap);
+ 851:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 854:	e8 6a fd ff ff       	call   5c3 <write>
+        ap++;
+ 859:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+ 85c:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 85f:	31 d2                	xor    %edx,%edx
+ 861:	e9 0e ff ff ff       	jmp    774 <printf+0x54>
+ 866:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 86d:	8d 76 00             	lea    0x0(%esi),%esi
+        putc(fd, c);
+ 870:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 873:	83 ec 04             	sub    $0x4,%esp
+ 876:	e9 59 ff ff ff       	jmp    7d4 <printf+0xb4>
+ 87b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 87f:	90                   	nop
+        s = (char*)*ap;
+ 880:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 883:	8b 18                	mov    (%eax),%ebx
+        ap++;
+ 885:	83 c0 04             	add    $0x4,%eax
+ 888:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        if(s == 0)
+ 88b:	85 db                	test   %ebx,%ebx
+ 88d:	74 17                	je     8a6 <printf+0x186>
+        while(*s != 0){
+ 88f:	0f b6 03             	movzbl (%ebx),%eax
+      state = 0;
+ 892:	31 d2                	xor    %edx,%edx
+        while(*s != 0){
+ 894:	84 c0                	test   %al,%al
+ 896:	0f 84 d8 fe ff ff    	je     774 <printf+0x54>
+ 89c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 89f:	89 de                	mov    %ebx,%esi
+ 8a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 8a4:	eb 1a                	jmp    8c0 <printf+0x1a0>
+          s = "(null)";
+ 8a6:	bb d2 0a 00 00       	mov    $0xad2,%ebx
+        while(*s != 0){
+ 8ab:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 8ae:	b8 28 00 00 00       	mov    $0x28,%eax
+ 8b3:	89 de                	mov    %ebx,%esi
+ 8b5:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 8b8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 8bf:	90                   	nop
+  write(fd, &c, 1);
+ 8c0:	83 ec 04             	sub    $0x4,%esp
+          s++;
+ 8c3:	83 c6 01             	add    $0x1,%esi
+ 8c6:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 8c9:	6a 01                	push   $0x1
+ 8cb:	57                   	push   %edi
+ 8cc:	53                   	push   %ebx
+ 8cd:	e8 f1 fc ff ff       	call   5c3 <write>
+        while(*s != 0){
+ 8d2:	0f b6 06             	movzbl (%esi),%eax
+ 8d5:	83 c4 10             	add    $0x10,%esp
+ 8d8:	84 c0                	test   %al,%al
+ 8da:	75 e4                	jne    8c0 <printf+0x1a0>
+ 8dc:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+      state = 0;
+ 8df:	31 d2                	xor    %edx,%edx
+ 8e1:	e9 8e fe ff ff       	jmp    774 <printf+0x54>
+ 8e6:	66 90                	xchg   %ax,%ax
+ 8e8:	66 90                	xchg   %ax,%ax
+ 8ea:	66 90                	xchg   %ax,%ax
+ 8ec:	66 90                	xchg   %ax,%ax
+ 8ee:	66 90                	xchg   %ax,%ax
+
+000008f0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 8f0:	f3 0f 1e fb          	endbr32 
+ 8f4:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 8f5:	a1 14 0e 00 00       	mov    0xe14,%eax
+{
+ 8fa:	89 e5                	mov    %esp,%ebp
+ 8fc:	57                   	push   %edi
+ 8fd:	56                   	push   %esi
+ 8fe:	53                   	push   %ebx
+ 8ff:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 902:	8b 10                	mov    (%eax),%edx
+  bp = (Header*)ap - 1;
+ 904:	8d 4b f8             	lea    -0x8(%ebx),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 907:	39 c8                	cmp    %ecx,%eax
+ 909:	73 15                	jae    920 <free+0x30>
+ 90b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 90f:	90                   	nop
+ 910:	39 d1                	cmp    %edx,%ecx
+ 912:	72 14                	jb     928 <free+0x38>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 914:	39 d0                	cmp    %edx,%eax
+ 916:	73 10                	jae    928 <free+0x38>
+{
+ 918:	89 d0                	mov    %edx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 91a:	8b 10                	mov    (%eax),%edx
+ 91c:	39 c8                	cmp    %ecx,%eax
+ 91e:	72 f0                	jb     910 <free+0x20>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 920:	39 d0                	cmp    %edx,%eax
+ 922:	72 f4                	jb     918 <free+0x28>
+ 924:	39 d1                	cmp    %edx,%ecx
+ 926:	73 f0                	jae    918 <free+0x28>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 928:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ 92b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
+ 92e:	39 fa                	cmp    %edi,%edx
+ 930:	74 1e                	je     950 <free+0x60>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+ 932:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 935:	8b 50 04             	mov    0x4(%eax),%edx
+ 938:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 93b:	39 f1                	cmp    %esi,%ecx
+ 93d:	74 28                	je     967 <free+0x77>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+ 93f:	89 08                	mov    %ecx,(%eax)
+  freep = p;
+}
+ 941:	5b                   	pop    %ebx
+  freep = p;
+ 942:	a3 14 0e 00 00       	mov    %eax,0xe14
+}
+ 947:	5e                   	pop    %esi
+ 948:	5f                   	pop    %edi
+ 949:	5d                   	pop    %ebp
+ 94a:	c3                   	ret    
+ 94b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 94f:	90                   	nop
+    bp->s.size += p->s.ptr->s.size;
+ 950:	03 72 04             	add    0x4(%edx),%esi
+ 953:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 956:	8b 10                	mov    (%eax),%edx
+ 958:	8b 12                	mov    (%edx),%edx
+ 95a:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 95d:	8b 50 04             	mov    0x4(%eax),%edx
+ 960:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 963:	39 f1                	cmp    %esi,%ecx
+ 965:	75 d8                	jne    93f <free+0x4f>
+    p->s.size += bp->s.size;
+ 967:	03 53 fc             	add    -0x4(%ebx),%edx
+  freep = p;
+ 96a:	a3 14 0e 00 00       	mov    %eax,0xe14
+    p->s.size += bp->s.size;
+ 96f:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 972:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ 975:	89 10                	mov    %edx,(%eax)
+}
+ 977:	5b                   	pop    %ebx
+ 978:	5e                   	pop    %esi
+ 979:	5f                   	pop    %edi
+ 97a:	5d                   	pop    %ebp
+ 97b:	c3                   	ret    
+ 97c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000980 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 980:	f3 0f 1e fb          	endbr32 
+ 984:	55                   	push   %ebp
+ 985:	89 e5                	mov    %esp,%ebp
+ 987:	57                   	push   %edi
+ 988:	56                   	push   %esi
+ 989:	53                   	push   %ebx
+ 98a:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 98d:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+ 990:	8b 3d 14 0e 00 00    	mov    0xe14,%edi
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 996:	8d 70 07             	lea    0x7(%eax),%esi
+ 999:	c1 ee 03             	shr    $0x3,%esi
+ 99c:	83 c6 01             	add    $0x1,%esi
+  if((prevp = freep) == 0){
+ 99f:	85 ff                	test   %edi,%edi
+ 9a1:	0f 84 a9 00 00 00    	je     a50 <malloc+0xd0>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 9a7:	8b 07                	mov    (%edi),%eax
+    if(p->s.size >= nunits){
+ 9a9:	8b 48 04             	mov    0x4(%eax),%ecx
+ 9ac:	39 f1                	cmp    %esi,%ecx
+ 9ae:	73 6d                	jae    a1d <malloc+0x9d>
+ 9b0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+ 9b6:	bb 00 10 00 00       	mov    $0x1000,%ebx
+ 9bb:	0f 43 de             	cmovae %esi,%ebx
+  p = sbrk(nu * sizeof(Header));
+ 9be:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
+ 9c5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+ 9c8:	eb 17                	jmp    9e1 <malloc+0x61>
+ 9ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 9d0:	8b 10                	mov    (%eax),%edx
+    if(p->s.size >= nunits){
+ 9d2:	8b 4a 04             	mov    0x4(%edx),%ecx
+ 9d5:	39 f1                	cmp    %esi,%ecx
+ 9d7:	73 4f                	jae    a28 <malloc+0xa8>
+ 9d9:	8b 3d 14 0e 00 00    	mov    0xe14,%edi
+ 9df:	89 d0                	mov    %edx,%eax
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 9e1:	39 c7                	cmp    %eax,%edi
+ 9e3:	75 eb                	jne    9d0 <malloc+0x50>
+  p = sbrk(nu * sizeof(Header));
+ 9e5:	83 ec 0c             	sub    $0xc,%esp
+ 9e8:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 9eb:	e8 3b fc ff ff       	call   62b <sbrk>
+  if(p == (char*)-1)
+ 9f0:	83 c4 10             	add    $0x10,%esp
+ 9f3:	83 f8 ff             	cmp    $0xffffffff,%eax
+ 9f6:	74 1b                	je     a13 <malloc+0x93>
+  hp->s.size = nu;
+ 9f8:	89 58 04             	mov    %ebx,0x4(%eax)
+  free((void*)(hp + 1));
+ 9fb:	83 ec 0c             	sub    $0xc,%esp
+ 9fe:	83 c0 08             	add    $0x8,%eax
+ a01:	50                   	push   %eax
+ a02:	e8 e9 fe ff ff       	call   8f0 <free>
+  return freep;
+ a07:	a1 14 0e 00 00       	mov    0xe14,%eax
+      if((p = morecore(nunits)) == 0)
+ a0c:	83 c4 10             	add    $0x10,%esp
+ a0f:	85 c0                	test   %eax,%eax
+ a11:	75 bd                	jne    9d0 <malloc+0x50>
+        return 0;
+  }
+}
+ a13:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return 0;
+ a16:	31 c0                	xor    %eax,%eax
+}
+ a18:	5b                   	pop    %ebx
+ a19:	5e                   	pop    %esi
+ a1a:	5f                   	pop    %edi
+ a1b:	5d                   	pop    %ebp
+ a1c:	c3                   	ret    
+    if(p->s.size >= nunits){
+ a1d:	89 c2                	mov    %eax,%edx
+ a1f:	89 f8                	mov    %edi,%eax
+ a21:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+ a28:	39 ce                	cmp    %ecx,%esi
+ a2a:	74 54                	je     a80 <malloc+0x100>
+        p->s.size -= nunits;
+ a2c:	29 f1                	sub    %esi,%ecx
+ a2e:	89 4a 04             	mov    %ecx,0x4(%edx)
+        p += p->s.size;
+ a31:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
+        p->s.size = nunits;
+ a34:	89 72 04             	mov    %esi,0x4(%edx)
+      freep = prevp;
+ a37:	a3 14 0e 00 00       	mov    %eax,0xe14
+}
+ a3c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return (void*)(p + 1);
+ a3f:	8d 42 08             	lea    0x8(%edx),%eax
+}
+ a42:	5b                   	pop    %ebx
+ a43:	5e                   	pop    %esi
+ a44:	5f                   	pop    %edi
+ a45:	5d                   	pop    %ebp
+ a46:	c3                   	ret    
+ a47:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ a4e:	66 90                	xchg   %ax,%ax
+    base.s.ptr = freep = prevp = &base;
+ a50:	c7 05 14 0e 00 00 18 	movl   $0xe18,0xe14
+ a57:	0e 00 00 
+    base.s.size = 0;
+ a5a:	bf 18 0e 00 00       	mov    $0xe18,%edi
+    base.s.ptr = freep = prevp = &base;
+ a5f:	c7 05 18 0e 00 00 18 	movl   $0xe18,0xe18
+ a66:	0e 00 00 
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ a69:	89 f8                	mov    %edi,%eax
+    base.s.size = 0;
+ a6b:	c7 05 1c 0e 00 00 00 	movl   $0x0,0xe1c
+ a72:	00 00 00 
+    if(p->s.size >= nunits){
+ a75:	e9 36 ff ff ff       	jmp    9b0 <malloc+0x30>
+ a7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        prevp->s.ptr = p->s.ptr;
+ a80:	8b 0a                	mov    (%edx),%ecx
+ a82:	89 08                	mov    %ecx,(%eax)
+ a84:	eb b1                	jmp    a37 <malloc+0xb7>
diff -ruN xv6-public/ls.d copy-xv6/ls.d
--- xv6-public/ls.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/ls.d	2022-09-05 23:26:12.036781090 +0530
@@ -0,0 +1 @@
+ls.o: ls.c /usr/include/stdc-predef.h types.h stat.h user.h fs.h
Binary files xv6-public/ls.o and copy-xv6/ls.o differ
diff -ruN xv6-public/ls.sym copy-xv6/ls.sym
--- xv6-public/ls.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/ls.sym	2022-09-05 23:26:12.048781090 +0530
@@ -0,0 +1,64 @@
+00000000 .text
+00000a88 .rodata
+00000af0 .eh_frame
+00000e04 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 ls.c
+00000e04 buf.1108
+00000000 ulib.c
+00000000 printf.c
+00000670 printint
+00000adc digits.1097
+00000000 umalloc.c
+00000e14 freep
+00000e18 base
+00000340 strcpy
+00000060 fmtname
+00000720 printf
+0000065b thread_exit
+00000570 memmove
+000005eb mknod
+00000460 gets
+00000623 getpid
+00000980 malloc
+00000633 sleep
+000005b3 pipe
+000005c3 write
+000005fb fstat
+000005d3 kill
+00000613 chdir
+000005db exec
+000005ab wait
+000005bb read
+000005f3 unlink
+0000059b fork
+0000062b sbrk
+0000063b uptime
+00000e04 __bss_start
+00000400 memset
+00000000 main
+00000370 strcmp
+0000061b dup
+000004e0 stat
+00000e04 _edata
+00000e20 _end
+00000603 link
+00000100 ls
+000005a3 exit
+00000530 atoi
+00000643 draw
+000003c0 strlen
+000005e3 open
+00000420 strchr
+0000064b thread_create
+0000060b mkdir
+000005cb close
+00000653 thread_join
+000008f0 free
diff -ruN xv6-public/main.d copy-xv6/main.d
--- xv6-public/main.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/main.d	2022-09-05 23:26:13.224781065 +0530
@@ -0,0 +1,2 @@
+main.o: main.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h proc.h x86.h
Binary files xv6-public/main.o and copy-xv6/main.o differ
diff -ruN xv6-public/Makefile copy-xv6/Makefile
--- xv6-public/Makefile	2022-09-05 23:23:48.532715193 +0530
+++ copy-xv6/Makefile	2022-09-05 22:16:52.450992409 +0530
@@ -103,7 +103,7 @@
 bootblock: bootasm.S bootmain.c
 	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
 	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
-	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7c00 -o bootblock.o bootasm.o bootmain.o
 	$(OBJDUMP) -S bootblock.o > bootblock.asm
 	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
 	./sign.pl bootblock
@@ -181,6 +181,9 @@
 	_usertests\
 	_wc\
 	_zombie\
+	_drawtest\
+	_thread\
+	_old_thread
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -249,7 +252,7 @@
 
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c drawtest.c thread.c old_thread.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
Binary files xv6-public/_mkdir and copy-xv6/_mkdir differ
diff -ruN xv6-public/mkdir.asm copy-xv6/mkdir.asm
--- xv6-public/mkdir.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/mkdir.asm	2022-09-05 23:26:12.072781089 +0530
@@ -0,0 +1,1238 @@
+
+_mkdir:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	57                   	push   %edi
+  12:	bf 01 00 00 00       	mov    $0x1,%edi
+  17:	56                   	push   %esi
+  18:	53                   	push   %ebx
+  19:	51                   	push   %ecx
+  1a:	83 ec 08             	sub    $0x8,%esp
+  1d:	8b 59 04             	mov    0x4(%ecx),%ebx
+  20:	8b 31                	mov    (%ecx),%esi
+  22:	83 c3 04             	add    $0x4,%ebx
+  int i;
+
+  if(argc < 2){
+  25:	83 fe 01             	cmp    $0x1,%esi
+  28:	7e 3a                	jle    64 <main+0x64>
+  2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    printf(2, "Usage: mkdir files...\n");
+    exit();
+  }
+
+  for(i = 1; i < argc; i++){
+    if(mkdir(argv[i]) < 0){
+  30:	83 ec 0c             	sub    $0xc,%esp
+  33:	ff 33                	pushl  (%ebx)
+  35:	e8 11 03 00 00       	call   34b <mkdir>
+  3a:	83 c4 10             	add    $0x10,%esp
+  3d:	85 c0                	test   %eax,%eax
+  3f:	78 0f                	js     50 <main+0x50>
+  for(i = 1; i < argc; i++){
+  41:	83 c7 01             	add    $0x1,%edi
+  44:	83 c3 04             	add    $0x4,%ebx
+  47:	39 fe                	cmp    %edi,%esi
+  49:	75 e5                	jne    30 <main+0x30>
+      printf(2, "mkdir: %s failed to create\n", argv[i]);
+      break;
+    }
+  }
+
+  exit();
+  4b:	e8 93 02 00 00       	call   2e3 <exit>
+      printf(2, "mkdir: %s failed to create\n", argv[i]);
+  50:	50                   	push   %eax
+  51:	ff 33                	pushl  (%ebx)
+  53:	68 df 07 00 00       	push   $0x7df
+  58:	6a 02                	push   $0x2
+  5a:	e8 01 04 00 00       	call   460 <printf>
+      break;
+  5f:	83 c4 10             	add    $0x10,%esp
+  62:	eb e7                	jmp    4b <main+0x4b>
+    printf(2, "Usage: mkdir files...\n");
+  64:	52                   	push   %edx
+  65:	52                   	push   %edx
+  66:	68 c8 07 00 00       	push   $0x7c8
+  6b:	6a 02                	push   $0x2
+  6d:	e8 ee 03 00 00       	call   460 <printf>
+    exit();
+  72:	e8 6c 02 00 00       	call   2e3 <exit>
+  77:	66 90                	xchg   %ax,%ax
+  79:	66 90                	xchg   %ax,%ax
+  7b:	66 90                	xchg   %ax,%ax
+  7d:	66 90                	xchg   %ax,%ax
+  7f:	90                   	nop
+
+00000080 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+  80:	f3 0f 1e fb          	endbr32 
+  84:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  85:	31 c0                	xor    %eax,%eax
+{
+  87:	89 e5                	mov    %esp,%ebp
+  89:	53                   	push   %ebx
+  8a:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  8d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+  90:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+  94:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+  97:	83 c0 01             	add    $0x1,%eax
+  9a:	84 d2                	test   %dl,%dl
+  9c:	75 f2                	jne    90 <strcpy+0x10>
+    ;
+  return os;
+}
+  9e:	89 c8                	mov    %ecx,%eax
+  a0:	5b                   	pop    %ebx
+  a1:	5d                   	pop    %ebp
+  a2:	c3                   	ret    
+  a3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000000b0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  b0:	f3 0f 1e fb          	endbr32 
+  b4:	55                   	push   %ebp
+  b5:	89 e5                	mov    %esp,%ebp
+  b7:	53                   	push   %ebx
+  b8:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  bb:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+  be:	0f b6 01             	movzbl (%ecx),%eax
+  c1:	0f b6 1a             	movzbl (%edx),%ebx
+  c4:	84 c0                	test   %al,%al
+  c6:	75 19                	jne    e1 <strcmp+0x31>
+  c8:	eb 26                	jmp    f0 <strcmp+0x40>
+  ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  d0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+  d4:	83 c1 01             	add    $0x1,%ecx
+  d7:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+  da:	0f b6 1a             	movzbl (%edx),%ebx
+  dd:	84 c0                	test   %al,%al
+  df:	74 0f                	je     f0 <strcmp+0x40>
+  e1:	38 d8                	cmp    %bl,%al
+  e3:	74 eb                	je     d0 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+  e5:	29 d8                	sub    %ebx,%eax
+}
+  e7:	5b                   	pop    %ebx
+  e8:	5d                   	pop    %ebp
+  e9:	c3                   	ret    
+  ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  f0:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+  f2:	29 d8                	sub    %ebx,%eax
+}
+  f4:	5b                   	pop    %ebx
+  f5:	5d                   	pop    %ebp
+  f6:	c3                   	ret    
+  f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  fe:	66 90                	xchg   %ax,%ax
+
+00000100 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 100:	f3 0f 1e fb          	endbr32 
+ 104:	55                   	push   %ebp
+ 105:	89 e5                	mov    %esp,%ebp
+ 107:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 10a:	80 3a 00             	cmpb   $0x0,(%edx)
+ 10d:	74 21                	je     130 <strlen+0x30>
+ 10f:	31 c0                	xor    %eax,%eax
+ 111:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 118:	83 c0 01             	add    $0x1,%eax
+ 11b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+ 11f:	89 c1                	mov    %eax,%ecx
+ 121:	75 f5                	jne    118 <strlen+0x18>
+    ;
+  return n;
+}
+ 123:	89 c8                	mov    %ecx,%eax
+ 125:	5d                   	pop    %ebp
+ 126:	c3                   	ret    
+ 127:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 12e:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+ 130:	31 c9                	xor    %ecx,%ecx
+}
+ 132:	5d                   	pop    %ebp
+ 133:	89 c8                	mov    %ecx,%eax
+ 135:	c3                   	ret    
+ 136:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 13d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000140 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 140:	f3 0f 1e fb          	endbr32 
+ 144:	55                   	push   %ebp
+ 145:	89 e5                	mov    %esp,%ebp
+ 147:	57                   	push   %edi
+ 148:	8b 55 08             	mov    0x8(%ebp),%edx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+ 14b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 14e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 151:	89 d7                	mov    %edx,%edi
+ 153:	fc                   	cld    
+ 154:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+ 156:	89 d0                	mov    %edx,%eax
+ 158:	5f                   	pop    %edi
+ 159:	5d                   	pop    %ebp
+ 15a:	c3                   	ret    
+ 15b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 15f:	90                   	nop
+
+00000160 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 160:	f3 0f 1e fb          	endbr32 
+ 164:	55                   	push   %ebp
+ 165:	89 e5                	mov    %esp,%ebp
+ 167:	8b 45 08             	mov    0x8(%ebp),%eax
+ 16a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+ 16e:	0f b6 10             	movzbl (%eax),%edx
+ 171:	84 d2                	test   %dl,%dl
+ 173:	75 16                	jne    18b <strchr+0x2b>
+ 175:	eb 21                	jmp    198 <strchr+0x38>
+ 177:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 17e:	66 90                	xchg   %ax,%ax
+ 180:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+ 184:	83 c0 01             	add    $0x1,%eax
+ 187:	84 d2                	test   %dl,%dl
+ 189:	74 0d                	je     198 <strchr+0x38>
+    if(*s == c)
+ 18b:	38 d1                	cmp    %dl,%cl
+ 18d:	75 f1                	jne    180 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+ 18f:	5d                   	pop    %ebp
+ 190:	c3                   	ret    
+ 191:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+ 198:	31 c0                	xor    %eax,%eax
+}
+ 19a:	5d                   	pop    %ebp
+ 19b:	c3                   	ret    
+ 19c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000001a0 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 1a0:	f3 0f 1e fb          	endbr32 
+ 1a4:	55                   	push   %ebp
+ 1a5:	89 e5                	mov    %esp,%ebp
+ 1a7:	57                   	push   %edi
+ 1a8:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1a9:	31 f6                	xor    %esi,%esi
+{
+ 1ab:	53                   	push   %ebx
+ 1ac:	89 f3                	mov    %esi,%ebx
+ 1ae:	83 ec 1c             	sub    $0x1c,%esp
+ 1b1:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+ 1b4:	eb 33                	jmp    1e9 <gets+0x49>
+ 1b6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1bd:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+ 1c0:	83 ec 04             	sub    $0x4,%esp
+ 1c3:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ 1c6:	6a 01                	push   $0x1
+ 1c8:	50                   	push   %eax
+ 1c9:	6a 00                	push   $0x0
+ 1cb:	e8 2b 01 00 00       	call   2fb <read>
+    if(cc < 1)
+ 1d0:	83 c4 10             	add    $0x10,%esp
+ 1d3:	85 c0                	test   %eax,%eax
+ 1d5:	7e 1c                	jle    1f3 <gets+0x53>
+      break;
+    buf[i++] = c;
+ 1d7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ 1db:	83 c7 01             	add    $0x1,%edi
+ 1de:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+ 1e1:	3c 0a                	cmp    $0xa,%al
+ 1e3:	74 23                	je     208 <gets+0x68>
+ 1e5:	3c 0d                	cmp    $0xd,%al
+ 1e7:	74 1f                	je     208 <gets+0x68>
+  for(i=0; i+1 < max; ){
+ 1e9:	83 c3 01             	add    $0x1,%ebx
+ 1ec:	89 fe                	mov    %edi,%esi
+ 1ee:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+ 1f1:	7c cd                	jl     1c0 <gets+0x20>
+ 1f3:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+ 1f5:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+ 1f8:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 1fb:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 1fe:	5b                   	pop    %ebx
+ 1ff:	5e                   	pop    %esi
+ 200:	5f                   	pop    %edi
+ 201:	5d                   	pop    %ebp
+ 202:	c3                   	ret    
+ 203:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 207:	90                   	nop
+ 208:	8b 75 08             	mov    0x8(%ebp),%esi
+ 20b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 20e:	01 de                	add    %ebx,%esi
+ 210:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+ 212:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 215:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 218:	5b                   	pop    %ebx
+ 219:	5e                   	pop    %esi
+ 21a:	5f                   	pop    %edi
+ 21b:	5d                   	pop    %ebp
+ 21c:	c3                   	ret    
+ 21d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000220 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 220:	f3 0f 1e fb          	endbr32 
+ 224:	55                   	push   %ebp
+ 225:	89 e5                	mov    %esp,%ebp
+ 227:	56                   	push   %esi
+ 228:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 229:	83 ec 08             	sub    $0x8,%esp
+ 22c:	6a 00                	push   $0x0
+ 22e:	ff 75 08             	pushl  0x8(%ebp)
+ 231:	e8 ed 00 00 00       	call   323 <open>
+  if(fd < 0)
+ 236:	83 c4 10             	add    $0x10,%esp
+ 239:	85 c0                	test   %eax,%eax
+ 23b:	78 2b                	js     268 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+ 23d:	83 ec 08             	sub    $0x8,%esp
+ 240:	ff 75 0c             	pushl  0xc(%ebp)
+ 243:	89 c3                	mov    %eax,%ebx
+ 245:	50                   	push   %eax
+ 246:	e8 f0 00 00 00       	call   33b <fstat>
+  close(fd);
+ 24b:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+ 24e:	89 c6                	mov    %eax,%esi
+  close(fd);
+ 250:	e8 b6 00 00 00       	call   30b <close>
+  return r;
+ 255:	83 c4 10             	add    $0x10,%esp
+}
+ 258:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 25b:	89 f0                	mov    %esi,%eax
+ 25d:	5b                   	pop    %ebx
+ 25e:	5e                   	pop    %esi
+ 25f:	5d                   	pop    %ebp
+ 260:	c3                   	ret    
+ 261:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+ 268:	be ff ff ff ff       	mov    $0xffffffff,%esi
+ 26d:	eb e9                	jmp    258 <stat+0x38>
+ 26f:	90                   	nop
+
+00000270 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 270:	f3 0f 1e fb          	endbr32 
+ 274:	55                   	push   %ebp
+ 275:	89 e5                	mov    %esp,%ebp
+ 277:	53                   	push   %ebx
+ 278:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 27b:	0f be 02             	movsbl (%edx),%eax
+ 27e:	8d 48 d0             	lea    -0x30(%eax),%ecx
+ 281:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+ 284:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+ 289:	77 1a                	ja     2a5 <atoi+0x35>
+ 28b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 28f:	90                   	nop
+    n = n*10 + *s++ - '0';
+ 290:	83 c2 01             	add    $0x1,%edx
+ 293:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+ 296:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+ 29a:	0f be 02             	movsbl (%edx),%eax
+ 29d:	8d 58 d0             	lea    -0x30(%eax),%ebx
+ 2a0:	80 fb 09             	cmp    $0x9,%bl
+ 2a3:	76 eb                	jbe    290 <atoi+0x20>
+  return n;
+}
+ 2a5:	89 c8                	mov    %ecx,%eax
+ 2a7:	5b                   	pop    %ebx
+ 2a8:	5d                   	pop    %ebp
+ 2a9:	c3                   	ret    
+ 2aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000002b0 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 2b0:	f3 0f 1e fb          	endbr32 
+ 2b4:	55                   	push   %ebp
+ 2b5:	89 e5                	mov    %esp,%ebp
+ 2b7:	57                   	push   %edi
+ 2b8:	8b 45 10             	mov    0x10(%ebp),%eax
+ 2bb:	8b 55 08             	mov    0x8(%ebp),%edx
+ 2be:	56                   	push   %esi
+ 2bf:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 2c2:	85 c0                	test   %eax,%eax
+ 2c4:	7e 0f                	jle    2d5 <memmove+0x25>
+ 2c6:	01 d0                	add    %edx,%eax
+  dst = vdst;
+ 2c8:	89 d7                	mov    %edx,%edi
+ 2ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+ 2d0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+ 2d1:	39 f8                	cmp    %edi,%eax
+ 2d3:	75 fb                	jne    2d0 <memmove+0x20>
+  return vdst;
+}
+ 2d5:	5e                   	pop    %esi
+ 2d6:	89 d0                	mov    %edx,%eax
+ 2d8:	5f                   	pop    %edi
+ 2d9:	5d                   	pop    %ebp
+ 2da:	c3                   	ret    
+
+000002db <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 2db:	b8 01 00 00 00       	mov    $0x1,%eax
+ 2e0:	cd 40                	int    $0x40
+ 2e2:	c3                   	ret    
+
+000002e3 <exit>:
+SYSCALL(exit)
+ 2e3:	b8 02 00 00 00       	mov    $0x2,%eax
+ 2e8:	cd 40                	int    $0x40
+ 2ea:	c3                   	ret    
+
+000002eb <wait>:
+SYSCALL(wait)
+ 2eb:	b8 03 00 00 00       	mov    $0x3,%eax
+ 2f0:	cd 40                	int    $0x40
+ 2f2:	c3                   	ret    
+
+000002f3 <pipe>:
+SYSCALL(pipe)
+ 2f3:	b8 04 00 00 00       	mov    $0x4,%eax
+ 2f8:	cd 40                	int    $0x40
+ 2fa:	c3                   	ret    
+
+000002fb <read>:
+SYSCALL(read)
+ 2fb:	b8 05 00 00 00       	mov    $0x5,%eax
+ 300:	cd 40                	int    $0x40
+ 302:	c3                   	ret    
+
+00000303 <write>:
+SYSCALL(write)
+ 303:	b8 10 00 00 00       	mov    $0x10,%eax
+ 308:	cd 40                	int    $0x40
+ 30a:	c3                   	ret    
+
+0000030b <close>:
+SYSCALL(close)
+ 30b:	b8 15 00 00 00       	mov    $0x15,%eax
+ 310:	cd 40                	int    $0x40
+ 312:	c3                   	ret    
+
+00000313 <kill>:
+SYSCALL(kill)
+ 313:	b8 06 00 00 00       	mov    $0x6,%eax
+ 318:	cd 40                	int    $0x40
+ 31a:	c3                   	ret    
+
+0000031b <exec>:
+SYSCALL(exec)
+ 31b:	b8 07 00 00 00       	mov    $0x7,%eax
+ 320:	cd 40                	int    $0x40
+ 322:	c3                   	ret    
+
+00000323 <open>:
+SYSCALL(open)
+ 323:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 328:	cd 40                	int    $0x40
+ 32a:	c3                   	ret    
+
+0000032b <mknod>:
+SYSCALL(mknod)
+ 32b:	b8 11 00 00 00       	mov    $0x11,%eax
+ 330:	cd 40                	int    $0x40
+ 332:	c3                   	ret    
+
+00000333 <unlink>:
+SYSCALL(unlink)
+ 333:	b8 12 00 00 00       	mov    $0x12,%eax
+ 338:	cd 40                	int    $0x40
+ 33a:	c3                   	ret    
+
+0000033b <fstat>:
+SYSCALL(fstat)
+ 33b:	b8 08 00 00 00       	mov    $0x8,%eax
+ 340:	cd 40                	int    $0x40
+ 342:	c3                   	ret    
+
+00000343 <link>:
+SYSCALL(link)
+ 343:	b8 13 00 00 00       	mov    $0x13,%eax
+ 348:	cd 40                	int    $0x40
+ 34a:	c3                   	ret    
+
+0000034b <mkdir>:
+SYSCALL(mkdir)
+ 34b:	b8 14 00 00 00       	mov    $0x14,%eax
+ 350:	cd 40                	int    $0x40
+ 352:	c3                   	ret    
+
+00000353 <chdir>:
+SYSCALL(chdir)
+ 353:	b8 09 00 00 00       	mov    $0x9,%eax
+ 358:	cd 40                	int    $0x40
+ 35a:	c3                   	ret    
+
+0000035b <dup>:
+SYSCALL(dup)
+ 35b:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 360:	cd 40                	int    $0x40
+ 362:	c3                   	ret    
+
+00000363 <getpid>:
+SYSCALL(getpid)
+ 363:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 368:	cd 40                	int    $0x40
+ 36a:	c3                   	ret    
+
+0000036b <sbrk>:
+SYSCALL(sbrk)
+ 36b:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 370:	cd 40                	int    $0x40
+ 372:	c3                   	ret    
+
+00000373 <sleep>:
+SYSCALL(sleep)
+ 373:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 378:	cd 40                	int    $0x40
+ 37a:	c3                   	ret    
+
+0000037b <uptime>:
+SYSCALL(uptime)
+ 37b:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 380:	cd 40                	int    $0x40
+ 382:	c3                   	ret    
+
+00000383 <draw>:
+SYSCALL(draw)
+ 383:	b8 16 00 00 00       	mov    $0x16,%eax
+ 388:	cd 40                	int    $0x40
+ 38a:	c3                   	ret    
+
+0000038b <thread_create>:
+
+SYSCALL(thread_create)
+ 38b:	b8 17 00 00 00       	mov    $0x17,%eax
+ 390:	cd 40                	int    $0x40
+ 392:	c3                   	ret    
+
+00000393 <thread_join>:
+SYSCALL(thread_join)
+ 393:	b8 18 00 00 00       	mov    $0x18,%eax
+ 398:	cd 40                	int    $0x40
+ 39a:	c3                   	ret    
+
+0000039b <thread_exit>:
+SYSCALL(thread_exit)
+ 39b:	b8 19 00 00 00       	mov    $0x19,%eax
+ 3a0:	cd 40                	int    $0x40
+ 3a2:	c3                   	ret    
+ 3a3:	66 90                	xchg   %ax,%ax
+ 3a5:	66 90                	xchg   %ax,%ax
+ 3a7:	66 90                	xchg   %ax,%ax
+ 3a9:	66 90                	xchg   %ax,%ax
+ 3ab:	66 90                	xchg   %ax,%ax
+ 3ad:	66 90                	xchg   %ax,%ax
+ 3af:	90                   	nop
+
+000003b0 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 3b0:	55                   	push   %ebp
+ 3b1:	89 e5                	mov    %esp,%ebp
+ 3b3:	57                   	push   %edi
+ 3b4:	56                   	push   %esi
+ 3b5:	53                   	push   %ebx
+ 3b6:	83 ec 3c             	sub    $0x3c,%esp
+ 3b9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+ 3bc:	89 d1                	mov    %edx,%ecx
+{
+ 3be:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  if(sgn && xx < 0){
+ 3c1:	85 d2                	test   %edx,%edx
+ 3c3:	0f 89 7f 00 00 00    	jns    448 <printint+0x98>
+ 3c9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
+ 3cd:	74 79                	je     448 <printint+0x98>
+    neg = 1;
+ 3cf:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+    x = -xx;
+ 3d6:	f7 d9                	neg    %ecx
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 3d8:	31 db                	xor    %ebx,%ebx
+ 3da:	8d 75 d7             	lea    -0x29(%ebp),%esi
+ 3dd:	8d 76 00             	lea    0x0(%esi),%esi
+  do{
+    buf[i++] = digits[x % base];
+ 3e0:	89 c8                	mov    %ecx,%eax
+ 3e2:	31 d2                	xor    %edx,%edx
+ 3e4:	89 cf                	mov    %ecx,%edi
+ 3e6:	f7 75 c4             	divl   -0x3c(%ebp)
+ 3e9:	0f b6 92 04 08 00 00 	movzbl 0x804(%edx),%edx
+ 3f0:	89 45 c0             	mov    %eax,-0x40(%ebp)
+ 3f3:	89 d8                	mov    %ebx,%eax
+ 3f5:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+ 3f8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+    buf[i++] = digits[x % base];
+ 3fb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
+  }while((x /= base) != 0);
+ 3fe:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
+ 401:	76 dd                	jbe    3e0 <printint+0x30>
+  if(neg)
+ 403:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+ 406:	85 c9                	test   %ecx,%ecx
+ 408:	74 0c                	je     416 <printint+0x66>
+    buf[i++] = '-';
+ 40a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+ 40f:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+ 411:	ba 2d 00 00 00       	mov    $0x2d,%edx
+
+  while(--i >= 0)
+ 416:	8b 7d b8             	mov    -0x48(%ebp),%edi
+ 419:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+ 41d:	eb 07                	jmp    426 <printint+0x76>
+ 41f:	90                   	nop
+ 420:	0f b6 13             	movzbl (%ebx),%edx
+ 423:	83 eb 01             	sub    $0x1,%ebx
+  write(fd, &c, 1);
+ 426:	83 ec 04             	sub    $0x4,%esp
+ 429:	88 55 d7             	mov    %dl,-0x29(%ebp)
+ 42c:	6a 01                	push   $0x1
+ 42e:	56                   	push   %esi
+ 42f:	57                   	push   %edi
+ 430:	e8 ce fe ff ff       	call   303 <write>
+  while(--i >= 0)
+ 435:	83 c4 10             	add    $0x10,%esp
+ 438:	39 de                	cmp    %ebx,%esi
+ 43a:	75 e4                	jne    420 <printint+0x70>
+    putc(fd, buf[i]);
+}
+ 43c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 43f:	5b                   	pop    %ebx
+ 440:	5e                   	pop    %esi
+ 441:	5f                   	pop    %edi
+ 442:	5d                   	pop    %ebp
+ 443:	c3                   	ret    
+ 444:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  neg = 0;
+ 448:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+ 44f:	eb 87                	jmp    3d8 <printint+0x28>
+ 451:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 458:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 45f:	90                   	nop
+
+00000460 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 460:	f3 0f 1e fb          	endbr32 
+ 464:	55                   	push   %ebp
+ 465:	89 e5                	mov    %esp,%ebp
+ 467:	57                   	push   %edi
+ 468:	56                   	push   %esi
+ 469:	53                   	push   %ebx
+ 46a:	83 ec 2c             	sub    $0x2c,%esp
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 46d:	8b 75 0c             	mov    0xc(%ebp),%esi
+ 470:	0f b6 1e             	movzbl (%esi),%ebx
+ 473:	84 db                	test   %bl,%bl
+ 475:	0f 84 b4 00 00 00    	je     52f <printf+0xcf>
+  ap = (uint*)(void*)&fmt + 1;
+ 47b:	8d 45 10             	lea    0x10(%ebp),%eax
+ 47e:	83 c6 01             	add    $0x1,%esi
+  write(fd, &c, 1);
+ 481:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  state = 0;
+ 484:	31 d2                	xor    %edx,%edx
+  ap = (uint*)(void*)&fmt + 1;
+ 486:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 489:	eb 33                	jmp    4be <printf+0x5e>
+ 48b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 48f:	90                   	nop
+ 490:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+ 493:	ba 25 00 00 00       	mov    $0x25,%edx
+      if(c == '%'){
+ 498:	83 f8 25             	cmp    $0x25,%eax
+ 49b:	74 17                	je     4b4 <printf+0x54>
+  write(fd, &c, 1);
+ 49d:	83 ec 04             	sub    $0x4,%esp
+ 4a0:	88 5d e7             	mov    %bl,-0x19(%ebp)
+ 4a3:	6a 01                	push   $0x1
+ 4a5:	57                   	push   %edi
+ 4a6:	ff 75 08             	pushl  0x8(%ebp)
+ 4a9:	e8 55 fe ff ff       	call   303 <write>
+ 4ae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+      } else {
+        putc(fd, c);
+ 4b1:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; fmt[i]; i++){
+ 4b4:	0f b6 1e             	movzbl (%esi),%ebx
+ 4b7:	83 c6 01             	add    $0x1,%esi
+ 4ba:	84 db                	test   %bl,%bl
+ 4bc:	74 71                	je     52f <printf+0xcf>
+    c = fmt[i] & 0xff;
+ 4be:	0f be cb             	movsbl %bl,%ecx
+ 4c1:	0f b6 c3             	movzbl %bl,%eax
+    if(state == 0){
+ 4c4:	85 d2                	test   %edx,%edx
+ 4c6:	74 c8                	je     490 <printf+0x30>
+      }
+    } else if(state == '%'){
+ 4c8:	83 fa 25             	cmp    $0x25,%edx
+ 4cb:	75 e7                	jne    4b4 <printf+0x54>
+      if(c == 'd'){
+ 4cd:	83 f8 64             	cmp    $0x64,%eax
+ 4d0:	0f 84 9a 00 00 00    	je     570 <printf+0x110>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+ 4d6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
+ 4dc:	83 f9 70             	cmp    $0x70,%ecx
+ 4df:	74 5f                	je     540 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+ 4e1:	83 f8 73             	cmp    $0x73,%eax
+ 4e4:	0f 84 d6 00 00 00    	je     5c0 <printf+0x160>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 4ea:	83 f8 63             	cmp    $0x63,%eax
+ 4ed:	0f 84 8d 00 00 00    	je     580 <printf+0x120>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+ 4f3:	83 f8 25             	cmp    $0x25,%eax
+ 4f6:	0f 84 b4 00 00 00    	je     5b0 <printf+0x150>
+  write(fd, &c, 1);
+ 4fc:	83 ec 04             	sub    $0x4,%esp
+ 4ff:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
+ 503:	6a 01                	push   $0x1
+ 505:	57                   	push   %edi
+ 506:	ff 75 08             	pushl  0x8(%ebp)
+ 509:	e8 f5 fd ff ff       	call   303 <write>
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+ 50e:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 511:	83 c4 0c             	add    $0xc,%esp
+ 514:	6a 01                	push   $0x1
+ 516:	83 c6 01             	add    $0x1,%esi
+ 519:	57                   	push   %edi
+ 51a:	ff 75 08             	pushl  0x8(%ebp)
+ 51d:	e8 e1 fd ff ff       	call   303 <write>
+  for(i = 0; fmt[i]; i++){
+ 522:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
+        putc(fd, c);
+ 526:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 529:	31 d2                	xor    %edx,%edx
+  for(i = 0; fmt[i]; i++){
+ 52b:	84 db                	test   %bl,%bl
+ 52d:	75 8f                	jne    4be <printf+0x5e>
+    }
+  }
+}
+ 52f:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 532:	5b                   	pop    %ebx
+ 533:	5e                   	pop    %esi
+ 534:	5f                   	pop    %edi
+ 535:	5d                   	pop    %ebp
+ 536:	c3                   	ret    
+ 537:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 53e:	66 90                	xchg   %ax,%ax
+        printint(fd, *ap, 16, 0);
+ 540:	83 ec 0c             	sub    $0xc,%esp
+ 543:	b9 10 00 00 00       	mov    $0x10,%ecx
+ 548:	6a 00                	push   $0x0
+ 54a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+ 54d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 550:	8b 13                	mov    (%ebx),%edx
+ 552:	e8 59 fe ff ff       	call   3b0 <printint>
+        ap++;
+ 557:	89 d8                	mov    %ebx,%eax
+ 559:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 55c:	31 d2                	xor    %edx,%edx
+        ap++;
+ 55e:	83 c0 04             	add    $0x4,%eax
+ 561:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 564:	e9 4b ff ff ff       	jmp    4b4 <printf+0x54>
+ 569:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        printint(fd, *ap, 10, 1);
+ 570:	83 ec 0c             	sub    $0xc,%esp
+ 573:	b9 0a 00 00 00       	mov    $0xa,%ecx
+ 578:	6a 01                	push   $0x1
+ 57a:	eb ce                	jmp    54a <printf+0xea>
+ 57c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        putc(fd, *ap);
+ 580:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+  write(fd, &c, 1);
+ 583:	83 ec 04             	sub    $0x4,%esp
+        putc(fd, *ap);
+ 586:	8b 03                	mov    (%ebx),%eax
+  write(fd, &c, 1);
+ 588:	6a 01                	push   $0x1
+        ap++;
+ 58a:	83 c3 04             	add    $0x4,%ebx
+  write(fd, &c, 1);
+ 58d:	57                   	push   %edi
+ 58e:	ff 75 08             	pushl  0x8(%ebp)
+        putc(fd, *ap);
+ 591:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 594:	e8 6a fd ff ff       	call   303 <write>
+        ap++;
+ 599:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+ 59c:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 59f:	31 d2                	xor    %edx,%edx
+ 5a1:	e9 0e ff ff ff       	jmp    4b4 <printf+0x54>
+ 5a6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 5ad:	8d 76 00             	lea    0x0(%esi),%esi
+        putc(fd, c);
+ 5b0:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 5b3:	83 ec 04             	sub    $0x4,%esp
+ 5b6:	e9 59 ff ff ff       	jmp    514 <printf+0xb4>
+ 5bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 5bf:	90                   	nop
+        s = (char*)*ap;
+ 5c0:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 5c3:	8b 18                	mov    (%eax),%ebx
+        ap++;
+ 5c5:	83 c0 04             	add    $0x4,%eax
+ 5c8:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        if(s == 0)
+ 5cb:	85 db                	test   %ebx,%ebx
+ 5cd:	74 17                	je     5e6 <printf+0x186>
+        while(*s != 0){
+ 5cf:	0f b6 03             	movzbl (%ebx),%eax
+      state = 0;
+ 5d2:	31 d2                	xor    %edx,%edx
+        while(*s != 0){
+ 5d4:	84 c0                	test   %al,%al
+ 5d6:	0f 84 d8 fe ff ff    	je     4b4 <printf+0x54>
+ 5dc:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 5df:	89 de                	mov    %ebx,%esi
+ 5e1:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 5e4:	eb 1a                	jmp    600 <printf+0x1a0>
+          s = "(null)";
+ 5e6:	bb fb 07 00 00       	mov    $0x7fb,%ebx
+        while(*s != 0){
+ 5eb:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 5ee:	b8 28 00 00 00       	mov    $0x28,%eax
+ 5f3:	89 de                	mov    %ebx,%esi
+ 5f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 5f8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 5ff:	90                   	nop
+  write(fd, &c, 1);
+ 600:	83 ec 04             	sub    $0x4,%esp
+          s++;
+ 603:	83 c6 01             	add    $0x1,%esi
+ 606:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 609:	6a 01                	push   $0x1
+ 60b:	57                   	push   %edi
+ 60c:	53                   	push   %ebx
+ 60d:	e8 f1 fc ff ff       	call   303 <write>
+        while(*s != 0){
+ 612:	0f b6 06             	movzbl (%esi),%eax
+ 615:	83 c4 10             	add    $0x10,%esp
+ 618:	84 c0                	test   %al,%al
+ 61a:	75 e4                	jne    600 <printf+0x1a0>
+ 61c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+      state = 0;
+ 61f:	31 d2                	xor    %edx,%edx
+ 621:	e9 8e fe ff ff       	jmp    4b4 <printf+0x54>
+ 626:	66 90                	xchg   %ax,%ax
+ 628:	66 90                	xchg   %ax,%ax
+ 62a:	66 90                	xchg   %ax,%ax
+ 62c:	66 90                	xchg   %ax,%ax
+ 62e:	66 90                	xchg   %ax,%ax
+
+00000630 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 630:	f3 0f 1e fb          	endbr32 
+ 634:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 635:	a1 bc 0a 00 00       	mov    0xabc,%eax
+{
+ 63a:	89 e5                	mov    %esp,%ebp
+ 63c:	57                   	push   %edi
+ 63d:	56                   	push   %esi
+ 63e:	53                   	push   %ebx
+ 63f:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 642:	8b 10                	mov    (%eax),%edx
+  bp = (Header*)ap - 1;
+ 644:	8d 4b f8             	lea    -0x8(%ebx),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 647:	39 c8                	cmp    %ecx,%eax
+ 649:	73 15                	jae    660 <free+0x30>
+ 64b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 64f:	90                   	nop
+ 650:	39 d1                	cmp    %edx,%ecx
+ 652:	72 14                	jb     668 <free+0x38>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 654:	39 d0                	cmp    %edx,%eax
+ 656:	73 10                	jae    668 <free+0x38>
+{
+ 658:	89 d0                	mov    %edx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 65a:	8b 10                	mov    (%eax),%edx
+ 65c:	39 c8                	cmp    %ecx,%eax
+ 65e:	72 f0                	jb     650 <free+0x20>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 660:	39 d0                	cmp    %edx,%eax
+ 662:	72 f4                	jb     658 <free+0x28>
+ 664:	39 d1                	cmp    %edx,%ecx
+ 666:	73 f0                	jae    658 <free+0x28>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 668:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ 66b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
+ 66e:	39 fa                	cmp    %edi,%edx
+ 670:	74 1e                	je     690 <free+0x60>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+ 672:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 675:	8b 50 04             	mov    0x4(%eax),%edx
+ 678:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 67b:	39 f1                	cmp    %esi,%ecx
+ 67d:	74 28                	je     6a7 <free+0x77>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+ 67f:	89 08                	mov    %ecx,(%eax)
+  freep = p;
+}
+ 681:	5b                   	pop    %ebx
+  freep = p;
+ 682:	a3 bc 0a 00 00       	mov    %eax,0xabc
+}
+ 687:	5e                   	pop    %esi
+ 688:	5f                   	pop    %edi
+ 689:	5d                   	pop    %ebp
+ 68a:	c3                   	ret    
+ 68b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 68f:	90                   	nop
+    bp->s.size += p->s.ptr->s.size;
+ 690:	03 72 04             	add    0x4(%edx),%esi
+ 693:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 696:	8b 10                	mov    (%eax),%edx
+ 698:	8b 12                	mov    (%edx),%edx
+ 69a:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 69d:	8b 50 04             	mov    0x4(%eax),%edx
+ 6a0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 6a3:	39 f1                	cmp    %esi,%ecx
+ 6a5:	75 d8                	jne    67f <free+0x4f>
+    p->s.size += bp->s.size;
+ 6a7:	03 53 fc             	add    -0x4(%ebx),%edx
+  freep = p;
+ 6aa:	a3 bc 0a 00 00       	mov    %eax,0xabc
+    p->s.size += bp->s.size;
+ 6af:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 6b2:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ 6b5:	89 10                	mov    %edx,(%eax)
+}
+ 6b7:	5b                   	pop    %ebx
+ 6b8:	5e                   	pop    %esi
+ 6b9:	5f                   	pop    %edi
+ 6ba:	5d                   	pop    %ebp
+ 6bb:	c3                   	ret    
+ 6bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000006c0 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 6c0:	f3 0f 1e fb          	endbr32 
+ 6c4:	55                   	push   %ebp
+ 6c5:	89 e5                	mov    %esp,%ebp
+ 6c7:	57                   	push   %edi
+ 6c8:	56                   	push   %esi
+ 6c9:	53                   	push   %ebx
+ 6ca:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 6cd:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+ 6d0:	8b 3d bc 0a 00 00    	mov    0xabc,%edi
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 6d6:	8d 70 07             	lea    0x7(%eax),%esi
+ 6d9:	c1 ee 03             	shr    $0x3,%esi
+ 6dc:	83 c6 01             	add    $0x1,%esi
+  if((prevp = freep) == 0){
+ 6df:	85 ff                	test   %edi,%edi
+ 6e1:	0f 84 a9 00 00 00    	je     790 <malloc+0xd0>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 6e7:	8b 07                	mov    (%edi),%eax
+    if(p->s.size >= nunits){
+ 6e9:	8b 48 04             	mov    0x4(%eax),%ecx
+ 6ec:	39 f1                	cmp    %esi,%ecx
+ 6ee:	73 6d                	jae    75d <malloc+0x9d>
+ 6f0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+ 6f6:	bb 00 10 00 00       	mov    $0x1000,%ebx
+ 6fb:	0f 43 de             	cmovae %esi,%ebx
+  p = sbrk(nu * sizeof(Header));
+ 6fe:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
+ 705:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+ 708:	eb 17                	jmp    721 <malloc+0x61>
+ 70a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 710:	8b 10                	mov    (%eax),%edx
+    if(p->s.size >= nunits){
+ 712:	8b 4a 04             	mov    0x4(%edx),%ecx
+ 715:	39 f1                	cmp    %esi,%ecx
+ 717:	73 4f                	jae    768 <malloc+0xa8>
+ 719:	8b 3d bc 0a 00 00    	mov    0xabc,%edi
+ 71f:	89 d0                	mov    %edx,%eax
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 721:	39 c7                	cmp    %eax,%edi
+ 723:	75 eb                	jne    710 <malloc+0x50>
+  p = sbrk(nu * sizeof(Header));
+ 725:	83 ec 0c             	sub    $0xc,%esp
+ 728:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 72b:	e8 3b fc ff ff       	call   36b <sbrk>
+  if(p == (char*)-1)
+ 730:	83 c4 10             	add    $0x10,%esp
+ 733:	83 f8 ff             	cmp    $0xffffffff,%eax
+ 736:	74 1b                	je     753 <malloc+0x93>
+  hp->s.size = nu;
+ 738:	89 58 04             	mov    %ebx,0x4(%eax)
+  free((void*)(hp + 1));
+ 73b:	83 ec 0c             	sub    $0xc,%esp
+ 73e:	83 c0 08             	add    $0x8,%eax
+ 741:	50                   	push   %eax
+ 742:	e8 e9 fe ff ff       	call   630 <free>
+  return freep;
+ 747:	a1 bc 0a 00 00       	mov    0xabc,%eax
+      if((p = morecore(nunits)) == 0)
+ 74c:	83 c4 10             	add    $0x10,%esp
+ 74f:	85 c0                	test   %eax,%eax
+ 751:	75 bd                	jne    710 <malloc+0x50>
+        return 0;
+  }
+}
+ 753:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return 0;
+ 756:	31 c0                	xor    %eax,%eax
+}
+ 758:	5b                   	pop    %ebx
+ 759:	5e                   	pop    %esi
+ 75a:	5f                   	pop    %edi
+ 75b:	5d                   	pop    %ebp
+ 75c:	c3                   	ret    
+    if(p->s.size >= nunits){
+ 75d:	89 c2                	mov    %eax,%edx
+ 75f:	89 f8                	mov    %edi,%eax
+ 761:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+ 768:	39 ce                	cmp    %ecx,%esi
+ 76a:	74 54                	je     7c0 <malloc+0x100>
+        p->s.size -= nunits;
+ 76c:	29 f1                	sub    %esi,%ecx
+ 76e:	89 4a 04             	mov    %ecx,0x4(%edx)
+        p += p->s.size;
+ 771:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
+        p->s.size = nunits;
+ 774:	89 72 04             	mov    %esi,0x4(%edx)
+      freep = prevp;
+ 777:	a3 bc 0a 00 00       	mov    %eax,0xabc
+}
+ 77c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return (void*)(p + 1);
+ 77f:	8d 42 08             	lea    0x8(%edx),%eax
+}
+ 782:	5b                   	pop    %ebx
+ 783:	5e                   	pop    %esi
+ 784:	5f                   	pop    %edi
+ 785:	5d                   	pop    %ebp
+ 786:	c3                   	ret    
+ 787:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 78e:	66 90                	xchg   %ax,%ax
+    base.s.ptr = freep = prevp = &base;
+ 790:	c7 05 bc 0a 00 00 c0 	movl   $0xac0,0xabc
+ 797:	0a 00 00 
+    base.s.size = 0;
+ 79a:	bf c0 0a 00 00       	mov    $0xac0,%edi
+    base.s.ptr = freep = prevp = &base;
+ 79f:	c7 05 c0 0a 00 00 c0 	movl   $0xac0,0xac0
+ 7a6:	0a 00 00 
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7a9:	89 f8                	mov    %edi,%eax
+    base.s.size = 0;
+ 7ab:	c7 05 c4 0a 00 00 00 	movl   $0x0,0xac4
+ 7b2:	00 00 00 
+    if(p->s.size >= nunits){
+ 7b5:	e9 36 ff ff ff       	jmp    6f0 <malloc+0x30>
+ 7ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        prevp->s.ptr = p->s.ptr;
+ 7c0:	8b 0a                	mov    (%edx),%ecx
+ 7c2:	89 08                	mov    %ecx,(%eax)
+ 7c4:	eb b1                	jmp    777 <malloc+0xb7>
diff -ruN xv6-public/mkdir.d copy-xv6/mkdir.d
--- xv6-public/mkdir.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/mkdir.d	2022-09-05 23:26:12.064781089 +0530
@@ -0,0 +1 @@
+mkdir.o: mkdir.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/mkdir.o and copy-xv6/mkdir.o differ
diff -ruN xv6-public/mkdir.sym copy-xv6/mkdir.sym
--- xv6-public/mkdir.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/mkdir.sym	2022-09-05 23:26:12.076781089 +0530
@@ -0,0 +1,61 @@
+00000000 .text
+000007c8 .rodata
+00000818 .eh_frame
+00000abc .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 mkdir.c
+00000000 ulib.c
+00000000 printf.c
+000003b0 printint
+00000804 digits.1097
+00000000 umalloc.c
+00000abc freep
+00000ac0 base
+00000080 strcpy
+00000460 printf
+0000039b thread_exit
+000002b0 memmove
+0000032b mknod
+000001a0 gets
+00000363 getpid
+000006c0 malloc
+00000373 sleep
+000002f3 pipe
+00000303 write
+0000033b fstat
+00000313 kill
+00000353 chdir
+0000031b exec
+000002eb wait
+000002fb read
+00000333 unlink
+000002db fork
+0000036b sbrk
+0000037b uptime
+00000abc __bss_start
+00000140 memset
+00000000 main
+000000b0 strcmp
+0000035b dup
+00000220 stat
+00000abc _edata
+00000ac8 _end
+00000343 link
+000002e3 exit
+00000270 atoi
+00000383 draw
+00000100 strlen
+00000323 open
+00000160 strchr
+0000038b thread_create
+0000034b mkdir
+0000030b close
+00000393 thread_join
+00000630 free
Binary files xv6-public/mkfs and copy-xv6/mkfs differ
diff -ruN xv6-public/mp.d copy-xv6/mp.d
--- xv6-public/mp.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/mp.d	2022-09-05 23:26:13.256781064 +0530
@@ -0,0 +1,2 @@
+mp.o: mp.c /usr/include/stdc-predef.h types.h defs.h param.h memlayout.h \
+ mp.h x86.h mmu.h proc.h
Binary files xv6-public/mp.o and copy-xv6/mp.o differ
Binary files xv6-public/_old_thread and copy-xv6/_old_thread differ
diff -ruN xv6-public/old_thread.asm copy-xv6/old_thread.asm
--- xv6-public/old_thread.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/old_thread.asm	2022-09-05 23:26:12.664781078 +0530
@@ -0,0 +1,1344 @@
+
+_old_thread:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+    printf(1, "Done s:%x\n", b->name);
+    thread_exit();
+    return;
+}
+int main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	57                   	push   %edi
+  12:	56                   	push   %esi
+  13:	53                   	push   %ebx
+  14:	51                   	push   %ecx
+  15:	83 ec 64             	sub    $0x64,%esp
+    struct balance b1 = {"b1", 3200};
+  18:	c7 45 a0 62 31 00 00 	movl   $0x3162,-0x60(%ebp)
+    struct balance b2 = {"b2", 2800};
+    void *s1, *s2;
+    int t1, t2, r1, r2;
+    s1 = malloc(4096);
+  1f:	68 00 10 00 00       	push   $0x1000
+    struct balance b1 = {"b1", 3200};
+  24:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
+  2b:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
+  32:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
+  39:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
+  40:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
+  47:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
+  4e:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+  55:	c7 45 c0 80 0c 00 00 	movl   $0xc80,-0x40(%ebp)
+    struct balance b2 = {"b2", 2800};
+  5c:	c7 45 c4 62 32 00 00 	movl   $0x3262,-0x3c(%ebp)
+  63:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
+  6a:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
+  71:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
+  78:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
+  7f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
+  86:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  8d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+  94:	c7 45 e4 f0 0a 00 00 	movl   $0xaf0,-0x1c(%ebp)
+    s1 = malloc(4096);
+  9b:	e8 50 07 00 00       	call   7f0 <malloc>
+    s2 = malloc(4096);
+  a0:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
+    s1 = malloc(4096);
+  a7:	89 c3                	mov    %eax,%ebx
+    s2 = malloc(4096);
+  a9:	e8 42 07 00 00       	call   7f0 <malloc>
+    t1 = thread_create(do_work, (void *)&b1, s1);
+  ae:	83 c4 0c             	add    $0xc,%esp
+    s2 = malloc(4096);
+  b1:	89 c6                	mov    %eax,%esi
+    t1 = thread_create(do_work, (void *)&b1, s1);
+  b3:	8d 45 a0             	lea    -0x60(%ebp),%eax
+  b6:	53                   	push   %ebx
+  b7:	50                   	push   %eax
+  b8:	68 10 01 00 00       	push   $0x110
+  bd:	e8 f9 03 00 00       	call   4bb <thread_create>
+    t2 = thread_create(do_work, (void *)&b2, s2);
+  c2:	83 c4 0c             	add    $0xc,%esp
+    t1 = thread_create(do_work, (void *)&b1, s1);
+  c5:	89 c3                	mov    %eax,%ebx
+    t2 = thread_create(do_work, (void *)&b2, s2);
+  c7:	8d 45 c4             	lea    -0x3c(%ebp),%eax
+  ca:	56                   	push   %esi
+  cb:	50                   	push   %eax
+  cc:	68 10 01 00 00       	push   $0x110
+  d1:	e8 e5 03 00 00       	call   4bb <thread_create>
+  d6:	89 c7                	mov    %eax,%edi
+    r1 = thread_join();
+  d8:	e8 e6 03 00 00       	call   4c3 <thread_join>
+  dd:	89 c6                	mov    %eax,%esi
+    r2 = thread_join();
+  df:	e8 df 03 00 00       	call   4c3 <thread_join>
+    printf(1, "Threads finished: (%d):%d, (%d):%d, shared balance:%d\n",
+  e4:	8b 15 58 0c 00 00    	mov    0xc58,%edx
+  ea:	83 c4 0c             	add    $0xc,%esp
+  ed:	52                   	push   %edx
+  ee:	50                   	push   %eax
+  ef:	57                   	push   %edi
+  f0:	56                   	push   %esi
+  f1:	53                   	push   %ebx
+  f2:	68 1c 09 00 00       	push   $0x91c
+  f7:	6a 01                	push   $0x1
+  f9:	e8 92 04 00 00       	call   590 <printf>
+           t1, r1, t2, r2, total_balance);
+    exit();
+  fe:	83 c4 20             	add    $0x20,%esp
+ 101:	e8 0d 03 00 00       	call   413 <exit>
+ 106:	66 90                	xchg   %ax,%ax
+ 108:	66 90                	xchg   %ax,%ax
+ 10a:	66 90                	xchg   %ax,%ax
+ 10c:	66 90                	xchg   %ax,%ax
+ 10e:	66 90                	xchg   %ax,%ax
+
+00000110 <do_work>:
+{
+ 110:	f3 0f 1e fb          	endbr32 
+ 114:	55                   	push   %ebp
+ 115:	89 e5                	mov    %esp,%ebp
+ 117:	56                   	push   %esi
+ 118:	53                   	push   %ebx
+ 119:	8b 75 08             	mov    0x8(%ebp),%esi
+    printf(1, "Starting do_work: s:%s\n", b->name);
+ 11c:	83 ec 04             	sub    $0x4,%esp
+ 11f:	56                   	push   %esi
+ 120:	68 f8 08 00 00       	push   $0x8f8
+ 125:	6a 01                	push   $0x1
+ 127:	e8 64 04 00 00       	call   590 <printf>
+    for (i = 0; i < b->amount; i++)
+ 12c:	8b 5e 20             	mov    0x20(%esi),%ebx
+ 12f:	83 c4 10             	add    $0x10,%esp
+ 132:	85 db                	test   %ebx,%ebx
+ 134:	7e 2f                	jle    165 <do_work+0x55>
+ 136:	31 c9                	xor    %ecx,%ecx
+ 138:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 13f:	90                   	nop
+        old = total_balance;
+ 140:	8b 15 58 0c 00 00    	mov    0xc58,%edx
+ 146:	b8 a0 86 01 00       	mov    $0x186a0,%eax
+ 14b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 14f:	90                   	nop
+        __asm volatile("nop" ::
+ 150:	90                   	nop
+    for (i = 0; i < d; i++)
+ 151:	83 e8 01             	sub    $0x1,%eax
+ 154:	75 fa                	jne    150 <do_work+0x40>
+        total_balance = old + 1;
+ 156:	8d 42 01             	lea    0x1(%edx),%eax
+    for (i = 0; i < b->amount; i++)
+ 159:	83 c1 01             	add    $0x1,%ecx
+        total_balance = old + 1;
+ 15c:	a3 58 0c 00 00       	mov    %eax,0xc58
+    for (i = 0; i < b->amount; i++)
+ 161:	39 d9                	cmp    %ebx,%ecx
+ 163:	75 db                	jne    140 <do_work+0x30>
+    printf(1, "Done s:%x\n", b->name);
+ 165:	83 ec 04             	sub    $0x4,%esp
+ 168:	56                   	push   %esi
+ 169:	68 10 09 00 00       	push   $0x910
+ 16e:	6a 01                	push   $0x1
+ 170:	e8 1b 04 00 00       	call   590 <printf>
+    thread_exit();
+ 175:	83 c4 10             	add    $0x10,%esp
+}
+ 178:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 17b:	5b                   	pop    %ebx
+ 17c:	5e                   	pop    %esi
+ 17d:	5d                   	pop    %ebp
+    thread_exit();
+ 17e:	e9 48 03 00 00       	jmp    4cb <thread_exit>
+ 183:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 18a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000190 <delay>:
+{
+ 190:	f3 0f 1e fb          	endbr32 
+ 194:	55                   	push   %ebp
+ 195:	89 e5                	mov    %esp,%ebp
+ 197:	8b 55 08             	mov    0x8(%ebp),%edx
+    for (i = 0; i < d; i++)
+ 19a:	85 d2                	test   %edx,%edx
+ 19c:	74 0a                	je     1a8 <delay+0x18>
+ 19e:	31 c0                	xor    %eax,%eax
+        __asm volatile("nop" ::
+ 1a0:	90                   	nop
+    for (i = 0; i < d; i++)
+ 1a1:	83 c0 01             	add    $0x1,%eax
+ 1a4:	39 c2                	cmp    %eax,%edx
+ 1a6:	75 f8                	jne    1a0 <delay+0x10>
+}
+ 1a8:	89 d0                	mov    %edx,%eax
+ 1aa:	5d                   	pop    %ebp
+ 1ab:	c3                   	ret    
+ 1ac:	66 90                	xchg   %ax,%ax
+ 1ae:	66 90                	xchg   %ax,%ax
+
+000001b0 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 1b0:	f3 0f 1e fb          	endbr32 
+ 1b4:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+ 1b5:	31 c0                	xor    %eax,%eax
+{
+ 1b7:	89 e5                	mov    %esp,%ebp
+ 1b9:	53                   	push   %ebx
+ 1ba:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 1bd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+ 1c0:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+ 1c4:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+ 1c7:	83 c0 01             	add    $0x1,%eax
+ 1ca:	84 d2                	test   %dl,%dl
+ 1cc:	75 f2                	jne    1c0 <strcpy+0x10>
+    ;
+  return os;
+}
+ 1ce:	89 c8                	mov    %ecx,%eax
+ 1d0:	5b                   	pop    %ebx
+ 1d1:	5d                   	pop    %ebp
+ 1d2:	c3                   	ret    
+ 1d3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000001e0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 1e0:	f3 0f 1e fb          	endbr32 
+ 1e4:	55                   	push   %ebp
+ 1e5:	89 e5                	mov    %esp,%ebp
+ 1e7:	53                   	push   %ebx
+ 1e8:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 1eb:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+ 1ee:	0f b6 01             	movzbl (%ecx),%eax
+ 1f1:	0f b6 1a             	movzbl (%edx),%ebx
+ 1f4:	84 c0                	test   %al,%al
+ 1f6:	75 19                	jne    211 <strcmp+0x31>
+ 1f8:	eb 26                	jmp    220 <strcmp+0x40>
+ 1fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 200:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+ 204:	83 c1 01             	add    $0x1,%ecx
+ 207:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+ 20a:	0f b6 1a             	movzbl (%edx),%ebx
+ 20d:	84 c0                	test   %al,%al
+ 20f:	74 0f                	je     220 <strcmp+0x40>
+ 211:	38 d8                	cmp    %bl,%al
+ 213:	74 eb                	je     200 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+ 215:	29 d8                	sub    %ebx,%eax
+}
+ 217:	5b                   	pop    %ebx
+ 218:	5d                   	pop    %ebp
+ 219:	c3                   	ret    
+ 21a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 220:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+ 222:	29 d8                	sub    %ebx,%eax
+}
+ 224:	5b                   	pop    %ebx
+ 225:	5d                   	pop    %ebp
+ 226:	c3                   	ret    
+ 227:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 22e:	66 90                	xchg   %ax,%ax
+
+00000230 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 230:	f3 0f 1e fb          	endbr32 
+ 234:	55                   	push   %ebp
+ 235:	89 e5                	mov    %esp,%ebp
+ 237:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 23a:	80 3a 00             	cmpb   $0x0,(%edx)
+ 23d:	74 21                	je     260 <strlen+0x30>
+ 23f:	31 c0                	xor    %eax,%eax
+ 241:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 248:	83 c0 01             	add    $0x1,%eax
+ 24b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+ 24f:	89 c1                	mov    %eax,%ecx
+ 251:	75 f5                	jne    248 <strlen+0x18>
+    ;
+  return n;
+}
+ 253:	89 c8                	mov    %ecx,%eax
+ 255:	5d                   	pop    %ebp
+ 256:	c3                   	ret    
+ 257:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 25e:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+ 260:	31 c9                	xor    %ecx,%ecx
+}
+ 262:	5d                   	pop    %ebp
+ 263:	89 c8                	mov    %ecx,%eax
+ 265:	c3                   	ret    
+ 266:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 26d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000270 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 270:	f3 0f 1e fb          	endbr32 
+ 274:	55                   	push   %ebp
+ 275:	89 e5                	mov    %esp,%ebp
+ 277:	57                   	push   %edi
+ 278:	8b 55 08             	mov    0x8(%ebp),%edx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+ 27b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 27e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 281:	89 d7                	mov    %edx,%edi
+ 283:	fc                   	cld    
+ 284:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+ 286:	89 d0                	mov    %edx,%eax
+ 288:	5f                   	pop    %edi
+ 289:	5d                   	pop    %ebp
+ 28a:	c3                   	ret    
+ 28b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 28f:	90                   	nop
+
+00000290 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 290:	f3 0f 1e fb          	endbr32 
+ 294:	55                   	push   %ebp
+ 295:	89 e5                	mov    %esp,%ebp
+ 297:	8b 45 08             	mov    0x8(%ebp),%eax
+ 29a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+ 29e:	0f b6 10             	movzbl (%eax),%edx
+ 2a1:	84 d2                	test   %dl,%dl
+ 2a3:	75 16                	jne    2bb <strchr+0x2b>
+ 2a5:	eb 21                	jmp    2c8 <strchr+0x38>
+ 2a7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 2ae:	66 90                	xchg   %ax,%ax
+ 2b0:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+ 2b4:	83 c0 01             	add    $0x1,%eax
+ 2b7:	84 d2                	test   %dl,%dl
+ 2b9:	74 0d                	je     2c8 <strchr+0x38>
+    if(*s == c)
+ 2bb:	38 d1                	cmp    %dl,%cl
+ 2bd:	75 f1                	jne    2b0 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+ 2bf:	5d                   	pop    %ebp
+ 2c0:	c3                   	ret    
+ 2c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+ 2c8:	31 c0                	xor    %eax,%eax
+}
+ 2ca:	5d                   	pop    %ebp
+ 2cb:	c3                   	ret    
+ 2cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000002d0 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 2d0:	f3 0f 1e fb          	endbr32 
+ 2d4:	55                   	push   %ebp
+ 2d5:	89 e5                	mov    %esp,%ebp
+ 2d7:	57                   	push   %edi
+ 2d8:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 2d9:	31 f6                	xor    %esi,%esi
+{
+ 2db:	53                   	push   %ebx
+ 2dc:	89 f3                	mov    %esi,%ebx
+ 2de:	83 ec 1c             	sub    $0x1c,%esp
+ 2e1:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+ 2e4:	eb 33                	jmp    319 <gets+0x49>
+ 2e6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 2ed:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+ 2f0:	83 ec 04             	sub    $0x4,%esp
+ 2f3:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ 2f6:	6a 01                	push   $0x1
+ 2f8:	50                   	push   %eax
+ 2f9:	6a 00                	push   $0x0
+ 2fb:	e8 2b 01 00 00       	call   42b <read>
+    if(cc < 1)
+ 300:	83 c4 10             	add    $0x10,%esp
+ 303:	85 c0                	test   %eax,%eax
+ 305:	7e 1c                	jle    323 <gets+0x53>
+      break;
+    buf[i++] = c;
+ 307:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ 30b:	83 c7 01             	add    $0x1,%edi
+ 30e:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+ 311:	3c 0a                	cmp    $0xa,%al
+ 313:	74 23                	je     338 <gets+0x68>
+ 315:	3c 0d                	cmp    $0xd,%al
+ 317:	74 1f                	je     338 <gets+0x68>
+  for(i=0; i+1 < max; ){
+ 319:	83 c3 01             	add    $0x1,%ebx
+ 31c:	89 fe                	mov    %edi,%esi
+ 31e:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+ 321:	7c cd                	jl     2f0 <gets+0x20>
+ 323:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+ 325:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+ 328:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 32b:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 32e:	5b                   	pop    %ebx
+ 32f:	5e                   	pop    %esi
+ 330:	5f                   	pop    %edi
+ 331:	5d                   	pop    %ebp
+ 332:	c3                   	ret    
+ 333:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 337:	90                   	nop
+ 338:	8b 75 08             	mov    0x8(%ebp),%esi
+ 33b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 33e:	01 de                	add    %ebx,%esi
+ 340:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+ 342:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 345:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 348:	5b                   	pop    %ebx
+ 349:	5e                   	pop    %esi
+ 34a:	5f                   	pop    %edi
+ 34b:	5d                   	pop    %ebp
+ 34c:	c3                   	ret    
+ 34d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000350 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 350:	f3 0f 1e fb          	endbr32 
+ 354:	55                   	push   %ebp
+ 355:	89 e5                	mov    %esp,%ebp
+ 357:	56                   	push   %esi
+ 358:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 359:	83 ec 08             	sub    $0x8,%esp
+ 35c:	6a 00                	push   $0x0
+ 35e:	ff 75 08             	pushl  0x8(%ebp)
+ 361:	e8 ed 00 00 00       	call   453 <open>
+  if(fd < 0)
+ 366:	83 c4 10             	add    $0x10,%esp
+ 369:	85 c0                	test   %eax,%eax
+ 36b:	78 2b                	js     398 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+ 36d:	83 ec 08             	sub    $0x8,%esp
+ 370:	ff 75 0c             	pushl  0xc(%ebp)
+ 373:	89 c3                	mov    %eax,%ebx
+ 375:	50                   	push   %eax
+ 376:	e8 f0 00 00 00       	call   46b <fstat>
+  close(fd);
+ 37b:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+ 37e:	89 c6                	mov    %eax,%esi
+  close(fd);
+ 380:	e8 b6 00 00 00       	call   43b <close>
+  return r;
+ 385:	83 c4 10             	add    $0x10,%esp
+}
+ 388:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 38b:	89 f0                	mov    %esi,%eax
+ 38d:	5b                   	pop    %ebx
+ 38e:	5e                   	pop    %esi
+ 38f:	5d                   	pop    %ebp
+ 390:	c3                   	ret    
+ 391:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+ 398:	be ff ff ff ff       	mov    $0xffffffff,%esi
+ 39d:	eb e9                	jmp    388 <stat+0x38>
+ 39f:	90                   	nop
+
+000003a0 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 3a0:	f3 0f 1e fb          	endbr32 
+ 3a4:	55                   	push   %ebp
+ 3a5:	89 e5                	mov    %esp,%ebp
+ 3a7:	53                   	push   %ebx
+ 3a8:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 3ab:	0f be 02             	movsbl (%edx),%eax
+ 3ae:	8d 48 d0             	lea    -0x30(%eax),%ecx
+ 3b1:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+ 3b4:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+ 3b9:	77 1a                	ja     3d5 <atoi+0x35>
+ 3bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 3bf:	90                   	nop
+    n = n*10 + *s++ - '0';
+ 3c0:	83 c2 01             	add    $0x1,%edx
+ 3c3:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+ 3c6:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+ 3ca:	0f be 02             	movsbl (%edx),%eax
+ 3cd:	8d 58 d0             	lea    -0x30(%eax),%ebx
+ 3d0:	80 fb 09             	cmp    $0x9,%bl
+ 3d3:	76 eb                	jbe    3c0 <atoi+0x20>
+  return n;
+}
+ 3d5:	89 c8                	mov    %ecx,%eax
+ 3d7:	5b                   	pop    %ebx
+ 3d8:	5d                   	pop    %ebp
+ 3d9:	c3                   	ret    
+ 3da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000003e0 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 3e0:	f3 0f 1e fb          	endbr32 
+ 3e4:	55                   	push   %ebp
+ 3e5:	89 e5                	mov    %esp,%ebp
+ 3e7:	57                   	push   %edi
+ 3e8:	8b 45 10             	mov    0x10(%ebp),%eax
+ 3eb:	8b 55 08             	mov    0x8(%ebp),%edx
+ 3ee:	56                   	push   %esi
+ 3ef:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 3f2:	85 c0                	test   %eax,%eax
+ 3f4:	7e 0f                	jle    405 <memmove+0x25>
+ 3f6:	01 d0                	add    %edx,%eax
+  dst = vdst;
+ 3f8:	89 d7                	mov    %edx,%edi
+ 3fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+ 400:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+ 401:	39 f8                	cmp    %edi,%eax
+ 403:	75 fb                	jne    400 <memmove+0x20>
+  return vdst;
+}
+ 405:	5e                   	pop    %esi
+ 406:	89 d0                	mov    %edx,%eax
+ 408:	5f                   	pop    %edi
+ 409:	5d                   	pop    %ebp
+ 40a:	c3                   	ret    
+
+0000040b <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 40b:	b8 01 00 00 00       	mov    $0x1,%eax
+ 410:	cd 40                	int    $0x40
+ 412:	c3                   	ret    
+
+00000413 <exit>:
+SYSCALL(exit)
+ 413:	b8 02 00 00 00       	mov    $0x2,%eax
+ 418:	cd 40                	int    $0x40
+ 41a:	c3                   	ret    
+
+0000041b <wait>:
+SYSCALL(wait)
+ 41b:	b8 03 00 00 00       	mov    $0x3,%eax
+ 420:	cd 40                	int    $0x40
+ 422:	c3                   	ret    
+
+00000423 <pipe>:
+SYSCALL(pipe)
+ 423:	b8 04 00 00 00       	mov    $0x4,%eax
+ 428:	cd 40                	int    $0x40
+ 42a:	c3                   	ret    
+
+0000042b <read>:
+SYSCALL(read)
+ 42b:	b8 05 00 00 00       	mov    $0x5,%eax
+ 430:	cd 40                	int    $0x40
+ 432:	c3                   	ret    
+
+00000433 <write>:
+SYSCALL(write)
+ 433:	b8 10 00 00 00       	mov    $0x10,%eax
+ 438:	cd 40                	int    $0x40
+ 43a:	c3                   	ret    
+
+0000043b <close>:
+SYSCALL(close)
+ 43b:	b8 15 00 00 00       	mov    $0x15,%eax
+ 440:	cd 40                	int    $0x40
+ 442:	c3                   	ret    
+
+00000443 <kill>:
+SYSCALL(kill)
+ 443:	b8 06 00 00 00       	mov    $0x6,%eax
+ 448:	cd 40                	int    $0x40
+ 44a:	c3                   	ret    
+
+0000044b <exec>:
+SYSCALL(exec)
+ 44b:	b8 07 00 00 00       	mov    $0x7,%eax
+ 450:	cd 40                	int    $0x40
+ 452:	c3                   	ret    
+
+00000453 <open>:
+SYSCALL(open)
+ 453:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 458:	cd 40                	int    $0x40
+ 45a:	c3                   	ret    
+
+0000045b <mknod>:
+SYSCALL(mknod)
+ 45b:	b8 11 00 00 00       	mov    $0x11,%eax
+ 460:	cd 40                	int    $0x40
+ 462:	c3                   	ret    
+
+00000463 <unlink>:
+SYSCALL(unlink)
+ 463:	b8 12 00 00 00       	mov    $0x12,%eax
+ 468:	cd 40                	int    $0x40
+ 46a:	c3                   	ret    
+
+0000046b <fstat>:
+SYSCALL(fstat)
+ 46b:	b8 08 00 00 00       	mov    $0x8,%eax
+ 470:	cd 40                	int    $0x40
+ 472:	c3                   	ret    
+
+00000473 <link>:
+SYSCALL(link)
+ 473:	b8 13 00 00 00       	mov    $0x13,%eax
+ 478:	cd 40                	int    $0x40
+ 47a:	c3                   	ret    
+
+0000047b <mkdir>:
+SYSCALL(mkdir)
+ 47b:	b8 14 00 00 00       	mov    $0x14,%eax
+ 480:	cd 40                	int    $0x40
+ 482:	c3                   	ret    
+
+00000483 <chdir>:
+SYSCALL(chdir)
+ 483:	b8 09 00 00 00       	mov    $0x9,%eax
+ 488:	cd 40                	int    $0x40
+ 48a:	c3                   	ret    
+
+0000048b <dup>:
+SYSCALL(dup)
+ 48b:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 490:	cd 40                	int    $0x40
+ 492:	c3                   	ret    
+
+00000493 <getpid>:
+SYSCALL(getpid)
+ 493:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 498:	cd 40                	int    $0x40
+ 49a:	c3                   	ret    
+
+0000049b <sbrk>:
+SYSCALL(sbrk)
+ 49b:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 4a0:	cd 40                	int    $0x40
+ 4a2:	c3                   	ret    
+
+000004a3 <sleep>:
+SYSCALL(sleep)
+ 4a3:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 4a8:	cd 40                	int    $0x40
+ 4aa:	c3                   	ret    
+
+000004ab <uptime>:
+SYSCALL(uptime)
+ 4ab:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 4b0:	cd 40                	int    $0x40
+ 4b2:	c3                   	ret    
+
+000004b3 <draw>:
+SYSCALL(draw)
+ 4b3:	b8 16 00 00 00       	mov    $0x16,%eax
+ 4b8:	cd 40                	int    $0x40
+ 4ba:	c3                   	ret    
+
+000004bb <thread_create>:
+
+SYSCALL(thread_create)
+ 4bb:	b8 17 00 00 00       	mov    $0x17,%eax
+ 4c0:	cd 40                	int    $0x40
+ 4c2:	c3                   	ret    
+
+000004c3 <thread_join>:
+SYSCALL(thread_join)
+ 4c3:	b8 18 00 00 00       	mov    $0x18,%eax
+ 4c8:	cd 40                	int    $0x40
+ 4ca:	c3                   	ret    
+
+000004cb <thread_exit>:
+SYSCALL(thread_exit)
+ 4cb:	b8 19 00 00 00       	mov    $0x19,%eax
+ 4d0:	cd 40                	int    $0x40
+ 4d2:	c3                   	ret    
+ 4d3:	66 90                	xchg   %ax,%ax
+ 4d5:	66 90                	xchg   %ax,%ax
+ 4d7:	66 90                	xchg   %ax,%ax
+ 4d9:	66 90                	xchg   %ax,%ax
+ 4db:	66 90                	xchg   %ax,%ax
+ 4dd:	66 90                	xchg   %ax,%ax
+ 4df:	90                   	nop
+
+000004e0 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 4e0:	55                   	push   %ebp
+ 4e1:	89 e5                	mov    %esp,%ebp
+ 4e3:	57                   	push   %edi
+ 4e4:	56                   	push   %esi
+ 4e5:	53                   	push   %ebx
+ 4e6:	83 ec 3c             	sub    $0x3c,%esp
+ 4e9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+ 4ec:	89 d1                	mov    %edx,%ecx
+{
+ 4ee:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  if(sgn && xx < 0){
+ 4f1:	85 d2                	test   %edx,%edx
+ 4f3:	0f 89 7f 00 00 00    	jns    578 <printint+0x98>
+ 4f9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
+ 4fd:	74 79                	je     578 <printint+0x98>
+    neg = 1;
+ 4ff:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+    x = -xx;
+ 506:	f7 d9                	neg    %ecx
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 508:	31 db                	xor    %ebx,%ebx
+ 50a:	8d 75 d7             	lea    -0x29(%ebp),%esi
+ 50d:	8d 76 00             	lea    0x0(%esi),%esi
+  do{
+    buf[i++] = digits[x % base];
+ 510:	89 c8                	mov    %ecx,%eax
+ 512:	31 d2                	xor    %edx,%edx
+ 514:	89 cf                	mov    %ecx,%edi
+ 516:	f7 75 c4             	divl   -0x3c(%ebp)
+ 519:	0f b6 92 5c 09 00 00 	movzbl 0x95c(%edx),%edx
+ 520:	89 45 c0             	mov    %eax,-0x40(%ebp)
+ 523:	89 d8                	mov    %ebx,%eax
+ 525:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+ 528:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+    buf[i++] = digits[x % base];
+ 52b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
+  }while((x /= base) != 0);
+ 52e:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
+ 531:	76 dd                	jbe    510 <printint+0x30>
+  if(neg)
+ 533:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+ 536:	85 c9                	test   %ecx,%ecx
+ 538:	74 0c                	je     546 <printint+0x66>
+    buf[i++] = '-';
+ 53a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+ 53f:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+ 541:	ba 2d 00 00 00       	mov    $0x2d,%edx
+
+  while(--i >= 0)
+ 546:	8b 7d b8             	mov    -0x48(%ebp),%edi
+ 549:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+ 54d:	eb 07                	jmp    556 <printint+0x76>
+ 54f:	90                   	nop
+ 550:	0f b6 13             	movzbl (%ebx),%edx
+ 553:	83 eb 01             	sub    $0x1,%ebx
+  write(fd, &c, 1);
+ 556:	83 ec 04             	sub    $0x4,%esp
+ 559:	88 55 d7             	mov    %dl,-0x29(%ebp)
+ 55c:	6a 01                	push   $0x1
+ 55e:	56                   	push   %esi
+ 55f:	57                   	push   %edi
+ 560:	e8 ce fe ff ff       	call   433 <write>
+  while(--i >= 0)
+ 565:	83 c4 10             	add    $0x10,%esp
+ 568:	39 de                	cmp    %ebx,%esi
+ 56a:	75 e4                	jne    550 <printint+0x70>
+    putc(fd, buf[i]);
+}
+ 56c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 56f:	5b                   	pop    %ebx
+ 570:	5e                   	pop    %esi
+ 571:	5f                   	pop    %edi
+ 572:	5d                   	pop    %ebp
+ 573:	c3                   	ret    
+ 574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  neg = 0;
+ 578:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+ 57f:	eb 87                	jmp    508 <printint+0x28>
+ 581:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 588:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 58f:	90                   	nop
+
+00000590 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 590:	f3 0f 1e fb          	endbr32 
+ 594:	55                   	push   %ebp
+ 595:	89 e5                	mov    %esp,%ebp
+ 597:	57                   	push   %edi
+ 598:	56                   	push   %esi
+ 599:	53                   	push   %ebx
+ 59a:	83 ec 2c             	sub    $0x2c,%esp
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 59d:	8b 75 0c             	mov    0xc(%ebp),%esi
+ 5a0:	0f b6 1e             	movzbl (%esi),%ebx
+ 5a3:	84 db                	test   %bl,%bl
+ 5a5:	0f 84 b4 00 00 00    	je     65f <printf+0xcf>
+  ap = (uint*)(void*)&fmt + 1;
+ 5ab:	8d 45 10             	lea    0x10(%ebp),%eax
+ 5ae:	83 c6 01             	add    $0x1,%esi
+  write(fd, &c, 1);
+ 5b1:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  state = 0;
+ 5b4:	31 d2                	xor    %edx,%edx
+  ap = (uint*)(void*)&fmt + 1;
+ 5b6:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 5b9:	eb 33                	jmp    5ee <printf+0x5e>
+ 5bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 5bf:	90                   	nop
+ 5c0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+ 5c3:	ba 25 00 00 00       	mov    $0x25,%edx
+      if(c == '%'){
+ 5c8:	83 f8 25             	cmp    $0x25,%eax
+ 5cb:	74 17                	je     5e4 <printf+0x54>
+  write(fd, &c, 1);
+ 5cd:	83 ec 04             	sub    $0x4,%esp
+ 5d0:	88 5d e7             	mov    %bl,-0x19(%ebp)
+ 5d3:	6a 01                	push   $0x1
+ 5d5:	57                   	push   %edi
+ 5d6:	ff 75 08             	pushl  0x8(%ebp)
+ 5d9:	e8 55 fe ff ff       	call   433 <write>
+ 5de:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+      } else {
+        putc(fd, c);
+ 5e1:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; fmt[i]; i++){
+ 5e4:	0f b6 1e             	movzbl (%esi),%ebx
+ 5e7:	83 c6 01             	add    $0x1,%esi
+ 5ea:	84 db                	test   %bl,%bl
+ 5ec:	74 71                	je     65f <printf+0xcf>
+    c = fmt[i] & 0xff;
+ 5ee:	0f be cb             	movsbl %bl,%ecx
+ 5f1:	0f b6 c3             	movzbl %bl,%eax
+    if(state == 0){
+ 5f4:	85 d2                	test   %edx,%edx
+ 5f6:	74 c8                	je     5c0 <printf+0x30>
+      }
+    } else if(state == '%'){
+ 5f8:	83 fa 25             	cmp    $0x25,%edx
+ 5fb:	75 e7                	jne    5e4 <printf+0x54>
+      if(c == 'd'){
+ 5fd:	83 f8 64             	cmp    $0x64,%eax
+ 600:	0f 84 9a 00 00 00    	je     6a0 <printf+0x110>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+ 606:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
+ 60c:	83 f9 70             	cmp    $0x70,%ecx
+ 60f:	74 5f                	je     670 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+ 611:	83 f8 73             	cmp    $0x73,%eax
+ 614:	0f 84 d6 00 00 00    	je     6f0 <printf+0x160>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 61a:	83 f8 63             	cmp    $0x63,%eax
+ 61d:	0f 84 8d 00 00 00    	je     6b0 <printf+0x120>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+ 623:	83 f8 25             	cmp    $0x25,%eax
+ 626:	0f 84 b4 00 00 00    	je     6e0 <printf+0x150>
+  write(fd, &c, 1);
+ 62c:	83 ec 04             	sub    $0x4,%esp
+ 62f:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
+ 633:	6a 01                	push   $0x1
+ 635:	57                   	push   %edi
+ 636:	ff 75 08             	pushl  0x8(%ebp)
+ 639:	e8 f5 fd ff ff       	call   433 <write>
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+ 63e:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 641:	83 c4 0c             	add    $0xc,%esp
+ 644:	6a 01                	push   $0x1
+ 646:	83 c6 01             	add    $0x1,%esi
+ 649:	57                   	push   %edi
+ 64a:	ff 75 08             	pushl  0x8(%ebp)
+ 64d:	e8 e1 fd ff ff       	call   433 <write>
+  for(i = 0; fmt[i]; i++){
+ 652:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
+        putc(fd, c);
+ 656:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 659:	31 d2                	xor    %edx,%edx
+  for(i = 0; fmt[i]; i++){
+ 65b:	84 db                	test   %bl,%bl
+ 65d:	75 8f                	jne    5ee <printf+0x5e>
+    }
+  }
+}
+ 65f:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 662:	5b                   	pop    %ebx
+ 663:	5e                   	pop    %esi
+ 664:	5f                   	pop    %edi
+ 665:	5d                   	pop    %ebp
+ 666:	c3                   	ret    
+ 667:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 66e:	66 90                	xchg   %ax,%ax
+        printint(fd, *ap, 16, 0);
+ 670:	83 ec 0c             	sub    $0xc,%esp
+ 673:	b9 10 00 00 00       	mov    $0x10,%ecx
+ 678:	6a 00                	push   $0x0
+ 67a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+ 67d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 680:	8b 13                	mov    (%ebx),%edx
+ 682:	e8 59 fe ff ff       	call   4e0 <printint>
+        ap++;
+ 687:	89 d8                	mov    %ebx,%eax
+ 689:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 68c:	31 d2                	xor    %edx,%edx
+        ap++;
+ 68e:	83 c0 04             	add    $0x4,%eax
+ 691:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 694:	e9 4b ff ff ff       	jmp    5e4 <printf+0x54>
+ 699:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        printint(fd, *ap, 10, 1);
+ 6a0:	83 ec 0c             	sub    $0xc,%esp
+ 6a3:	b9 0a 00 00 00       	mov    $0xa,%ecx
+ 6a8:	6a 01                	push   $0x1
+ 6aa:	eb ce                	jmp    67a <printf+0xea>
+ 6ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        putc(fd, *ap);
+ 6b0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+  write(fd, &c, 1);
+ 6b3:	83 ec 04             	sub    $0x4,%esp
+        putc(fd, *ap);
+ 6b6:	8b 03                	mov    (%ebx),%eax
+  write(fd, &c, 1);
+ 6b8:	6a 01                	push   $0x1
+        ap++;
+ 6ba:	83 c3 04             	add    $0x4,%ebx
+  write(fd, &c, 1);
+ 6bd:	57                   	push   %edi
+ 6be:	ff 75 08             	pushl  0x8(%ebp)
+        putc(fd, *ap);
+ 6c1:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 6c4:	e8 6a fd ff ff       	call   433 <write>
+        ap++;
+ 6c9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+ 6cc:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 6cf:	31 d2                	xor    %edx,%edx
+ 6d1:	e9 0e ff ff ff       	jmp    5e4 <printf+0x54>
+ 6d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 6dd:	8d 76 00             	lea    0x0(%esi),%esi
+        putc(fd, c);
+ 6e0:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 6e3:	83 ec 04             	sub    $0x4,%esp
+ 6e6:	e9 59 ff ff ff       	jmp    644 <printf+0xb4>
+ 6eb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 6ef:	90                   	nop
+        s = (char*)*ap;
+ 6f0:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 6f3:	8b 18                	mov    (%eax),%ebx
+        ap++;
+ 6f5:	83 c0 04             	add    $0x4,%eax
+ 6f8:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        if(s == 0)
+ 6fb:	85 db                	test   %ebx,%ebx
+ 6fd:	74 17                	je     716 <printf+0x186>
+        while(*s != 0){
+ 6ff:	0f b6 03             	movzbl (%ebx),%eax
+      state = 0;
+ 702:	31 d2                	xor    %edx,%edx
+        while(*s != 0){
+ 704:	84 c0                	test   %al,%al
+ 706:	0f 84 d8 fe ff ff    	je     5e4 <printf+0x54>
+ 70c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 70f:	89 de                	mov    %ebx,%esi
+ 711:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 714:	eb 1a                	jmp    730 <printf+0x1a0>
+          s = "(null)";
+ 716:	bb 53 09 00 00       	mov    $0x953,%ebx
+        while(*s != 0){
+ 71b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 71e:	b8 28 00 00 00       	mov    $0x28,%eax
+ 723:	89 de                	mov    %ebx,%esi
+ 725:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 728:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 72f:	90                   	nop
+  write(fd, &c, 1);
+ 730:	83 ec 04             	sub    $0x4,%esp
+          s++;
+ 733:	83 c6 01             	add    $0x1,%esi
+ 736:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 739:	6a 01                	push   $0x1
+ 73b:	57                   	push   %edi
+ 73c:	53                   	push   %ebx
+ 73d:	e8 f1 fc ff ff       	call   433 <write>
+        while(*s != 0){
+ 742:	0f b6 06             	movzbl (%esi),%eax
+ 745:	83 c4 10             	add    $0x10,%esp
+ 748:	84 c0                	test   %al,%al
+ 74a:	75 e4                	jne    730 <printf+0x1a0>
+ 74c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+      state = 0;
+ 74f:	31 d2                	xor    %edx,%edx
+ 751:	e9 8e fe ff ff       	jmp    5e4 <printf+0x54>
+ 756:	66 90                	xchg   %ax,%ax
+ 758:	66 90                	xchg   %ax,%ax
+ 75a:	66 90                	xchg   %ax,%ax
+ 75c:	66 90                	xchg   %ax,%ax
+ 75e:	66 90                	xchg   %ax,%ax
+
+00000760 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 760:	f3 0f 1e fb          	endbr32 
+ 764:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 765:	a1 5c 0c 00 00       	mov    0xc5c,%eax
+{
+ 76a:	89 e5                	mov    %esp,%ebp
+ 76c:	57                   	push   %edi
+ 76d:	56                   	push   %esi
+ 76e:	53                   	push   %ebx
+ 76f:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 772:	8b 10                	mov    (%eax),%edx
+  bp = (Header*)ap - 1;
+ 774:	8d 4b f8             	lea    -0x8(%ebx),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 777:	39 c8                	cmp    %ecx,%eax
+ 779:	73 15                	jae    790 <free+0x30>
+ 77b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 77f:	90                   	nop
+ 780:	39 d1                	cmp    %edx,%ecx
+ 782:	72 14                	jb     798 <free+0x38>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 784:	39 d0                	cmp    %edx,%eax
+ 786:	73 10                	jae    798 <free+0x38>
+{
+ 788:	89 d0                	mov    %edx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 78a:	8b 10                	mov    (%eax),%edx
+ 78c:	39 c8                	cmp    %ecx,%eax
+ 78e:	72 f0                	jb     780 <free+0x20>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 790:	39 d0                	cmp    %edx,%eax
+ 792:	72 f4                	jb     788 <free+0x28>
+ 794:	39 d1                	cmp    %edx,%ecx
+ 796:	73 f0                	jae    788 <free+0x28>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 798:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ 79b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
+ 79e:	39 fa                	cmp    %edi,%edx
+ 7a0:	74 1e                	je     7c0 <free+0x60>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+ 7a2:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 7a5:	8b 50 04             	mov    0x4(%eax),%edx
+ 7a8:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 7ab:	39 f1                	cmp    %esi,%ecx
+ 7ad:	74 28                	je     7d7 <free+0x77>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+ 7af:	89 08                	mov    %ecx,(%eax)
+  freep = p;
+}
+ 7b1:	5b                   	pop    %ebx
+  freep = p;
+ 7b2:	a3 5c 0c 00 00       	mov    %eax,0xc5c
+}
+ 7b7:	5e                   	pop    %esi
+ 7b8:	5f                   	pop    %edi
+ 7b9:	5d                   	pop    %ebp
+ 7ba:	c3                   	ret    
+ 7bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 7bf:	90                   	nop
+    bp->s.size += p->s.ptr->s.size;
+ 7c0:	03 72 04             	add    0x4(%edx),%esi
+ 7c3:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 7c6:	8b 10                	mov    (%eax),%edx
+ 7c8:	8b 12                	mov    (%edx),%edx
+ 7ca:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 7cd:	8b 50 04             	mov    0x4(%eax),%edx
+ 7d0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 7d3:	39 f1                	cmp    %esi,%ecx
+ 7d5:	75 d8                	jne    7af <free+0x4f>
+    p->s.size += bp->s.size;
+ 7d7:	03 53 fc             	add    -0x4(%ebx),%edx
+  freep = p;
+ 7da:	a3 5c 0c 00 00       	mov    %eax,0xc5c
+    p->s.size += bp->s.size;
+ 7df:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 7e2:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ 7e5:	89 10                	mov    %edx,(%eax)
+}
+ 7e7:	5b                   	pop    %ebx
+ 7e8:	5e                   	pop    %esi
+ 7e9:	5f                   	pop    %edi
+ 7ea:	5d                   	pop    %ebp
+ 7eb:	c3                   	ret    
+ 7ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000007f0 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 7f0:	f3 0f 1e fb          	endbr32 
+ 7f4:	55                   	push   %ebp
+ 7f5:	89 e5                	mov    %esp,%ebp
+ 7f7:	57                   	push   %edi
+ 7f8:	56                   	push   %esi
+ 7f9:	53                   	push   %ebx
+ 7fa:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 7fd:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+ 800:	8b 3d 5c 0c 00 00    	mov    0xc5c,%edi
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 806:	8d 70 07             	lea    0x7(%eax),%esi
+ 809:	c1 ee 03             	shr    $0x3,%esi
+ 80c:	83 c6 01             	add    $0x1,%esi
+  if((prevp = freep) == 0){
+ 80f:	85 ff                	test   %edi,%edi
+ 811:	0f 84 a9 00 00 00    	je     8c0 <malloc+0xd0>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 817:	8b 07                	mov    (%edi),%eax
+    if(p->s.size >= nunits){
+ 819:	8b 48 04             	mov    0x4(%eax),%ecx
+ 81c:	39 f1                	cmp    %esi,%ecx
+ 81e:	73 6d                	jae    88d <malloc+0x9d>
+ 820:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+ 826:	bb 00 10 00 00       	mov    $0x1000,%ebx
+ 82b:	0f 43 de             	cmovae %esi,%ebx
+  p = sbrk(nu * sizeof(Header));
+ 82e:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
+ 835:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+ 838:	eb 17                	jmp    851 <malloc+0x61>
+ 83a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 840:	8b 10                	mov    (%eax),%edx
+    if(p->s.size >= nunits){
+ 842:	8b 4a 04             	mov    0x4(%edx),%ecx
+ 845:	39 f1                	cmp    %esi,%ecx
+ 847:	73 4f                	jae    898 <malloc+0xa8>
+ 849:	8b 3d 5c 0c 00 00    	mov    0xc5c,%edi
+ 84f:	89 d0                	mov    %edx,%eax
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 851:	39 c7                	cmp    %eax,%edi
+ 853:	75 eb                	jne    840 <malloc+0x50>
+  p = sbrk(nu * sizeof(Header));
+ 855:	83 ec 0c             	sub    $0xc,%esp
+ 858:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 85b:	e8 3b fc ff ff       	call   49b <sbrk>
+  if(p == (char*)-1)
+ 860:	83 c4 10             	add    $0x10,%esp
+ 863:	83 f8 ff             	cmp    $0xffffffff,%eax
+ 866:	74 1b                	je     883 <malloc+0x93>
+  hp->s.size = nu;
+ 868:	89 58 04             	mov    %ebx,0x4(%eax)
+  free((void*)(hp + 1));
+ 86b:	83 ec 0c             	sub    $0xc,%esp
+ 86e:	83 c0 08             	add    $0x8,%eax
+ 871:	50                   	push   %eax
+ 872:	e8 e9 fe ff ff       	call   760 <free>
+  return freep;
+ 877:	a1 5c 0c 00 00       	mov    0xc5c,%eax
+      if((p = morecore(nunits)) == 0)
+ 87c:	83 c4 10             	add    $0x10,%esp
+ 87f:	85 c0                	test   %eax,%eax
+ 881:	75 bd                	jne    840 <malloc+0x50>
+        return 0;
+  }
+}
+ 883:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return 0;
+ 886:	31 c0                	xor    %eax,%eax
+}
+ 888:	5b                   	pop    %ebx
+ 889:	5e                   	pop    %esi
+ 88a:	5f                   	pop    %edi
+ 88b:	5d                   	pop    %ebp
+ 88c:	c3                   	ret    
+    if(p->s.size >= nunits){
+ 88d:	89 c2                	mov    %eax,%edx
+ 88f:	89 f8                	mov    %edi,%eax
+ 891:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+ 898:	39 ce                	cmp    %ecx,%esi
+ 89a:	74 54                	je     8f0 <malloc+0x100>
+        p->s.size -= nunits;
+ 89c:	29 f1                	sub    %esi,%ecx
+ 89e:	89 4a 04             	mov    %ecx,0x4(%edx)
+        p += p->s.size;
+ 8a1:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
+        p->s.size = nunits;
+ 8a4:	89 72 04             	mov    %esi,0x4(%edx)
+      freep = prevp;
+ 8a7:	a3 5c 0c 00 00       	mov    %eax,0xc5c
+}
+ 8ac:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return (void*)(p + 1);
+ 8af:	8d 42 08             	lea    0x8(%edx),%eax
+}
+ 8b2:	5b                   	pop    %ebx
+ 8b3:	5e                   	pop    %esi
+ 8b4:	5f                   	pop    %edi
+ 8b5:	5d                   	pop    %ebp
+ 8b6:	c3                   	ret    
+ 8b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 8be:	66 90                	xchg   %ax,%ax
+    base.s.ptr = freep = prevp = &base;
+ 8c0:	c7 05 5c 0c 00 00 60 	movl   $0xc60,0xc5c
+ 8c7:	0c 00 00 
+    base.s.size = 0;
+ 8ca:	bf 60 0c 00 00       	mov    $0xc60,%edi
+    base.s.ptr = freep = prevp = &base;
+ 8cf:	c7 05 60 0c 00 00 60 	movl   $0xc60,0xc60
+ 8d6:	0c 00 00 
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 8d9:	89 f8                	mov    %edi,%eax
+    base.s.size = 0;
+ 8db:	c7 05 64 0c 00 00 00 	movl   $0x0,0xc64
+ 8e2:	00 00 00 
+    if(p->s.size >= nunits){
+ 8e5:	e9 36 ff ff ff       	jmp    820 <malloc+0x30>
+ 8ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        prevp->s.ptr = p->s.ptr;
+ 8f0:	8b 0a                	mov    (%edx),%ecx
+ 8f2:	89 08                	mov    %ecx,(%eax)
+ 8f4:	eb b1                	jmp    8a7 <malloc+0xb7>
diff -ruN xv6-public/old_thread.c copy-xv6/old_thread.c
--- xv6-public/old_thread.c	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/old_thread.c	2022-09-05 22:14:12.179259301 +0530
@@ -0,0 +1,53 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+struct balance
+{
+    char name[32];
+    int amount;
+};
+volatile int total_balance = 0;
+volatile unsigned int delay(unsigned int d)
+{
+    unsigned int i;
+    for (i = 0; i < d; i++)
+    {
+        __asm volatile("nop" ::
+                           :);
+    }
+    return i;
+}
+void do_work(void *arg)
+{
+    int i;
+    int old;
+    struct balance *b = (struct balance *)arg;
+    printf(1, "Starting do_work: s:%s\n", b->name);
+    for (i = 0; i < b->amount; i++)
+    {
+        // thread_spin_lock(&lock);
+        old = total_balance;
+        delay(100000);
+        total_balance = old + 1;
+        // thread_spin_unlock(&lock);
+    }
+    printf(1, "Done s:%x\n", b->name);
+    thread_exit();
+    return;
+}
+int main(int argc, char *argv[])
+{
+    struct balance b1 = {"b1", 3200};
+    struct balance b2 = {"b2", 2800};
+    void *s1, *s2;
+    int t1, t2, r1, r2;
+    s1 = malloc(4096);
+    s2 = malloc(4096);
+    t1 = thread_create(do_work, (void *)&b1, s1);
+    t2 = thread_create(do_work, (void *)&b2, s2);
+    r1 = thread_join();
+    r2 = thread_join();
+    printf(1, "Threads finished: (%d):%d, (%d):%d, shared balance:%d\n",
+           t1, r1, t2, r2, total_balance);
+    exit();
+}
\ No newline at end of file
diff -ruN xv6-public/old_thread.d copy-xv6/old_thread.d
--- xv6-public/old_thread.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/old_thread.d	2022-09-05 23:26:12.656781078 +0530
@@ -0,0 +1,2 @@
+old_thread.o: old_thread.c /usr/include/stdc-predef.h types.h stat.h \
+ user.h
Binary files xv6-public/old_thread.o and copy-xv6/old_thread.o differ
diff -ruN xv6-public/old_thread.sym copy-xv6/old_thread.sym
--- xv6-public/old_thread.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/old_thread.sym	2022-09-05 23:26:12.668781078 +0530
@@ -0,0 +1,64 @@
+00000000 .text
+000008f8 .rodata
+00000970 .eh_frame
+00000c58 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 old_thread.c
+00000000 ulib.c
+00000000 printf.c
+000004e0 printint
+0000095c digits.1097
+00000000 umalloc.c
+00000c5c freep
+00000c60 base
+000001b0 strcpy
+00000590 printf
+000004cb thread_exit
+000003e0 memmove
+0000045b mknod
+000002d0 gets
+00000493 getpid
+000007f0 malloc
+000004a3 sleep
+00000423 pipe
+00000433 write
+0000046b fstat
+00000443 kill
+00000483 chdir
+0000044b exec
+0000041b wait
+0000042b read
+00000463 unlink
+0000040b fork
+0000049b sbrk
+000004ab uptime
+00000c58 __bss_start
+00000110 do_work
+00000270 memset
+00000000 main
+00000c58 total_balance
+000001e0 strcmp
+0000048b dup
+00000190 delay
+00000350 stat
+00000c58 _edata
+00000c68 _end
+00000473 link
+00000413 exit
+000003a0 atoi
+000004b3 draw
+00000230 strlen
+00000453 open
+00000290 strchr
+000004bb thread_create
+0000047b mkdir
+0000043b close
+000004c3 thread_join
+00000760 free
diff -ruN xv6-public/picirq.d copy-xv6/picirq.d
--- xv6-public/picirq.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/picirq.d	2022-09-05 23:26:13.272781064 +0530
@@ -0,0 +1 @@
+picirq.o: picirq.c /usr/include/stdc-predef.h types.h x86.h traps.h
Binary files xv6-public/picirq.o and copy-xv6/picirq.o differ
diff -ruN xv6-public/pipe.d copy-xv6/pipe.d
--- xv6-public/pipe.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/pipe.d	2022-09-05 23:26:13.312781063 +0530
@@ -0,0 +1,2 @@
+pipe.o: pipe.c /usr/include/stdc-predef.h types.h defs.h param.h mmu.h \
+ proc.h fs.h spinlock.h sleeplock.h file.h
Binary files xv6-public/pipe.o and copy-xv6/pipe.o differ
diff -ruN xv6-public/printf.d copy-xv6/printf.d
--- xv6-public/printf.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/printf.d	2022-09-05 23:26:11.756781094 +0530
@@ -0,0 +1 @@
+printf.o: printf.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/printf.o and copy-xv6/printf.o differ
diff -ruN xv6-public/proc.c copy-xv6/proc.c
--- xv6-public/proc.c	2022-09-05 23:23:48.536715198 +0530
+++ copy-xv6/proc.c	2022-09-05 21:29:56.962948230 +0530
@@ -376,6 +376,7 @@
     panic("sched running");
   if(readeflags()&FL_IF)
     panic("sched interruptible");
+    
   intena = mycpu()->intena;
   swtch(&p->context, mycpu()->scheduler);
   mycpu()->intena = intena;
@@ -532,3 +533,182 @@
     cprintf("\n");
   }
 }
+
+struct tls {
+  int tid;
+  // char myLetter;
+};
+//also refer to 2500 void userinit(void)
+
+	  /*
+	  The thread_create() call should behave very much like fork,
+	  except that instead of copying the address space to a new page directory,
+	  clone initializes the new process so that the new process
+	  and cloned process use the same page directory.
+	  Thus, memory will be shared, and the two "processes" are really actually threads.
+	   */
+    	  //Arg should behave like a normal argument to a normal function, where do we put arguments?
+	  //On the  stack, but on the user stack, not kernel.
+//You should just set user's eip to start execution from *fcn.
+	  //you should set it in the trapframe --
+	  //that's the eip that the kernel restores before exiting back into the process
+	  //The new thread starts executing at the address specified by fcn .
+int thread_create(void(*fcn)(void*), void *arg, void *stack)
+{
+
+	  int i, pid;
+	  struct proc *nt;
+	  struct proc *curproc = myproc();
+
+    //Allocate thread.
+	  if((nt = allocproc()) == 0){
+	    return -1;
+	  }
+
+
+	  //just make up a flag saying that this entry is a thread.
+	  nt->thread = 1;
+    //pagedir is shared hence unlike fork, we do not copy it.
+	  nt->pgdir = curproc->pgdir;
+    //setting size and trapframe of new thread from parent process.
+	  nt->sz = curproc->sz;
+	  nt->parent = curproc;
+	  *nt->tf = *curproc->tf;
+	  
+	  uint sp; //stack pointer
+    //creating user stack.
+    uint ustack[2];
+
+    //making sure stack is one page in size
+	  sp = (uint)stack + PGSIZE;
+	  memset((char*)stack, 0, PGSIZE); //main may recycle stack page, so need to clear it first
+
+    // tls is a small structure holding thread information like thread id and index, held at the top of every stack created.
+	  struct tls t;
+	  t.tid = nt->pid - curproc->pid - 1; //tid starts from 0
+	  sp -= sizeof(struct tls);
+	  memmove((char*)sp, (char*)&t, sizeof(struct tls));
+
+    //passing fake return PC to user stack
+	  ustack[0] = 0xffffffff; 
+
+    //passing arg to user stack
+	  ustack[1] = (uint)arg;
+	  //void do_work(void *arg)
+	  sp -= 2*4;
+	  if(copyout(nt->pgdir, sp, ustack, 2*4) < 0) return -1;
+
+	  //initialize thread's stack pointer
+	  nt->tf->esp = sp;
+
+	  // Clear %eax so that fork returns 0 in the child.
+	  //np->tf->eax = 0;
+    //setting the instruction pointer to fcn from where the execution begins
+	  nt->tf->eip = (uint)fcn;
+
+	  //we will copy file descriptors in the same manner fork() does it.
+	  for(i = 0; i < NOFILE; i++)
+	    if(curproc->ofile[i])
+	      nt->ofile[i] = filedup(curproc->ofile[i]);
+
+    //setting new thread's current working dfirectory to the same directory as the parent process.
+	  nt->cwd = idup(curproc->cwd);
+	  safestrcpy(nt->name, curproc->name, sizeof(nt->name));
+	  pid = nt->pid;
+
+	  acquire(&ptable.lock);
+
+	  nt->state = RUNNABLE;
+
+	  release(&ptable.lock);
+
+	  //As with fork(), the PID of the new thread is returned to the parent.
+	  return pid;
+}
+
+int thread_join(void){
+
+	  struct proc *p;
+	  int havekids, pid;
+	  struct proc *curproc = myproc();
+
+	  acquire(&ptable.lock);
+
+	  for(;;){
+	    // Scan through table looking for exited children.
+	    havekids = 0;
+	    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+	      if(p->parent != curproc || p->thread != 1)
+	        continue;
+	      havekids = 1;
+	      if(p->state == ZOMBIE){
+	        // Found one.
+	        pid = p->pid;
+	        kfree(p->kstack);
+	        p->kstack = 0;
+	        p->pgdir = 0;;//slight change here.
+	        p->pid = 0;
+	        p->parent = 0;
+	        p->name[0] = 0;
+	        p->killed = 0;
+	        p->state = UNUSED;
+	        p->thread = 0;
+	        release(&ptable.lock);
+	        return pid;
+	      }
+	    }
+
+	    // No point waiting if we don't have any children.
+	    if(!havekids || curproc->killed){
+	      release(&ptable.lock);
+	      return -1;
+	    }
+
+	    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+	    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+	  }
+
+	  return -1;
+}
+
+void thread_exit(){
+
+	  struct proc *curproc = myproc();
+	  struct proc *p;
+	  int fd;
+
+    if(curproc == initproc)
+      panic("init exiting");
+
+	  // Close all open files.
+	  for(fd = 0; fd < NOFILE; fd++){
+	    if(curproc->ofile[fd]){
+	      fileclose(curproc->ofile[fd]);
+	      curproc->ofile[fd] = 0;
+	    }
+	  }
+
+	  begin_op();
+	  iput(curproc->cwd);
+	  end_op();
+	  curproc->cwd = 0;
+
+	  acquire(&ptable.lock);
+
+	  // Parent might be sleeping in wait().
+	  wakeup1(curproc->parent);
+
+	  // Pass abandoned children to init.
+	  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+	    if(p->parent == curproc){
+	      p->parent = initproc;
+	      if(p->state == ZOMBIE)
+	        wakeup1(initproc);
+	    }
+	  }
+
+	  // Jump into the scheduler, never to return.
+	  curproc->state = ZOMBIE;
+	  sched();
+	  panic("zombie exit");
+}
\ No newline at end of file
diff -ruN xv6-public/proc.d copy-xv6/proc.d
--- xv6-public/proc.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/proc.d	2022-09-05 23:26:13.412781060 +0530
@@ -0,0 +1,2 @@
+proc.o: proc.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h x86.h proc.h spinlock.h
diff -ruN xv6-public/proc.h copy-xv6/proc.h
--- xv6-public/proc.h	2022-09-05 23:23:48.536715198 +0530
+++ copy-xv6/proc.h	2022-09-04 18:08:24.619928932 +0530
@@ -49,6 +49,7 @@
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int thread; 
 };
 
 // Process memory is laid out contiguously, low addresses first:
Binary files xv6-public/proc.o and copy-xv6/proc.o differ
Binary files xv6-public/_rm and copy-xv6/_rm differ
diff -ruN xv6-public/rm.asm copy-xv6/rm.asm
--- xv6-public/rm.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/rm.asm	2022-09-05 23:26:12.100781089 +0530
@@ -0,0 +1,1238 @@
+
+_rm:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	57                   	push   %edi
+  12:	bf 01 00 00 00       	mov    $0x1,%edi
+  17:	56                   	push   %esi
+  18:	53                   	push   %ebx
+  19:	51                   	push   %ecx
+  1a:	83 ec 08             	sub    $0x8,%esp
+  1d:	8b 59 04             	mov    0x4(%ecx),%ebx
+  20:	8b 31                	mov    (%ecx),%esi
+  22:	83 c3 04             	add    $0x4,%ebx
+  int i;
+
+  if(argc < 2){
+  25:	83 fe 01             	cmp    $0x1,%esi
+  28:	7e 3a                	jle    64 <main+0x64>
+  2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    printf(2, "Usage: rm files...\n");
+    exit();
+  }
+
+  for(i = 1; i < argc; i++){
+    if(unlink(argv[i]) < 0){
+  30:	83 ec 0c             	sub    $0xc,%esp
+  33:	ff 33                	pushl  (%ebx)
+  35:	e8 f9 02 00 00       	call   333 <unlink>
+  3a:	83 c4 10             	add    $0x10,%esp
+  3d:	85 c0                	test   %eax,%eax
+  3f:	78 0f                	js     50 <main+0x50>
+  for(i = 1; i < argc; i++){
+  41:	83 c7 01             	add    $0x1,%edi
+  44:	83 c3 04             	add    $0x4,%ebx
+  47:	39 fe                	cmp    %edi,%esi
+  49:	75 e5                	jne    30 <main+0x30>
+      printf(2, "rm: %s failed to delete\n", argv[i]);
+      break;
+    }
+  }
+
+  exit();
+  4b:	e8 93 02 00 00       	call   2e3 <exit>
+      printf(2, "rm: %s failed to delete\n", argv[i]);
+  50:	50                   	push   %eax
+  51:	ff 33                	pushl  (%ebx)
+  53:	68 dc 07 00 00       	push   $0x7dc
+  58:	6a 02                	push   $0x2
+  5a:	e8 01 04 00 00       	call   460 <printf>
+      break;
+  5f:	83 c4 10             	add    $0x10,%esp
+  62:	eb e7                	jmp    4b <main+0x4b>
+    printf(2, "Usage: rm files...\n");
+  64:	52                   	push   %edx
+  65:	52                   	push   %edx
+  66:	68 c8 07 00 00       	push   $0x7c8
+  6b:	6a 02                	push   $0x2
+  6d:	e8 ee 03 00 00       	call   460 <printf>
+    exit();
+  72:	e8 6c 02 00 00       	call   2e3 <exit>
+  77:	66 90                	xchg   %ax,%ax
+  79:	66 90                	xchg   %ax,%ax
+  7b:	66 90                	xchg   %ax,%ax
+  7d:	66 90                	xchg   %ax,%ax
+  7f:	90                   	nop
+
+00000080 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+  80:	f3 0f 1e fb          	endbr32 
+  84:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  85:	31 c0                	xor    %eax,%eax
+{
+  87:	89 e5                	mov    %esp,%ebp
+  89:	53                   	push   %ebx
+  8a:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  8d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+  90:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+  94:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+  97:	83 c0 01             	add    $0x1,%eax
+  9a:	84 d2                	test   %dl,%dl
+  9c:	75 f2                	jne    90 <strcpy+0x10>
+    ;
+  return os;
+}
+  9e:	89 c8                	mov    %ecx,%eax
+  a0:	5b                   	pop    %ebx
+  a1:	5d                   	pop    %ebp
+  a2:	c3                   	ret    
+  a3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000000b0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  b0:	f3 0f 1e fb          	endbr32 
+  b4:	55                   	push   %ebp
+  b5:	89 e5                	mov    %esp,%ebp
+  b7:	53                   	push   %ebx
+  b8:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  bb:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+  be:	0f b6 01             	movzbl (%ecx),%eax
+  c1:	0f b6 1a             	movzbl (%edx),%ebx
+  c4:	84 c0                	test   %al,%al
+  c6:	75 19                	jne    e1 <strcmp+0x31>
+  c8:	eb 26                	jmp    f0 <strcmp+0x40>
+  ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  d0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+  d4:	83 c1 01             	add    $0x1,%ecx
+  d7:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+  da:	0f b6 1a             	movzbl (%edx),%ebx
+  dd:	84 c0                	test   %al,%al
+  df:	74 0f                	je     f0 <strcmp+0x40>
+  e1:	38 d8                	cmp    %bl,%al
+  e3:	74 eb                	je     d0 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+  e5:	29 d8                	sub    %ebx,%eax
+}
+  e7:	5b                   	pop    %ebx
+  e8:	5d                   	pop    %ebp
+  e9:	c3                   	ret    
+  ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  f0:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+  f2:	29 d8                	sub    %ebx,%eax
+}
+  f4:	5b                   	pop    %ebx
+  f5:	5d                   	pop    %ebp
+  f6:	c3                   	ret    
+  f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  fe:	66 90                	xchg   %ax,%ax
+
+00000100 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 100:	f3 0f 1e fb          	endbr32 
+ 104:	55                   	push   %ebp
+ 105:	89 e5                	mov    %esp,%ebp
+ 107:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 10a:	80 3a 00             	cmpb   $0x0,(%edx)
+ 10d:	74 21                	je     130 <strlen+0x30>
+ 10f:	31 c0                	xor    %eax,%eax
+ 111:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 118:	83 c0 01             	add    $0x1,%eax
+ 11b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+ 11f:	89 c1                	mov    %eax,%ecx
+ 121:	75 f5                	jne    118 <strlen+0x18>
+    ;
+  return n;
+}
+ 123:	89 c8                	mov    %ecx,%eax
+ 125:	5d                   	pop    %ebp
+ 126:	c3                   	ret    
+ 127:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 12e:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+ 130:	31 c9                	xor    %ecx,%ecx
+}
+ 132:	5d                   	pop    %ebp
+ 133:	89 c8                	mov    %ecx,%eax
+ 135:	c3                   	ret    
+ 136:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 13d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000140 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 140:	f3 0f 1e fb          	endbr32 
+ 144:	55                   	push   %ebp
+ 145:	89 e5                	mov    %esp,%ebp
+ 147:	57                   	push   %edi
+ 148:	8b 55 08             	mov    0x8(%ebp),%edx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+ 14b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 14e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 151:	89 d7                	mov    %edx,%edi
+ 153:	fc                   	cld    
+ 154:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+ 156:	89 d0                	mov    %edx,%eax
+ 158:	5f                   	pop    %edi
+ 159:	5d                   	pop    %ebp
+ 15a:	c3                   	ret    
+ 15b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 15f:	90                   	nop
+
+00000160 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 160:	f3 0f 1e fb          	endbr32 
+ 164:	55                   	push   %ebp
+ 165:	89 e5                	mov    %esp,%ebp
+ 167:	8b 45 08             	mov    0x8(%ebp),%eax
+ 16a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+ 16e:	0f b6 10             	movzbl (%eax),%edx
+ 171:	84 d2                	test   %dl,%dl
+ 173:	75 16                	jne    18b <strchr+0x2b>
+ 175:	eb 21                	jmp    198 <strchr+0x38>
+ 177:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 17e:	66 90                	xchg   %ax,%ax
+ 180:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+ 184:	83 c0 01             	add    $0x1,%eax
+ 187:	84 d2                	test   %dl,%dl
+ 189:	74 0d                	je     198 <strchr+0x38>
+    if(*s == c)
+ 18b:	38 d1                	cmp    %dl,%cl
+ 18d:	75 f1                	jne    180 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+ 18f:	5d                   	pop    %ebp
+ 190:	c3                   	ret    
+ 191:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+ 198:	31 c0                	xor    %eax,%eax
+}
+ 19a:	5d                   	pop    %ebp
+ 19b:	c3                   	ret    
+ 19c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000001a0 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 1a0:	f3 0f 1e fb          	endbr32 
+ 1a4:	55                   	push   %ebp
+ 1a5:	89 e5                	mov    %esp,%ebp
+ 1a7:	57                   	push   %edi
+ 1a8:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1a9:	31 f6                	xor    %esi,%esi
+{
+ 1ab:	53                   	push   %ebx
+ 1ac:	89 f3                	mov    %esi,%ebx
+ 1ae:	83 ec 1c             	sub    $0x1c,%esp
+ 1b1:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+ 1b4:	eb 33                	jmp    1e9 <gets+0x49>
+ 1b6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1bd:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+ 1c0:	83 ec 04             	sub    $0x4,%esp
+ 1c3:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ 1c6:	6a 01                	push   $0x1
+ 1c8:	50                   	push   %eax
+ 1c9:	6a 00                	push   $0x0
+ 1cb:	e8 2b 01 00 00       	call   2fb <read>
+    if(cc < 1)
+ 1d0:	83 c4 10             	add    $0x10,%esp
+ 1d3:	85 c0                	test   %eax,%eax
+ 1d5:	7e 1c                	jle    1f3 <gets+0x53>
+      break;
+    buf[i++] = c;
+ 1d7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ 1db:	83 c7 01             	add    $0x1,%edi
+ 1de:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+ 1e1:	3c 0a                	cmp    $0xa,%al
+ 1e3:	74 23                	je     208 <gets+0x68>
+ 1e5:	3c 0d                	cmp    $0xd,%al
+ 1e7:	74 1f                	je     208 <gets+0x68>
+  for(i=0; i+1 < max; ){
+ 1e9:	83 c3 01             	add    $0x1,%ebx
+ 1ec:	89 fe                	mov    %edi,%esi
+ 1ee:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+ 1f1:	7c cd                	jl     1c0 <gets+0x20>
+ 1f3:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+ 1f5:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+ 1f8:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 1fb:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 1fe:	5b                   	pop    %ebx
+ 1ff:	5e                   	pop    %esi
+ 200:	5f                   	pop    %edi
+ 201:	5d                   	pop    %ebp
+ 202:	c3                   	ret    
+ 203:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 207:	90                   	nop
+ 208:	8b 75 08             	mov    0x8(%ebp),%esi
+ 20b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 20e:	01 de                	add    %ebx,%esi
+ 210:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+ 212:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 215:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 218:	5b                   	pop    %ebx
+ 219:	5e                   	pop    %esi
+ 21a:	5f                   	pop    %edi
+ 21b:	5d                   	pop    %ebp
+ 21c:	c3                   	ret    
+ 21d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000220 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 220:	f3 0f 1e fb          	endbr32 
+ 224:	55                   	push   %ebp
+ 225:	89 e5                	mov    %esp,%ebp
+ 227:	56                   	push   %esi
+ 228:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 229:	83 ec 08             	sub    $0x8,%esp
+ 22c:	6a 00                	push   $0x0
+ 22e:	ff 75 08             	pushl  0x8(%ebp)
+ 231:	e8 ed 00 00 00       	call   323 <open>
+  if(fd < 0)
+ 236:	83 c4 10             	add    $0x10,%esp
+ 239:	85 c0                	test   %eax,%eax
+ 23b:	78 2b                	js     268 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+ 23d:	83 ec 08             	sub    $0x8,%esp
+ 240:	ff 75 0c             	pushl  0xc(%ebp)
+ 243:	89 c3                	mov    %eax,%ebx
+ 245:	50                   	push   %eax
+ 246:	e8 f0 00 00 00       	call   33b <fstat>
+  close(fd);
+ 24b:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+ 24e:	89 c6                	mov    %eax,%esi
+  close(fd);
+ 250:	e8 b6 00 00 00       	call   30b <close>
+  return r;
+ 255:	83 c4 10             	add    $0x10,%esp
+}
+ 258:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 25b:	89 f0                	mov    %esi,%eax
+ 25d:	5b                   	pop    %ebx
+ 25e:	5e                   	pop    %esi
+ 25f:	5d                   	pop    %ebp
+ 260:	c3                   	ret    
+ 261:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+ 268:	be ff ff ff ff       	mov    $0xffffffff,%esi
+ 26d:	eb e9                	jmp    258 <stat+0x38>
+ 26f:	90                   	nop
+
+00000270 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 270:	f3 0f 1e fb          	endbr32 
+ 274:	55                   	push   %ebp
+ 275:	89 e5                	mov    %esp,%ebp
+ 277:	53                   	push   %ebx
+ 278:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 27b:	0f be 02             	movsbl (%edx),%eax
+ 27e:	8d 48 d0             	lea    -0x30(%eax),%ecx
+ 281:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+ 284:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+ 289:	77 1a                	ja     2a5 <atoi+0x35>
+ 28b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 28f:	90                   	nop
+    n = n*10 + *s++ - '0';
+ 290:	83 c2 01             	add    $0x1,%edx
+ 293:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+ 296:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+ 29a:	0f be 02             	movsbl (%edx),%eax
+ 29d:	8d 58 d0             	lea    -0x30(%eax),%ebx
+ 2a0:	80 fb 09             	cmp    $0x9,%bl
+ 2a3:	76 eb                	jbe    290 <atoi+0x20>
+  return n;
+}
+ 2a5:	89 c8                	mov    %ecx,%eax
+ 2a7:	5b                   	pop    %ebx
+ 2a8:	5d                   	pop    %ebp
+ 2a9:	c3                   	ret    
+ 2aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000002b0 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 2b0:	f3 0f 1e fb          	endbr32 
+ 2b4:	55                   	push   %ebp
+ 2b5:	89 e5                	mov    %esp,%ebp
+ 2b7:	57                   	push   %edi
+ 2b8:	8b 45 10             	mov    0x10(%ebp),%eax
+ 2bb:	8b 55 08             	mov    0x8(%ebp),%edx
+ 2be:	56                   	push   %esi
+ 2bf:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 2c2:	85 c0                	test   %eax,%eax
+ 2c4:	7e 0f                	jle    2d5 <memmove+0x25>
+ 2c6:	01 d0                	add    %edx,%eax
+  dst = vdst;
+ 2c8:	89 d7                	mov    %edx,%edi
+ 2ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+ 2d0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+ 2d1:	39 f8                	cmp    %edi,%eax
+ 2d3:	75 fb                	jne    2d0 <memmove+0x20>
+  return vdst;
+}
+ 2d5:	5e                   	pop    %esi
+ 2d6:	89 d0                	mov    %edx,%eax
+ 2d8:	5f                   	pop    %edi
+ 2d9:	5d                   	pop    %ebp
+ 2da:	c3                   	ret    
+
+000002db <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 2db:	b8 01 00 00 00       	mov    $0x1,%eax
+ 2e0:	cd 40                	int    $0x40
+ 2e2:	c3                   	ret    
+
+000002e3 <exit>:
+SYSCALL(exit)
+ 2e3:	b8 02 00 00 00       	mov    $0x2,%eax
+ 2e8:	cd 40                	int    $0x40
+ 2ea:	c3                   	ret    
+
+000002eb <wait>:
+SYSCALL(wait)
+ 2eb:	b8 03 00 00 00       	mov    $0x3,%eax
+ 2f0:	cd 40                	int    $0x40
+ 2f2:	c3                   	ret    
+
+000002f3 <pipe>:
+SYSCALL(pipe)
+ 2f3:	b8 04 00 00 00       	mov    $0x4,%eax
+ 2f8:	cd 40                	int    $0x40
+ 2fa:	c3                   	ret    
+
+000002fb <read>:
+SYSCALL(read)
+ 2fb:	b8 05 00 00 00       	mov    $0x5,%eax
+ 300:	cd 40                	int    $0x40
+ 302:	c3                   	ret    
+
+00000303 <write>:
+SYSCALL(write)
+ 303:	b8 10 00 00 00       	mov    $0x10,%eax
+ 308:	cd 40                	int    $0x40
+ 30a:	c3                   	ret    
+
+0000030b <close>:
+SYSCALL(close)
+ 30b:	b8 15 00 00 00       	mov    $0x15,%eax
+ 310:	cd 40                	int    $0x40
+ 312:	c3                   	ret    
+
+00000313 <kill>:
+SYSCALL(kill)
+ 313:	b8 06 00 00 00       	mov    $0x6,%eax
+ 318:	cd 40                	int    $0x40
+ 31a:	c3                   	ret    
+
+0000031b <exec>:
+SYSCALL(exec)
+ 31b:	b8 07 00 00 00       	mov    $0x7,%eax
+ 320:	cd 40                	int    $0x40
+ 322:	c3                   	ret    
+
+00000323 <open>:
+SYSCALL(open)
+ 323:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 328:	cd 40                	int    $0x40
+ 32a:	c3                   	ret    
+
+0000032b <mknod>:
+SYSCALL(mknod)
+ 32b:	b8 11 00 00 00       	mov    $0x11,%eax
+ 330:	cd 40                	int    $0x40
+ 332:	c3                   	ret    
+
+00000333 <unlink>:
+SYSCALL(unlink)
+ 333:	b8 12 00 00 00       	mov    $0x12,%eax
+ 338:	cd 40                	int    $0x40
+ 33a:	c3                   	ret    
+
+0000033b <fstat>:
+SYSCALL(fstat)
+ 33b:	b8 08 00 00 00       	mov    $0x8,%eax
+ 340:	cd 40                	int    $0x40
+ 342:	c3                   	ret    
+
+00000343 <link>:
+SYSCALL(link)
+ 343:	b8 13 00 00 00       	mov    $0x13,%eax
+ 348:	cd 40                	int    $0x40
+ 34a:	c3                   	ret    
+
+0000034b <mkdir>:
+SYSCALL(mkdir)
+ 34b:	b8 14 00 00 00       	mov    $0x14,%eax
+ 350:	cd 40                	int    $0x40
+ 352:	c3                   	ret    
+
+00000353 <chdir>:
+SYSCALL(chdir)
+ 353:	b8 09 00 00 00       	mov    $0x9,%eax
+ 358:	cd 40                	int    $0x40
+ 35a:	c3                   	ret    
+
+0000035b <dup>:
+SYSCALL(dup)
+ 35b:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 360:	cd 40                	int    $0x40
+ 362:	c3                   	ret    
+
+00000363 <getpid>:
+SYSCALL(getpid)
+ 363:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 368:	cd 40                	int    $0x40
+ 36a:	c3                   	ret    
+
+0000036b <sbrk>:
+SYSCALL(sbrk)
+ 36b:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 370:	cd 40                	int    $0x40
+ 372:	c3                   	ret    
+
+00000373 <sleep>:
+SYSCALL(sleep)
+ 373:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 378:	cd 40                	int    $0x40
+ 37a:	c3                   	ret    
+
+0000037b <uptime>:
+SYSCALL(uptime)
+ 37b:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 380:	cd 40                	int    $0x40
+ 382:	c3                   	ret    
+
+00000383 <draw>:
+SYSCALL(draw)
+ 383:	b8 16 00 00 00       	mov    $0x16,%eax
+ 388:	cd 40                	int    $0x40
+ 38a:	c3                   	ret    
+
+0000038b <thread_create>:
+
+SYSCALL(thread_create)
+ 38b:	b8 17 00 00 00       	mov    $0x17,%eax
+ 390:	cd 40                	int    $0x40
+ 392:	c3                   	ret    
+
+00000393 <thread_join>:
+SYSCALL(thread_join)
+ 393:	b8 18 00 00 00       	mov    $0x18,%eax
+ 398:	cd 40                	int    $0x40
+ 39a:	c3                   	ret    
+
+0000039b <thread_exit>:
+SYSCALL(thread_exit)
+ 39b:	b8 19 00 00 00       	mov    $0x19,%eax
+ 3a0:	cd 40                	int    $0x40
+ 3a2:	c3                   	ret    
+ 3a3:	66 90                	xchg   %ax,%ax
+ 3a5:	66 90                	xchg   %ax,%ax
+ 3a7:	66 90                	xchg   %ax,%ax
+ 3a9:	66 90                	xchg   %ax,%ax
+ 3ab:	66 90                	xchg   %ax,%ax
+ 3ad:	66 90                	xchg   %ax,%ax
+ 3af:	90                   	nop
+
+000003b0 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 3b0:	55                   	push   %ebp
+ 3b1:	89 e5                	mov    %esp,%ebp
+ 3b3:	57                   	push   %edi
+ 3b4:	56                   	push   %esi
+ 3b5:	53                   	push   %ebx
+ 3b6:	83 ec 3c             	sub    $0x3c,%esp
+ 3b9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+ 3bc:	89 d1                	mov    %edx,%ecx
+{
+ 3be:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  if(sgn && xx < 0){
+ 3c1:	85 d2                	test   %edx,%edx
+ 3c3:	0f 89 7f 00 00 00    	jns    448 <printint+0x98>
+ 3c9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
+ 3cd:	74 79                	je     448 <printint+0x98>
+    neg = 1;
+ 3cf:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+    x = -xx;
+ 3d6:	f7 d9                	neg    %ecx
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 3d8:	31 db                	xor    %ebx,%ebx
+ 3da:	8d 75 d7             	lea    -0x29(%ebp),%esi
+ 3dd:	8d 76 00             	lea    0x0(%esi),%esi
+  do{
+    buf[i++] = digits[x % base];
+ 3e0:	89 c8                	mov    %ecx,%eax
+ 3e2:	31 d2                	xor    %edx,%edx
+ 3e4:	89 cf                	mov    %ecx,%edi
+ 3e6:	f7 75 c4             	divl   -0x3c(%ebp)
+ 3e9:	0f b6 92 fc 07 00 00 	movzbl 0x7fc(%edx),%edx
+ 3f0:	89 45 c0             	mov    %eax,-0x40(%ebp)
+ 3f3:	89 d8                	mov    %ebx,%eax
+ 3f5:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+ 3f8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+    buf[i++] = digits[x % base];
+ 3fb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
+  }while((x /= base) != 0);
+ 3fe:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
+ 401:	76 dd                	jbe    3e0 <printint+0x30>
+  if(neg)
+ 403:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+ 406:	85 c9                	test   %ecx,%ecx
+ 408:	74 0c                	je     416 <printint+0x66>
+    buf[i++] = '-';
+ 40a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+ 40f:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+ 411:	ba 2d 00 00 00       	mov    $0x2d,%edx
+
+  while(--i >= 0)
+ 416:	8b 7d b8             	mov    -0x48(%ebp),%edi
+ 419:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+ 41d:	eb 07                	jmp    426 <printint+0x76>
+ 41f:	90                   	nop
+ 420:	0f b6 13             	movzbl (%ebx),%edx
+ 423:	83 eb 01             	sub    $0x1,%ebx
+  write(fd, &c, 1);
+ 426:	83 ec 04             	sub    $0x4,%esp
+ 429:	88 55 d7             	mov    %dl,-0x29(%ebp)
+ 42c:	6a 01                	push   $0x1
+ 42e:	56                   	push   %esi
+ 42f:	57                   	push   %edi
+ 430:	e8 ce fe ff ff       	call   303 <write>
+  while(--i >= 0)
+ 435:	83 c4 10             	add    $0x10,%esp
+ 438:	39 de                	cmp    %ebx,%esi
+ 43a:	75 e4                	jne    420 <printint+0x70>
+    putc(fd, buf[i]);
+}
+ 43c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 43f:	5b                   	pop    %ebx
+ 440:	5e                   	pop    %esi
+ 441:	5f                   	pop    %edi
+ 442:	5d                   	pop    %ebp
+ 443:	c3                   	ret    
+ 444:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  neg = 0;
+ 448:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+ 44f:	eb 87                	jmp    3d8 <printint+0x28>
+ 451:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 458:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 45f:	90                   	nop
+
+00000460 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 460:	f3 0f 1e fb          	endbr32 
+ 464:	55                   	push   %ebp
+ 465:	89 e5                	mov    %esp,%ebp
+ 467:	57                   	push   %edi
+ 468:	56                   	push   %esi
+ 469:	53                   	push   %ebx
+ 46a:	83 ec 2c             	sub    $0x2c,%esp
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 46d:	8b 75 0c             	mov    0xc(%ebp),%esi
+ 470:	0f b6 1e             	movzbl (%esi),%ebx
+ 473:	84 db                	test   %bl,%bl
+ 475:	0f 84 b4 00 00 00    	je     52f <printf+0xcf>
+  ap = (uint*)(void*)&fmt + 1;
+ 47b:	8d 45 10             	lea    0x10(%ebp),%eax
+ 47e:	83 c6 01             	add    $0x1,%esi
+  write(fd, &c, 1);
+ 481:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  state = 0;
+ 484:	31 d2                	xor    %edx,%edx
+  ap = (uint*)(void*)&fmt + 1;
+ 486:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 489:	eb 33                	jmp    4be <printf+0x5e>
+ 48b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 48f:	90                   	nop
+ 490:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+ 493:	ba 25 00 00 00       	mov    $0x25,%edx
+      if(c == '%'){
+ 498:	83 f8 25             	cmp    $0x25,%eax
+ 49b:	74 17                	je     4b4 <printf+0x54>
+  write(fd, &c, 1);
+ 49d:	83 ec 04             	sub    $0x4,%esp
+ 4a0:	88 5d e7             	mov    %bl,-0x19(%ebp)
+ 4a3:	6a 01                	push   $0x1
+ 4a5:	57                   	push   %edi
+ 4a6:	ff 75 08             	pushl  0x8(%ebp)
+ 4a9:	e8 55 fe ff ff       	call   303 <write>
+ 4ae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+      } else {
+        putc(fd, c);
+ 4b1:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; fmt[i]; i++){
+ 4b4:	0f b6 1e             	movzbl (%esi),%ebx
+ 4b7:	83 c6 01             	add    $0x1,%esi
+ 4ba:	84 db                	test   %bl,%bl
+ 4bc:	74 71                	je     52f <printf+0xcf>
+    c = fmt[i] & 0xff;
+ 4be:	0f be cb             	movsbl %bl,%ecx
+ 4c1:	0f b6 c3             	movzbl %bl,%eax
+    if(state == 0){
+ 4c4:	85 d2                	test   %edx,%edx
+ 4c6:	74 c8                	je     490 <printf+0x30>
+      }
+    } else if(state == '%'){
+ 4c8:	83 fa 25             	cmp    $0x25,%edx
+ 4cb:	75 e7                	jne    4b4 <printf+0x54>
+      if(c == 'd'){
+ 4cd:	83 f8 64             	cmp    $0x64,%eax
+ 4d0:	0f 84 9a 00 00 00    	je     570 <printf+0x110>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+ 4d6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
+ 4dc:	83 f9 70             	cmp    $0x70,%ecx
+ 4df:	74 5f                	je     540 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+ 4e1:	83 f8 73             	cmp    $0x73,%eax
+ 4e4:	0f 84 d6 00 00 00    	je     5c0 <printf+0x160>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 4ea:	83 f8 63             	cmp    $0x63,%eax
+ 4ed:	0f 84 8d 00 00 00    	je     580 <printf+0x120>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+ 4f3:	83 f8 25             	cmp    $0x25,%eax
+ 4f6:	0f 84 b4 00 00 00    	je     5b0 <printf+0x150>
+  write(fd, &c, 1);
+ 4fc:	83 ec 04             	sub    $0x4,%esp
+ 4ff:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
+ 503:	6a 01                	push   $0x1
+ 505:	57                   	push   %edi
+ 506:	ff 75 08             	pushl  0x8(%ebp)
+ 509:	e8 f5 fd ff ff       	call   303 <write>
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+ 50e:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 511:	83 c4 0c             	add    $0xc,%esp
+ 514:	6a 01                	push   $0x1
+ 516:	83 c6 01             	add    $0x1,%esi
+ 519:	57                   	push   %edi
+ 51a:	ff 75 08             	pushl  0x8(%ebp)
+ 51d:	e8 e1 fd ff ff       	call   303 <write>
+  for(i = 0; fmt[i]; i++){
+ 522:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
+        putc(fd, c);
+ 526:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 529:	31 d2                	xor    %edx,%edx
+  for(i = 0; fmt[i]; i++){
+ 52b:	84 db                	test   %bl,%bl
+ 52d:	75 8f                	jne    4be <printf+0x5e>
+    }
+  }
+}
+ 52f:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 532:	5b                   	pop    %ebx
+ 533:	5e                   	pop    %esi
+ 534:	5f                   	pop    %edi
+ 535:	5d                   	pop    %ebp
+ 536:	c3                   	ret    
+ 537:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 53e:	66 90                	xchg   %ax,%ax
+        printint(fd, *ap, 16, 0);
+ 540:	83 ec 0c             	sub    $0xc,%esp
+ 543:	b9 10 00 00 00       	mov    $0x10,%ecx
+ 548:	6a 00                	push   $0x0
+ 54a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+ 54d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 550:	8b 13                	mov    (%ebx),%edx
+ 552:	e8 59 fe ff ff       	call   3b0 <printint>
+        ap++;
+ 557:	89 d8                	mov    %ebx,%eax
+ 559:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 55c:	31 d2                	xor    %edx,%edx
+        ap++;
+ 55e:	83 c0 04             	add    $0x4,%eax
+ 561:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 564:	e9 4b ff ff ff       	jmp    4b4 <printf+0x54>
+ 569:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        printint(fd, *ap, 10, 1);
+ 570:	83 ec 0c             	sub    $0xc,%esp
+ 573:	b9 0a 00 00 00       	mov    $0xa,%ecx
+ 578:	6a 01                	push   $0x1
+ 57a:	eb ce                	jmp    54a <printf+0xea>
+ 57c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        putc(fd, *ap);
+ 580:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+  write(fd, &c, 1);
+ 583:	83 ec 04             	sub    $0x4,%esp
+        putc(fd, *ap);
+ 586:	8b 03                	mov    (%ebx),%eax
+  write(fd, &c, 1);
+ 588:	6a 01                	push   $0x1
+        ap++;
+ 58a:	83 c3 04             	add    $0x4,%ebx
+  write(fd, &c, 1);
+ 58d:	57                   	push   %edi
+ 58e:	ff 75 08             	pushl  0x8(%ebp)
+        putc(fd, *ap);
+ 591:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 594:	e8 6a fd ff ff       	call   303 <write>
+        ap++;
+ 599:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+ 59c:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 59f:	31 d2                	xor    %edx,%edx
+ 5a1:	e9 0e ff ff ff       	jmp    4b4 <printf+0x54>
+ 5a6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 5ad:	8d 76 00             	lea    0x0(%esi),%esi
+        putc(fd, c);
+ 5b0:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 5b3:	83 ec 04             	sub    $0x4,%esp
+ 5b6:	e9 59 ff ff ff       	jmp    514 <printf+0xb4>
+ 5bb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 5bf:	90                   	nop
+        s = (char*)*ap;
+ 5c0:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 5c3:	8b 18                	mov    (%eax),%ebx
+        ap++;
+ 5c5:	83 c0 04             	add    $0x4,%eax
+ 5c8:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        if(s == 0)
+ 5cb:	85 db                	test   %ebx,%ebx
+ 5cd:	74 17                	je     5e6 <printf+0x186>
+        while(*s != 0){
+ 5cf:	0f b6 03             	movzbl (%ebx),%eax
+      state = 0;
+ 5d2:	31 d2                	xor    %edx,%edx
+        while(*s != 0){
+ 5d4:	84 c0                	test   %al,%al
+ 5d6:	0f 84 d8 fe ff ff    	je     4b4 <printf+0x54>
+ 5dc:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 5df:	89 de                	mov    %ebx,%esi
+ 5e1:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 5e4:	eb 1a                	jmp    600 <printf+0x1a0>
+          s = "(null)";
+ 5e6:	bb f5 07 00 00       	mov    $0x7f5,%ebx
+        while(*s != 0){
+ 5eb:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 5ee:	b8 28 00 00 00       	mov    $0x28,%eax
+ 5f3:	89 de                	mov    %ebx,%esi
+ 5f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 5f8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 5ff:	90                   	nop
+  write(fd, &c, 1);
+ 600:	83 ec 04             	sub    $0x4,%esp
+          s++;
+ 603:	83 c6 01             	add    $0x1,%esi
+ 606:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 609:	6a 01                	push   $0x1
+ 60b:	57                   	push   %edi
+ 60c:	53                   	push   %ebx
+ 60d:	e8 f1 fc ff ff       	call   303 <write>
+        while(*s != 0){
+ 612:	0f b6 06             	movzbl (%esi),%eax
+ 615:	83 c4 10             	add    $0x10,%esp
+ 618:	84 c0                	test   %al,%al
+ 61a:	75 e4                	jne    600 <printf+0x1a0>
+ 61c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+      state = 0;
+ 61f:	31 d2                	xor    %edx,%edx
+ 621:	e9 8e fe ff ff       	jmp    4b4 <printf+0x54>
+ 626:	66 90                	xchg   %ax,%ax
+ 628:	66 90                	xchg   %ax,%ax
+ 62a:	66 90                	xchg   %ax,%ax
+ 62c:	66 90                	xchg   %ax,%ax
+ 62e:	66 90                	xchg   %ax,%ax
+
+00000630 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 630:	f3 0f 1e fb          	endbr32 
+ 634:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 635:	a1 b4 0a 00 00       	mov    0xab4,%eax
+{
+ 63a:	89 e5                	mov    %esp,%ebp
+ 63c:	57                   	push   %edi
+ 63d:	56                   	push   %esi
+ 63e:	53                   	push   %ebx
+ 63f:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 642:	8b 10                	mov    (%eax),%edx
+  bp = (Header*)ap - 1;
+ 644:	8d 4b f8             	lea    -0x8(%ebx),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 647:	39 c8                	cmp    %ecx,%eax
+ 649:	73 15                	jae    660 <free+0x30>
+ 64b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 64f:	90                   	nop
+ 650:	39 d1                	cmp    %edx,%ecx
+ 652:	72 14                	jb     668 <free+0x38>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 654:	39 d0                	cmp    %edx,%eax
+ 656:	73 10                	jae    668 <free+0x38>
+{
+ 658:	89 d0                	mov    %edx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 65a:	8b 10                	mov    (%eax),%edx
+ 65c:	39 c8                	cmp    %ecx,%eax
+ 65e:	72 f0                	jb     650 <free+0x20>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 660:	39 d0                	cmp    %edx,%eax
+ 662:	72 f4                	jb     658 <free+0x28>
+ 664:	39 d1                	cmp    %edx,%ecx
+ 666:	73 f0                	jae    658 <free+0x28>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 668:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ 66b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
+ 66e:	39 fa                	cmp    %edi,%edx
+ 670:	74 1e                	je     690 <free+0x60>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+ 672:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 675:	8b 50 04             	mov    0x4(%eax),%edx
+ 678:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 67b:	39 f1                	cmp    %esi,%ecx
+ 67d:	74 28                	je     6a7 <free+0x77>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+ 67f:	89 08                	mov    %ecx,(%eax)
+  freep = p;
+}
+ 681:	5b                   	pop    %ebx
+  freep = p;
+ 682:	a3 b4 0a 00 00       	mov    %eax,0xab4
+}
+ 687:	5e                   	pop    %esi
+ 688:	5f                   	pop    %edi
+ 689:	5d                   	pop    %ebp
+ 68a:	c3                   	ret    
+ 68b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 68f:	90                   	nop
+    bp->s.size += p->s.ptr->s.size;
+ 690:	03 72 04             	add    0x4(%edx),%esi
+ 693:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 696:	8b 10                	mov    (%eax),%edx
+ 698:	8b 12                	mov    (%edx),%edx
+ 69a:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 69d:	8b 50 04             	mov    0x4(%eax),%edx
+ 6a0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 6a3:	39 f1                	cmp    %esi,%ecx
+ 6a5:	75 d8                	jne    67f <free+0x4f>
+    p->s.size += bp->s.size;
+ 6a7:	03 53 fc             	add    -0x4(%ebx),%edx
+  freep = p;
+ 6aa:	a3 b4 0a 00 00       	mov    %eax,0xab4
+    p->s.size += bp->s.size;
+ 6af:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 6b2:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ 6b5:	89 10                	mov    %edx,(%eax)
+}
+ 6b7:	5b                   	pop    %ebx
+ 6b8:	5e                   	pop    %esi
+ 6b9:	5f                   	pop    %edi
+ 6ba:	5d                   	pop    %ebp
+ 6bb:	c3                   	ret    
+ 6bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000006c0 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 6c0:	f3 0f 1e fb          	endbr32 
+ 6c4:	55                   	push   %ebp
+ 6c5:	89 e5                	mov    %esp,%ebp
+ 6c7:	57                   	push   %edi
+ 6c8:	56                   	push   %esi
+ 6c9:	53                   	push   %ebx
+ 6ca:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 6cd:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+ 6d0:	8b 3d b4 0a 00 00    	mov    0xab4,%edi
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 6d6:	8d 70 07             	lea    0x7(%eax),%esi
+ 6d9:	c1 ee 03             	shr    $0x3,%esi
+ 6dc:	83 c6 01             	add    $0x1,%esi
+  if((prevp = freep) == 0){
+ 6df:	85 ff                	test   %edi,%edi
+ 6e1:	0f 84 a9 00 00 00    	je     790 <malloc+0xd0>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 6e7:	8b 07                	mov    (%edi),%eax
+    if(p->s.size >= nunits){
+ 6e9:	8b 48 04             	mov    0x4(%eax),%ecx
+ 6ec:	39 f1                	cmp    %esi,%ecx
+ 6ee:	73 6d                	jae    75d <malloc+0x9d>
+ 6f0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+ 6f6:	bb 00 10 00 00       	mov    $0x1000,%ebx
+ 6fb:	0f 43 de             	cmovae %esi,%ebx
+  p = sbrk(nu * sizeof(Header));
+ 6fe:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
+ 705:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+ 708:	eb 17                	jmp    721 <malloc+0x61>
+ 70a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 710:	8b 10                	mov    (%eax),%edx
+    if(p->s.size >= nunits){
+ 712:	8b 4a 04             	mov    0x4(%edx),%ecx
+ 715:	39 f1                	cmp    %esi,%ecx
+ 717:	73 4f                	jae    768 <malloc+0xa8>
+ 719:	8b 3d b4 0a 00 00    	mov    0xab4,%edi
+ 71f:	89 d0                	mov    %edx,%eax
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 721:	39 c7                	cmp    %eax,%edi
+ 723:	75 eb                	jne    710 <malloc+0x50>
+  p = sbrk(nu * sizeof(Header));
+ 725:	83 ec 0c             	sub    $0xc,%esp
+ 728:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 72b:	e8 3b fc ff ff       	call   36b <sbrk>
+  if(p == (char*)-1)
+ 730:	83 c4 10             	add    $0x10,%esp
+ 733:	83 f8 ff             	cmp    $0xffffffff,%eax
+ 736:	74 1b                	je     753 <malloc+0x93>
+  hp->s.size = nu;
+ 738:	89 58 04             	mov    %ebx,0x4(%eax)
+  free((void*)(hp + 1));
+ 73b:	83 ec 0c             	sub    $0xc,%esp
+ 73e:	83 c0 08             	add    $0x8,%eax
+ 741:	50                   	push   %eax
+ 742:	e8 e9 fe ff ff       	call   630 <free>
+  return freep;
+ 747:	a1 b4 0a 00 00       	mov    0xab4,%eax
+      if((p = morecore(nunits)) == 0)
+ 74c:	83 c4 10             	add    $0x10,%esp
+ 74f:	85 c0                	test   %eax,%eax
+ 751:	75 bd                	jne    710 <malloc+0x50>
+        return 0;
+  }
+}
+ 753:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return 0;
+ 756:	31 c0                	xor    %eax,%eax
+}
+ 758:	5b                   	pop    %ebx
+ 759:	5e                   	pop    %esi
+ 75a:	5f                   	pop    %edi
+ 75b:	5d                   	pop    %ebp
+ 75c:	c3                   	ret    
+    if(p->s.size >= nunits){
+ 75d:	89 c2                	mov    %eax,%edx
+ 75f:	89 f8                	mov    %edi,%eax
+ 761:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+ 768:	39 ce                	cmp    %ecx,%esi
+ 76a:	74 54                	je     7c0 <malloc+0x100>
+        p->s.size -= nunits;
+ 76c:	29 f1                	sub    %esi,%ecx
+ 76e:	89 4a 04             	mov    %ecx,0x4(%edx)
+        p += p->s.size;
+ 771:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
+        p->s.size = nunits;
+ 774:	89 72 04             	mov    %esi,0x4(%edx)
+      freep = prevp;
+ 777:	a3 b4 0a 00 00       	mov    %eax,0xab4
+}
+ 77c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return (void*)(p + 1);
+ 77f:	8d 42 08             	lea    0x8(%edx),%eax
+}
+ 782:	5b                   	pop    %ebx
+ 783:	5e                   	pop    %esi
+ 784:	5f                   	pop    %edi
+ 785:	5d                   	pop    %ebp
+ 786:	c3                   	ret    
+ 787:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 78e:	66 90                	xchg   %ax,%ax
+    base.s.ptr = freep = prevp = &base;
+ 790:	c7 05 b4 0a 00 00 b8 	movl   $0xab8,0xab4
+ 797:	0a 00 00 
+    base.s.size = 0;
+ 79a:	bf b8 0a 00 00       	mov    $0xab8,%edi
+    base.s.ptr = freep = prevp = &base;
+ 79f:	c7 05 b8 0a 00 00 b8 	movl   $0xab8,0xab8
+ 7a6:	0a 00 00 
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7a9:	89 f8                	mov    %edi,%eax
+    base.s.size = 0;
+ 7ab:	c7 05 bc 0a 00 00 00 	movl   $0x0,0xabc
+ 7b2:	00 00 00 
+    if(p->s.size >= nunits){
+ 7b5:	e9 36 ff ff ff       	jmp    6f0 <malloc+0x30>
+ 7ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        prevp->s.ptr = p->s.ptr;
+ 7c0:	8b 0a                	mov    (%edx),%ecx
+ 7c2:	89 08                	mov    %ecx,(%eax)
+ 7c4:	eb b1                	jmp    777 <malloc+0xb7>
diff -ruN xv6-public/rm.d copy-xv6/rm.d
--- xv6-public/rm.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/rm.d	2022-09-05 23:26:12.092781089 +0530
@@ -0,0 +1 @@
+rm.o: rm.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/rm.o and copy-xv6/rm.o differ
diff -ruN xv6-public/rm.sym copy-xv6/rm.sym
--- xv6-public/rm.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/rm.sym	2022-09-05 23:26:12.104781089 +0530
@@ -0,0 +1,61 @@
+00000000 .text
+000007c8 .rodata
+00000810 .eh_frame
+00000ab4 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 rm.c
+00000000 ulib.c
+00000000 printf.c
+000003b0 printint
+000007fc digits.1097
+00000000 umalloc.c
+00000ab4 freep
+00000ab8 base
+00000080 strcpy
+00000460 printf
+0000039b thread_exit
+000002b0 memmove
+0000032b mknod
+000001a0 gets
+00000363 getpid
+000006c0 malloc
+00000373 sleep
+000002f3 pipe
+00000303 write
+0000033b fstat
+00000313 kill
+00000353 chdir
+0000031b exec
+000002eb wait
+000002fb read
+00000333 unlink
+000002db fork
+0000036b sbrk
+0000037b uptime
+00000ab4 __bss_start
+00000140 memset
+00000000 main
+000000b0 strcmp
+0000035b dup
+00000220 stat
+00000ab4 _edata
+00000ac0 _end
+00000343 link
+000002e3 exit
+00000270 atoi
+00000383 draw
+00000100 strlen
+00000323 open
+00000160 strchr
+0000038b thread_create
+0000034b mkdir
+0000030b close
+00000393 thread_join
+00000630 free
Binary files xv6-public/_sh and copy-xv6/_sh differ
diff -ruN xv6-public/sh.asm copy-xv6/sh.asm
--- xv6-public/sh.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/sh.asm	2022-09-05 23:26:12.192781087 +0530
@@ -0,0 +1,2642 @@
+
+_sh:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+  return 0;
+}
+
+int
+main(void)
+{
+       0:	f3 0f 1e fb          	endbr32 
+       4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+       8:	83 e4 f0             	and    $0xfffffff0,%esp
+       b:	ff 71 fc             	pushl  -0x4(%ecx)
+       e:	55                   	push   %ebp
+       f:	89 e5                	mov    %esp,%ebp
+      11:	51                   	push   %ecx
+      12:	83 ec 04             	sub    $0x4,%esp
+  static char buf[100];
+  int fd;
+
+  // Ensure that three file descriptors are open.
+  while((fd = open("console", O_RDWR)) >= 0){
+      15:	eb 12                	jmp    29 <main+0x29>
+      17:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      1e:	66 90                	xchg   %ax,%ax
+    if(fd >= 3){
+      20:	83 f8 02             	cmp    $0x2,%eax
+      23:	0f 8f b7 00 00 00    	jg     e0 <main+0xe0>
+  while((fd = open("console", O_RDWR)) >= 0){
+      29:	83 ec 08             	sub    $0x8,%esp
+      2c:	6a 02                	push   $0x2
+      2e:	68 19 13 00 00       	push   $0x1319
+      33:	e8 9b 0d 00 00       	call   dd3 <open>
+      38:	83 c4 10             	add    $0x10,%esp
+      3b:	85 c0                	test   %eax,%eax
+      3d:	79 e1                	jns    20 <main+0x20>
+      3f:	eb 32                	jmp    73 <main+0x73>
+      41:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+
+  // Read and run input commands.
+  while(getcmd(buf, sizeof(buf)) >= 0){
+    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
+      48:	80 3d 62 19 00 00 20 	cmpb   $0x20,0x1962
+      4f:	74 51                	je     a2 <main+0xa2>
+      51:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+int
+fork1(void)
+{
+  int pid;
+
+  pid = fork();
+      58:	e8 2e 0d 00 00       	call   d8b <fork>
+  if(pid == -1)
+      5d:	83 f8 ff             	cmp    $0xffffffff,%eax
+      60:	0f 84 9d 00 00 00    	je     103 <main+0x103>
+    if(fork1() == 0)
+      66:	85 c0                	test   %eax,%eax
+      68:	0f 84 80 00 00 00    	je     ee <main+0xee>
+    wait();
+      6e:	e8 28 0d 00 00       	call   d9b <wait>
+  while(getcmd(buf, sizeof(buf)) >= 0){
+      73:	83 ec 08             	sub    $0x8,%esp
+      76:	6a 64                	push   $0x64
+      78:	68 60 19 00 00       	push   $0x1960
+      7d:	e8 8e 00 00 00       	call   110 <getcmd>
+      82:	83 c4 10             	add    $0x10,%esp
+      85:	85 c0                	test   %eax,%eax
+      87:	78 14                	js     9d <main+0x9d>
+    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
+      89:	80 3d 60 19 00 00 63 	cmpb   $0x63,0x1960
+      90:	75 c6                	jne    58 <main+0x58>
+      92:	80 3d 61 19 00 00 64 	cmpb   $0x64,0x1961
+      99:	75 bd                	jne    58 <main+0x58>
+      9b:	eb ab                	jmp    48 <main+0x48>
+  exit();
+      9d:	e8 f1 0c 00 00       	call   d93 <exit>
+      buf[strlen(buf)-1] = 0;  // chop \n
+      a2:	83 ec 0c             	sub    $0xc,%esp
+      a5:	68 60 19 00 00       	push   $0x1960
+      aa:	e8 01 0b 00 00       	call   bb0 <strlen>
+      if(chdir(buf+3) < 0)
+      af:	c7 04 24 63 19 00 00 	movl   $0x1963,(%esp)
+      buf[strlen(buf)-1] = 0;  // chop \n
+      b6:	c6 80 5f 19 00 00 00 	movb   $0x0,0x195f(%eax)
+      if(chdir(buf+3) < 0)
+      bd:	e8 41 0d 00 00       	call   e03 <chdir>
+      c2:	83 c4 10             	add    $0x10,%esp
+      c5:	85 c0                	test   %eax,%eax
+      c7:	79 aa                	jns    73 <main+0x73>
+        printf(2, "cannot cd %s\n", buf+3);
+      c9:	50                   	push   %eax
+      ca:	68 63 19 00 00       	push   $0x1963
+      cf:	68 21 13 00 00       	push   $0x1321
+      d4:	6a 02                	push   $0x2
+      d6:	e8 35 0e 00 00       	call   f10 <printf>
+      db:	83 c4 10             	add    $0x10,%esp
+      de:	eb 93                	jmp    73 <main+0x73>
+      close(fd);
+      e0:	83 ec 0c             	sub    $0xc,%esp
+      e3:	50                   	push   %eax
+      e4:	e8 d2 0c 00 00       	call   dbb <close>
+      break;
+      e9:	83 c4 10             	add    $0x10,%esp
+      ec:	eb 85                	jmp    73 <main+0x73>
+      runcmd(parsecmd(buf));
+      ee:	83 ec 0c             	sub    $0xc,%esp
+      f1:	68 60 19 00 00       	push   $0x1960
+      f6:	e8 c5 09 00 00       	call   ac0 <parsecmd>
+      fb:	89 04 24             	mov    %eax,(%esp)
+      fe:	e8 7d 00 00 00       	call   180 <runcmd>
+    panic("fork");
+     103:	83 ec 0c             	sub    $0xc,%esp
+     106:	68 a2 12 00 00       	push   $0x12a2
+     10b:	e8 50 00 00 00       	call   160 <panic>
+
+00000110 <getcmd>:
+{
+     110:	f3 0f 1e fb          	endbr32 
+     114:	55                   	push   %ebp
+     115:	89 e5                	mov    %esp,%ebp
+     117:	56                   	push   %esi
+     118:	53                   	push   %ebx
+     119:	8b 75 0c             	mov    0xc(%ebp),%esi
+     11c:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  printf(2, "$ ");
+     11f:	83 ec 08             	sub    $0x8,%esp
+     122:	68 78 12 00 00       	push   $0x1278
+     127:	6a 02                	push   $0x2
+     129:	e8 e2 0d 00 00       	call   f10 <printf>
+  memset(buf, 0, nbuf);
+     12e:	83 c4 0c             	add    $0xc,%esp
+     131:	56                   	push   %esi
+     132:	6a 00                	push   $0x0
+     134:	53                   	push   %ebx
+     135:	e8 b6 0a 00 00       	call   bf0 <memset>
+  gets(buf, nbuf);
+     13a:	58                   	pop    %eax
+     13b:	5a                   	pop    %edx
+     13c:	56                   	push   %esi
+     13d:	53                   	push   %ebx
+     13e:	e8 0d 0b 00 00       	call   c50 <gets>
+  if(buf[0] == 0) // EOF
+     143:	83 c4 10             	add    $0x10,%esp
+     146:	31 c0                	xor    %eax,%eax
+     148:	80 3b 00             	cmpb   $0x0,(%ebx)
+     14b:	0f 94 c0             	sete   %al
+}
+     14e:	8d 65 f8             	lea    -0x8(%ebp),%esp
+     151:	5b                   	pop    %ebx
+  if(buf[0] == 0) // EOF
+     152:	f7 d8                	neg    %eax
+}
+     154:	5e                   	pop    %esi
+     155:	5d                   	pop    %ebp
+     156:	c3                   	ret    
+     157:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     15e:	66 90                	xchg   %ax,%ax
+
+00000160 <panic>:
+{
+     160:	f3 0f 1e fb          	endbr32 
+     164:	55                   	push   %ebp
+     165:	89 e5                	mov    %esp,%ebp
+     167:	83 ec 0c             	sub    $0xc,%esp
+  printf(2, "%s\n", s);
+     16a:	ff 75 08             	pushl  0x8(%ebp)
+     16d:	68 15 13 00 00       	push   $0x1315
+     172:	6a 02                	push   $0x2
+     174:	e8 97 0d 00 00       	call   f10 <printf>
+  exit();
+     179:	e8 15 0c 00 00       	call   d93 <exit>
+     17e:	66 90                	xchg   %ax,%ax
+
+00000180 <runcmd>:
+{
+     180:	f3 0f 1e fb          	endbr32 
+     184:	55                   	push   %ebp
+     185:	89 e5                	mov    %esp,%ebp
+     187:	53                   	push   %ebx
+     188:	83 ec 14             	sub    $0x14,%esp
+     18b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  if(cmd == 0)
+     18e:	85 db                	test   %ebx,%ebx
+     190:	74 7e                	je     210 <runcmd+0x90>
+  switch(cmd->type){
+     192:	83 3b 05             	cmpl   $0x5,(%ebx)
+     195:	0f 87 04 01 00 00    	ja     29f <runcmd+0x11f>
+     19b:	8b 03                	mov    (%ebx),%eax
+     19d:	3e ff 24 85 30 13 00 	notrack jmp *0x1330(,%eax,4)
+     1a4:	00 
+    if(pipe(p) < 0)
+     1a5:	83 ec 0c             	sub    $0xc,%esp
+     1a8:	8d 45 f0             	lea    -0x10(%ebp),%eax
+     1ab:	50                   	push   %eax
+     1ac:	e8 f2 0b 00 00       	call   da3 <pipe>
+     1b1:	83 c4 10             	add    $0x10,%esp
+     1b4:	85 c0                	test   %eax,%eax
+     1b6:	0f 88 05 01 00 00    	js     2c1 <runcmd+0x141>
+  pid = fork();
+     1bc:	e8 ca 0b 00 00       	call   d8b <fork>
+  if(pid == -1)
+     1c1:	83 f8 ff             	cmp    $0xffffffff,%eax
+     1c4:	0f 84 60 01 00 00    	je     32a <runcmd+0x1aa>
+    if(fork1() == 0){
+     1ca:	85 c0                	test   %eax,%eax
+     1cc:	0f 84 fc 00 00 00    	je     2ce <runcmd+0x14e>
+  pid = fork();
+     1d2:	e8 b4 0b 00 00       	call   d8b <fork>
+  if(pid == -1)
+     1d7:	83 f8 ff             	cmp    $0xffffffff,%eax
+     1da:	0f 84 4a 01 00 00    	je     32a <runcmd+0x1aa>
+    if(fork1() == 0){
+     1e0:	85 c0                	test   %eax,%eax
+     1e2:	0f 84 14 01 00 00    	je     2fc <runcmd+0x17c>
+    close(p[0]);
+     1e8:	83 ec 0c             	sub    $0xc,%esp
+     1eb:	ff 75 f0             	pushl  -0x10(%ebp)
+     1ee:	e8 c8 0b 00 00       	call   dbb <close>
+    close(p[1]);
+     1f3:	58                   	pop    %eax
+     1f4:	ff 75 f4             	pushl  -0xc(%ebp)
+     1f7:	e8 bf 0b 00 00       	call   dbb <close>
+    wait();
+     1fc:	e8 9a 0b 00 00       	call   d9b <wait>
+    wait();
+     201:	e8 95 0b 00 00       	call   d9b <wait>
+    break;
+     206:	83 c4 10             	add    $0x10,%esp
+     209:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    exit();
+     210:	e8 7e 0b 00 00       	call   d93 <exit>
+  pid = fork();
+     215:	e8 71 0b 00 00       	call   d8b <fork>
+  if(pid == -1)
+     21a:	83 f8 ff             	cmp    $0xffffffff,%eax
+     21d:	0f 84 07 01 00 00    	je     32a <runcmd+0x1aa>
+    if(fork1() == 0)
+     223:	85 c0                	test   %eax,%eax
+     225:	75 e9                	jne    210 <runcmd+0x90>
+     227:	eb 6b                	jmp    294 <runcmd+0x114>
+    if(ecmd->argv[0] == 0)
+     229:	8b 43 04             	mov    0x4(%ebx),%eax
+     22c:	85 c0                	test   %eax,%eax
+     22e:	74 e0                	je     210 <runcmd+0x90>
+    exec(ecmd->argv[0], ecmd->argv);
+     230:	8d 53 04             	lea    0x4(%ebx),%edx
+     233:	51                   	push   %ecx
+     234:	51                   	push   %ecx
+     235:	52                   	push   %edx
+     236:	50                   	push   %eax
+     237:	e8 8f 0b 00 00       	call   dcb <exec>
+    printf(2, "exec %s failed\n", ecmd->argv[0]);
+     23c:	83 c4 0c             	add    $0xc,%esp
+     23f:	ff 73 04             	pushl  0x4(%ebx)
+     242:	68 82 12 00 00       	push   $0x1282
+     247:	6a 02                	push   $0x2
+     249:	e8 c2 0c 00 00       	call   f10 <printf>
+    break;
+     24e:	83 c4 10             	add    $0x10,%esp
+     251:	eb bd                	jmp    210 <runcmd+0x90>
+  pid = fork();
+     253:	e8 33 0b 00 00       	call   d8b <fork>
+  if(pid == -1)
+     258:	83 f8 ff             	cmp    $0xffffffff,%eax
+     25b:	0f 84 c9 00 00 00    	je     32a <runcmd+0x1aa>
+    if(fork1() == 0)
+     261:	85 c0                	test   %eax,%eax
+     263:	74 2f                	je     294 <runcmd+0x114>
+    wait();
+     265:	e8 31 0b 00 00       	call   d9b <wait>
+    runcmd(lcmd->right);
+     26a:	83 ec 0c             	sub    $0xc,%esp
+     26d:	ff 73 08             	pushl  0x8(%ebx)
+     270:	e8 0b ff ff ff       	call   180 <runcmd>
+    close(rcmd->fd);
+     275:	83 ec 0c             	sub    $0xc,%esp
+     278:	ff 73 14             	pushl  0x14(%ebx)
+     27b:	e8 3b 0b 00 00       	call   dbb <close>
+    if(open(rcmd->file, rcmd->mode) < 0){
+     280:	58                   	pop    %eax
+     281:	5a                   	pop    %edx
+     282:	ff 73 10             	pushl  0x10(%ebx)
+     285:	ff 73 08             	pushl  0x8(%ebx)
+     288:	e8 46 0b 00 00       	call   dd3 <open>
+     28d:	83 c4 10             	add    $0x10,%esp
+     290:	85 c0                	test   %eax,%eax
+     292:	78 18                	js     2ac <runcmd+0x12c>
+      runcmd(bcmd->cmd);
+     294:	83 ec 0c             	sub    $0xc,%esp
+     297:	ff 73 04             	pushl  0x4(%ebx)
+     29a:	e8 e1 fe ff ff       	call   180 <runcmd>
+    panic("runcmd");
+     29f:	83 ec 0c             	sub    $0xc,%esp
+     2a2:	68 7b 12 00 00       	push   $0x127b
+     2a7:	e8 b4 fe ff ff       	call   160 <panic>
+      printf(2, "open %s failed\n", rcmd->file);
+     2ac:	51                   	push   %ecx
+     2ad:	ff 73 08             	pushl  0x8(%ebx)
+     2b0:	68 92 12 00 00       	push   $0x1292
+     2b5:	6a 02                	push   $0x2
+     2b7:	e8 54 0c 00 00       	call   f10 <printf>
+      exit();
+     2bc:	e8 d2 0a 00 00       	call   d93 <exit>
+      panic("pipe");
+     2c1:	83 ec 0c             	sub    $0xc,%esp
+     2c4:	68 a7 12 00 00       	push   $0x12a7
+     2c9:	e8 92 fe ff ff       	call   160 <panic>
+      close(1);
+     2ce:	83 ec 0c             	sub    $0xc,%esp
+     2d1:	6a 01                	push   $0x1
+     2d3:	e8 e3 0a 00 00       	call   dbb <close>
+      dup(p[1]);
+     2d8:	58                   	pop    %eax
+     2d9:	ff 75 f4             	pushl  -0xc(%ebp)
+     2dc:	e8 2a 0b 00 00       	call   e0b <dup>
+      close(p[0]);
+     2e1:	58                   	pop    %eax
+     2e2:	ff 75 f0             	pushl  -0x10(%ebp)
+     2e5:	e8 d1 0a 00 00       	call   dbb <close>
+      close(p[1]);
+     2ea:	58                   	pop    %eax
+     2eb:	ff 75 f4             	pushl  -0xc(%ebp)
+     2ee:	e8 c8 0a 00 00       	call   dbb <close>
+      runcmd(pcmd->left);
+     2f3:	5a                   	pop    %edx
+     2f4:	ff 73 04             	pushl  0x4(%ebx)
+     2f7:	e8 84 fe ff ff       	call   180 <runcmd>
+      close(0);
+     2fc:	83 ec 0c             	sub    $0xc,%esp
+     2ff:	6a 00                	push   $0x0
+     301:	e8 b5 0a 00 00       	call   dbb <close>
+      dup(p[0]);
+     306:	5a                   	pop    %edx
+     307:	ff 75 f0             	pushl  -0x10(%ebp)
+     30a:	e8 fc 0a 00 00       	call   e0b <dup>
+      close(p[0]);
+     30f:	59                   	pop    %ecx
+     310:	ff 75 f0             	pushl  -0x10(%ebp)
+     313:	e8 a3 0a 00 00       	call   dbb <close>
+      close(p[1]);
+     318:	58                   	pop    %eax
+     319:	ff 75 f4             	pushl  -0xc(%ebp)
+     31c:	e8 9a 0a 00 00       	call   dbb <close>
+      runcmd(pcmd->right);
+     321:	58                   	pop    %eax
+     322:	ff 73 08             	pushl  0x8(%ebx)
+     325:	e8 56 fe ff ff       	call   180 <runcmd>
+    panic("fork");
+     32a:	83 ec 0c             	sub    $0xc,%esp
+     32d:	68 a2 12 00 00       	push   $0x12a2
+     332:	e8 29 fe ff ff       	call   160 <panic>
+     337:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     33e:	66 90                	xchg   %ax,%ax
+
+00000340 <fork1>:
+{
+     340:	f3 0f 1e fb          	endbr32 
+     344:	55                   	push   %ebp
+     345:	89 e5                	mov    %esp,%ebp
+     347:	83 ec 08             	sub    $0x8,%esp
+  pid = fork();
+     34a:	e8 3c 0a 00 00       	call   d8b <fork>
+  if(pid == -1)
+     34f:	83 f8 ff             	cmp    $0xffffffff,%eax
+     352:	74 02                	je     356 <fork1+0x16>
+  return pid;
+}
+     354:	c9                   	leave  
+     355:	c3                   	ret    
+    panic("fork");
+     356:	83 ec 0c             	sub    $0xc,%esp
+     359:	68 a2 12 00 00       	push   $0x12a2
+     35e:	e8 fd fd ff ff       	call   160 <panic>
+     363:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     36a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000370 <execcmd>:
+//PAGEBREAK!
+// Constructors
+
+struct cmd*
+execcmd(void)
+{
+     370:	f3 0f 1e fb          	endbr32 
+     374:	55                   	push   %ebp
+     375:	89 e5                	mov    %esp,%ebp
+     377:	53                   	push   %ebx
+     378:	83 ec 10             	sub    $0x10,%esp
+  struct execcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     37b:	6a 54                	push   $0x54
+     37d:	e8 ee 0d 00 00       	call   1170 <malloc>
+  memset(cmd, 0, sizeof(*cmd));
+     382:	83 c4 0c             	add    $0xc,%esp
+     385:	6a 54                	push   $0x54
+  cmd = malloc(sizeof(*cmd));
+     387:	89 c3                	mov    %eax,%ebx
+  memset(cmd, 0, sizeof(*cmd));
+     389:	6a 00                	push   $0x0
+     38b:	50                   	push   %eax
+     38c:	e8 5f 08 00 00       	call   bf0 <memset>
+  cmd->type = EXEC;
+     391:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
+  return (struct cmd*)cmd;
+}
+     397:	89 d8                	mov    %ebx,%eax
+     399:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+     39c:	c9                   	leave  
+     39d:	c3                   	ret    
+     39e:	66 90                	xchg   %ax,%ax
+
+000003a0 <redircmd>:
+
+struct cmd*
+redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
+{
+     3a0:	f3 0f 1e fb          	endbr32 
+     3a4:	55                   	push   %ebp
+     3a5:	89 e5                	mov    %esp,%ebp
+     3a7:	53                   	push   %ebx
+     3a8:	83 ec 10             	sub    $0x10,%esp
+  struct redircmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     3ab:	6a 18                	push   $0x18
+     3ad:	e8 be 0d 00 00       	call   1170 <malloc>
+  memset(cmd, 0, sizeof(*cmd));
+     3b2:	83 c4 0c             	add    $0xc,%esp
+     3b5:	6a 18                	push   $0x18
+  cmd = malloc(sizeof(*cmd));
+     3b7:	89 c3                	mov    %eax,%ebx
+  memset(cmd, 0, sizeof(*cmd));
+     3b9:	6a 00                	push   $0x0
+     3bb:	50                   	push   %eax
+     3bc:	e8 2f 08 00 00       	call   bf0 <memset>
+  cmd->type = REDIR;
+  cmd->cmd = subcmd;
+     3c1:	8b 45 08             	mov    0x8(%ebp),%eax
+  cmd->type = REDIR;
+     3c4:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
+  cmd->cmd = subcmd;
+     3ca:	89 43 04             	mov    %eax,0x4(%ebx)
+  cmd->file = file;
+     3cd:	8b 45 0c             	mov    0xc(%ebp),%eax
+     3d0:	89 43 08             	mov    %eax,0x8(%ebx)
+  cmd->efile = efile;
+     3d3:	8b 45 10             	mov    0x10(%ebp),%eax
+     3d6:	89 43 0c             	mov    %eax,0xc(%ebx)
+  cmd->mode = mode;
+     3d9:	8b 45 14             	mov    0x14(%ebp),%eax
+     3dc:	89 43 10             	mov    %eax,0x10(%ebx)
+  cmd->fd = fd;
+     3df:	8b 45 18             	mov    0x18(%ebp),%eax
+     3e2:	89 43 14             	mov    %eax,0x14(%ebx)
+  return (struct cmd*)cmd;
+}
+     3e5:	89 d8                	mov    %ebx,%eax
+     3e7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+     3ea:	c9                   	leave  
+     3eb:	c3                   	ret    
+     3ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000003f0 <pipecmd>:
+
+struct cmd*
+pipecmd(struct cmd *left, struct cmd *right)
+{
+     3f0:	f3 0f 1e fb          	endbr32 
+     3f4:	55                   	push   %ebp
+     3f5:	89 e5                	mov    %esp,%ebp
+     3f7:	53                   	push   %ebx
+     3f8:	83 ec 10             	sub    $0x10,%esp
+  struct pipecmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     3fb:	6a 0c                	push   $0xc
+     3fd:	e8 6e 0d 00 00       	call   1170 <malloc>
+  memset(cmd, 0, sizeof(*cmd));
+     402:	83 c4 0c             	add    $0xc,%esp
+     405:	6a 0c                	push   $0xc
+  cmd = malloc(sizeof(*cmd));
+     407:	89 c3                	mov    %eax,%ebx
+  memset(cmd, 0, sizeof(*cmd));
+     409:	6a 00                	push   $0x0
+     40b:	50                   	push   %eax
+     40c:	e8 df 07 00 00       	call   bf0 <memset>
+  cmd->type = PIPE;
+  cmd->left = left;
+     411:	8b 45 08             	mov    0x8(%ebp),%eax
+  cmd->type = PIPE;
+     414:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
+  cmd->left = left;
+     41a:	89 43 04             	mov    %eax,0x4(%ebx)
+  cmd->right = right;
+     41d:	8b 45 0c             	mov    0xc(%ebp),%eax
+     420:	89 43 08             	mov    %eax,0x8(%ebx)
+  return (struct cmd*)cmd;
+}
+     423:	89 d8                	mov    %ebx,%eax
+     425:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+     428:	c9                   	leave  
+     429:	c3                   	ret    
+     42a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000430 <listcmd>:
+
+struct cmd*
+listcmd(struct cmd *left, struct cmd *right)
+{
+     430:	f3 0f 1e fb          	endbr32 
+     434:	55                   	push   %ebp
+     435:	89 e5                	mov    %esp,%ebp
+     437:	53                   	push   %ebx
+     438:	83 ec 10             	sub    $0x10,%esp
+  struct listcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     43b:	6a 0c                	push   $0xc
+     43d:	e8 2e 0d 00 00       	call   1170 <malloc>
+  memset(cmd, 0, sizeof(*cmd));
+     442:	83 c4 0c             	add    $0xc,%esp
+     445:	6a 0c                	push   $0xc
+  cmd = malloc(sizeof(*cmd));
+     447:	89 c3                	mov    %eax,%ebx
+  memset(cmd, 0, sizeof(*cmd));
+     449:	6a 00                	push   $0x0
+     44b:	50                   	push   %eax
+     44c:	e8 9f 07 00 00       	call   bf0 <memset>
+  cmd->type = LIST;
+  cmd->left = left;
+     451:	8b 45 08             	mov    0x8(%ebp),%eax
+  cmd->type = LIST;
+     454:	c7 03 04 00 00 00    	movl   $0x4,(%ebx)
+  cmd->left = left;
+     45a:	89 43 04             	mov    %eax,0x4(%ebx)
+  cmd->right = right;
+     45d:	8b 45 0c             	mov    0xc(%ebp),%eax
+     460:	89 43 08             	mov    %eax,0x8(%ebx)
+  return (struct cmd*)cmd;
+}
+     463:	89 d8                	mov    %ebx,%eax
+     465:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+     468:	c9                   	leave  
+     469:	c3                   	ret    
+     46a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000470 <backcmd>:
+
+struct cmd*
+backcmd(struct cmd *subcmd)
+{
+     470:	f3 0f 1e fb          	endbr32 
+     474:	55                   	push   %ebp
+     475:	89 e5                	mov    %esp,%ebp
+     477:	53                   	push   %ebx
+     478:	83 ec 10             	sub    $0x10,%esp
+  struct backcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     47b:	6a 08                	push   $0x8
+     47d:	e8 ee 0c 00 00       	call   1170 <malloc>
+  memset(cmd, 0, sizeof(*cmd));
+     482:	83 c4 0c             	add    $0xc,%esp
+     485:	6a 08                	push   $0x8
+  cmd = malloc(sizeof(*cmd));
+     487:	89 c3                	mov    %eax,%ebx
+  memset(cmd, 0, sizeof(*cmd));
+     489:	6a 00                	push   $0x0
+     48b:	50                   	push   %eax
+     48c:	e8 5f 07 00 00       	call   bf0 <memset>
+  cmd->type = BACK;
+  cmd->cmd = subcmd;
+     491:	8b 45 08             	mov    0x8(%ebp),%eax
+  cmd->type = BACK;
+     494:	c7 03 05 00 00 00    	movl   $0x5,(%ebx)
+  cmd->cmd = subcmd;
+     49a:	89 43 04             	mov    %eax,0x4(%ebx)
+  return (struct cmd*)cmd;
+}
+     49d:	89 d8                	mov    %ebx,%eax
+     49f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+     4a2:	c9                   	leave  
+     4a3:	c3                   	ret    
+     4a4:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     4ab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+     4af:	90                   	nop
+
+000004b0 <gettoken>:
+char whitespace[] = " \t\r\n\v";
+char symbols[] = "<|>&;()";
+
+int
+gettoken(char **ps, char *es, char **q, char **eq)
+{
+     4b0:	f3 0f 1e fb          	endbr32 
+     4b4:	55                   	push   %ebp
+     4b5:	89 e5                	mov    %esp,%ebp
+     4b7:	57                   	push   %edi
+     4b8:	56                   	push   %esi
+     4b9:	53                   	push   %ebx
+     4ba:	83 ec 0c             	sub    $0xc,%esp
+  char *s;
+  int ret;
+
+  s = *ps;
+     4bd:	8b 45 08             	mov    0x8(%ebp),%eax
+{
+     4c0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+     4c3:	8b 75 10             	mov    0x10(%ebp),%esi
+  s = *ps;
+     4c6:	8b 38                	mov    (%eax),%edi
+  while(s < es && strchr(whitespace, *s))
+     4c8:	39 df                	cmp    %ebx,%edi
+     4ca:	72 0b                	jb     4d7 <gettoken+0x27>
+     4cc:	eb 21                	jmp    4ef <gettoken+0x3f>
+     4ce:	66 90                	xchg   %ax,%ax
+    s++;
+     4d0:	83 c7 01             	add    $0x1,%edi
+  while(s < es && strchr(whitespace, *s))
+     4d3:	39 fb                	cmp    %edi,%ebx
+     4d5:	74 18                	je     4ef <gettoken+0x3f>
+     4d7:	0f be 07             	movsbl (%edi),%eax
+     4da:	83 ec 08             	sub    $0x8,%esp
+     4dd:	50                   	push   %eax
+     4de:	68 40 19 00 00       	push   $0x1940
+     4e3:	e8 28 07 00 00       	call   c10 <strchr>
+     4e8:	83 c4 10             	add    $0x10,%esp
+     4eb:	85 c0                	test   %eax,%eax
+     4ed:	75 e1                	jne    4d0 <gettoken+0x20>
+  if(q)
+     4ef:	85 f6                	test   %esi,%esi
+     4f1:	74 02                	je     4f5 <gettoken+0x45>
+    *q = s;
+     4f3:	89 3e                	mov    %edi,(%esi)
+  ret = *s;
+     4f5:	0f b6 07             	movzbl (%edi),%eax
+  switch(*s){
+     4f8:	3c 3c                	cmp    $0x3c,%al
+     4fa:	0f 8f d0 00 00 00    	jg     5d0 <gettoken+0x120>
+     500:	3c 3a                	cmp    $0x3a,%al
+     502:	0f 8f b4 00 00 00    	jg     5bc <gettoken+0x10c>
+     508:	84 c0                	test   %al,%al
+     50a:	75 44                	jne    550 <gettoken+0xa0>
+     50c:	31 f6                	xor    %esi,%esi
+    ret = 'a';
+    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+      s++;
+    break;
+  }
+  if(eq)
+     50e:	8b 55 14             	mov    0x14(%ebp),%edx
+     511:	85 d2                	test   %edx,%edx
+     513:	74 05                	je     51a <gettoken+0x6a>
+    *eq = s;
+     515:	8b 45 14             	mov    0x14(%ebp),%eax
+     518:	89 38                	mov    %edi,(%eax)
+
+  while(s < es && strchr(whitespace, *s))
+     51a:	39 df                	cmp    %ebx,%edi
+     51c:	72 09                	jb     527 <gettoken+0x77>
+     51e:	eb 1f                	jmp    53f <gettoken+0x8f>
+    s++;
+     520:	83 c7 01             	add    $0x1,%edi
+  while(s < es && strchr(whitespace, *s))
+     523:	39 fb                	cmp    %edi,%ebx
+     525:	74 18                	je     53f <gettoken+0x8f>
+     527:	0f be 07             	movsbl (%edi),%eax
+     52a:	83 ec 08             	sub    $0x8,%esp
+     52d:	50                   	push   %eax
+     52e:	68 40 19 00 00       	push   $0x1940
+     533:	e8 d8 06 00 00       	call   c10 <strchr>
+     538:	83 c4 10             	add    $0x10,%esp
+     53b:	85 c0                	test   %eax,%eax
+     53d:	75 e1                	jne    520 <gettoken+0x70>
+  *ps = s;
+     53f:	8b 45 08             	mov    0x8(%ebp),%eax
+     542:	89 38                	mov    %edi,(%eax)
+  return ret;
+}
+     544:	8d 65 f4             	lea    -0xc(%ebp),%esp
+     547:	89 f0                	mov    %esi,%eax
+     549:	5b                   	pop    %ebx
+     54a:	5e                   	pop    %esi
+     54b:	5f                   	pop    %edi
+     54c:	5d                   	pop    %ebp
+     54d:	c3                   	ret    
+     54e:	66 90                	xchg   %ax,%ax
+  switch(*s){
+     550:	79 5e                	jns    5b0 <gettoken+0x100>
+    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+     552:	39 fb                	cmp    %edi,%ebx
+     554:	77 34                	ja     58a <gettoken+0xda>
+  if(eq)
+     556:	8b 45 14             	mov    0x14(%ebp),%eax
+     559:	be 61 00 00 00       	mov    $0x61,%esi
+     55e:	85 c0                	test   %eax,%eax
+     560:	75 b3                	jne    515 <gettoken+0x65>
+     562:	eb db                	jmp    53f <gettoken+0x8f>
+     564:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+     568:	0f be 07             	movsbl (%edi),%eax
+     56b:	83 ec 08             	sub    $0x8,%esp
+     56e:	50                   	push   %eax
+     56f:	68 38 19 00 00       	push   $0x1938
+     574:	e8 97 06 00 00       	call   c10 <strchr>
+     579:	83 c4 10             	add    $0x10,%esp
+     57c:	85 c0                	test   %eax,%eax
+     57e:	75 22                	jne    5a2 <gettoken+0xf2>
+      s++;
+     580:	83 c7 01             	add    $0x1,%edi
+    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+     583:	39 fb                	cmp    %edi,%ebx
+     585:	74 cf                	je     556 <gettoken+0xa6>
+     587:	0f b6 07             	movzbl (%edi),%eax
+     58a:	83 ec 08             	sub    $0x8,%esp
+     58d:	0f be f0             	movsbl %al,%esi
+     590:	56                   	push   %esi
+     591:	68 40 19 00 00       	push   $0x1940
+     596:	e8 75 06 00 00       	call   c10 <strchr>
+     59b:	83 c4 10             	add    $0x10,%esp
+     59e:	85 c0                	test   %eax,%eax
+     5a0:	74 c6                	je     568 <gettoken+0xb8>
+    ret = 'a';
+     5a2:	be 61 00 00 00       	mov    $0x61,%esi
+     5a7:	e9 62 ff ff ff       	jmp    50e <gettoken+0x5e>
+     5ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  switch(*s){
+     5b0:	3c 26                	cmp    $0x26,%al
+     5b2:	74 08                	je     5bc <gettoken+0x10c>
+     5b4:	8d 48 d8             	lea    -0x28(%eax),%ecx
+     5b7:	80 f9 01             	cmp    $0x1,%cl
+     5ba:	77 96                	ja     552 <gettoken+0xa2>
+  ret = *s;
+     5bc:	0f be f0             	movsbl %al,%esi
+    s++;
+     5bf:	83 c7 01             	add    $0x1,%edi
+    break;
+     5c2:	e9 47 ff ff ff       	jmp    50e <gettoken+0x5e>
+     5c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     5ce:	66 90                	xchg   %ax,%ax
+  switch(*s){
+     5d0:	3c 3e                	cmp    $0x3e,%al
+     5d2:	75 1c                	jne    5f0 <gettoken+0x140>
+    if(*s == '>'){
+     5d4:	80 7f 01 3e          	cmpb   $0x3e,0x1(%edi)
+    s++;
+     5d8:	8d 47 01             	lea    0x1(%edi),%eax
+    if(*s == '>'){
+     5db:	74 1c                	je     5f9 <gettoken+0x149>
+    s++;
+     5dd:	89 c7                	mov    %eax,%edi
+     5df:	be 3e 00 00 00       	mov    $0x3e,%esi
+     5e4:	e9 25 ff ff ff       	jmp    50e <gettoken+0x5e>
+     5e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  switch(*s){
+     5f0:	3c 7c                	cmp    $0x7c,%al
+     5f2:	74 c8                	je     5bc <gettoken+0x10c>
+     5f4:	e9 59 ff ff ff       	jmp    552 <gettoken+0xa2>
+      s++;
+     5f9:	83 c7 02             	add    $0x2,%edi
+      ret = '+';
+     5fc:	be 2b 00 00 00       	mov    $0x2b,%esi
+     601:	e9 08 ff ff ff       	jmp    50e <gettoken+0x5e>
+     606:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     60d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000610 <peek>:
+
+int
+peek(char **ps, char *es, char *toks)
+{
+     610:	f3 0f 1e fb          	endbr32 
+     614:	55                   	push   %ebp
+     615:	89 e5                	mov    %esp,%ebp
+     617:	57                   	push   %edi
+     618:	56                   	push   %esi
+     619:	53                   	push   %ebx
+     61a:	83 ec 0c             	sub    $0xc,%esp
+     61d:	8b 7d 08             	mov    0x8(%ebp),%edi
+     620:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *s;
+
+  s = *ps;
+     623:	8b 1f                	mov    (%edi),%ebx
+  while(s < es && strchr(whitespace, *s))
+     625:	39 f3                	cmp    %esi,%ebx
+     627:	72 0e                	jb     637 <peek+0x27>
+     629:	eb 24                	jmp    64f <peek+0x3f>
+     62b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+     62f:	90                   	nop
+    s++;
+     630:	83 c3 01             	add    $0x1,%ebx
+  while(s < es && strchr(whitespace, *s))
+     633:	39 de                	cmp    %ebx,%esi
+     635:	74 18                	je     64f <peek+0x3f>
+     637:	0f be 03             	movsbl (%ebx),%eax
+     63a:	83 ec 08             	sub    $0x8,%esp
+     63d:	50                   	push   %eax
+     63e:	68 40 19 00 00       	push   $0x1940
+     643:	e8 c8 05 00 00       	call   c10 <strchr>
+     648:	83 c4 10             	add    $0x10,%esp
+     64b:	85 c0                	test   %eax,%eax
+     64d:	75 e1                	jne    630 <peek+0x20>
+  *ps = s;
+     64f:	89 1f                	mov    %ebx,(%edi)
+  return *s && strchr(toks, *s);
+     651:	0f be 03             	movsbl (%ebx),%eax
+     654:	31 d2                	xor    %edx,%edx
+     656:	84 c0                	test   %al,%al
+     658:	75 0e                	jne    668 <peek+0x58>
+}
+     65a:	8d 65 f4             	lea    -0xc(%ebp),%esp
+     65d:	89 d0                	mov    %edx,%eax
+     65f:	5b                   	pop    %ebx
+     660:	5e                   	pop    %esi
+     661:	5f                   	pop    %edi
+     662:	5d                   	pop    %ebp
+     663:	c3                   	ret    
+     664:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  return *s && strchr(toks, *s);
+     668:	83 ec 08             	sub    $0x8,%esp
+     66b:	50                   	push   %eax
+     66c:	ff 75 10             	pushl  0x10(%ebp)
+     66f:	e8 9c 05 00 00       	call   c10 <strchr>
+     674:	83 c4 10             	add    $0x10,%esp
+     677:	31 d2                	xor    %edx,%edx
+     679:	85 c0                	test   %eax,%eax
+     67b:	0f 95 c2             	setne  %dl
+}
+     67e:	8d 65 f4             	lea    -0xc(%ebp),%esp
+     681:	5b                   	pop    %ebx
+     682:	89 d0                	mov    %edx,%eax
+     684:	5e                   	pop    %esi
+     685:	5f                   	pop    %edi
+     686:	5d                   	pop    %ebp
+     687:	c3                   	ret    
+     688:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     68f:	90                   	nop
+
+00000690 <parseredirs>:
+  return cmd;
+}
+
+struct cmd*
+parseredirs(struct cmd *cmd, char **ps, char *es)
+{
+     690:	f3 0f 1e fb          	endbr32 
+     694:	55                   	push   %ebp
+     695:	89 e5                	mov    %esp,%ebp
+     697:	57                   	push   %edi
+     698:	56                   	push   %esi
+     699:	53                   	push   %ebx
+     69a:	83 ec 1c             	sub    $0x1c,%esp
+     69d:	8b 75 0c             	mov    0xc(%ebp),%esi
+     6a0:	8b 5d 10             	mov    0x10(%ebp),%ebx
+  int tok;
+  char *q, *eq;
+
+  while(peek(ps, es, "<>")){
+     6a3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+     6a7:	90                   	nop
+     6a8:	83 ec 04             	sub    $0x4,%esp
+     6ab:	68 c9 12 00 00       	push   $0x12c9
+     6b0:	53                   	push   %ebx
+     6b1:	56                   	push   %esi
+     6b2:	e8 59 ff ff ff       	call   610 <peek>
+     6b7:	83 c4 10             	add    $0x10,%esp
+     6ba:	85 c0                	test   %eax,%eax
+     6bc:	74 6a                	je     728 <parseredirs+0x98>
+    tok = gettoken(ps, es, 0, 0);
+     6be:	6a 00                	push   $0x0
+     6c0:	6a 00                	push   $0x0
+     6c2:	53                   	push   %ebx
+     6c3:	56                   	push   %esi
+     6c4:	e8 e7 fd ff ff       	call   4b0 <gettoken>
+     6c9:	89 c7                	mov    %eax,%edi
+    if(gettoken(ps, es, &q, &eq) != 'a')
+     6cb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+     6ce:	50                   	push   %eax
+     6cf:	8d 45 e0             	lea    -0x20(%ebp),%eax
+     6d2:	50                   	push   %eax
+     6d3:	53                   	push   %ebx
+     6d4:	56                   	push   %esi
+     6d5:	e8 d6 fd ff ff       	call   4b0 <gettoken>
+     6da:	83 c4 20             	add    $0x20,%esp
+     6dd:	83 f8 61             	cmp    $0x61,%eax
+     6e0:	75 51                	jne    733 <parseredirs+0xa3>
+      panic("missing file for redirection");
+    switch(tok){
+     6e2:	83 ff 3c             	cmp    $0x3c,%edi
+     6e5:	74 31                	je     718 <parseredirs+0x88>
+     6e7:	83 ff 3e             	cmp    $0x3e,%edi
+     6ea:	74 05                	je     6f1 <parseredirs+0x61>
+     6ec:	83 ff 2b             	cmp    $0x2b,%edi
+     6ef:	75 b7                	jne    6a8 <parseredirs+0x18>
+      break;
+    case '>':
+      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+      break;
+    case '+':  // >>
+      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+     6f1:	83 ec 0c             	sub    $0xc,%esp
+     6f4:	6a 01                	push   $0x1
+     6f6:	68 01 02 00 00       	push   $0x201
+     6fb:	ff 75 e4             	pushl  -0x1c(%ebp)
+     6fe:	ff 75 e0             	pushl  -0x20(%ebp)
+     701:	ff 75 08             	pushl  0x8(%ebp)
+     704:	e8 97 fc ff ff       	call   3a0 <redircmd>
+      break;
+     709:	83 c4 20             	add    $0x20,%esp
+      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+     70c:	89 45 08             	mov    %eax,0x8(%ebp)
+      break;
+     70f:	eb 97                	jmp    6a8 <parseredirs+0x18>
+     711:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
+     718:	83 ec 0c             	sub    $0xc,%esp
+     71b:	6a 00                	push   $0x0
+     71d:	6a 00                	push   $0x0
+     71f:	eb da                	jmp    6fb <parseredirs+0x6b>
+     721:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    }
+  }
+  return cmd;
+}
+     728:	8b 45 08             	mov    0x8(%ebp),%eax
+     72b:	8d 65 f4             	lea    -0xc(%ebp),%esp
+     72e:	5b                   	pop    %ebx
+     72f:	5e                   	pop    %esi
+     730:	5f                   	pop    %edi
+     731:	5d                   	pop    %ebp
+     732:	c3                   	ret    
+      panic("missing file for redirection");
+     733:	83 ec 0c             	sub    $0xc,%esp
+     736:	68 ac 12 00 00       	push   $0x12ac
+     73b:	e8 20 fa ff ff       	call   160 <panic>
+
+00000740 <parseexec>:
+  return cmd;
+}
+
+struct cmd*
+parseexec(char **ps, char *es)
+{
+     740:	f3 0f 1e fb          	endbr32 
+     744:	55                   	push   %ebp
+     745:	89 e5                	mov    %esp,%ebp
+     747:	57                   	push   %edi
+     748:	56                   	push   %esi
+     749:	53                   	push   %ebx
+     74a:	83 ec 30             	sub    $0x30,%esp
+     74d:	8b 75 08             	mov    0x8(%ebp),%esi
+     750:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  char *q, *eq;
+  int tok, argc;
+  struct execcmd *cmd;
+  struct cmd *ret;
+
+  if(peek(ps, es, "("))
+     753:	68 cc 12 00 00       	push   $0x12cc
+     758:	57                   	push   %edi
+     759:	56                   	push   %esi
+     75a:	e8 b1 fe ff ff       	call   610 <peek>
+     75f:	83 c4 10             	add    $0x10,%esp
+     762:	85 c0                	test   %eax,%eax
+     764:	0f 85 96 00 00 00    	jne    800 <parseexec+0xc0>
+     76a:	89 c3                	mov    %eax,%ebx
+    return parseblock(ps, es);
+
+  ret = execcmd();
+     76c:	e8 ff fb ff ff       	call   370 <execcmd>
+  cmd = (struct execcmd*)ret;
+
+  argc = 0;
+  ret = parseredirs(ret, ps, es);
+     771:	83 ec 04             	sub    $0x4,%esp
+     774:	57                   	push   %edi
+     775:	56                   	push   %esi
+     776:	50                   	push   %eax
+  ret = execcmd();
+     777:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  ret = parseredirs(ret, ps, es);
+     77a:	e8 11 ff ff ff       	call   690 <parseredirs>
+  while(!peek(ps, es, "|)&;")){
+     77f:	83 c4 10             	add    $0x10,%esp
+  ret = parseredirs(ret, ps, es);
+     782:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  while(!peek(ps, es, "|)&;")){
+     785:	eb 1c                	jmp    7a3 <parseexec+0x63>
+     787:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     78e:	66 90                	xchg   %ax,%ax
+    cmd->argv[argc] = q;
+    cmd->eargv[argc] = eq;
+    argc++;
+    if(argc >= MAXARGS)
+      panic("too many args");
+    ret = parseredirs(ret, ps, es);
+     790:	83 ec 04             	sub    $0x4,%esp
+     793:	57                   	push   %edi
+     794:	56                   	push   %esi
+     795:	ff 75 d4             	pushl  -0x2c(%ebp)
+     798:	e8 f3 fe ff ff       	call   690 <parseredirs>
+     79d:	83 c4 10             	add    $0x10,%esp
+     7a0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  while(!peek(ps, es, "|)&;")){
+     7a3:	83 ec 04             	sub    $0x4,%esp
+     7a6:	68 e3 12 00 00       	push   $0x12e3
+     7ab:	57                   	push   %edi
+     7ac:	56                   	push   %esi
+     7ad:	e8 5e fe ff ff       	call   610 <peek>
+     7b2:	83 c4 10             	add    $0x10,%esp
+     7b5:	85 c0                	test   %eax,%eax
+     7b7:	75 67                	jne    820 <parseexec+0xe0>
+    if((tok=gettoken(ps, es, &q, &eq)) == 0)
+     7b9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+     7bc:	50                   	push   %eax
+     7bd:	8d 45 e0             	lea    -0x20(%ebp),%eax
+     7c0:	50                   	push   %eax
+     7c1:	57                   	push   %edi
+     7c2:	56                   	push   %esi
+     7c3:	e8 e8 fc ff ff       	call   4b0 <gettoken>
+     7c8:	83 c4 10             	add    $0x10,%esp
+     7cb:	85 c0                	test   %eax,%eax
+     7cd:	74 51                	je     820 <parseexec+0xe0>
+    if(tok != 'a')
+     7cf:	83 f8 61             	cmp    $0x61,%eax
+     7d2:	75 6b                	jne    83f <parseexec+0xff>
+    cmd->argv[argc] = q;
+     7d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
+     7d7:	8b 55 d0             	mov    -0x30(%ebp),%edx
+     7da:	89 44 9a 04          	mov    %eax,0x4(%edx,%ebx,4)
+    cmd->eargv[argc] = eq;
+     7de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+     7e1:	89 44 9a 2c          	mov    %eax,0x2c(%edx,%ebx,4)
+    argc++;
+     7e5:	83 c3 01             	add    $0x1,%ebx
+    if(argc >= MAXARGS)
+     7e8:	83 fb 0a             	cmp    $0xa,%ebx
+     7eb:	75 a3                	jne    790 <parseexec+0x50>
+      panic("too many args");
+     7ed:	83 ec 0c             	sub    $0xc,%esp
+     7f0:	68 d5 12 00 00       	push   $0x12d5
+     7f5:	e8 66 f9 ff ff       	call   160 <panic>
+     7fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    return parseblock(ps, es);
+     800:	83 ec 08             	sub    $0x8,%esp
+     803:	57                   	push   %edi
+     804:	56                   	push   %esi
+     805:	e8 66 01 00 00       	call   970 <parseblock>
+     80a:	83 c4 10             	add    $0x10,%esp
+     80d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  }
+  cmd->argv[argc] = 0;
+  cmd->eargv[argc] = 0;
+  return ret;
+}
+     810:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+     813:	8d 65 f4             	lea    -0xc(%ebp),%esp
+     816:	5b                   	pop    %ebx
+     817:	5e                   	pop    %esi
+     818:	5f                   	pop    %edi
+     819:	5d                   	pop    %ebp
+     81a:	c3                   	ret    
+     81b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+     81f:	90                   	nop
+  cmd->argv[argc] = 0;
+     820:	8b 45 d0             	mov    -0x30(%ebp),%eax
+     823:	8d 04 98             	lea    (%eax,%ebx,4),%eax
+     826:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+  cmd->eargv[argc] = 0;
+     82d:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
+}
+     834:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+     837:	8d 65 f4             	lea    -0xc(%ebp),%esp
+     83a:	5b                   	pop    %ebx
+     83b:	5e                   	pop    %esi
+     83c:	5f                   	pop    %edi
+     83d:	5d                   	pop    %ebp
+     83e:	c3                   	ret    
+      panic("syntax");
+     83f:	83 ec 0c             	sub    $0xc,%esp
+     842:	68 ce 12 00 00       	push   $0x12ce
+     847:	e8 14 f9 ff ff       	call   160 <panic>
+     84c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000850 <parsepipe>:
+{
+     850:	f3 0f 1e fb          	endbr32 
+     854:	55                   	push   %ebp
+     855:	89 e5                	mov    %esp,%ebp
+     857:	57                   	push   %edi
+     858:	56                   	push   %esi
+     859:	53                   	push   %ebx
+     85a:	83 ec 14             	sub    $0x14,%esp
+     85d:	8b 75 08             	mov    0x8(%ebp),%esi
+     860:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  cmd = parseexec(ps, es);
+     863:	57                   	push   %edi
+     864:	56                   	push   %esi
+     865:	e8 d6 fe ff ff       	call   740 <parseexec>
+  if(peek(ps, es, "|")){
+     86a:	83 c4 0c             	add    $0xc,%esp
+     86d:	68 e8 12 00 00       	push   $0x12e8
+  cmd = parseexec(ps, es);
+     872:	89 c3                	mov    %eax,%ebx
+  if(peek(ps, es, "|")){
+     874:	57                   	push   %edi
+     875:	56                   	push   %esi
+     876:	e8 95 fd ff ff       	call   610 <peek>
+     87b:	83 c4 10             	add    $0x10,%esp
+     87e:	85 c0                	test   %eax,%eax
+     880:	75 0e                	jne    890 <parsepipe+0x40>
+}
+     882:	8d 65 f4             	lea    -0xc(%ebp),%esp
+     885:	89 d8                	mov    %ebx,%eax
+     887:	5b                   	pop    %ebx
+     888:	5e                   	pop    %esi
+     889:	5f                   	pop    %edi
+     88a:	5d                   	pop    %ebp
+     88b:	c3                   	ret    
+     88c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    gettoken(ps, es, 0, 0);
+     890:	6a 00                	push   $0x0
+     892:	6a 00                	push   $0x0
+     894:	57                   	push   %edi
+     895:	56                   	push   %esi
+     896:	e8 15 fc ff ff       	call   4b0 <gettoken>
+    cmd = pipecmd(cmd, parsepipe(ps, es));
+     89b:	58                   	pop    %eax
+     89c:	5a                   	pop    %edx
+     89d:	57                   	push   %edi
+     89e:	56                   	push   %esi
+     89f:	e8 ac ff ff ff       	call   850 <parsepipe>
+     8a4:	89 5d 08             	mov    %ebx,0x8(%ebp)
+     8a7:	83 c4 10             	add    $0x10,%esp
+     8aa:	89 45 0c             	mov    %eax,0xc(%ebp)
+}
+     8ad:	8d 65 f4             	lea    -0xc(%ebp),%esp
+     8b0:	5b                   	pop    %ebx
+     8b1:	5e                   	pop    %esi
+     8b2:	5f                   	pop    %edi
+     8b3:	5d                   	pop    %ebp
+    cmd = pipecmd(cmd, parsepipe(ps, es));
+     8b4:	e9 37 fb ff ff       	jmp    3f0 <pipecmd>
+     8b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+000008c0 <parseline>:
+{
+     8c0:	f3 0f 1e fb          	endbr32 
+     8c4:	55                   	push   %ebp
+     8c5:	89 e5                	mov    %esp,%ebp
+     8c7:	57                   	push   %edi
+     8c8:	56                   	push   %esi
+     8c9:	53                   	push   %ebx
+     8ca:	83 ec 14             	sub    $0x14,%esp
+     8cd:	8b 75 08             	mov    0x8(%ebp),%esi
+     8d0:	8b 7d 0c             	mov    0xc(%ebp),%edi
+  cmd = parsepipe(ps, es);
+     8d3:	57                   	push   %edi
+     8d4:	56                   	push   %esi
+     8d5:	e8 76 ff ff ff       	call   850 <parsepipe>
+  while(peek(ps, es, "&")){
+     8da:	83 c4 10             	add    $0x10,%esp
+  cmd = parsepipe(ps, es);
+     8dd:	89 c3                	mov    %eax,%ebx
+  while(peek(ps, es, "&")){
+     8df:	eb 1f                	jmp    900 <parseline+0x40>
+     8e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    gettoken(ps, es, 0, 0);
+     8e8:	6a 00                	push   $0x0
+     8ea:	6a 00                	push   $0x0
+     8ec:	57                   	push   %edi
+     8ed:	56                   	push   %esi
+     8ee:	e8 bd fb ff ff       	call   4b0 <gettoken>
+    cmd = backcmd(cmd);
+     8f3:	89 1c 24             	mov    %ebx,(%esp)
+     8f6:	e8 75 fb ff ff       	call   470 <backcmd>
+     8fb:	83 c4 10             	add    $0x10,%esp
+     8fe:	89 c3                	mov    %eax,%ebx
+  while(peek(ps, es, "&")){
+     900:	83 ec 04             	sub    $0x4,%esp
+     903:	68 ea 12 00 00       	push   $0x12ea
+     908:	57                   	push   %edi
+     909:	56                   	push   %esi
+     90a:	e8 01 fd ff ff       	call   610 <peek>
+     90f:	83 c4 10             	add    $0x10,%esp
+     912:	85 c0                	test   %eax,%eax
+     914:	75 d2                	jne    8e8 <parseline+0x28>
+  if(peek(ps, es, ";")){
+     916:	83 ec 04             	sub    $0x4,%esp
+     919:	68 e6 12 00 00       	push   $0x12e6
+     91e:	57                   	push   %edi
+     91f:	56                   	push   %esi
+     920:	e8 eb fc ff ff       	call   610 <peek>
+     925:	83 c4 10             	add    $0x10,%esp
+     928:	85 c0                	test   %eax,%eax
+     92a:	75 14                	jne    940 <parseline+0x80>
+}
+     92c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+     92f:	89 d8                	mov    %ebx,%eax
+     931:	5b                   	pop    %ebx
+     932:	5e                   	pop    %esi
+     933:	5f                   	pop    %edi
+     934:	5d                   	pop    %ebp
+     935:	c3                   	ret    
+     936:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     93d:	8d 76 00             	lea    0x0(%esi),%esi
+    gettoken(ps, es, 0, 0);
+     940:	6a 00                	push   $0x0
+     942:	6a 00                	push   $0x0
+     944:	57                   	push   %edi
+     945:	56                   	push   %esi
+     946:	e8 65 fb ff ff       	call   4b0 <gettoken>
+    cmd = listcmd(cmd, parseline(ps, es));
+     94b:	58                   	pop    %eax
+     94c:	5a                   	pop    %edx
+     94d:	57                   	push   %edi
+     94e:	56                   	push   %esi
+     94f:	e8 6c ff ff ff       	call   8c0 <parseline>
+     954:	89 5d 08             	mov    %ebx,0x8(%ebp)
+     957:	83 c4 10             	add    $0x10,%esp
+     95a:	89 45 0c             	mov    %eax,0xc(%ebp)
+}
+     95d:	8d 65 f4             	lea    -0xc(%ebp),%esp
+     960:	5b                   	pop    %ebx
+     961:	5e                   	pop    %esi
+     962:	5f                   	pop    %edi
+     963:	5d                   	pop    %ebp
+    cmd = listcmd(cmd, parseline(ps, es));
+     964:	e9 c7 fa ff ff       	jmp    430 <listcmd>
+     969:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00000970 <parseblock>:
+{
+     970:	f3 0f 1e fb          	endbr32 
+     974:	55                   	push   %ebp
+     975:	89 e5                	mov    %esp,%ebp
+     977:	57                   	push   %edi
+     978:	56                   	push   %esi
+     979:	53                   	push   %ebx
+     97a:	83 ec 10             	sub    $0x10,%esp
+     97d:	8b 5d 08             	mov    0x8(%ebp),%ebx
+     980:	8b 75 0c             	mov    0xc(%ebp),%esi
+  if(!peek(ps, es, "("))
+     983:	68 cc 12 00 00       	push   $0x12cc
+     988:	56                   	push   %esi
+     989:	53                   	push   %ebx
+     98a:	e8 81 fc ff ff       	call   610 <peek>
+     98f:	83 c4 10             	add    $0x10,%esp
+     992:	85 c0                	test   %eax,%eax
+     994:	74 4a                	je     9e0 <parseblock+0x70>
+  gettoken(ps, es, 0, 0);
+     996:	6a 00                	push   $0x0
+     998:	6a 00                	push   $0x0
+     99a:	56                   	push   %esi
+     99b:	53                   	push   %ebx
+     99c:	e8 0f fb ff ff       	call   4b0 <gettoken>
+  cmd = parseline(ps, es);
+     9a1:	58                   	pop    %eax
+     9a2:	5a                   	pop    %edx
+     9a3:	56                   	push   %esi
+     9a4:	53                   	push   %ebx
+     9a5:	e8 16 ff ff ff       	call   8c0 <parseline>
+  if(!peek(ps, es, ")"))
+     9aa:	83 c4 0c             	add    $0xc,%esp
+     9ad:	68 08 13 00 00       	push   $0x1308
+  cmd = parseline(ps, es);
+     9b2:	89 c7                	mov    %eax,%edi
+  if(!peek(ps, es, ")"))
+     9b4:	56                   	push   %esi
+     9b5:	53                   	push   %ebx
+     9b6:	e8 55 fc ff ff       	call   610 <peek>
+     9bb:	83 c4 10             	add    $0x10,%esp
+     9be:	85 c0                	test   %eax,%eax
+     9c0:	74 2b                	je     9ed <parseblock+0x7d>
+  gettoken(ps, es, 0, 0);
+     9c2:	6a 00                	push   $0x0
+     9c4:	6a 00                	push   $0x0
+     9c6:	56                   	push   %esi
+     9c7:	53                   	push   %ebx
+     9c8:	e8 e3 fa ff ff       	call   4b0 <gettoken>
+  cmd = parseredirs(cmd, ps, es);
+     9cd:	83 c4 0c             	add    $0xc,%esp
+     9d0:	56                   	push   %esi
+     9d1:	53                   	push   %ebx
+     9d2:	57                   	push   %edi
+     9d3:	e8 b8 fc ff ff       	call   690 <parseredirs>
+}
+     9d8:	8d 65 f4             	lea    -0xc(%ebp),%esp
+     9db:	5b                   	pop    %ebx
+     9dc:	5e                   	pop    %esi
+     9dd:	5f                   	pop    %edi
+     9de:	5d                   	pop    %ebp
+     9df:	c3                   	ret    
+    panic("parseblock");
+     9e0:	83 ec 0c             	sub    $0xc,%esp
+     9e3:	68 ec 12 00 00       	push   $0x12ec
+     9e8:	e8 73 f7 ff ff       	call   160 <panic>
+    panic("syntax - missing )");
+     9ed:	83 ec 0c             	sub    $0xc,%esp
+     9f0:	68 f7 12 00 00       	push   $0x12f7
+     9f5:	e8 66 f7 ff ff       	call   160 <panic>
+     9fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000a00 <nulterminate>:
+
+// NUL-terminate all the counted strings.
+struct cmd*
+nulterminate(struct cmd *cmd)
+{
+     a00:	f3 0f 1e fb          	endbr32 
+     a04:	55                   	push   %ebp
+     a05:	89 e5                	mov    %esp,%ebp
+     a07:	53                   	push   %ebx
+     a08:	83 ec 04             	sub    $0x4,%esp
+     a0b:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  struct execcmd *ecmd;
+  struct listcmd *lcmd;
+  struct pipecmd *pcmd;
+  struct redircmd *rcmd;
+
+  if(cmd == 0)
+     a0e:	85 db                	test   %ebx,%ebx
+     a10:	0f 84 9a 00 00 00    	je     ab0 <nulterminate+0xb0>
+    return 0;
+
+  switch(cmd->type){
+     a16:	83 3b 05             	cmpl   $0x5,(%ebx)
+     a19:	77 6d                	ja     a88 <nulterminate+0x88>
+     a1b:	8b 03                	mov    (%ebx),%eax
+     a1d:	3e ff 24 85 48 13 00 	notrack jmp *0x1348(,%eax,4)
+     a24:	00 
+     a25:	8d 76 00             	lea    0x0(%esi),%esi
+    nulterminate(pcmd->right);
+    break;
+
+  case LIST:
+    lcmd = (struct listcmd*)cmd;
+    nulterminate(lcmd->left);
+     a28:	83 ec 0c             	sub    $0xc,%esp
+     a2b:	ff 73 04             	pushl  0x4(%ebx)
+     a2e:	e8 cd ff ff ff       	call   a00 <nulterminate>
+    nulterminate(lcmd->right);
+     a33:	58                   	pop    %eax
+     a34:	ff 73 08             	pushl  0x8(%ebx)
+     a37:	e8 c4 ff ff ff       	call   a00 <nulterminate>
+    break;
+     a3c:	83 c4 10             	add    $0x10,%esp
+     a3f:	89 d8                	mov    %ebx,%eax
+    bcmd = (struct backcmd*)cmd;
+    nulterminate(bcmd->cmd);
+    break;
+  }
+  return cmd;
+}
+     a41:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+     a44:	c9                   	leave  
+     a45:	c3                   	ret    
+     a46:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     a4d:	8d 76 00             	lea    0x0(%esi),%esi
+    nulterminate(bcmd->cmd);
+     a50:	83 ec 0c             	sub    $0xc,%esp
+     a53:	ff 73 04             	pushl  0x4(%ebx)
+     a56:	e8 a5 ff ff ff       	call   a00 <nulterminate>
+    break;
+     a5b:	89 d8                	mov    %ebx,%eax
+     a5d:	83 c4 10             	add    $0x10,%esp
+}
+     a60:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+     a63:	c9                   	leave  
+     a64:	c3                   	ret    
+     a65:	8d 76 00             	lea    0x0(%esi),%esi
+    for(i=0; ecmd->argv[i]; i++)
+     a68:	8b 4b 04             	mov    0x4(%ebx),%ecx
+     a6b:	8d 43 08             	lea    0x8(%ebx),%eax
+     a6e:	85 c9                	test   %ecx,%ecx
+     a70:	74 16                	je     a88 <nulterminate+0x88>
+     a72:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      *ecmd->eargv[i] = 0;
+     a78:	8b 50 24             	mov    0x24(%eax),%edx
+     a7b:	83 c0 04             	add    $0x4,%eax
+     a7e:	c6 02 00             	movb   $0x0,(%edx)
+    for(i=0; ecmd->argv[i]; i++)
+     a81:	8b 50 fc             	mov    -0x4(%eax),%edx
+     a84:	85 d2                	test   %edx,%edx
+     a86:	75 f0                	jne    a78 <nulterminate+0x78>
+  switch(cmd->type){
+     a88:	89 d8                	mov    %ebx,%eax
+}
+     a8a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+     a8d:	c9                   	leave  
+     a8e:	c3                   	ret    
+     a8f:	90                   	nop
+    nulterminate(rcmd->cmd);
+     a90:	83 ec 0c             	sub    $0xc,%esp
+     a93:	ff 73 04             	pushl  0x4(%ebx)
+     a96:	e8 65 ff ff ff       	call   a00 <nulterminate>
+    *rcmd->efile = 0;
+     a9b:	8b 43 0c             	mov    0xc(%ebx),%eax
+    break;
+     a9e:	83 c4 10             	add    $0x10,%esp
+    *rcmd->efile = 0;
+     aa1:	c6 00 00             	movb   $0x0,(%eax)
+    break;
+     aa4:	89 d8                	mov    %ebx,%eax
+}
+     aa6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+     aa9:	c9                   	leave  
+     aaa:	c3                   	ret    
+     aab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+     aaf:	90                   	nop
+    return 0;
+     ab0:	31 c0                	xor    %eax,%eax
+     ab2:	eb 8d                	jmp    a41 <nulterminate+0x41>
+     ab4:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     abb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+     abf:	90                   	nop
+
+00000ac0 <parsecmd>:
+{
+     ac0:	f3 0f 1e fb          	endbr32 
+     ac4:	55                   	push   %ebp
+     ac5:	89 e5                	mov    %esp,%ebp
+     ac7:	56                   	push   %esi
+     ac8:	53                   	push   %ebx
+  es = s + strlen(s);
+     ac9:	8b 5d 08             	mov    0x8(%ebp),%ebx
+     acc:	83 ec 0c             	sub    $0xc,%esp
+     acf:	53                   	push   %ebx
+     ad0:	e8 db 00 00 00       	call   bb0 <strlen>
+  cmd = parseline(&s, es);
+     ad5:	59                   	pop    %ecx
+     ad6:	5e                   	pop    %esi
+  es = s + strlen(s);
+     ad7:	01 c3                	add    %eax,%ebx
+  cmd = parseline(&s, es);
+     ad9:	8d 45 08             	lea    0x8(%ebp),%eax
+     adc:	53                   	push   %ebx
+     add:	50                   	push   %eax
+     ade:	e8 dd fd ff ff       	call   8c0 <parseline>
+  peek(&s, es, "");
+     ae3:	83 c4 0c             	add    $0xc,%esp
+  cmd = parseline(&s, es);
+     ae6:	89 c6                	mov    %eax,%esi
+  peek(&s, es, "");
+     ae8:	8d 45 08             	lea    0x8(%ebp),%eax
+     aeb:	68 91 12 00 00       	push   $0x1291
+     af0:	53                   	push   %ebx
+     af1:	50                   	push   %eax
+     af2:	e8 19 fb ff ff       	call   610 <peek>
+  if(s != es){
+     af7:	8b 45 08             	mov    0x8(%ebp),%eax
+     afa:	83 c4 10             	add    $0x10,%esp
+     afd:	39 d8                	cmp    %ebx,%eax
+     aff:	75 12                	jne    b13 <parsecmd+0x53>
+  nulterminate(cmd);
+     b01:	83 ec 0c             	sub    $0xc,%esp
+     b04:	56                   	push   %esi
+     b05:	e8 f6 fe ff ff       	call   a00 <nulterminate>
+}
+     b0a:	8d 65 f8             	lea    -0x8(%ebp),%esp
+     b0d:	89 f0                	mov    %esi,%eax
+     b0f:	5b                   	pop    %ebx
+     b10:	5e                   	pop    %esi
+     b11:	5d                   	pop    %ebp
+     b12:	c3                   	ret    
+    printf(2, "leftovers: %s\n", s);
+     b13:	52                   	push   %edx
+     b14:	50                   	push   %eax
+     b15:	68 0a 13 00 00       	push   $0x130a
+     b1a:	6a 02                	push   $0x2
+     b1c:	e8 ef 03 00 00       	call   f10 <printf>
+    panic("syntax");
+     b21:	c7 04 24 ce 12 00 00 	movl   $0x12ce,(%esp)
+     b28:	e8 33 f6 ff ff       	call   160 <panic>
+     b2d:	66 90                	xchg   %ax,%ax
+     b2f:	90                   	nop
+
+00000b30 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+     b30:	f3 0f 1e fb          	endbr32 
+     b34:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+     b35:	31 c0                	xor    %eax,%eax
+{
+     b37:	89 e5                	mov    %esp,%ebp
+     b39:	53                   	push   %ebx
+     b3a:	8b 4d 08             	mov    0x8(%ebp),%ecx
+     b3d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+     b40:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+     b44:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+     b47:	83 c0 01             	add    $0x1,%eax
+     b4a:	84 d2                	test   %dl,%dl
+     b4c:	75 f2                	jne    b40 <strcpy+0x10>
+    ;
+  return os;
+}
+     b4e:	89 c8                	mov    %ecx,%eax
+     b50:	5b                   	pop    %ebx
+     b51:	5d                   	pop    %ebp
+     b52:	c3                   	ret    
+     b53:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     b5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000b60 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+     b60:	f3 0f 1e fb          	endbr32 
+     b64:	55                   	push   %ebp
+     b65:	89 e5                	mov    %esp,%ebp
+     b67:	53                   	push   %ebx
+     b68:	8b 4d 08             	mov    0x8(%ebp),%ecx
+     b6b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+     b6e:	0f b6 01             	movzbl (%ecx),%eax
+     b71:	0f b6 1a             	movzbl (%edx),%ebx
+     b74:	84 c0                	test   %al,%al
+     b76:	75 19                	jne    b91 <strcmp+0x31>
+     b78:	eb 26                	jmp    ba0 <strcmp+0x40>
+     b7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+     b80:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+     b84:	83 c1 01             	add    $0x1,%ecx
+     b87:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+     b8a:	0f b6 1a             	movzbl (%edx),%ebx
+     b8d:	84 c0                	test   %al,%al
+     b8f:	74 0f                	je     ba0 <strcmp+0x40>
+     b91:	38 d8                	cmp    %bl,%al
+     b93:	74 eb                	je     b80 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+     b95:	29 d8                	sub    %ebx,%eax
+}
+     b97:	5b                   	pop    %ebx
+     b98:	5d                   	pop    %ebp
+     b99:	c3                   	ret    
+     b9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+     ba0:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+     ba2:	29 d8                	sub    %ebx,%eax
+}
+     ba4:	5b                   	pop    %ebx
+     ba5:	5d                   	pop    %ebp
+     ba6:	c3                   	ret    
+     ba7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     bae:	66 90                	xchg   %ax,%ax
+
+00000bb0 <strlen>:
+
+uint
+strlen(const char *s)
+{
+     bb0:	f3 0f 1e fb          	endbr32 
+     bb4:	55                   	push   %ebp
+     bb5:	89 e5                	mov    %esp,%ebp
+     bb7:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+     bba:	80 3a 00             	cmpb   $0x0,(%edx)
+     bbd:	74 21                	je     be0 <strlen+0x30>
+     bbf:	31 c0                	xor    %eax,%eax
+     bc1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     bc8:	83 c0 01             	add    $0x1,%eax
+     bcb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+     bcf:	89 c1                	mov    %eax,%ecx
+     bd1:	75 f5                	jne    bc8 <strlen+0x18>
+    ;
+  return n;
+}
+     bd3:	89 c8                	mov    %ecx,%eax
+     bd5:	5d                   	pop    %ebp
+     bd6:	c3                   	ret    
+     bd7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     bde:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+     be0:	31 c9                	xor    %ecx,%ecx
+}
+     be2:	5d                   	pop    %ebp
+     be3:	89 c8                	mov    %ecx,%eax
+     be5:	c3                   	ret    
+     be6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     bed:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000bf0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+     bf0:	f3 0f 1e fb          	endbr32 
+     bf4:	55                   	push   %ebp
+     bf5:	89 e5                	mov    %esp,%ebp
+     bf7:	57                   	push   %edi
+     bf8:	8b 55 08             	mov    0x8(%ebp),%edx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+     bfb:	8b 4d 10             	mov    0x10(%ebp),%ecx
+     bfe:	8b 45 0c             	mov    0xc(%ebp),%eax
+     c01:	89 d7                	mov    %edx,%edi
+     c03:	fc                   	cld    
+     c04:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+     c06:	89 d0                	mov    %edx,%eax
+     c08:	5f                   	pop    %edi
+     c09:	5d                   	pop    %ebp
+     c0a:	c3                   	ret    
+     c0b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+     c0f:	90                   	nop
+
+00000c10 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+     c10:	f3 0f 1e fb          	endbr32 
+     c14:	55                   	push   %ebp
+     c15:	89 e5                	mov    %esp,%ebp
+     c17:	8b 45 08             	mov    0x8(%ebp),%eax
+     c1a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+     c1e:	0f b6 10             	movzbl (%eax),%edx
+     c21:	84 d2                	test   %dl,%dl
+     c23:	75 16                	jne    c3b <strchr+0x2b>
+     c25:	eb 21                	jmp    c48 <strchr+0x38>
+     c27:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     c2e:	66 90                	xchg   %ax,%ax
+     c30:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+     c34:	83 c0 01             	add    $0x1,%eax
+     c37:	84 d2                	test   %dl,%dl
+     c39:	74 0d                	je     c48 <strchr+0x38>
+    if(*s == c)
+     c3b:	38 d1                	cmp    %dl,%cl
+     c3d:	75 f1                	jne    c30 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+     c3f:	5d                   	pop    %ebp
+     c40:	c3                   	ret    
+     c41:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+     c48:	31 c0                	xor    %eax,%eax
+}
+     c4a:	5d                   	pop    %ebp
+     c4b:	c3                   	ret    
+     c4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000c50 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+     c50:	f3 0f 1e fb          	endbr32 
+     c54:	55                   	push   %ebp
+     c55:	89 e5                	mov    %esp,%ebp
+     c57:	57                   	push   %edi
+     c58:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+     c59:	31 f6                	xor    %esi,%esi
+{
+     c5b:	53                   	push   %ebx
+     c5c:	89 f3                	mov    %esi,%ebx
+     c5e:	83 ec 1c             	sub    $0x1c,%esp
+     c61:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+     c64:	eb 33                	jmp    c99 <gets+0x49>
+     c66:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     c6d:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+     c70:	83 ec 04             	sub    $0x4,%esp
+     c73:	8d 45 e7             	lea    -0x19(%ebp),%eax
+     c76:	6a 01                	push   $0x1
+     c78:	50                   	push   %eax
+     c79:	6a 00                	push   $0x0
+     c7b:	e8 2b 01 00 00       	call   dab <read>
+    if(cc < 1)
+     c80:	83 c4 10             	add    $0x10,%esp
+     c83:	85 c0                	test   %eax,%eax
+     c85:	7e 1c                	jle    ca3 <gets+0x53>
+      break;
+    buf[i++] = c;
+     c87:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+     c8b:	83 c7 01             	add    $0x1,%edi
+     c8e:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+     c91:	3c 0a                	cmp    $0xa,%al
+     c93:	74 23                	je     cb8 <gets+0x68>
+     c95:	3c 0d                	cmp    $0xd,%al
+     c97:	74 1f                	je     cb8 <gets+0x68>
+  for(i=0; i+1 < max; ){
+     c99:	83 c3 01             	add    $0x1,%ebx
+     c9c:	89 fe                	mov    %edi,%esi
+     c9e:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+     ca1:	7c cd                	jl     c70 <gets+0x20>
+     ca3:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+     ca5:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+     ca8:	c6 03 00             	movb   $0x0,(%ebx)
+}
+     cab:	8d 65 f4             	lea    -0xc(%ebp),%esp
+     cae:	5b                   	pop    %ebx
+     caf:	5e                   	pop    %esi
+     cb0:	5f                   	pop    %edi
+     cb1:	5d                   	pop    %ebp
+     cb2:	c3                   	ret    
+     cb3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+     cb7:	90                   	nop
+     cb8:	8b 75 08             	mov    0x8(%ebp),%esi
+     cbb:	8b 45 08             	mov    0x8(%ebp),%eax
+     cbe:	01 de                	add    %ebx,%esi
+     cc0:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+     cc2:	c6 03 00             	movb   $0x0,(%ebx)
+}
+     cc5:	8d 65 f4             	lea    -0xc(%ebp),%esp
+     cc8:	5b                   	pop    %ebx
+     cc9:	5e                   	pop    %esi
+     cca:	5f                   	pop    %edi
+     ccb:	5d                   	pop    %ebp
+     ccc:	c3                   	ret    
+     ccd:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000cd0 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+     cd0:	f3 0f 1e fb          	endbr32 
+     cd4:	55                   	push   %ebp
+     cd5:	89 e5                	mov    %esp,%ebp
+     cd7:	56                   	push   %esi
+     cd8:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+     cd9:	83 ec 08             	sub    $0x8,%esp
+     cdc:	6a 00                	push   $0x0
+     cde:	ff 75 08             	pushl  0x8(%ebp)
+     ce1:	e8 ed 00 00 00       	call   dd3 <open>
+  if(fd < 0)
+     ce6:	83 c4 10             	add    $0x10,%esp
+     ce9:	85 c0                	test   %eax,%eax
+     ceb:	78 2b                	js     d18 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+     ced:	83 ec 08             	sub    $0x8,%esp
+     cf0:	ff 75 0c             	pushl  0xc(%ebp)
+     cf3:	89 c3                	mov    %eax,%ebx
+     cf5:	50                   	push   %eax
+     cf6:	e8 f0 00 00 00       	call   deb <fstat>
+  close(fd);
+     cfb:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+     cfe:	89 c6                	mov    %eax,%esi
+  close(fd);
+     d00:	e8 b6 00 00 00       	call   dbb <close>
+  return r;
+     d05:	83 c4 10             	add    $0x10,%esp
+}
+     d08:	8d 65 f8             	lea    -0x8(%ebp),%esp
+     d0b:	89 f0                	mov    %esi,%eax
+     d0d:	5b                   	pop    %ebx
+     d0e:	5e                   	pop    %esi
+     d0f:	5d                   	pop    %ebp
+     d10:	c3                   	ret    
+     d11:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+     d18:	be ff ff ff ff       	mov    $0xffffffff,%esi
+     d1d:	eb e9                	jmp    d08 <stat+0x38>
+     d1f:	90                   	nop
+
+00000d20 <atoi>:
+
+int
+atoi(const char *s)
+{
+     d20:	f3 0f 1e fb          	endbr32 
+     d24:	55                   	push   %ebp
+     d25:	89 e5                	mov    %esp,%ebp
+     d27:	53                   	push   %ebx
+     d28:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+     d2b:	0f be 02             	movsbl (%edx),%eax
+     d2e:	8d 48 d0             	lea    -0x30(%eax),%ecx
+     d31:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+     d34:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+     d39:	77 1a                	ja     d55 <atoi+0x35>
+     d3b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+     d3f:	90                   	nop
+    n = n*10 + *s++ - '0';
+     d40:	83 c2 01             	add    $0x1,%edx
+     d43:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+     d46:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+     d4a:	0f be 02             	movsbl (%edx),%eax
+     d4d:	8d 58 d0             	lea    -0x30(%eax),%ebx
+     d50:	80 fb 09             	cmp    $0x9,%bl
+     d53:	76 eb                	jbe    d40 <atoi+0x20>
+  return n;
+}
+     d55:	89 c8                	mov    %ecx,%eax
+     d57:	5b                   	pop    %ebx
+     d58:	5d                   	pop    %ebp
+     d59:	c3                   	ret    
+     d5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000d60 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+     d60:	f3 0f 1e fb          	endbr32 
+     d64:	55                   	push   %ebp
+     d65:	89 e5                	mov    %esp,%ebp
+     d67:	57                   	push   %edi
+     d68:	8b 45 10             	mov    0x10(%ebp),%eax
+     d6b:	8b 55 08             	mov    0x8(%ebp),%edx
+     d6e:	56                   	push   %esi
+     d6f:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+     d72:	85 c0                	test   %eax,%eax
+     d74:	7e 0f                	jle    d85 <memmove+0x25>
+     d76:	01 d0                	add    %edx,%eax
+  dst = vdst;
+     d78:	89 d7                	mov    %edx,%edi
+     d7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+     d80:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+     d81:	39 f8                	cmp    %edi,%eax
+     d83:	75 fb                	jne    d80 <memmove+0x20>
+  return vdst;
+}
+     d85:	5e                   	pop    %esi
+     d86:	89 d0                	mov    %edx,%eax
+     d88:	5f                   	pop    %edi
+     d89:	5d                   	pop    %ebp
+     d8a:	c3                   	ret    
+
+00000d8b <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+     d8b:	b8 01 00 00 00       	mov    $0x1,%eax
+     d90:	cd 40                	int    $0x40
+     d92:	c3                   	ret    
+
+00000d93 <exit>:
+SYSCALL(exit)
+     d93:	b8 02 00 00 00       	mov    $0x2,%eax
+     d98:	cd 40                	int    $0x40
+     d9a:	c3                   	ret    
+
+00000d9b <wait>:
+SYSCALL(wait)
+     d9b:	b8 03 00 00 00       	mov    $0x3,%eax
+     da0:	cd 40                	int    $0x40
+     da2:	c3                   	ret    
+
+00000da3 <pipe>:
+SYSCALL(pipe)
+     da3:	b8 04 00 00 00       	mov    $0x4,%eax
+     da8:	cd 40                	int    $0x40
+     daa:	c3                   	ret    
+
+00000dab <read>:
+SYSCALL(read)
+     dab:	b8 05 00 00 00       	mov    $0x5,%eax
+     db0:	cd 40                	int    $0x40
+     db2:	c3                   	ret    
+
+00000db3 <write>:
+SYSCALL(write)
+     db3:	b8 10 00 00 00       	mov    $0x10,%eax
+     db8:	cd 40                	int    $0x40
+     dba:	c3                   	ret    
+
+00000dbb <close>:
+SYSCALL(close)
+     dbb:	b8 15 00 00 00       	mov    $0x15,%eax
+     dc0:	cd 40                	int    $0x40
+     dc2:	c3                   	ret    
+
+00000dc3 <kill>:
+SYSCALL(kill)
+     dc3:	b8 06 00 00 00       	mov    $0x6,%eax
+     dc8:	cd 40                	int    $0x40
+     dca:	c3                   	ret    
+
+00000dcb <exec>:
+SYSCALL(exec)
+     dcb:	b8 07 00 00 00       	mov    $0x7,%eax
+     dd0:	cd 40                	int    $0x40
+     dd2:	c3                   	ret    
+
+00000dd3 <open>:
+SYSCALL(open)
+     dd3:	b8 0f 00 00 00       	mov    $0xf,%eax
+     dd8:	cd 40                	int    $0x40
+     dda:	c3                   	ret    
+
+00000ddb <mknod>:
+SYSCALL(mknod)
+     ddb:	b8 11 00 00 00       	mov    $0x11,%eax
+     de0:	cd 40                	int    $0x40
+     de2:	c3                   	ret    
+
+00000de3 <unlink>:
+SYSCALL(unlink)
+     de3:	b8 12 00 00 00       	mov    $0x12,%eax
+     de8:	cd 40                	int    $0x40
+     dea:	c3                   	ret    
+
+00000deb <fstat>:
+SYSCALL(fstat)
+     deb:	b8 08 00 00 00       	mov    $0x8,%eax
+     df0:	cd 40                	int    $0x40
+     df2:	c3                   	ret    
+
+00000df3 <link>:
+SYSCALL(link)
+     df3:	b8 13 00 00 00       	mov    $0x13,%eax
+     df8:	cd 40                	int    $0x40
+     dfa:	c3                   	ret    
+
+00000dfb <mkdir>:
+SYSCALL(mkdir)
+     dfb:	b8 14 00 00 00       	mov    $0x14,%eax
+     e00:	cd 40                	int    $0x40
+     e02:	c3                   	ret    
+
+00000e03 <chdir>:
+SYSCALL(chdir)
+     e03:	b8 09 00 00 00       	mov    $0x9,%eax
+     e08:	cd 40                	int    $0x40
+     e0a:	c3                   	ret    
+
+00000e0b <dup>:
+SYSCALL(dup)
+     e0b:	b8 0a 00 00 00       	mov    $0xa,%eax
+     e10:	cd 40                	int    $0x40
+     e12:	c3                   	ret    
+
+00000e13 <getpid>:
+SYSCALL(getpid)
+     e13:	b8 0b 00 00 00       	mov    $0xb,%eax
+     e18:	cd 40                	int    $0x40
+     e1a:	c3                   	ret    
+
+00000e1b <sbrk>:
+SYSCALL(sbrk)
+     e1b:	b8 0c 00 00 00       	mov    $0xc,%eax
+     e20:	cd 40                	int    $0x40
+     e22:	c3                   	ret    
+
+00000e23 <sleep>:
+SYSCALL(sleep)
+     e23:	b8 0d 00 00 00       	mov    $0xd,%eax
+     e28:	cd 40                	int    $0x40
+     e2a:	c3                   	ret    
+
+00000e2b <uptime>:
+SYSCALL(uptime)
+     e2b:	b8 0e 00 00 00       	mov    $0xe,%eax
+     e30:	cd 40                	int    $0x40
+     e32:	c3                   	ret    
+
+00000e33 <draw>:
+SYSCALL(draw)
+     e33:	b8 16 00 00 00       	mov    $0x16,%eax
+     e38:	cd 40                	int    $0x40
+     e3a:	c3                   	ret    
+
+00000e3b <thread_create>:
+
+SYSCALL(thread_create)
+     e3b:	b8 17 00 00 00       	mov    $0x17,%eax
+     e40:	cd 40                	int    $0x40
+     e42:	c3                   	ret    
+
+00000e43 <thread_join>:
+SYSCALL(thread_join)
+     e43:	b8 18 00 00 00       	mov    $0x18,%eax
+     e48:	cd 40                	int    $0x40
+     e4a:	c3                   	ret    
+
+00000e4b <thread_exit>:
+SYSCALL(thread_exit)
+     e4b:	b8 19 00 00 00       	mov    $0x19,%eax
+     e50:	cd 40                	int    $0x40
+     e52:	c3                   	ret    
+     e53:	66 90                	xchg   %ax,%ax
+     e55:	66 90                	xchg   %ax,%ax
+     e57:	66 90                	xchg   %ax,%ax
+     e59:	66 90                	xchg   %ax,%ax
+     e5b:	66 90                	xchg   %ax,%ax
+     e5d:	66 90                	xchg   %ax,%ax
+     e5f:	90                   	nop
+
+00000e60 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+     e60:	55                   	push   %ebp
+     e61:	89 e5                	mov    %esp,%ebp
+     e63:	57                   	push   %edi
+     e64:	56                   	push   %esi
+     e65:	53                   	push   %ebx
+     e66:	83 ec 3c             	sub    $0x3c,%esp
+     e69:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+     e6c:	89 d1                	mov    %edx,%ecx
+{
+     e6e:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  if(sgn && xx < 0){
+     e71:	85 d2                	test   %edx,%edx
+     e73:	0f 89 7f 00 00 00    	jns    ef8 <printint+0x98>
+     e79:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
+     e7d:	74 79                	je     ef8 <printint+0x98>
+    neg = 1;
+     e7f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+    x = -xx;
+     e86:	f7 d9                	neg    %ecx
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+     e88:	31 db                	xor    %ebx,%ebx
+     e8a:	8d 75 d7             	lea    -0x29(%ebp),%esi
+     e8d:	8d 76 00             	lea    0x0(%esi),%esi
+  do{
+    buf[i++] = digits[x % base];
+     e90:	89 c8                	mov    %ecx,%eax
+     e92:	31 d2                	xor    %edx,%edx
+     e94:	89 cf                	mov    %ecx,%edi
+     e96:	f7 75 c4             	divl   -0x3c(%ebp)
+     e99:	0f b6 92 68 13 00 00 	movzbl 0x1368(%edx),%edx
+     ea0:	89 45 c0             	mov    %eax,-0x40(%ebp)
+     ea3:	89 d8                	mov    %ebx,%eax
+     ea5:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+     ea8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+    buf[i++] = digits[x % base];
+     eab:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
+  }while((x /= base) != 0);
+     eae:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
+     eb1:	76 dd                	jbe    e90 <printint+0x30>
+  if(neg)
+     eb3:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+     eb6:	85 c9                	test   %ecx,%ecx
+     eb8:	74 0c                	je     ec6 <printint+0x66>
+    buf[i++] = '-';
+     eba:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+     ebf:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+     ec1:	ba 2d 00 00 00       	mov    $0x2d,%edx
+
+  while(--i >= 0)
+     ec6:	8b 7d b8             	mov    -0x48(%ebp),%edi
+     ec9:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+     ecd:	eb 07                	jmp    ed6 <printint+0x76>
+     ecf:	90                   	nop
+     ed0:	0f b6 13             	movzbl (%ebx),%edx
+     ed3:	83 eb 01             	sub    $0x1,%ebx
+  write(fd, &c, 1);
+     ed6:	83 ec 04             	sub    $0x4,%esp
+     ed9:	88 55 d7             	mov    %dl,-0x29(%ebp)
+     edc:	6a 01                	push   $0x1
+     ede:	56                   	push   %esi
+     edf:	57                   	push   %edi
+     ee0:	e8 ce fe ff ff       	call   db3 <write>
+  while(--i >= 0)
+     ee5:	83 c4 10             	add    $0x10,%esp
+     ee8:	39 de                	cmp    %ebx,%esi
+     eea:	75 e4                	jne    ed0 <printint+0x70>
+    putc(fd, buf[i]);
+}
+     eec:	8d 65 f4             	lea    -0xc(%ebp),%esp
+     eef:	5b                   	pop    %ebx
+     ef0:	5e                   	pop    %esi
+     ef1:	5f                   	pop    %edi
+     ef2:	5d                   	pop    %ebp
+     ef3:	c3                   	ret    
+     ef4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  neg = 0;
+     ef8:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+     eff:	eb 87                	jmp    e88 <printint+0x28>
+     f01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     f08:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     f0f:	90                   	nop
+
+00000f10 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+     f10:	f3 0f 1e fb          	endbr32 
+     f14:	55                   	push   %ebp
+     f15:	89 e5                	mov    %esp,%ebp
+     f17:	57                   	push   %edi
+     f18:	56                   	push   %esi
+     f19:	53                   	push   %ebx
+     f1a:	83 ec 2c             	sub    $0x2c,%esp
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+     f1d:	8b 75 0c             	mov    0xc(%ebp),%esi
+     f20:	0f b6 1e             	movzbl (%esi),%ebx
+     f23:	84 db                	test   %bl,%bl
+     f25:	0f 84 b4 00 00 00    	je     fdf <printf+0xcf>
+  ap = (uint*)(void*)&fmt + 1;
+     f2b:	8d 45 10             	lea    0x10(%ebp),%eax
+     f2e:	83 c6 01             	add    $0x1,%esi
+  write(fd, &c, 1);
+     f31:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  state = 0;
+     f34:	31 d2                	xor    %edx,%edx
+  ap = (uint*)(void*)&fmt + 1;
+     f36:	89 45 d0             	mov    %eax,-0x30(%ebp)
+     f39:	eb 33                	jmp    f6e <printf+0x5e>
+     f3b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+     f3f:	90                   	nop
+     f40:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+     f43:	ba 25 00 00 00       	mov    $0x25,%edx
+      if(c == '%'){
+     f48:	83 f8 25             	cmp    $0x25,%eax
+     f4b:	74 17                	je     f64 <printf+0x54>
+  write(fd, &c, 1);
+     f4d:	83 ec 04             	sub    $0x4,%esp
+     f50:	88 5d e7             	mov    %bl,-0x19(%ebp)
+     f53:	6a 01                	push   $0x1
+     f55:	57                   	push   %edi
+     f56:	ff 75 08             	pushl  0x8(%ebp)
+     f59:	e8 55 fe ff ff       	call   db3 <write>
+     f5e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+      } else {
+        putc(fd, c);
+     f61:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; fmt[i]; i++){
+     f64:	0f b6 1e             	movzbl (%esi),%ebx
+     f67:	83 c6 01             	add    $0x1,%esi
+     f6a:	84 db                	test   %bl,%bl
+     f6c:	74 71                	je     fdf <printf+0xcf>
+    c = fmt[i] & 0xff;
+     f6e:	0f be cb             	movsbl %bl,%ecx
+     f71:	0f b6 c3             	movzbl %bl,%eax
+    if(state == 0){
+     f74:	85 d2                	test   %edx,%edx
+     f76:	74 c8                	je     f40 <printf+0x30>
+      }
+    } else if(state == '%'){
+     f78:	83 fa 25             	cmp    $0x25,%edx
+     f7b:	75 e7                	jne    f64 <printf+0x54>
+      if(c == 'd'){
+     f7d:	83 f8 64             	cmp    $0x64,%eax
+     f80:	0f 84 9a 00 00 00    	je     1020 <printf+0x110>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+     f86:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
+     f8c:	83 f9 70             	cmp    $0x70,%ecx
+     f8f:	74 5f                	je     ff0 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+     f91:	83 f8 73             	cmp    $0x73,%eax
+     f94:	0f 84 d6 00 00 00    	je     1070 <printf+0x160>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+     f9a:	83 f8 63             	cmp    $0x63,%eax
+     f9d:	0f 84 8d 00 00 00    	je     1030 <printf+0x120>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+     fa3:	83 f8 25             	cmp    $0x25,%eax
+     fa6:	0f 84 b4 00 00 00    	je     1060 <printf+0x150>
+  write(fd, &c, 1);
+     fac:	83 ec 04             	sub    $0x4,%esp
+     faf:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
+     fb3:	6a 01                	push   $0x1
+     fb5:	57                   	push   %edi
+     fb6:	ff 75 08             	pushl  0x8(%ebp)
+     fb9:	e8 f5 fd ff ff       	call   db3 <write>
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+     fbe:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+     fc1:	83 c4 0c             	add    $0xc,%esp
+     fc4:	6a 01                	push   $0x1
+     fc6:	83 c6 01             	add    $0x1,%esi
+     fc9:	57                   	push   %edi
+     fca:	ff 75 08             	pushl  0x8(%ebp)
+     fcd:	e8 e1 fd ff ff       	call   db3 <write>
+  for(i = 0; fmt[i]; i++){
+     fd2:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
+        putc(fd, c);
+     fd6:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+     fd9:	31 d2                	xor    %edx,%edx
+  for(i = 0; fmt[i]; i++){
+     fdb:	84 db                	test   %bl,%bl
+     fdd:	75 8f                	jne    f6e <printf+0x5e>
+    }
+  }
+}
+     fdf:	8d 65 f4             	lea    -0xc(%ebp),%esp
+     fe2:	5b                   	pop    %ebx
+     fe3:	5e                   	pop    %esi
+     fe4:	5f                   	pop    %edi
+     fe5:	5d                   	pop    %ebp
+     fe6:	c3                   	ret    
+     fe7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     fee:	66 90                	xchg   %ax,%ax
+        printint(fd, *ap, 16, 0);
+     ff0:	83 ec 0c             	sub    $0xc,%esp
+     ff3:	b9 10 00 00 00       	mov    $0x10,%ecx
+     ff8:	6a 00                	push   $0x0
+     ffa:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+     ffd:	8b 45 08             	mov    0x8(%ebp),%eax
+    1000:	8b 13                	mov    (%ebx),%edx
+    1002:	e8 59 fe ff ff       	call   e60 <printint>
+        ap++;
+    1007:	89 d8                	mov    %ebx,%eax
+    1009:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+    100c:	31 d2                	xor    %edx,%edx
+        ap++;
+    100e:	83 c0 04             	add    $0x4,%eax
+    1011:	89 45 d0             	mov    %eax,-0x30(%ebp)
+    1014:	e9 4b ff ff ff       	jmp    f64 <printf+0x54>
+    1019:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        printint(fd, *ap, 10, 1);
+    1020:	83 ec 0c             	sub    $0xc,%esp
+    1023:	b9 0a 00 00 00       	mov    $0xa,%ecx
+    1028:	6a 01                	push   $0x1
+    102a:	eb ce                	jmp    ffa <printf+0xea>
+    102c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        putc(fd, *ap);
+    1030:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+  write(fd, &c, 1);
+    1033:	83 ec 04             	sub    $0x4,%esp
+        putc(fd, *ap);
+    1036:	8b 03                	mov    (%ebx),%eax
+  write(fd, &c, 1);
+    1038:	6a 01                	push   $0x1
+        ap++;
+    103a:	83 c3 04             	add    $0x4,%ebx
+  write(fd, &c, 1);
+    103d:	57                   	push   %edi
+    103e:	ff 75 08             	pushl  0x8(%ebp)
+        putc(fd, *ap);
+    1041:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+    1044:	e8 6a fd ff ff       	call   db3 <write>
+        ap++;
+    1049:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+    104c:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+    104f:	31 d2                	xor    %edx,%edx
+    1051:	e9 0e ff ff ff       	jmp    f64 <printf+0x54>
+    1056:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    105d:	8d 76 00             	lea    0x0(%esi),%esi
+        putc(fd, c);
+    1060:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+    1063:	83 ec 04             	sub    $0x4,%esp
+    1066:	e9 59 ff ff ff       	jmp    fc4 <printf+0xb4>
+    106b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    106f:	90                   	nop
+        s = (char*)*ap;
+    1070:	8b 45 d0             	mov    -0x30(%ebp),%eax
+    1073:	8b 18                	mov    (%eax),%ebx
+        ap++;
+    1075:	83 c0 04             	add    $0x4,%eax
+    1078:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        if(s == 0)
+    107b:	85 db                	test   %ebx,%ebx
+    107d:	74 17                	je     1096 <printf+0x186>
+        while(*s != 0){
+    107f:	0f b6 03             	movzbl (%ebx),%eax
+      state = 0;
+    1082:	31 d2                	xor    %edx,%edx
+        while(*s != 0){
+    1084:	84 c0                	test   %al,%al
+    1086:	0f 84 d8 fe ff ff    	je     f64 <printf+0x54>
+    108c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+    108f:	89 de                	mov    %ebx,%esi
+    1091:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    1094:	eb 1a                	jmp    10b0 <printf+0x1a0>
+          s = "(null)";
+    1096:	bb 60 13 00 00       	mov    $0x1360,%ebx
+        while(*s != 0){
+    109b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+    109e:	b8 28 00 00 00       	mov    $0x28,%eax
+    10a3:	89 de                	mov    %ebx,%esi
+    10a5:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    10a8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    10af:	90                   	nop
+  write(fd, &c, 1);
+    10b0:	83 ec 04             	sub    $0x4,%esp
+          s++;
+    10b3:	83 c6 01             	add    $0x1,%esi
+    10b6:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+    10b9:	6a 01                	push   $0x1
+    10bb:	57                   	push   %edi
+    10bc:	53                   	push   %ebx
+    10bd:	e8 f1 fc ff ff       	call   db3 <write>
+        while(*s != 0){
+    10c2:	0f b6 06             	movzbl (%esi),%eax
+    10c5:	83 c4 10             	add    $0x10,%esp
+    10c8:	84 c0                	test   %al,%al
+    10ca:	75 e4                	jne    10b0 <printf+0x1a0>
+    10cc:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+      state = 0;
+    10cf:	31 d2                	xor    %edx,%edx
+    10d1:	e9 8e fe ff ff       	jmp    f64 <printf+0x54>
+    10d6:	66 90                	xchg   %ax,%ax
+    10d8:	66 90                	xchg   %ax,%ax
+    10da:	66 90                	xchg   %ax,%ax
+    10dc:	66 90                	xchg   %ax,%ax
+    10de:	66 90                	xchg   %ax,%ax
+
+000010e0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    10e0:	f3 0f 1e fb          	endbr32 
+    10e4:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    10e5:	a1 c4 19 00 00       	mov    0x19c4,%eax
+{
+    10ea:	89 e5                	mov    %esp,%ebp
+    10ec:	57                   	push   %edi
+    10ed:	56                   	push   %esi
+    10ee:	53                   	push   %ebx
+    10ef:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    10f2:	8b 10                	mov    (%eax),%edx
+  bp = (Header*)ap - 1;
+    10f4:	8d 4b f8             	lea    -0x8(%ebx),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    10f7:	39 c8                	cmp    %ecx,%eax
+    10f9:	73 15                	jae    1110 <free+0x30>
+    10fb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    10ff:	90                   	nop
+    1100:	39 d1                	cmp    %edx,%ecx
+    1102:	72 14                	jb     1118 <free+0x38>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1104:	39 d0                	cmp    %edx,%eax
+    1106:	73 10                	jae    1118 <free+0x38>
+{
+    1108:	89 d0                	mov    %edx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    110a:	8b 10                	mov    (%eax),%edx
+    110c:	39 c8                	cmp    %ecx,%eax
+    110e:	72 f0                	jb     1100 <free+0x20>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1110:	39 d0                	cmp    %edx,%eax
+    1112:	72 f4                	jb     1108 <free+0x28>
+    1114:	39 d1                	cmp    %edx,%ecx
+    1116:	73 f0                	jae    1108 <free+0x28>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    1118:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    111b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
+    111e:	39 fa                	cmp    %edi,%edx
+    1120:	74 1e                	je     1140 <free+0x60>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    1122:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    1125:	8b 50 04             	mov    0x4(%eax),%edx
+    1128:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+    112b:	39 f1                	cmp    %esi,%ecx
+    112d:	74 28                	je     1157 <free+0x77>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    112f:	89 08                	mov    %ecx,(%eax)
+  freep = p;
+}
+    1131:	5b                   	pop    %ebx
+  freep = p;
+    1132:	a3 c4 19 00 00       	mov    %eax,0x19c4
+}
+    1137:	5e                   	pop    %esi
+    1138:	5f                   	pop    %edi
+    1139:	5d                   	pop    %ebp
+    113a:	c3                   	ret    
+    113b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    113f:	90                   	nop
+    bp->s.size += p->s.ptr->s.size;
+    1140:	03 72 04             	add    0x4(%edx),%esi
+    1143:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    1146:	8b 10                	mov    (%eax),%edx
+    1148:	8b 12                	mov    (%edx),%edx
+    114a:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    114d:	8b 50 04             	mov    0x4(%eax),%edx
+    1150:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+    1153:	39 f1                	cmp    %esi,%ecx
+    1155:	75 d8                	jne    112f <free+0x4f>
+    p->s.size += bp->s.size;
+    1157:	03 53 fc             	add    -0x4(%ebx),%edx
+  freep = p;
+    115a:	a3 c4 19 00 00       	mov    %eax,0x19c4
+    p->s.size += bp->s.size;
+    115f:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    1162:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    1165:	89 10                	mov    %edx,(%eax)
+}
+    1167:	5b                   	pop    %ebx
+    1168:	5e                   	pop    %esi
+    1169:	5f                   	pop    %edi
+    116a:	5d                   	pop    %ebp
+    116b:	c3                   	ret    
+    116c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00001170 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1170:	f3 0f 1e fb          	endbr32 
+    1174:	55                   	push   %ebp
+    1175:	89 e5                	mov    %esp,%ebp
+    1177:	57                   	push   %edi
+    1178:	56                   	push   %esi
+    1179:	53                   	push   %ebx
+    117a:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    117d:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    1180:	8b 3d c4 19 00 00    	mov    0x19c4,%edi
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1186:	8d 70 07             	lea    0x7(%eax),%esi
+    1189:	c1 ee 03             	shr    $0x3,%esi
+    118c:	83 c6 01             	add    $0x1,%esi
+  if((prevp = freep) == 0){
+    118f:	85 ff                	test   %edi,%edi
+    1191:	0f 84 a9 00 00 00    	je     1240 <malloc+0xd0>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    1197:	8b 07                	mov    (%edi),%eax
+    if(p->s.size >= nunits){
+    1199:	8b 48 04             	mov    0x4(%eax),%ecx
+    119c:	39 f1                	cmp    %esi,%ecx
+    119e:	73 6d                	jae    120d <malloc+0x9d>
+    11a0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    11a6:	bb 00 10 00 00       	mov    $0x1000,%ebx
+    11ab:	0f 43 de             	cmovae %esi,%ebx
+  p = sbrk(nu * sizeof(Header));
+    11ae:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
+    11b5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+    11b8:	eb 17                	jmp    11d1 <malloc+0x61>
+    11ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    11c0:	8b 10                	mov    (%eax),%edx
+    if(p->s.size >= nunits){
+    11c2:	8b 4a 04             	mov    0x4(%edx),%ecx
+    11c5:	39 f1                	cmp    %esi,%ecx
+    11c7:	73 4f                	jae    1218 <malloc+0xa8>
+    11c9:	8b 3d c4 19 00 00    	mov    0x19c4,%edi
+    11cf:	89 d0                	mov    %edx,%eax
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    11d1:	39 c7                	cmp    %eax,%edi
+    11d3:	75 eb                	jne    11c0 <malloc+0x50>
+  p = sbrk(nu * sizeof(Header));
+    11d5:	83 ec 0c             	sub    $0xc,%esp
+    11d8:	ff 75 e4             	pushl  -0x1c(%ebp)
+    11db:	e8 3b fc ff ff       	call   e1b <sbrk>
+  if(p == (char*)-1)
+    11e0:	83 c4 10             	add    $0x10,%esp
+    11e3:	83 f8 ff             	cmp    $0xffffffff,%eax
+    11e6:	74 1b                	je     1203 <malloc+0x93>
+  hp->s.size = nu;
+    11e8:	89 58 04             	mov    %ebx,0x4(%eax)
+  free((void*)(hp + 1));
+    11eb:	83 ec 0c             	sub    $0xc,%esp
+    11ee:	83 c0 08             	add    $0x8,%eax
+    11f1:	50                   	push   %eax
+    11f2:	e8 e9 fe ff ff       	call   10e0 <free>
+  return freep;
+    11f7:	a1 c4 19 00 00       	mov    0x19c4,%eax
+      if((p = morecore(nunits)) == 0)
+    11fc:	83 c4 10             	add    $0x10,%esp
+    11ff:	85 c0                	test   %eax,%eax
+    1201:	75 bd                	jne    11c0 <malloc+0x50>
+        return 0;
+  }
+}
+    1203:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return 0;
+    1206:	31 c0                	xor    %eax,%eax
+}
+    1208:	5b                   	pop    %ebx
+    1209:	5e                   	pop    %esi
+    120a:	5f                   	pop    %edi
+    120b:	5d                   	pop    %ebp
+    120c:	c3                   	ret    
+    if(p->s.size >= nunits){
+    120d:	89 c2                	mov    %eax,%edx
+    120f:	89 f8                	mov    %edi,%eax
+    1211:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    1218:	39 ce                	cmp    %ecx,%esi
+    121a:	74 54                	je     1270 <malloc+0x100>
+        p->s.size -= nunits;
+    121c:	29 f1                	sub    %esi,%ecx
+    121e:	89 4a 04             	mov    %ecx,0x4(%edx)
+        p += p->s.size;
+    1221:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
+        p->s.size = nunits;
+    1224:	89 72 04             	mov    %esi,0x4(%edx)
+      freep = prevp;
+    1227:	a3 c4 19 00 00       	mov    %eax,0x19c4
+}
+    122c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return (void*)(p + 1);
+    122f:	8d 42 08             	lea    0x8(%edx),%eax
+}
+    1232:	5b                   	pop    %ebx
+    1233:	5e                   	pop    %esi
+    1234:	5f                   	pop    %edi
+    1235:	5d                   	pop    %ebp
+    1236:	c3                   	ret    
+    1237:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    123e:	66 90                	xchg   %ax,%ax
+    base.s.ptr = freep = prevp = &base;
+    1240:	c7 05 c4 19 00 00 c8 	movl   $0x19c8,0x19c4
+    1247:	19 00 00 
+    base.s.size = 0;
+    124a:	bf c8 19 00 00       	mov    $0x19c8,%edi
+    base.s.ptr = freep = prevp = &base;
+    124f:	c7 05 c8 19 00 00 c8 	movl   $0x19c8,0x19c8
+    1256:	19 00 00 
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    1259:	89 f8                	mov    %edi,%eax
+    base.s.size = 0;
+    125b:	c7 05 cc 19 00 00 00 	movl   $0x0,0x19cc
+    1262:	00 00 00 
+    if(p->s.size >= nunits){
+    1265:	e9 36 ff ff ff       	jmp    11a0 <malloc+0x30>
+    126a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        prevp->s.ptr = p->s.ptr;
+    1270:	8b 0a                	mov    (%edx),%ecx
+    1272:	89 08                	mov    %ecx,(%eax)
+    1274:	eb b1                	jmp    1227 <malloc+0xb7>
diff -ruN xv6-public/sh.d copy-xv6/sh.d
--- xv6-public/sh.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/sh.d	2022-09-05 23:26:12.180781087 +0530
@@ -0,0 +1 @@
+sh.o: sh.c /usr/include/stdc-predef.h types.h user.h fcntl.h
Binary files xv6-public/sh.o and copy-xv6/sh.o differ
diff -ruN xv6-public/sh.sym copy-xv6/sh.sym
--- xv6-public/sh.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/sh.sym	2022-09-05 23:26:12.192781087 +0530
@@ -0,0 +1,83 @@
+00000000 .text
+00001278 .rodata
+0000137c .eh_frame
+00001938 .data
+00001960 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 sh.c
+00001960 buf.1135
+00000000 ulib.c
+00000000 printf.c
+00000e60 printint
+00001368 digits.1097
+00000000 umalloc.c
+000019c4 freep
+000019c8 base
+00000b30 strcpy
+00000f10 printf
+00000e4b thread_exit
+00000d60 memmove
+00000ddb mknod
+00000370 execcmd
+00000c50 gets
+00000e13 getpid
+00000850 parsepipe
+00000ac0 parsecmd
+00000470 backcmd
+00000610 peek
+00000690 parseredirs
+000004b0 gettoken
+00001170 malloc
+00000e23 sleep
+00001940 whitespace
+00000340 fork1
+00000a00 nulterminate
+00000da3 pipe
+00000110 getcmd
+00000db3 write
+00000deb fstat
+00000dc3 kill
+00000e03 chdir
+000008c0 parseline
+00000180 runcmd
+00000970 parseblock
+00000dcb exec
+00000d9b wait
+00001938 symbols
+00000dab read
+00000740 parseexec
+00000de3 unlink
+00000160 panic
+00000d8b fork
+00000e1b sbrk
+00000e2b uptime
+00001946 __bss_start
+00000bf0 memset
+00000000 main
+00000b60 strcmp
+00000e0b dup
+000003f0 pipecmd
+000003a0 redircmd
+00000cd0 stat
+00001946 _edata
+000019d0 _end
+00000df3 link
+00000d93 exit
+00000d20 atoi
+00000e33 draw
+00000bb0 strlen
+00000dd3 open
+00000c10 strchr
+00000e3b thread_create
+00000dfb mkdir
+00000dbb close
+00000e43 thread_join
+00000430 listcmd
+000010e0 free
diff -ruN xv6-public/sleeplock.d copy-xv6/sleeplock.d
--- xv6-public/sleeplock.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/sleeplock.d	2022-09-05 23:26:13.440781059 +0530
@@ -0,0 +1,2 @@
+sleeplock.o: sleeplock.c /usr/include/stdc-predef.h types.h defs.h \
+ param.h x86.h memlayout.h mmu.h proc.h spinlock.h sleeplock.h
Binary files xv6-public/sleeplock.o and copy-xv6/sleeplock.o differ
diff -ruN xv6-public/spinlock.d copy-xv6/spinlock.d
--- xv6-public/spinlock.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/spinlock.d	2022-09-05 23:26:13.476781058 +0530
@@ -0,0 +1,2 @@
+spinlock.o: spinlock.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ x86.h memlayout.h mmu.h proc.h spinlock.h
Binary files xv6-public/spinlock.o and copy-xv6/spinlock.o differ
Binary files xv6-public/_stressfs and copy-xv6/_stressfs differ
diff -ruN xv6-public/stressfs.asm copy-xv6/stressfs.asm
--- xv6-public/stressfs.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/stressfs.asm	2022-09-05 23:26:12.220781087 +0530
@@ -0,0 +1,1317 @@
+
+_stressfs:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "fs.h"
+#include "fcntl.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+  int fd, i;
+  char path[] = "stressfs0";
+   b:	b8 30 00 00 00       	mov    $0x30,%eax
+{
+  10:	ff 71 fc             	pushl  -0x4(%ecx)
+  13:	55                   	push   %ebp
+  14:	89 e5                	mov    %esp,%ebp
+  16:	57                   	push   %edi
+  17:	56                   	push   %esi
+  char data[512];
+
+  printf(1, "stressfs starting\n");
+  memset(data, 'a', sizeof(data));
+  18:	8d b5 e8 fd ff ff    	lea    -0x218(%ebp),%esi
+{
+  1e:	53                   	push   %ebx
+
+  for(i = 0; i < 4; i++)
+  1f:	31 db                	xor    %ebx,%ebx
+{
+  21:	51                   	push   %ecx
+  22:	81 ec 20 02 00 00    	sub    $0x220,%esp
+  char path[] = "stressfs0";
+  28:	66 89 85 e6 fd ff ff 	mov    %ax,-0x21a(%ebp)
+  printf(1, "stressfs starting\n");
+  2f:	68 88 08 00 00       	push   $0x888
+  34:	6a 01                	push   $0x1
+  char path[] = "stressfs0";
+  36:	c7 85 de fd ff ff 73 	movl   $0x65727473,-0x222(%ebp)
+  3d:	74 72 65 
+  40:	c7 85 e2 fd ff ff 73 	movl   $0x73667373,-0x21e(%ebp)
+  47:	73 66 73 
+  printf(1, "stressfs starting\n");
+  4a:	e8 d1 04 00 00       	call   520 <printf>
+  memset(data, 'a', sizeof(data));
+  4f:	83 c4 0c             	add    $0xc,%esp
+  52:	68 00 02 00 00       	push   $0x200
+  57:	6a 61                	push   $0x61
+  59:	56                   	push   %esi
+  5a:	e8 a1 01 00 00       	call   200 <memset>
+  5f:	83 c4 10             	add    $0x10,%esp
+    if(fork() > 0)
+  62:	e8 34 03 00 00       	call   39b <fork>
+  67:	85 c0                	test   %eax,%eax
+  69:	0f 8f bb 00 00 00    	jg     12a <main+0x12a>
+  for(i = 0; i < 4; i++)
+  6f:	83 c3 01             	add    $0x1,%ebx
+  72:	83 fb 04             	cmp    $0x4,%ebx
+  75:	75 eb                	jne    62 <main+0x62>
+  77:	bf 04 00 00 00       	mov    $0x4,%edi
+      break;
+
+  printf(1, "write %d\n", i);
+  7c:	83 ec 04             	sub    $0x4,%esp
+  7f:	53                   	push   %ebx
+
+  path[8] += i;
+  fd = open(path, O_CREATE | O_RDWR);
+  80:	bb 14 00 00 00       	mov    $0x14,%ebx
+  printf(1, "write %d\n", i);
+  85:	68 9b 08 00 00       	push   $0x89b
+  8a:	6a 01                	push   $0x1
+  8c:	e8 8f 04 00 00       	call   520 <printf>
+  path[8] += i;
+  91:	89 f8                	mov    %edi,%eax
+  fd = open(path, O_CREATE | O_RDWR);
+  93:	5f                   	pop    %edi
+  path[8] += i;
+  94:	00 85 e6 fd ff ff    	add    %al,-0x21a(%ebp)
+  fd = open(path, O_CREATE | O_RDWR);
+  9a:	58                   	pop    %eax
+  9b:	8d 85 de fd ff ff    	lea    -0x222(%ebp),%eax
+  a1:	68 02 02 00 00       	push   $0x202
+  a6:	50                   	push   %eax
+  a7:	e8 37 03 00 00       	call   3e3 <open>
+  ac:	83 c4 10             	add    $0x10,%esp
+  af:	89 c7                	mov    %eax,%edi
+  for(i = 0; i < 20; i++)
+  b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+//    printf(fd, "%d\n", i);
+    write(fd, data, sizeof(data));
+  b8:	83 ec 04             	sub    $0x4,%esp
+  bb:	68 00 02 00 00       	push   $0x200
+  c0:	56                   	push   %esi
+  c1:	57                   	push   %edi
+  c2:	e8 fc 02 00 00       	call   3c3 <write>
+  for(i = 0; i < 20; i++)
+  c7:	83 c4 10             	add    $0x10,%esp
+  ca:	83 eb 01             	sub    $0x1,%ebx
+  cd:	75 e9                	jne    b8 <main+0xb8>
+  close(fd);
+  cf:	83 ec 0c             	sub    $0xc,%esp
+  d2:	57                   	push   %edi
+  d3:	e8 f3 02 00 00       	call   3cb <close>
+
+  printf(1, "read\n");
+  d8:	58                   	pop    %eax
+  d9:	5a                   	pop    %edx
+  da:	68 a5 08 00 00       	push   $0x8a5
+  df:	6a 01                	push   $0x1
+  e1:	e8 3a 04 00 00       	call   520 <printf>
+
+  fd = open(path, O_RDONLY);
+  e6:	8d 85 de fd ff ff    	lea    -0x222(%ebp),%eax
+  ec:	59                   	pop    %ecx
+  ed:	5b                   	pop    %ebx
+  ee:	6a 00                	push   $0x0
+  f0:	bb 14 00 00 00       	mov    $0x14,%ebx
+  f5:	50                   	push   %eax
+  f6:	e8 e8 02 00 00       	call   3e3 <open>
+  fb:	83 c4 10             	add    $0x10,%esp
+  fe:	89 c7                	mov    %eax,%edi
+  for (i = 0; i < 20; i++)
+    read(fd, data, sizeof(data));
+ 100:	83 ec 04             	sub    $0x4,%esp
+ 103:	68 00 02 00 00       	push   $0x200
+ 108:	56                   	push   %esi
+ 109:	57                   	push   %edi
+ 10a:	e8 ac 02 00 00       	call   3bb <read>
+  for (i = 0; i < 20; i++)
+ 10f:	83 c4 10             	add    $0x10,%esp
+ 112:	83 eb 01             	sub    $0x1,%ebx
+ 115:	75 e9                	jne    100 <main+0x100>
+  close(fd);
+ 117:	83 ec 0c             	sub    $0xc,%esp
+ 11a:	57                   	push   %edi
+ 11b:	e8 ab 02 00 00       	call   3cb <close>
+
+  wait();
+ 120:	e8 86 02 00 00       	call   3ab <wait>
+
+  exit();
+ 125:	e8 79 02 00 00       	call   3a3 <exit>
+ 12a:	89 df                	mov    %ebx,%edi
+ 12c:	e9 4b ff ff ff       	jmp    7c <main+0x7c>
+ 131:	66 90                	xchg   %ax,%ax
+ 133:	66 90                	xchg   %ax,%ax
+ 135:	66 90                	xchg   %ax,%ax
+ 137:	66 90                	xchg   %ax,%ax
+ 139:	66 90                	xchg   %ax,%ax
+ 13b:	66 90                	xchg   %ax,%ax
+ 13d:	66 90                	xchg   %ax,%ax
+ 13f:	90                   	nop
+
+00000140 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 140:	f3 0f 1e fb          	endbr32 
+ 144:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+ 145:	31 c0                	xor    %eax,%eax
+{
+ 147:	89 e5                	mov    %esp,%ebp
+ 149:	53                   	push   %ebx
+ 14a:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 14d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+ 150:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+ 154:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+ 157:	83 c0 01             	add    $0x1,%eax
+ 15a:	84 d2                	test   %dl,%dl
+ 15c:	75 f2                	jne    150 <strcpy+0x10>
+    ;
+  return os;
+}
+ 15e:	89 c8                	mov    %ecx,%eax
+ 160:	5b                   	pop    %ebx
+ 161:	5d                   	pop    %ebp
+ 162:	c3                   	ret    
+ 163:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 16a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000170 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 170:	f3 0f 1e fb          	endbr32 
+ 174:	55                   	push   %ebp
+ 175:	89 e5                	mov    %esp,%ebp
+ 177:	53                   	push   %ebx
+ 178:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 17b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+ 17e:	0f b6 01             	movzbl (%ecx),%eax
+ 181:	0f b6 1a             	movzbl (%edx),%ebx
+ 184:	84 c0                	test   %al,%al
+ 186:	75 19                	jne    1a1 <strcmp+0x31>
+ 188:	eb 26                	jmp    1b0 <strcmp+0x40>
+ 18a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 190:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+ 194:	83 c1 01             	add    $0x1,%ecx
+ 197:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+ 19a:	0f b6 1a             	movzbl (%edx),%ebx
+ 19d:	84 c0                	test   %al,%al
+ 19f:	74 0f                	je     1b0 <strcmp+0x40>
+ 1a1:	38 d8                	cmp    %bl,%al
+ 1a3:	74 eb                	je     190 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+ 1a5:	29 d8                	sub    %ebx,%eax
+}
+ 1a7:	5b                   	pop    %ebx
+ 1a8:	5d                   	pop    %ebp
+ 1a9:	c3                   	ret    
+ 1aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 1b0:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+ 1b2:	29 d8                	sub    %ebx,%eax
+}
+ 1b4:	5b                   	pop    %ebx
+ 1b5:	5d                   	pop    %ebp
+ 1b6:	c3                   	ret    
+ 1b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1be:	66 90                	xchg   %ax,%ax
+
+000001c0 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 1c0:	f3 0f 1e fb          	endbr32 
+ 1c4:	55                   	push   %ebp
+ 1c5:	89 e5                	mov    %esp,%ebp
+ 1c7:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 1ca:	80 3a 00             	cmpb   $0x0,(%edx)
+ 1cd:	74 21                	je     1f0 <strlen+0x30>
+ 1cf:	31 c0                	xor    %eax,%eax
+ 1d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1d8:	83 c0 01             	add    $0x1,%eax
+ 1db:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+ 1df:	89 c1                	mov    %eax,%ecx
+ 1e1:	75 f5                	jne    1d8 <strlen+0x18>
+    ;
+  return n;
+}
+ 1e3:	89 c8                	mov    %ecx,%eax
+ 1e5:	5d                   	pop    %ebp
+ 1e6:	c3                   	ret    
+ 1e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1ee:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+ 1f0:	31 c9                	xor    %ecx,%ecx
+}
+ 1f2:	5d                   	pop    %ebp
+ 1f3:	89 c8                	mov    %ecx,%eax
+ 1f5:	c3                   	ret    
+ 1f6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1fd:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000200 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 200:	f3 0f 1e fb          	endbr32 
+ 204:	55                   	push   %ebp
+ 205:	89 e5                	mov    %esp,%ebp
+ 207:	57                   	push   %edi
+ 208:	8b 55 08             	mov    0x8(%ebp),%edx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+ 20b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 20e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 211:	89 d7                	mov    %edx,%edi
+ 213:	fc                   	cld    
+ 214:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+ 216:	89 d0                	mov    %edx,%eax
+ 218:	5f                   	pop    %edi
+ 219:	5d                   	pop    %ebp
+ 21a:	c3                   	ret    
+ 21b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 21f:	90                   	nop
+
+00000220 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 220:	f3 0f 1e fb          	endbr32 
+ 224:	55                   	push   %ebp
+ 225:	89 e5                	mov    %esp,%ebp
+ 227:	8b 45 08             	mov    0x8(%ebp),%eax
+ 22a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+ 22e:	0f b6 10             	movzbl (%eax),%edx
+ 231:	84 d2                	test   %dl,%dl
+ 233:	75 16                	jne    24b <strchr+0x2b>
+ 235:	eb 21                	jmp    258 <strchr+0x38>
+ 237:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 23e:	66 90                	xchg   %ax,%ax
+ 240:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+ 244:	83 c0 01             	add    $0x1,%eax
+ 247:	84 d2                	test   %dl,%dl
+ 249:	74 0d                	je     258 <strchr+0x38>
+    if(*s == c)
+ 24b:	38 d1                	cmp    %dl,%cl
+ 24d:	75 f1                	jne    240 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+ 24f:	5d                   	pop    %ebp
+ 250:	c3                   	ret    
+ 251:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+ 258:	31 c0                	xor    %eax,%eax
+}
+ 25a:	5d                   	pop    %ebp
+ 25b:	c3                   	ret    
+ 25c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000260 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 260:	f3 0f 1e fb          	endbr32 
+ 264:	55                   	push   %ebp
+ 265:	89 e5                	mov    %esp,%ebp
+ 267:	57                   	push   %edi
+ 268:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 269:	31 f6                	xor    %esi,%esi
+{
+ 26b:	53                   	push   %ebx
+ 26c:	89 f3                	mov    %esi,%ebx
+ 26e:	83 ec 1c             	sub    $0x1c,%esp
+ 271:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+ 274:	eb 33                	jmp    2a9 <gets+0x49>
+ 276:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 27d:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+ 280:	83 ec 04             	sub    $0x4,%esp
+ 283:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ 286:	6a 01                	push   $0x1
+ 288:	50                   	push   %eax
+ 289:	6a 00                	push   $0x0
+ 28b:	e8 2b 01 00 00       	call   3bb <read>
+    if(cc < 1)
+ 290:	83 c4 10             	add    $0x10,%esp
+ 293:	85 c0                	test   %eax,%eax
+ 295:	7e 1c                	jle    2b3 <gets+0x53>
+      break;
+    buf[i++] = c;
+ 297:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ 29b:	83 c7 01             	add    $0x1,%edi
+ 29e:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+ 2a1:	3c 0a                	cmp    $0xa,%al
+ 2a3:	74 23                	je     2c8 <gets+0x68>
+ 2a5:	3c 0d                	cmp    $0xd,%al
+ 2a7:	74 1f                	je     2c8 <gets+0x68>
+  for(i=0; i+1 < max; ){
+ 2a9:	83 c3 01             	add    $0x1,%ebx
+ 2ac:	89 fe                	mov    %edi,%esi
+ 2ae:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+ 2b1:	7c cd                	jl     280 <gets+0x20>
+ 2b3:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+ 2b5:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+ 2b8:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 2bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 2be:	5b                   	pop    %ebx
+ 2bf:	5e                   	pop    %esi
+ 2c0:	5f                   	pop    %edi
+ 2c1:	5d                   	pop    %ebp
+ 2c2:	c3                   	ret    
+ 2c3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 2c7:	90                   	nop
+ 2c8:	8b 75 08             	mov    0x8(%ebp),%esi
+ 2cb:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2ce:	01 de                	add    %ebx,%esi
+ 2d0:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+ 2d2:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 2d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 2d8:	5b                   	pop    %ebx
+ 2d9:	5e                   	pop    %esi
+ 2da:	5f                   	pop    %edi
+ 2db:	5d                   	pop    %ebp
+ 2dc:	c3                   	ret    
+ 2dd:	8d 76 00             	lea    0x0(%esi),%esi
+
+000002e0 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 2e0:	f3 0f 1e fb          	endbr32 
+ 2e4:	55                   	push   %ebp
+ 2e5:	89 e5                	mov    %esp,%ebp
+ 2e7:	56                   	push   %esi
+ 2e8:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 2e9:	83 ec 08             	sub    $0x8,%esp
+ 2ec:	6a 00                	push   $0x0
+ 2ee:	ff 75 08             	pushl  0x8(%ebp)
+ 2f1:	e8 ed 00 00 00       	call   3e3 <open>
+  if(fd < 0)
+ 2f6:	83 c4 10             	add    $0x10,%esp
+ 2f9:	85 c0                	test   %eax,%eax
+ 2fb:	78 2b                	js     328 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+ 2fd:	83 ec 08             	sub    $0x8,%esp
+ 300:	ff 75 0c             	pushl  0xc(%ebp)
+ 303:	89 c3                	mov    %eax,%ebx
+ 305:	50                   	push   %eax
+ 306:	e8 f0 00 00 00       	call   3fb <fstat>
+  close(fd);
+ 30b:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+ 30e:	89 c6                	mov    %eax,%esi
+  close(fd);
+ 310:	e8 b6 00 00 00       	call   3cb <close>
+  return r;
+ 315:	83 c4 10             	add    $0x10,%esp
+}
+ 318:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 31b:	89 f0                	mov    %esi,%eax
+ 31d:	5b                   	pop    %ebx
+ 31e:	5e                   	pop    %esi
+ 31f:	5d                   	pop    %ebp
+ 320:	c3                   	ret    
+ 321:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+ 328:	be ff ff ff ff       	mov    $0xffffffff,%esi
+ 32d:	eb e9                	jmp    318 <stat+0x38>
+ 32f:	90                   	nop
+
+00000330 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 330:	f3 0f 1e fb          	endbr32 
+ 334:	55                   	push   %ebp
+ 335:	89 e5                	mov    %esp,%ebp
+ 337:	53                   	push   %ebx
+ 338:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 33b:	0f be 02             	movsbl (%edx),%eax
+ 33e:	8d 48 d0             	lea    -0x30(%eax),%ecx
+ 341:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+ 344:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+ 349:	77 1a                	ja     365 <atoi+0x35>
+ 34b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 34f:	90                   	nop
+    n = n*10 + *s++ - '0';
+ 350:	83 c2 01             	add    $0x1,%edx
+ 353:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+ 356:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+ 35a:	0f be 02             	movsbl (%edx),%eax
+ 35d:	8d 58 d0             	lea    -0x30(%eax),%ebx
+ 360:	80 fb 09             	cmp    $0x9,%bl
+ 363:	76 eb                	jbe    350 <atoi+0x20>
+  return n;
+}
+ 365:	89 c8                	mov    %ecx,%eax
+ 367:	5b                   	pop    %ebx
+ 368:	5d                   	pop    %ebp
+ 369:	c3                   	ret    
+ 36a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000370 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 370:	f3 0f 1e fb          	endbr32 
+ 374:	55                   	push   %ebp
+ 375:	89 e5                	mov    %esp,%ebp
+ 377:	57                   	push   %edi
+ 378:	8b 45 10             	mov    0x10(%ebp),%eax
+ 37b:	8b 55 08             	mov    0x8(%ebp),%edx
+ 37e:	56                   	push   %esi
+ 37f:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 382:	85 c0                	test   %eax,%eax
+ 384:	7e 0f                	jle    395 <memmove+0x25>
+ 386:	01 d0                	add    %edx,%eax
+  dst = vdst;
+ 388:	89 d7                	mov    %edx,%edi
+ 38a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+ 390:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+ 391:	39 f8                	cmp    %edi,%eax
+ 393:	75 fb                	jne    390 <memmove+0x20>
+  return vdst;
+}
+ 395:	5e                   	pop    %esi
+ 396:	89 d0                	mov    %edx,%eax
+ 398:	5f                   	pop    %edi
+ 399:	5d                   	pop    %ebp
+ 39a:	c3                   	ret    
+
+0000039b <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 39b:	b8 01 00 00 00       	mov    $0x1,%eax
+ 3a0:	cd 40                	int    $0x40
+ 3a2:	c3                   	ret    
+
+000003a3 <exit>:
+SYSCALL(exit)
+ 3a3:	b8 02 00 00 00       	mov    $0x2,%eax
+ 3a8:	cd 40                	int    $0x40
+ 3aa:	c3                   	ret    
+
+000003ab <wait>:
+SYSCALL(wait)
+ 3ab:	b8 03 00 00 00       	mov    $0x3,%eax
+ 3b0:	cd 40                	int    $0x40
+ 3b2:	c3                   	ret    
+
+000003b3 <pipe>:
+SYSCALL(pipe)
+ 3b3:	b8 04 00 00 00       	mov    $0x4,%eax
+ 3b8:	cd 40                	int    $0x40
+ 3ba:	c3                   	ret    
+
+000003bb <read>:
+SYSCALL(read)
+ 3bb:	b8 05 00 00 00       	mov    $0x5,%eax
+ 3c0:	cd 40                	int    $0x40
+ 3c2:	c3                   	ret    
+
+000003c3 <write>:
+SYSCALL(write)
+ 3c3:	b8 10 00 00 00       	mov    $0x10,%eax
+ 3c8:	cd 40                	int    $0x40
+ 3ca:	c3                   	ret    
+
+000003cb <close>:
+SYSCALL(close)
+ 3cb:	b8 15 00 00 00       	mov    $0x15,%eax
+ 3d0:	cd 40                	int    $0x40
+ 3d2:	c3                   	ret    
+
+000003d3 <kill>:
+SYSCALL(kill)
+ 3d3:	b8 06 00 00 00       	mov    $0x6,%eax
+ 3d8:	cd 40                	int    $0x40
+ 3da:	c3                   	ret    
+
+000003db <exec>:
+SYSCALL(exec)
+ 3db:	b8 07 00 00 00       	mov    $0x7,%eax
+ 3e0:	cd 40                	int    $0x40
+ 3e2:	c3                   	ret    
+
+000003e3 <open>:
+SYSCALL(open)
+ 3e3:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 3e8:	cd 40                	int    $0x40
+ 3ea:	c3                   	ret    
+
+000003eb <mknod>:
+SYSCALL(mknod)
+ 3eb:	b8 11 00 00 00       	mov    $0x11,%eax
+ 3f0:	cd 40                	int    $0x40
+ 3f2:	c3                   	ret    
+
+000003f3 <unlink>:
+SYSCALL(unlink)
+ 3f3:	b8 12 00 00 00       	mov    $0x12,%eax
+ 3f8:	cd 40                	int    $0x40
+ 3fa:	c3                   	ret    
+
+000003fb <fstat>:
+SYSCALL(fstat)
+ 3fb:	b8 08 00 00 00       	mov    $0x8,%eax
+ 400:	cd 40                	int    $0x40
+ 402:	c3                   	ret    
+
+00000403 <link>:
+SYSCALL(link)
+ 403:	b8 13 00 00 00       	mov    $0x13,%eax
+ 408:	cd 40                	int    $0x40
+ 40a:	c3                   	ret    
+
+0000040b <mkdir>:
+SYSCALL(mkdir)
+ 40b:	b8 14 00 00 00       	mov    $0x14,%eax
+ 410:	cd 40                	int    $0x40
+ 412:	c3                   	ret    
+
+00000413 <chdir>:
+SYSCALL(chdir)
+ 413:	b8 09 00 00 00       	mov    $0x9,%eax
+ 418:	cd 40                	int    $0x40
+ 41a:	c3                   	ret    
+
+0000041b <dup>:
+SYSCALL(dup)
+ 41b:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 420:	cd 40                	int    $0x40
+ 422:	c3                   	ret    
+
+00000423 <getpid>:
+SYSCALL(getpid)
+ 423:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 428:	cd 40                	int    $0x40
+ 42a:	c3                   	ret    
+
+0000042b <sbrk>:
+SYSCALL(sbrk)
+ 42b:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 430:	cd 40                	int    $0x40
+ 432:	c3                   	ret    
+
+00000433 <sleep>:
+SYSCALL(sleep)
+ 433:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 438:	cd 40                	int    $0x40
+ 43a:	c3                   	ret    
+
+0000043b <uptime>:
+SYSCALL(uptime)
+ 43b:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 440:	cd 40                	int    $0x40
+ 442:	c3                   	ret    
+
+00000443 <draw>:
+SYSCALL(draw)
+ 443:	b8 16 00 00 00       	mov    $0x16,%eax
+ 448:	cd 40                	int    $0x40
+ 44a:	c3                   	ret    
+
+0000044b <thread_create>:
+
+SYSCALL(thread_create)
+ 44b:	b8 17 00 00 00       	mov    $0x17,%eax
+ 450:	cd 40                	int    $0x40
+ 452:	c3                   	ret    
+
+00000453 <thread_join>:
+SYSCALL(thread_join)
+ 453:	b8 18 00 00 00       	mov    $0x18,%eax
+ 458:	cd 40                	int    $0x40
+ 45a:	c3                   	ret    
+
+0000045b <thread_exit>:
+SYSCALL(thread_exit)
+ 45b:	b8 19 00 00 00       	mov    $0x19,%eax
+ 460:	cd 40                	int    $0x40
+ 462:	c3                   	ret    
+ 463:	66 90                	xchg   %ax,%ax
+ 465:	66 90                	xchg   %ax,%ax
+ 467:	66 90                	xchg   %ax,%ax
+ 469:	66 90                	xchg   %ax,%ax
+ 46b:	66 90                	xchg   %ax,%ax
+ 46d:	66 90                	xchg   %ax,%ax
+ 46f:	90                   	nop
+
+00000470 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 470:	55                   	push   %ebp
+ 471:	89 e5                	mov    %esp,%ebp
+ 473:	57                   	push   %edi
+ 474:	56                   	push   %esi
+ 475:	53                   	push   %ebx
+ 476:	83 ec 3c             	sub    $0x3c,%esp
+ 479:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+ 47c:	89 d1                	mov    %edx,%ecx
+{
+ 47e:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  if(sgn && xx < 0){
+ 481:	85 d2                	test   %edx,%edx
+ 483:	0f 89 7f 00 00 00    	jns    508 <printint+0x98>
+ 489:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
+ 48d:	74 79                	je     508 <printint+0x98>
+    neg = 1;
+ 48f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+    x = -xx;
+ 496:	f7 d9                	neg    %ecx
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 498:	31 db                	xor    %ebx,%ebx
+ 49a:	8d 75 d7             	lea    -0x29(%ebp),%esi
+ 49d:	8d 76 00             	lea    0x0(%esi),%esi
+  do{
+    buf[i++] = digits[x % base];
+ 4a0:	89 c8                	mov    %ecx,%eax
+ 4a2:	31 d2                	xor    %edx,%edx
+ 4a4:	89 cf                	mov    %ecx,%edi
+ 4a6:	f7 75 c4             	divl   -0x3c(%ebp)
+ 4a9:	0f b6 92 b4 08 00 00 	movzbl 0x8b4(%edx),%edx
+ 4b0:	89 45 c0             	mov    %eax,-0x40(%ebp)
+ 4b3:	89 d8                	mov    %ebx,%eax
+ 4b5:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+ 4b8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+    buf[i++] = digits[x % base];
+ 4bb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
+  }while((x /= base) != 0);
+ 4be:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
+ 4c1:	76 dd                	jbe    4a0 <printint+0x30>
+  if(neg)
+ 4c3:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+ 4c6:	85 c9                	test   %ecx,%ecx
+ 4c8:	74 0c                	je     4d6 <printint+0x66>
+    buf[i++] = '-';
+ 4ca:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+ 4cf:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+ 4d1:	ba 2d 00 00 00       	mov    $0x2d,%edx
+
+  while(--i >= 0)
+ 4d6:	8b 7d b8             	mov    -0x48(%ebp),%edi
+ 4d9:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+ 4dd:	eb 07                	jmp    4e6 <printint+0x76>
+ 4df:	90                   	nop
+ 4e0:	0f b6 13             	movzbl (%ebx),%edx
+ 4e3:	83 eb 01             	sub    $0x1,%ebx
+  write(fd, &c, 1);
+ 4e6:	83 ec 04             	sub    $0x4,%esp
+ 4e9:	88 55 d7             	mov    %dl,-0x29(%ebp)
+ 4ec:	6a 01                	push   $0x1
+ 4ee:	56                   	push   %esi
+ 4ef:	57                   	push   %edi
+ 4f0:	e8 ce fe ff ff       	call   3c3 <write>
+  while(--i >= 0)
+ 4f5:	83 c4 10             	add    $0x10,%esp
+ 4f8:	39 de                	cmp    %ebx,%esi
+ 4fa:	75 e4                	jne    4e0 <printint+0x70>
+    putc(fd, buf[i]);
+}
+ 4fc:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 4ff:	5b                   	pop    %ebx
+ 500:	5e                   	pop    %esi
+ 501:	5f                   	pop    %edi
+ 502:	5d                   	pop    %ebp
+ 503:	c3                   	ret    
+ 504:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  neg = 0;
+ 508:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+ 50f:	eb 87                	jmp    498 <printint+0x28>
+ 511:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 518:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 51f:	90                   	nop
+
+00000520 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 520:	f3 0f 1e fb          	endbr32 
+ 524:	55                   	push   %ebp
+ 525:	89 e5                	mov    %esp,%ebp
+ 527:	57                   	push   %edi
+ 528:	56                   	push   %esi
+ 529:	53                   	push   %ebx
+ 52a:	83 ec 2c             	sub    $0x2c,%esp
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 52d:	8b 75 0c             	mov    0xc(%ebp),%esi
+ 530:	0f b6 1e             	movzbl (%esi),%ebx
+ 533:	84 db                	test   %bl,%bl
+ 535:	0f 84 b4 00 00 00    	je     5ef <printf+0xcf>
+  ap = (uint*)(void*)&fmt + 1;
+ 53b:	8d 45 10             	lea    0x10(%ebp),%eax
+ 53e:	83 c6 01             	add    $0x1,%esi
+  write(fd, &c, 1);
+ 541:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  state = 0;
+ 544:	31 d2                	xor    %edx,%edx
+  ap = (uint*)(void*)&fmt + 1;
+ 546:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 549:	eb 33                	jmp    57e <printf+0x5e>
+ 54b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 54f:	90                   	nop
+ 550:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+ 553:	ba 25 00 00 00       	mov    $0x25,%edx
+      if(c == '%'){
+ 558:	83 f8 25             	cmp    $0x25,%eax
+ 55b:	74 17                	je     574 <printf+0x54>
+  write(fd, &c, 1);
+ 55d:	83 ec 04             	sub    $0x4,%esp
+ 560:	88 5d e7             	mov    %bl,-0x19(%ebp)
+ 563:	6a 01                	push   $0x1
+ 565:	57                   	push   %edi
+ 566:	ff 75 08             	pushl  0x8(%ebp)
+ 569:	e8 55 fe ff ff       	call   3c3 <write>
+ 56e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+      } else {
+        putc(fd, c);
+ 571:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; fmt[i]; i++){
+ 574:	0f b6 1e             	movzbl (%esi),%ebx
+ 577:	83 c6 01             	add    $0x1,%esi
+ 57a:	84 db                	test   %bl,%bl
+ 57c:	74 71                	je     5ef <printf+0xcf>
+    c = fmt[i] & 0xff;
+ 57e:	0f be cb             	movsbl %bl,%ecx
+ 581:	0f b6 c3             	movzbl %bl,%eax
+    if(state == 0){
+ 584:	85 d2                	test   %edx,%edx
+ 586:	74 c8                	je     550 <printf+0x30>
+      }
+    } else if(state == '%'){
+ 588:	83 fa 25             	cmp    $0x25,%edx
+ 58b:	75 e7                	jne    574 <printf+0x54>
+      if(c == 'd'){
+ 58d:	83 f8 64             	cmp    $0x64,%eax
+ 590:	0f 84 9a 00 00 00    	je     630 <printf+0x110>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+ 596:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
+ 59c:	83 f9 70             	cmp    $0x70,%ecx
+ 59f:	74 5f                	je     600 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+ 5a1:	83 f8 73             	cmp    $0x73,%eax
+ 5a4:	0f 84 d6 00 00 00    	je     680 <printf+0x160>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 5aa:	83 f8 63             	cmp    $0x63,%eax
+ 5ad:	0f 84 8d 00 00 00    	je     640 <printf+0x120>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+ 5b3:	83 f8 25             	cmp    $0x25,%eax
+ 5b6:	0f 84 b4 00 00 00    	je     670 <printf+0x150>
+  write(fd, &c, 1);
+ 5bc:	83 ec 04             	sub    $0x4,%esp
+ 5bf:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
+ 5c3:	6a 01                	push   $0x1
+ 5c5:	57                   	push   %edi
+ 5c6:	ff 75 08             	pushl  0x8(%ebp)
+ 5c9:	e8 f5 fd ff ff       	call   3c3 <write>
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+ 5ce:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 5d1:	83 c4 0c             	add    $0xc,%esp
+ 5d4:	6a 01                	push   $0x1
+ 5d6:	83 c6 01             	add    $0x1,%esi
+ 5d9:	57                   	push   %edi
+ 5da:	ff 75 08             	pushl  0x8(%ebp)
+ 5dd:	e8 e1 fd ff ff       	call   3c3 <write>
+  for(i = 0; fmt[i]; i++){
+ 5e2:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
+        putc(fd, c);
+ 5e6:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 5e9:	31 d2                	xor    %edx,%edx
+  for(i = 0; fmt[i]; i++){
+ 5eb:	84 db                	test   %bl,%bl
+ 5ed:	75 8f                	jne    57e <printf+0x5e>
+    }
+  }
+}
+ 5ef:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 5f2:	5b                   	pop    %ebx
+ 5f3:	5e                   	pop    %esi
+ 5f4:	5f                   	pop    %edi
+ 5f5:	5d                   	pop    %ebp
+ 5f6:	c3                   	ret    
+ 5f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 5fe:	66 90                	xchg   %ax,%ax
+        printint(fd, *ap, 16, 0);
+ 600:	83 ec 0c             	sub    $0xc,%esp
+ 603:	b9 10 00 00 00       	mov    $0x10,%ecx
+ 608:	6a 00                	push   $0x0
+ 60a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+ 60d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 610:	8b 13                	mov    (%ebx),%edx
+ 612:	e8 59 fe ff ff       	call   470 <printint>
+        ap++;
+ 617:	89 d8                	mov    %ebx,%eax
+ 619:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 61c:	31 d2                	xor    %edx,%edx
+        ap++;
+ 61e:	83 c0 04             	add    $0x4,%eax
+ 621:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 624:	e9 4b ff ff ff       	jmp    574 <printf+0x54>
+ 629:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        printint(fd, *ap, 10, 1);
+ 630:	83 ec 0c             	sub    $0xc,%esp
+ 633:	b9 0a 00 00 00       	mov    $0xa,%ecx
+ 638:	6a 01                	push   $0x1
+ 63a:	eb ce                	jmp    60a <printf+0xea>
+ 63c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        putc(fd, *ap);
+ 640:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+  write(fd, &c, 1);
+ 643:	83 ec 04             	sub    $0x4,%esp
+        putc(fd, *ap);
+ 646:	8b 03                	mov    (%ebx),%eax
+  write(fd, &c, 1);
+ 648:	6a 01                	push   $0x1
+        ap++;
+ 64a:	83 c3 04             	add    $0x4,%ebx
+  write(fd, &c, 1);
+ 64d:	57                   	push   %edi
+ 64e:	ff 75 08             	pushl  0x8(%ebp)
+        putc(fd, *ap);
+ 651:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 654:	e8 6a fd ff ff       	call   3c3 <write>
+        ap++;
+ 659:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+ 65c:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 65f:	31 d2                	xor    %edx,%edx
+ 661:	e9 0e ff ff ff       	jmp    574 <printf+0x54>
+ 666:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 66d:	8d 76 00             	lea    0x0(%esi),%esi
+        putc(fd, c);
+ 670:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 673:	83 ec 04             	sub    $0x4,%esp
+ 676:	e9 59 ff ff ff       	jmp    5d4 <printf+0xb4>
+ 67b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 67f:	90                   	nop
+        s = (char*)*ap;
+ 680:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 683:	8b 18                	mov    (%eax),%ebx
+        ap++;
+ 685:	83 c0 04             	add    $0x4,%eax
+ 688:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        if(s == 0)
+ 68b:	85 db                	test   %ebx,%ebx
+ 68d:	74 17                	je     6a6 <printf+0x186>
+        while(*s != 0){
+ 68f:	0f b6 03             	movzbl (%ebx),%eax
+      state = 0;
+ 692:	31 d2                	xor    %edx,%edx
+        while(*s != 0){
+ 694:	84 c0                	test   %al,%al
+ 696:	0f 84 d8 fe ff ff    	je     574 <printf+0x54>
+ 69c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 69f:	89 de                	mov    %ebx,%esi
+ 6a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 6a4:	eb 1a                	jmp    6c0 <printf+0x1a0>
+          s = "(null)";
+ 6a6:	bb ab 08 00 00       	mov    $0x8ab,%ebx
+        while(*s != 0){
+ 6ab:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 6ae:	b8 28 00 00 00       	mov    $0x28,%eax
+ 6b3:	89 de                	mov    %ebx,%esi
+ 6b5:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 6b8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 6bf:	90                   	nop
+  write(fd, &c, 1);
+ 6c0:	83 ec 04             	sub    $0x4,%esp
+          s++;
+ 6c3:	83 c6 01             	add    $0x1,%esi
+ 6c6:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 6c9:	6a 01                	push   $0x1
+ 6cb:	57                   	push   %edi
+ 6cc:	53                   	push   %ebx
+ 6cd:	e8 f1 fc ff ff       	call   3c3 <write>
+        while(*s != 0){
+ 6d2:	0f b6 06             	movzbl (%esi),%eax
+ 6d5:	83 c4 10             	add    $0x10,%esp
+ 6d8:	84 c0                	test   %al,%al
+ 6da:	75 e4                	jne    6c0 <printf+0x1a0>
+ 6dc:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+      state = 0;
+ 6df:	31 d2                	xor    %edx,%edx
+ 6e1:	e9 8e fe ff ff       	jmp    574 <printf+0x54>
+ 6e6:	66 90                	xchg   %ax,%ax
+ 6e8:	66 90                	xchg   %ax,%ax
+ 6ea:	66 90                	xchg   %ax,%ax
+ 6ec:	66 90                	xchg   %ax,%ax
+ 6ee:	66 90                	xchg   %ax,%ax
+
+000006f0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 6f0:	f3 0f 1e fb          	endbr32 
+ 6f4:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 6f5:	a1 6c 0b 00 00       	mov    0xb6c,%eax
+{
+ 6fa:	89 e5                	mov    %esp,%ebp
+ 6fc:	57                   	push   %edi
+ 6fd:	56                   	push   %esi
+ 6fe:	53                   	push   %ebx
+ 6ff:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 702:	8b 10                	mov    (%eax),%edx
+  bp = (Header*)ap - 1;
+ 704:	8d 4b f8             	lea    -0x8(%ebx),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 707:	39 c8                	cmp    %ecx,%eax
+ 709:	73 15                	jae    720 <free+0x30>
+ 70b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 70f:	90                   	nop
+ 710:	39 d1                	cmp    %edx,%ecx
+ 712:	72 14                	jb     728 <free+0x38>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 714:	39 d0                	cmp    %edx,%eax
+ 716:	73 10                	jae    728 <free+0x38>
+{
+ 718:	89 d0                	mov    %edx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 71a:	8b 10                	mov    (%eax),%edx
+ 71c:	39 c8                	cmp    %ecx,%eax
+ 71e:	72 f0                	jb     710 <free+0x20>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 720:	39 d0                	cmp    %edx,%eax
+ 722:	72 f4                	jb     718 <free+0x28>
+ 724:	39 d1                	cmp    %edx,%ecx
+ 726:	73 f0                	jae    718 <free+0x28>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 728:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ 72b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
+ 72e:	39 fa                	cmp    %edi,%edx
+ 730:	74 1e                	je     750 <free+0x60>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+ 732:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 735:	8b 50 04             	mov    0x4(%eax),%edx
+ 738:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 73b:	39 f1                	cmp    %esi,%ecx
+ 73d:	74 28                	je     767 <free+0x77>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+ 73f:	89 08                	mov    %ecx,(%eax)
+  freep = p;
+}
+ 741:	5b                   	pop    %ebx
+  freep = p;
+ 742:	a3 6c 0b 00 00       	mov    %eax,0xb6c
+}
+ 747:	5e                   	pop    %esi
+ 748:	5f                   	pop    %edi
+ 749:	5d                   	pop    %ebp
+ 74a:	c3                   	ret    
+ 74b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 74f:	90                   	nop
+    bp->s.size += p->s.ptr->s.size;
+ 750:	03 72 04             	add    0x4(%edx),%esi
+ 753:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 756:	8b 10                	mov    (%eax),%edx
+ 758:	8b 12                	mov    (%edx),%edx
+ 75a:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 75d:	8b 50 04             	mov    0x4(%eax),%edx
+ 760:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 763:	39 f1                	cmp    %esi,%ecx
+ 765:	75 d8                	jne    73f <free+0x4f>
+    p->s.size += bp->s.size;
+ 767:	03 53 fc             	add    -0x4(%ebx),%edx
+  freep = p;
+ 76a:	a3 6c 0b 00 00       	mov    %eax,0xb6c
+    p->s.size += bp->s.size;
+ 76f:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 772:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ 775:	89 10                	mov    %edx,(%eax)
+}
+ 777:	5b                   	pop    %ebx
+ 778:	5e                   	pop    %esi
+ 779:	5f                   	pop    %edi
+ 77a:	5d                   	pop    %ebp
+ 77b:	c3                   	ret    
+ 77c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000780 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 780:	f3 0f 1e fb          	endbr32 
+ 784:	55                   	push   %ebp
+ 785:	89 e5                	mov    %esp,%ebp
+ 787:	57                   	push   %edi
+ 788:	56                   	push   %esi
+ 789:	53                   	push   %ebx
+ 78a:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 78d:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+ 790:	8b 3d 6c 0b 00 00    	mov    0xb6c,%edi
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 796:	8d 70 07             	lea    0x7(%eax),%esi
+ 799:	c1 ee 03             	shr    $0x3,%esi
+ 79c:	83 c6 01             	add    $0x1,%esi
+  if((prevp = freep) == 0){
+ 79f:	85 ff                	test   %edi,%edi
+ 7a1:	0f 84 a9 00 00 00    	je     850 <malloc+0xd0>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7a7:	8b 07                	mov    (%edi),%eax
+    if(p->s.size >= nunits){
+ 7a9:	8b 48 04             	mov    0x4(%eax),%ecx
+ 7ac:	39 f1                	cmp    %esi,%ecx
+ 7ae:	73 6d                	jae    81d <malloc+0x9d>
+ 7b0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+ 7b6:	bb 00 10 00 00       	mov    $0x1000,%ebx
+ 7bb:	0f 43 de             	cmovae %esi,%ebx
+  p = sbrk(nu * sizeof(Header));
+ 7be:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
+ 7c5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+ 7c8:	eb 17                	jmp    7e1 <malloc+0x61>
+ 7ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7d0:	8b 10                	mov    (%eax),%edx
+    if(p->s.size >= nunits){
+ 7d2:	8b 4a 04             	mov    0x4(%edx),%ecx
+ 7d5:	39 f1                	cmp    %esi,%ecx
+ 7d7:	73 4f                	jae    828 <malloc+0xa8>
+ 7d9:	8b 3d 6c 0b 00 00    	mov    0xb6c,%edi
+ 7df:	89 d0                	mov    %edx,%eax
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 7e1:	39 c7                	cmp    %eax,%edi
+ 7e3:	75 eb                	jne    7d0 <malloc+0x50>
+  p = sbrk(nu * sizeof(Header));
+ 7e5:	83 ec 0c             	sub    $0xc,%esp
+ 7e8:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 7eb:	e8 3b fc ff ff       	call   42b <sbrk>
+  if(p == (char*)-1)
+ 7f0:	83 c4 10             	add    $0x10,%esp
+ 7f3:	83 f8 ff             	cmp    $0xffffffff,%eax
+ 7f6:	74 1b                	je     813 <malloc+0x93>
+  hp->s.size = nu;
+ 7f8:	89 58 04             	mov    %ebx,0x4(%eax)
+  free((void*)(hp + 1));
+ 7fb:	83 ec 0c             	sub    $0xc,%esp
+ 7fe:	83 c0 08             	add    $0x8,%eax
+ 801:	50                   	push   %eax
+ 802:	e8 e9 fe ff ff       	call   6f0 <free>
+  return freep;
+ 807:	a1 6c 0b 00 00       	mov    0xb6c,%eax
+      if((p = morecore(nunits)) == 0)
+ 80c:	83 c4 10             	add    $0x10,%esp
+ 80f:	85 c0                	test   %eax,%eax
+ 811:	75 bd                	jne    7d0 <malloc+0x50>
+        return 0;
+  }
+}
+ 813:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return 0;
+ 816:	31 c0                	xor    %eax,%eax
+}
+ 818:	5b                   	pop    %ebx
+ 819:	5e                   	pop    %esi
+ 81a:	5f                   	pop    %edi
+ 81b:	5d                   	pop    %ebp
+ 81c:	c3                   	ret    
+    if(p->s.size >= nunits){
+ 81d:	89 c2                	mov    %eax,%edx
+ 81f:	89 f8                	mov    %edi,%eax
+ 821:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+ 828:	39 ce                	cmp    %ecx,%esi
+ 82a:	74 54                	je     880 <malloc+0x100>
+        p->s.size -= nunits;
+ 82c:	29 f1                	sub    %esi,%ecx
+ 82e:	89 4a 04             	mov    %ecx,0x4(%edx)
+        p += p->s.size;
+ 831:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
+        p->s.size = nunits;
+ 834:	89 72 04             	mov    %esi,0x4(%edx)
+      freep = prevp;
+ 837:	a3 6c 0b 00 00       	mov    %eax,0xb6c
+}
+ 83c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return (void*)(p + 1);
+ 83f:	8d 42 08             	lea    0x8(%edx),%eax
+}
+ 842:	5b                   	pop    %ebx
+ 843:	5e                   	pop    %esi
+ 844:	5f                   	pop    %edi
+ 845:	5d                   	pop    %ebp
+ 846:	c3                   	ret    
+ 847:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 84e:	66 90                	xchg   %ax,%ax
+    base.s.ptr = freep = prevp = &base;
+ 850:	c7 05 6c 0b 00 00 70 	movl   $0xb70,0xb6c
+ 857:	0b 00 00 
+    base.s.size = 0;
+ 85a:	bf 70 0b 00 00       	mov    $0xb70,%edi
+    base.s.ptr = freep = prevp = &base;
+ 85f:	c7 05 70 0b 00 00 70 	movl   $0xb70,0xb70
+ 866:	0b 00 00 
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 869:	89 f8                	mov    %edi,%eax
+    base.s.size = 0;
+ 86b:	c7 05 74 0b 00 00 00 	movl   $0x0,0xb74
+ 872:	00 00 00 
+    if(p->s.size >= nunits){
+ 875:	e9 36 ff ff ff       	jmp    7b0 <malloc+0x30>
+ 87a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        prevp->s.ptr = p->s.ptr;
+ 880:	8b 0a                	mov    (%edx),%ecx
+ 882:	89 08                	mov    %ecx,(%eax)
+ 884:	eb b1                	jmp    837 <malloc+0xb7>
diff -ruN xv6-public/stressfs.d copy-xv6/stressfs.d
--- xv6-public/stressfs.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/stressfs.d	2022-09-05 23:26:12.212781087 +0530
@@ -0,0 +1,2 @@
+stressfs.o: stressfs.c /usr/include/stdc-predef.h types.h stat.h user.h \
+ fs.h fcntl.h
Binary files xv6-public/stressfs.o and copy-xv6/stressfs.o differ
diff -ruN xv6-public/stressfs.sym copy-xv6/stressfs.sym
--- xv6-public/stressfs.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/stressfs.sym	2022-09-05 23:26:12.224781087 +0530
@@ -0,0 +1,61 @@
+00000000 .text
+00000888 .rodata
+000008c8 .eh_frame
+00000b6c .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 stressfs.c
+00000000 ulib.c
+00000000 printf.c
+00000470 printint
+000008b4 digits.1097
+00000000 umalloc.c
+00000b6c freep
+00000b70 base
+00000140 strcpy
+00000520 printf
+0000045b thread_exit
+00000370 memmove
+000003eb mknod
+00000260 gets
+00000423 getpid
+00000780 malloc
+00000433 sleep
+000003b3 pipe
+000003c3 write
+000003fb fstat
+000003d3 kill
+00000413 chdir
+000003db exec
+000003ab wait
+000003bb read
+000003f3 unlink
+0000039b fork
+0000042b sbrk
+0000043b uptime
+00000b6c __bss_start
+00000200 memset
+00000000 main
+00000170 strcmp
+0000041b dup
+000002e0 stat
+00000b6c _edata
+00000b78 _end
+00000403 link
+000003a3 exit
+00000330 atoi
+00000443 draw
+000001c0 strlen
+000003e3 open
+00000220 strchr
+0000044b thread_create
+0000040b mkdir
+000003cb close
+00000453 thread_join
+000006f0 free
diff -ruN xv6-public/string.d copy-xv6/string.d
--- xv6-public/string.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/string.d	2022-09-05 23:26:13.516781057 +0530
@@ -0,0 +1 @@
+string.o: string.c /usr/include/stdc-predef.h types.h x86.h
Binary files xv6-public/string.o and copy-xv6/string.o differ
Binary files xv6-public/swtch.o and copy-xv6/swtch.o differ
diff -ruN xv6-public/syscall.c copy-xv6/syscall.c
--- xv6-public/syscall.c	2022-09-05 23:23:48.536715198 +0530
+++ copy-xv6/syscall.c	2022-09-03 23:55:48.614985000 +0530
@@ -103,6 +103,10 @@
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_draw(void);
+extern int sys_thread_create(void);
+extern int sys_thread_join(void);
+extern int sys_thread_exit(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +130,10 @@
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_draw]  sys_draw,
+[SYS_thread_create] sys_thread_create,
+[SYS_thread_join]   sys_thread_join,
+[SYS_thread_exit]   sys_thread_exit,
 };
 
 void
diff -ruN xv6-public/syscall.d copy-xv6/syscall.d
--- xv6-public/syscall.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/syscall.d	2022-09-05 23:26:13.552781056 +0530
@@ -0,0 +1,2 @@
+syscall.o: syscall.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h proc.h x86.h syscall.h
diff -ruN xv6-public/syscall.h copy-xv6/syscall.h
--- xv6-public/syscall.h	2022-09-05 23:23:48.536715198 +0530
+++ copy-xv6/syscall.h	2022-09-03 23:53:13.144178000 +0530
@@ -20,3 +20,7 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_draw 22
+#define SYS_thread_create 23
+#define SYS_thread_join   24
+#define SYS_thread_exit   25
Binary files xv6-public/syscall.o and copy-xv6/syscall.o differ
diff -ruN xv6-public/sysfile.d copy-xv6/sysfile.d
--- xv6-public/sysfile.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/sysfile.d	2022-09-05 23:26:13.636781055 +0530
@@ -0,0 +1,2 @@
+sysfile.o: sysfile.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ stat.h mmu.h proc.h fs.h spinlock.h sleeplock.h file.h fcntl.h
Binary files xv6-public/sysfile.o and copy-xv6/sysfile.o differ
diff -ruN xv6-public/sysproc.c copy-xv6/sysproc.c
--- xv6-public/sysproc.c	2022-09-05 23:23:48.536715198 +0530
+++ copy-xv6/sysproc.c	2022-09-04 00:21:47.242291000 +0530
@@ -6,6 +6,7 @@
 #include "memlayout.h"
 #include "mmu.h"
 #include "proc.h"
+// #include "proc.c"
 
 int
 sys_fork(void)
@@ -89,3 +90,75 @@
   release(&tickslock);
   return xticks;
 }
+
+//
+int
+sys_thread_create(void) {
+  int fcn;
+  char* arg;
+  char* stack;
+  if (argint(0, &fcn) < 0)
+    return -1;
+  if (argstr(1, &arg) < 0)
+    return -1;
+  if (argstr(2, &stack) < 0)
+    return -1;
+  // fcn make integer to void(*)(void*)
+  return thread_create((void(*)(void*))fcn, arg, stack);
+}
+int
+sys_thread_exit(void)
+{
+  thread_exit();
+  return 0;
+}
+int
+sys_thread_join(void)
+{
+  return thread_join();
+}
+
+int
+sys_draw(void)
+{
+  void* buf;
+  uint size;
+  argptr(0, (void*)&buf, sizeof(buf));
+  argptr(1, (void*)&size, sizeof(size));
+
+  char text[] = R"(
+    Everyone Loves Mickey Mouse!
+                   >?>?>
+)";
+  if(sizeof(text)>size)
+    return -1;
+
+  strncpy((char *)buf, text, size);
+  return sizeof(text);
+}
+
+// int
+// sys_thread_create(void) {
+//   int fcn;
+//   char* arg;
+//   char* stack;
+//   if (argint(0, &fcn) < 0)
+//     return -1;
+//   if (argstr(1, &arg) < 0)
+//     return -1;
+//   if (argstr(2, &stack) < 0)
+//     return -1;
+//   // fcn make integer to void(*)(void*)
+//   return thread_create((void(*)(void*))fcn, arg, stack);
+// }
+// int
+// sys_thread_exit(void)
+// {
+//   thread_exit();
+//   return 0;
+// }
+// int
+// sys_thread_join(void)
+// {
+//   return thread_join();
+// }
diff -ruN xv6-public/sysproc.d copy-xv6/sysproc.d
--- xv6-public/sysproc.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/sysproc.d	2022-09-05 23:26:13.672781054 +0530
@@ -0,0 +1,2 @@
+sysproc.o: sysproc.c /usr/include/stdc-predef.h types.h x86.h defs.h \
+ date.h param.h memlayout.h mmu.h proc.h
Binary files xv6-public/sysproc.o and copy-xv6/sysproc.o differ
Binary files xv6-public/_thread and copy-xv6/_thread differ
diff -ruN xv6-public/thread.asm copy-xv6/thread.asm
--- xv6-public/thread.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/thread.asm	2022-09-05 23:26:12.632781078 +0530
@@ -0,0 +1,1493 @@
+
+_thread:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+  thread_exit();
+  return;
+}
+
+int main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	57                   	push   %edi
+  12:	56                   	push   %esi
+  13:	53                   	push   %ebx
+  14:	51                   	push   %ecx
+  15:	83 ec 64             	sub    $0x64,%esp
+
+  struct balance b1 = {"b1", 3200};
+  18:	c7 45 a0 62 31 00 00 	movl   $0x3162,-0x60(%ebp)
+  struct balance b2 = {"b2", 2800};
+
+  void *s1, *s2;
+  int t1, t2, r1, r2;
+
+  s1 = malloc(4096);
+  1f:	68 00 10 00 00       	push   $0x1000
+  struct balance b1 = {"b1", 3200};
+  24:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
+  2b:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
+  32:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
+  39:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
+  40:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
+  47:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
+  4e:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+  55:	c7 45 c0 80 0c 00 00 	movl   $0xc80,-0x40(%ebp)
+  struct balance b2 = {"b2", 2800};
+  5c:	c7 45 c4 62 32 00 00 	movl   $0x3262,-0x3c(%ebp)
+  63:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
+  6a:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
+  71:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
+  78:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
+  7f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
+  86:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  8d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+  94:	c7 45 e4 f0 0a 00 00 	movl   $0xaf0,-0x1c(%ebp)
+  s1 = malloc(4096);
+  9b:	e8 70 08 00 00       	call   910 <malloc>
+  s2 = malloc(4096);
+  a0:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
+  s1 = malloc(4096);
+  a7:	89 c3                	mov    %eax,%ebx
+  s2 = malloc(4096);
+  a9:	e8 62 08 00 00       	call   910 <malloc>
+
+  // Initialize thread_spin_lock
+  // thread_initlock(&lock,"do work");
+  mutex_initlock(&m_lock,"do work");
+
+  t1 = thread_create(do_work, (void *)&b1, s1);
+  ae:	83 c4 0c             	add    $0xc,%esp
+  lk->name=name;
+  b1:	c7 05 60 0e 00 00 3b 	movl   $0xa3b,0xe60
+  b8:	0a 00 00 
+  s2 = malloc(4096);
+  bb:	89 c6                	mov    %eax,%esi
+  t1 = thread_create(do_work, (void *)&b1, s1);
+  bd:	8d 45 a0             	lea    -0x60(%ebp),%eax
+  c0:	53                   	push   %ebx
+  c1:	50                   	push   %eax
+  c2:	68 f0 01 00 00       	push   $0x1f0
+  lk->locked = 0;
+  c7:	c7 05 64 0e 00 00 00 	movl   $0x0,0xe64
+  ce:	00 00 00 
+  t1 = thread_create(do_work, (void *)&b1, s1);
+  d1:	e8 05 05 00 00       	call   5db <thread_create>
+  t2 = thread_create(do_work, (void *)&b2, s2);
+  d6:	83 c4 0c             	add    $0xc,%esp
+  t1 = thread_create(do_work, (void *)&b1, s1);
+  d9:	89 c3                	mov    %eax,%ebx
+  t2 = thread_create(do_work, (void *)&b2, s2);
+  db:	8d 45 c4             	lea    -0x3c(%ebp),%eax
+  de:	56                   	push   %esi
+  df:	50                   	push   %eax
+  e0:	68 f0 01 00 00       	push   $0x1f0
+  e5:	e8 f1 04 00 00       	call   5db <thread_create>
+  ea:	89 c7                	mov    %eax,%edi
+
+  r1 = thread_join();
+  ec:	e8 f2 04 00 00       	call   5e3 <thread_join>
+  f1:	89 c6                	mov    %eax,%esi
+  r2 = thread_join();
+  f3:	e8 eb 04 00 00       	call   5e3 <thread_join>
+
+  printf(1, "Threads finished: (%d):%d, (%d):%d, shared balance:%d\n",
+  f8:	8b 15 48 0e 00 00    	mov    0xe48,%edx
+  fe:	83 c4 0c             	add    $0xc,%esp
+ 101:	52                   	push   %edx
+ 102:	50                   	push   %eax
+ 103:	57                   	push   %edi
+ 104:	56                   	push   %esi
+ 105:	53                   	push   %ebx
+ 106:	68 44 0a 00 00       	push   $0xa44
+ 10b:	6a 01                	push   $0x1
+ 10d:	e8 9e 05 00 00       	call   6b0 <printf>
+         t1, r1, t2, r2, total_balance);
+
+  exit();
+ 112:	83 c4 20             	add    $0x20,%esp
+ 115:	e8 19 04 00 00       	call   533 <exit>
+ 11a:	66 90                	xchg   %ax,%ax
+ 11c:	66 90                	xchg   %ax,%ax
+ 11e:	66 90                	xchg   %ax,%ax
+
+00000120 <delay>:
+{
+ 120:	f3 0f 1e fb          	endbr32 
+ 124:	55                   	push   %ebp
+ 125:	89 e5                	mov    %esp,%ebp
+ 127:	8b 55 08             	mov    0x8(%ebp),%edx
+  for (i = 0; i < d; i++)
+ 12a:	85 d2                	test   %edx,%edx
+ 12c:	74 0a                	je     138 <delay+0x18>
+ 12e:	31 c0                	xor    %eax,%eax
+    __asm volatile("nop" ::
+ 130:	90                   	nop
+  for (i = 0; i < d; i++)
+ 131:	83 c0 01             	add    $0x1,%eax
+ 134:	39 c2                	cmp    %eax,%edx
+ 136:	75 f8                	jne    130 <delay+0x10>
+}
+ 138:	89 d0                	mov    %edx,%eax
+ 13a:	5d                   	pop    %ebp
+ 13b:	c3                   	ret    
+ 13c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000140 <thread_initlock>:
+{
+ 140:	f3 0f 1e fb          	endbr32 
+ 144:	55                   	push   %ebp
+ 145:	89 e5                	mov    %esp,%ebp
+ 147:	8b 45 08             	mov    0x8(%ebp),%eax
+  lk->name = name;
+ 14a:	8b 55 0c             	mov    0xc(%ebp),%edx
+  lk->locked = 0;
+ 14d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+  lk->name = name;
+ 153:	89 50 04             	mov    %edx,0x4(%eax)
+}
+ 156:	5d                   	pop    %ebp
+ 157:	c3                   	ret    
+ 158:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 15f:	90                   	nop
+
+00000160 <mutex_initlock>:
+{
+ 160:	f3 0f 1e fb          	endbr32 
+ 164:	55                   	push   %ebp
+ 165:	89 e5                	mov    %esp,%ebp
+ 167:	8b 45 08             	mov    0x8(%ebp),%eax
+  lk->name=name;
+ 16a:	8b 55 0c             	mov    0xc(%ebp),%edx
+  lk->locked = 0;
+ 16d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+  lk->name=name;
+ 174:	89 10                	mov    %edx,(%eax)
+}
+ 176:	5d                   	pop    %ebp
+ 177:	c3                   	ret    
+ 178:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 17f:	90                   	nop
+
+00000180 <thread_spin_lock>:
+{
+ 180:	f3 0f 1e fb          	endbr32 
+ 184:	55                   	push   %ebp
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+ 185:	b9 01 00 00 00       	mov    $0x1,%ecx
+ 18a:	89 e5                	mov    %esp,%ebp
+ 18c:	8b 55 08             	mov    0x8(%ebp),%edx
+ 18f:	90                   	nop
+ 190:	89 c8                	mov    %ecx,%eax
+ 192:	f0 87 02             	lock xchg %eax,(%edx)
+  while (xchg(&lk->locked, 1) != 0)
+ 195:	85 c0                	test   %eax,%eax
+ 197:	75 f7                	jne    190 <thread_spin_lock+0x10>
+  __sync_synchronize();
+ 199:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
+}
+ 19e:	5d                   	pop    %ebp
+ 19f:	c3                   	ret    
+
+000001a0 <mutex_lock>:
+{
+ 1a0:	f3 0f 1e fb          	endbr32 
+ 1a4:	55                   	push   %ebp
+ 1a5:	b8 01 00 00 00       	mov    $0x1,%eax
+ 1aa:	89 e5                	mov    %esp,%ebp
+ 1ac:	56                   	push   %esi
+ 1ad:	8b 55 08             	mov    0x8(%ebp),%edx
+ 1b0:	53                   	push   %ebx
+ 1b1:	f0 87 42 04          	lock xchg %eax,0x4(%edx)
+  while (xchg(&lk->locked, 1) != 0)
+ 1b5:	85 c0                	test   %eax,%eax
+ 1b7:	74 25                	je     1de <mutex_lock+0x3e>
+ 1b9:	8d 5a 04             	lea    0x4(%edx),%ebx
+ 1bc:	be 01 00 00 00       	mov    $0x1,%esi
+ 1c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    sleep(1);
+ 1c8:	83 ec 0c             	sub    $0xc,%esp
+ 1cb:	6a 01                	push   $0x1
+ 1cd:	e8 f1 03 00 00       	call   5c3 <sleep>
+ 1d2:	89 f0                	mov    %esi,%eax
+ 1d4:	f0 87 03             	lock xchg %eax,(%ebx)
+  while (xchg(&lk->locked, 1) != 0)
+ 1d7:	83 c4 10             	add    $0x10,%esp
+ 1da:	85 c0                	test   %eax,%eax
+ 1dc:	75 ea                	jne    1c8 <mutex_lock+0x28>
+  __sync_synchronize();
+ 1de:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
+}
+ 1e3:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 1e6:	5b                   	pop    %ebx
+ 1e7:	5e                   	pop    %esi
+ 1e8:	5d                   	pop    %ebp
+ 1e9:	c3                   	ret    
+ 1ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000001f0 <do_work>:
+{
+ 1f0:	f3 0f 1e fb          	endbr32 
+ 1f4:	55                   	push   %ebp
+ 1f5:	89 e5                	mov    %esp,%ebp
+ 1f7:	56                   	push   %esi
+ 1f8:	53                   	push   %ebx
+ 1f9:	8b 5d 08             	mov    0x8(%ebp),%ebx
+  printf(1, "Starting do_work: s:%s\n", b->name);
+ 1fc:	83 ec 04             	sub    $0x4,%esp
+ 1ff:	53                   	push   %ebx
+ 200:	68 18 0a 00 00       	push   $0xa18
+ 205:	6a 01                	push   $0x1
+ 207:	e8 a4 04 00 00       	call   6b0 <printf>
+  for (i = 0; i < b->amount; i++)
+ 20c:	8b 43 20             	mov    0x20(%ebx),%eax
+ 20f:	83 c4 10             	add    $0x10,%esp
+ 212:	85 c0                	test   %eax,%eax
+ 214:	7e 4f                	jle    265 <do_work+0x75>
+ 216:	31 f6                	xor    %esi,%esi
+ 218:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 21f:	90                   	nop
+     mutex_lock(&m_lock);
+ 220:	83 ec 0c             	sub    $0xc,%esp
+ 223:	68 60 0e 00 00       	push   $0xe60
+ 228:	e8 73 ff ff ff       	call   1a0 <mutex_lock>
+    old = total_balance;
+ 22d:	8b 15 48 0e 00 00    	mov    0xe48,%edx
+ 233:	83 c4 10             	add    $0x10,%esp
+ 236:	b8 a0 86 01 00       	mov    $0x186a0,%eax
+ 23b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 23f:	90                   	nop
+    __asm volatile("nop" ::
+ 240:	90                   	nop
+  for (i = 0; i < d; i++)
+ 241:	83 e8 01             	sub    $0x1,%eax
+ 244:	75 fa                	jne    240 <do_work+0x50>
+    total_balance = old + 1;
+ 246:	8d 42 01             	lea    0x1(%edx),%eax
+ 249:	a3 48 0e 00 00       	mov    %eax,0xe48
+  __sync_synchronize();
+ 24e:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
+  asm volatile("movl $0, %0"
+ 253:	c7 05 64 0e 00 00 00 	movl   $0x0,0xe64
+ 25a:	00 00 00 
+  for (i = 0; i < b->amount; i++)
+ 25d:	83 c6 01             	add    $0x1,%esi
+ 260:	39 73 20             	cmp    %esi,0x20(%ebx)
+ 263:	7f bb                	jg     220 <do_work+0x30>
+  printf(1, "Done s:%s\n", b->name);
+ 265:	83 ec 04             	sub    $0x4,%esp
+ 268:	53                   	push   %ebx
+ 269:	68 30 0a 00 00       	push   $0xa30
+ 26e:	6a 01                	push   $0x1
+ 270:	e8 3b 04 00 00       	call   6b0 <printf>
+  thread_exit();
+ 275:	83 c4 10             	add    $0x10,%esp
+}
+ 278:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 27b:	5b                   	pop    %ebx
+ 27c:	5e                   	pop    %esi
+ 27d:	5d                   	pop    %ebp
+  thread_exit();
+ 27e:	e9 68 03 00 00       	jmp    5eb <thread_exit>
+ 283:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 28a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000290 <thread_spin_unlock>:
+{
+ 290:	f3 0f 1e fb          	endbr32 
+ 294:	55                   	push   %ebp
+ 295:	89 e5                	mov    %esp,%ebp
+ 297:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+ 29a:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
+  asm volatile("movl $0, %0"
+ 29f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+ 2a5:	5d                   	pop    %ebp
+ 2a6:	c3                   	ret    
+ 2a7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 2ae:	66 90                	xchg   %ax,%ax
+
+000002b0 <mutex_unlock>:
+{
+ 2b0:	f3 0f 1e fb          	endbr32 
+ 2b4:	55                   	push   %ebp
+ 2b5:	89 e5                	mov    %esp,%ebp
+ 2b7:	8b 45 08             	mov    0x8(%ebp),%eax
+  __sync_synchronize();
+ 2ba:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
+  asm volatile("movl $0, %0"
+ 2bf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+}
+ 2c6:	5d                   	pop    %ebp
+ 2c7:	c3                   	ret    
+ 2c8:	66 90                	xchg   %ax,%ax
+ 2ca:	66 90                	xchg   %ax,%ax
+ 2cc:	66 90                	xchg   %ax,%ax
+ 2ce:	66 90                	xchg   %ax,%ax
+
+000002d0 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 2d0:	f3 0f 1e fb          	endbr32 
+ 2d4:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+ 2d5:	31 c0                	xor    %eax,%eax
+{
+ 2d7:	89 e5                	mov    %esp,%ebp
+ 2d9:	53                   	push   %ebx
+ 2da:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 2dd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+ 2e0:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+ 2e4:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+ 2e7:	83 c0 01             	add    $0x1,%eax
+ 2ea:	84 d2                	test   %dl,%dl
+ 2ec:	75 f2                	jne    2e0 <strcpy+0x10>
+    ;
+  return os;
+}
+ 2ee:	89 c8                	mov    %ecx,%eax
+ 2f0:	5b                   	pop    %ebx
+ 2f1:	5d                   	pop    %ebp
+ 2f2:	c3                   	ret    
+ 2f3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 2fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000300 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 300:	f3 0f 1e fb          	endbr32 
+ 304:	55                   	push   %ebp
+ 305:	89 e5                	mov    %esp,%ebp
+ 307:	53                   	push   %ebx
+ 308:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 30b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+ 30e:	0f b6 01             	movzbl (%ecx),%eax
+ 311:	0f b6 1a             	movzbl (%edx),%ebx
+ 314:	84 c0                	test   %al,%al
+ 316:	75 19                	jne    331 <strcmp+0x31>
+ 318:	eb 26                	jmp    340 <strcmp+0x40>
+ 31a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 320:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+ 324:	83 c1 01             	add    $0x1,%ecx
+ 327:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+ 32a:	0f b6 1a             	movzbl (%edx),%ebx
+ 32d:	84 c0                	test   %al,%al
+ 32f:	74 0f                	je     340 <strcmp+0x40>
+ 331:	38 d8                	cmp    %bl,%al
+ 333:	74 eb                	je     320 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+ 335:	29 d8                	sub    %ebx,%eax
+}
+ 337:	5b                   	pop    %ebx
+ 338:	5d                   	pop    %ebp
+ 339:	c3                   	ret    
+ 33a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 340:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+ 342:	29 d8                	sub    %ebx,%eax
+}
+ 344:	5b                   	pop    %ebx
+ 345:	5d                   	pop    %ebp
+ 346:	c3                   	ret    
+ 347:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 34e:	66 90                	xchg   %ax,%ax
+
+00000350 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 350:	f3 0f 1e fb          	endbr32 
+ 354:	55                   	push   %ebp
+ 355:	89 e5                	mov    %esp,%ebp
+ 357:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 35a:	80 3a 00             	cmpb   $0x0,(%edx)
+ 35d:	74 21                	je     380 <strlen+0x30>
+ 35f:	31 c0                	xor    %eax,%eax
+ 361:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 368:	83 c0 01             	add    $0x1,%eax
+ 36b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+ 36f:	89 c1                	mov    %eax,%ecx
+ 371:	75 f5                	jne    368 <strlen+0x18>
+    ;
+  return n;
+}
+ 373:	89 c8                	mov    %ecx,%eax
+ 375:	5d                   	pop    %ebp
+ 376:	c3                   	ret    
+ 377:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 37e:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+ 380:	31 c9                	xor    %ecx,%ecx
+}
+ 382:	5d                   	pop    %ebp
+ 383:	89 c8                	mov    %ecx,%eax
+ 385:	c3                   	ret    
+ 386:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 38d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000390 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 390:	f3 0f 1e fb          	endbr32 
+ 394:	55                   	push   %ebp
+ 395:	89 e5                	mov    %esp,%ebp
+ 397:	57                   	push   %edi
+ 398:	8b 55 08             	mov    0x8(%ebp),%edx
+  asm volatile("cld; rep stosb" :
+ 39b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 39e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3a1:	89 d7                	mov    %edx,%edi
+ 3a3:	fc                   	cld    
+ 3a4:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+ 3a6:	89 d0                	mov    %edx,%eax
+ 3a8:	5f                   	pop    %edi
+ 3a9:	5d                   	pop    %ebp
+ 3aa:	c3                   	ret    
+ 3ab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 3af:	90                   	nop
+
+000003b0 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 3b0:	f3 0f 1e fb          	endbr32 
+ 3b4:	55                   	push   %ebp
+ 3b5:	89 e5                	mov    %esp,%ebp
+ 3b7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3ba:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+ 3be:	0f b6 10             	movzbl (%eax),%edx
+ 3c1:	84 d2                	test   %dl,%dl
+ 3c3:	75 16                	jne    3db <strchr+0x2b>
+ 3c5:	eb 21                	jmp    3e8 <strchr+0x38>
+ 3c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 3ce:	66 90                	xchg   %ax,%ax
+ 3d0:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+ 3d4:	83 c0 01             	add    $0x1,%eax
+ 3d7:	84 d2                	test   %dl,%dl
+ 3d9:	74 0d                	je     3e8 <strchr+0x38>
+    if(*s == c)
+ 3db:	38 d1                	cmp    %dl,%cl
+ 3dd:	75 f1                	jne    3d0 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+ 3df:	5d                   	pop    %ebp
+ 3e0:	c3                   	ret    
+ 3e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+ 3e8:	31 c0                	xor    %eax,%eax
+}
+ 3ea:	5d                   	pop    %ebp
+ 3eb:	c3                   	ret    
+ 3ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000003f0 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 3f0:	f3 0f 1e fb          	endbr32 
+ 3f4:	55                   	push   %ebp
+ 3f5:	89 e5                	mov    %esp,%ebp
+ 3f7:	57                   	push   %edi
+ 3f8:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 3f9:	31 f6                	xor    %esi,%esi
+{
+ 3fb:	53                   	push   %ebx
+ 3fc:	89 f3                	mov    %esi,%ebx
+ 3fe:	83 ec 1c             	sub    $0x1c,%esp
+ 401:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+ 404:	eb 33                	jmp    439 <gets+0x49>
+ 406:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 40d:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+ 410:	83 ec 04             	sub    $0x4,%esp
+ 413:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ 416:	6a 01                	push   $0x1
+ 418:	50                   	push   %eax
+ 419:	6a 00                	push   $0x0
+ 41b:	e8 2b 01 00 00       	call   54b <read>
+    if(cc < 1)
+ 420:	83 c4 10             	add    $0x10,%esp
+ 423:	85 c0                	test   %eax,%eax
+ 425:	7e 1c                	jle    443 <gets+0x53>
+      break;
+    buf[i++] = c;
+ 427:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ 42b:	83 c7 01             	add    $0x1,%edi
+ 42e:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+ 431:	3c 0a                	cmp    $0xa,%al
+ 433:	74 23                	je     458 <gets+0x68>
+ 435:	3c 0d                	cmp    $0xd,%al
+ 437:	74 1f                	je     458 <gets+0x68>
+  for(i=0; i+1 < max; ){
+ 439:	83 c3 01             	add    $0x1,%ebx
+ 43c:	89 fe                	mov    %edi,%esi
+ 43e:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+ 441:	7c cd                	jl     410 <gets+0x20>
+ 443:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+ 445:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+ 448:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 44b:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 44e:	5b                   	pop    %ebx
+ 44f:	5e                   	pop    %esi
+ 450:	5f                   	pop    %edi
+ 451:	5d                   	pop    %ebp
+ 452:	c3                   	ret    
+ 453:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 457:	90                   	nop
+ 458:	8b 75 08             	mov    0x8(%ebp),%esi
+ 45b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 45e:	01 de                	add    %ebx,%esi
+ 460:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+ 462:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 465:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 468:	5b                   	pop    %ebx
+ 469:	5e                   	pop    %esi
+ 46a:	5f                   	pop    %edi
+ 46b:	5d                   	pop    %ebp
+ 46c:	c3                   	ret    
+ 46d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000470 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 470:	f3 0f 1e fb          	endbr32 
+ 474:	55                   	push   %ebp
+ 475:	89 e5                	mov    %esp,%ebp
+ 477:	56                   	push   %esi
+ 478:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 479:	83 ec 08             	sub    $0x8,%esp
+ 47c:	6a 00                	push   $0x0
+ 47e:	ff 75 08             	pushl  0x8(%ebp)
+ 481:	e8 ed 00 00 00       	call   573 <open>
+  if(fd < 0)
+ 486:	83 c4 10             	add    $0x10,%esp
+ 489:	85 c0                	test   %eax,%eax
+ 48b:	78 2b                	js     4b8 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+ 48d:	83 ec 08             	sub    $0x8,%esp
+ 490:	ff 75 0c             	pushl  0xc(%ebp)
+ 493:	89 c3                	mov    %eax,%ebx
+ 495:	50                   	push   %eax
+ 496:	e8 f0 00 00 00       	call   58b <fstat>
+  close(fd);
+ 49b:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+ 49e:	89 c6                	mov    %eax,%esi
+  close(fd);
+ 4a0:	e8 b6 00 00 00       	call   55b <close>
+  return r;
+ 4a5:	83 c4 10             	add    $0x10,%esp
+}
+ 4a8:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 4ab:	89 f0                	mov    %esi,%eax
+ 4ad:	5b                   	pop    %ebx
+ 4ae:	5e                   	pop    %esi
+ 4af:	5d                   	pop    %ebp
+ 4b0:	c3                   	ret    
+ 4b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+ 4b8:	be ff ff ff ff       	mov    $0xffffffff,%esi
+ 4bd:	eb e9                	jmp    4a8 <stat+0x38>
+ 4bf:	90                   	nop
+
+000004c0 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 4c0:	f3 0f 1e fb          	endbr32 
+ 4c4:	55                   	push   %ebp
+ 4c5:	89 e5                	mov    %esp,%ebp
+ 4c7:	53                   	push   %ebx
+ 4c8:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 4cb:	0f be 02             	movsbl (%edx),%eax
+ 4ce:	8d 48 d0             	lea    -0x30(%eax),%ecx
+ 4d1:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+ 4d4:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+ 4d9:	77 1a                	ja     4f5 <atoi+0x35>
+ 4db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 4df:	90                   	nop
+    n = n*10 + *s++ - '0';
+ 4e0:	83 c2 01             	add    $0x1,%edx
+ 4e3:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+ 4e6:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+ 4ea:	0f be 02             	movsbl (%edx),%eax
+ 4ed:	8d 58 d0             	lea    -0x30(%eax),%ebx
+ 4f0:	80 fb 09             	cmp    $0x9,%bl
+ 4f3:	76 eb                	jbe    4e0 <atoi+0x20>
+  return n;
+}
+ 4f5:	89 c8                	mov    %ecx,%eax
+ 4f7:	5b                   	pop    %ebx
+ 4f8:	5d                   	pop    %ebp
+ 4f9:	c3                   	ret    
+ 4fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000500 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 500:	f3 0f 1e fb          	endbr32 
+ 504:	55                   	push   %ebp
+ 505:	89 e5                	mov    %esp,%ebp
+ 507:	57                   	push   %edi
+ 508:	8b 45 10             	mov    0x10(%ebp),%eax
+ 50b:	8b 55 08             	mov    0x8(%ebp),%edx
+ 50e:	56                   	push   %esi
+ 50f:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 512:	85 c0                	test   %eax,%eax
+ 514:	7e 0f                	jle    525 <memmove+0x25>
+ 516:	01 d0                	add    %edx,%eax
+  dst = vdst;
+ 518:	89 d7                	mov    %edx,%edi
+ 51a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+ 520:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+ 521:	39 f8                	cmp    %edi,%eax
+ 523:	75 fb                	jne    520 <memmove+0x20>
+  return vdst;
+}
+ 525:	5e                   	pop    %esi
+ 526:	89 d0                	mov    %edx,%eax
+ 528:	5f                   	pop    %edi
+ 529:	5d                   	pop    %ebp
+ 52a:	c3                   	ret    
+
+0000052b <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 52b:	b8 01 00 00 00       	mov    $0x1,%eax
+ 530:	cd 40                	int    $0x40
+ 532:	c3                   	ret    
+
+00000533 <exit>:
+SYSCALL(exit)
+ 533:	b8 02 00 00 00       	mov    $0x2,%eax
+ 538:	cd 40                	int    $0x40
+ 53a:	c3                   	ret    
+
+0000053b <wait>:
+SYSCALL(wait)
+ 53b:	b8 03 00 00 00       	mov    $0x3,%eax
+ 540:	cd 40                	int    $0x40
+ 542:	c3                   	ret    
+
+00000543 <pipe>:
+SYSCALL(pipe)
+ 543:	b8 04 00 00 00       	mov    $0x4,%eax
+ 548:	cd 40                	int    $0x40
+ 54a:	c3                   	ret    
+
+0000054b <read>:
+SYSCALL(read)
+ 54b:	b8 05 00 00 00       	mov    $0x5,%eax
+ 550:	cd 40                	int    $0x40
+ 552:	c3                   	ret    
+
+00000553 <write>:
+SYSCALL(write)
+ 553:	b8 10 00 00 00       	mov    $0x10,%eax
+ 558:	cd 40                	int    $0x40
+ 55a:	c3                   	ret    
+
+0000055b <close>:
+SYSCALL(close)
+ 55b:	b8 15 00 00 00       	mov    $0x15,%eax
+ 560:	cd 40                	int    $0x40
+ 562:	c3                   	ret    
+
+00000563 <kill>:
+SYSCALL(kill)
+ 563:	b8 06 00 00 00       	mov    $0x6,%eax
+ 568:	cd 40                	int    $0x40
+ 56a:	c3                   	ret    
+
+0000056b <exec>:
+SYSCALL(exec)
+ 56b:	b8 07 00 00 00       	mov    $0x7,%eax
+ 570:	cd 40                	int    $0x40
+ 572:	c3                   	ret    
+
+00000573 <open>:
+SYSCALL(open)
+ 573:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 578:	cd 40                	int    $0x40
+ 57a:	c3                   	ret    
+
+0000057b <mknod>:
+SYSCALL(mknod)
+ 57b:	b8 11 00 00 00       	mov    $0x11,%eax
+ 580:	cd 40                	int    $0x40
+ 582:	c3                   	ret    
+
+00000583 <unlink>:
+SYSCALL(unlink)
+ 583:	b8 12 00 00 00       	mov    $0x12,%eax
+ 588:	cd 40                	int    $0x40
+ 58a:	c3                   	ret    
+
+0000058b <fstat>:
+SYSCALL(fstat)
+ 58b:	b8 08 00 00 00       	mov    $0x8,%eax
+ 590:	cd 40                	int    $0x40
+ 592:	c3                   	ret    
+
+00000593 <link>:
+SYSCALL(link)
+ 593:	b8 13 00 00 00       	mov    $0x13,%eax
+ 598:	cd 40                	int    $0x40
+ 59a:	c3                   	ret    
+
+0000059b <mkdir>:
+SYSCALL(mkdir)
+ 59b:	b8 14 00 00 00       	mov    $0x14,%eax
+ 5a0:	cd 40                	int    $0x40
+ 5a2:	c3                   	ret    
+
+000005a3 <chdir>:
+SYSCALL(chdir)
+ 5a3:	b8 09 00 00 00       	mov    $0x9,%eax
+ 5a8:	cd 40                	int    $0x40
+ 5aa:	c3                   	ret    
+
+000005ab <dup>:
+SYSCALL(dup)
+ 5ab:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 5b0:	cd 40                	int    $0x40
+ 5b2:	c3                   	ret    
+
+000005b3 <getpid>:
+SYSCALL(getpid)
+ 5b3:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 5b8:	cd 40                	int    $0x40
+ 5ba:	c3                   	ret    
+
+000005bb <sbrk>:
+SYSCALL(sbrk)
+ 5bb:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 5c0:	cd 40                	int    $0x40
+ 5c2:	c3                   	ret    
+
+000005c3 <sleep>:
+SYSCALL(sleep)
+ 5c3:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 5c8:	cd 40                	int    $0x40
+ 5ca:	c3                   	ret    
+
+000005cb <uptime>:
+SYSCALL(uptime)
+ 5cb:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 5d0:	cd 40                	int    $0x40
+ 5d2:	c3                   	ret    
+
+000005d3 <draw>:
+SYSCALL(draw)
+ 5d3:	b8 16 00 00 00       	mov    $0x16,%eax
+ 5d8:	cd 40                	int    $0x40
+ 5da:	c3                   	ret    
+
+000005db <thread_create>:
+
+SYSCALL(thread_create)
+ 5db:	b8 17 00 00 00       	mov    $0x17,%eax
+ 5e0:	cd 40                	int    $0x40
+ 5e2:	c3                   	ret    
+
+000005e3 <thread_join>:
+SYSCALL(thread_join)
+ 5e3:	b8 18 00 00 00       	mov    $0x18,%eax
+ 5e8:	cd 40                	int    $0x40
+ 5ea:	c3                   	ret    
+
+000005eb <thread_exit>:
+SYSCALL(thread_exit)
+ 5eb:	b8 19 00 00 00       	mov    $0x19,%eax
+ 5f0:	cd 40                	int    $0x40
+ 5f2:	c3                   	ret    
+ 5f3:	66 90                	xchg   %ax,%ax
+ 5f5:	66 90                	xchg   %ax,%ax
+ 5f7:	66 90                	xchg   %ax,%ax
+ 5f9:	66 90                	xchg   %ax,%ax
+ 5fb:	66 90                	xchg   %ax,%ax
+ 5fd:	66 90                	xchg   %ax,%ax
+ 5ff:	90                   	nop
+
+00000600 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 600:	55                   	push   %ebp
+ 601:	89 e5                	mov    %esp,%ebp
+ 603:	57                   	push   %edi
+ 604:	56                   	push   %esi
+ 605:	53                   	push   %ebx
+ 606:	83 ec 3c             	sub    $0x3c,%esp
+ 609:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+ 60c:	89 d1                	mov    %edx,%ecx
+{
+ 60e:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  if(sgn && xx < 0){
+ 611:	85 d2                	test   %edx,%edx
+ 613:	0f 89 7f 00 00 00    	jns    698 <printint+0x98>
+ 619:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
+ 61d:	74 79                	je     698 <printint+0x98>
+    neg = 1;
+ 61f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+    x = -xx;
+ 626:	f7 d9                	neg    %ecx
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 628:	31 db                	xor    %ebx,%ebx
+ 62a:	8d 75 d7             	lea    -0x29(%ebp),%esi
+ 62d:	8d 76 00             	lea    0x0(%esi),%esi
+  do{
+    buf[i++] = digits[x % base];
+ 630:	89 c8                	mov    %ecx,%eax
+ 632:	31 d2                	xor    %edx,%edx
+ 634:	89 cf                	mov    %ecx,%edi
+ 636:	f7 75 c4             	divl   -0x3c(%ebp)
+ 639:	0f b6 92 84 0a 00 00 	movzbl 0xa84(%edx),%edx
+ 640:	89 45 c0             	mov    %eax,-0x40(%ebp)
+ 643:	89 d8                	mov    %ebx,%eax
+ 645:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+ 648:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+    buf[i++] = digits[x % base];
+ 64b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
+  }while((x /= base) != 0);
+ 64e:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
+ 651:	76 dd                	jbe    630 <printint+0x30>
+  if(neg)
+ 653:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+ 656:	85 c9                	test   %ecx,%ecx
+ 658:	74 0c                	je     666 <printint+0x66>
+    buf[i++] = '-';
+ 65a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+ 65f:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+ 661:	ba 2d 00 00 00       	mov    $0x2d,%edx
+
+  while(--i >= 0)
+ 666:	8b 7d b8             	mov    -0x48(%ebp),%edi
+ 669:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+ 66d:	eb 07                	jmp    676 <printint+0x76>
+ 66f:	90                   	nop
+ 670:	0f b6 13             	movzbl (%ebx),%edx
+ 673:	83 eb 01             	sub    $0x1,%ebx
+  write(fd, &c, 1);
+ 676:	83 ec 04             	sub    $0x4,%esp
+ 679:	88 55 d7             	mov    %dl,-0x29(%ebp)
+ 67c:	6a 01                	push   $0x1
+ 67e:	56                   	push   %esi
+ 67f:	57                   	push   %edi
+ 680:	e8 ce fe ff ff       	call   553 <write>
+  while(--i >= 0)
+ 685:	83 c4 10             	add    $0x10,%esp
+ 688:	39 de                	cmp    %ebx,%esi
+ 68a:	75 e4                	jne    670 <printint+0x70>
+    putc(fd, buf[i]);
+}
+ 68c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 68f:	5b                   	pop    %ebx
+ 690:	5e                   	pop    %esi
+ 691:	5f                   	pop    %edi
+ 692:	5d                   	pop    %ebp
+ 693:	c3                   	ret    
+ 694:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  neg = 0;
+ 698:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+ 69f:	eb 87                	jmp    628 <printint+0x28>
+ 6a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 6a8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 6af:	90                   	nop
+
+000006b0 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 6b0:	f3 0f 1e fb          	endbr32 
+ 6b4:	55                   	push   %ebp
+ 6b5:	89 e5                	mov    %esp,%ebp
+ 6b7:	57                   	push   %edi
+ 6b8:	56                   	push   %esi
+ 6b9:	53                   	push   %ebx
+ 6ba:	83 ec 2c             	sub    $0x2c,%esp
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 6bd:	8b 75 0c             	mov    0xc(%ebp),%esi
+ 6c0:	0f b6 1e             	movzbl (%esi),%ebx
+ 6c3:	84 db                	test   %bl,%bl
+ 6c5:	0f 84 b4 00 00 00    	je     77f <printf+0xcf>
+  ap = (uint*)(void*)&fmt + 1;
+ 6cb:	8d 45 10             	lea    0x10(%ebp),%eax
+ 6ce:	83 c6 01             	add    $0x1,%esi
+  write(fd, &c, 1);
+ 6d1:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  state = 0;
+ 6d4:	31 d2                	xor    %edx,%edx
+  ap = (uint*)(void*)&fmt + 1;
+ 6d6:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 6d9:	eb 33                	jmp    70e <printf+0x5e>
+ 6db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 6df:	90                   	nop
+ 6e0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+ 6e3:	ba 25 00 00 00       	mov    $0x25,%edx
+      if(c == '%'){
+ 6e8:	83 f8 25             	cmp    $0x25,%eax
+ 6eb:	74 17                	je     704 <printf+0x54>
+  write(fd, &c, 1);
+ 6ed:	83 ec 04             	sub    $0x4,%esp
+ 6f0:	88 5d e7             	mov    %bl,-0x19(%ebp)
+ 6f3:	6a 01                	push   $0x1
+ 6f5:	57                   	push   %edi
+ 6f6:	ff 75 08             	pushl  0x8(%ebp)
+ 6f9:	e8 55 fe ff ff       	call   553 <write>
+ 6fe:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+      } else {
+        putc(fd, c);
+ 701:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; fmt[i]; i++){
+ 704:	0f b6 1e             	movzbl (%esi),%ebx
+ 707:	83 c6 01             	add    $0x1,%esi
+ 70a:	84 db                	test   %bl,%bl
+ 70c:	74 71                	je     77f <printf+0xcf>
+    c = fmt[i] & 0xff;
+ 70e:	0f be cb             	movsbl %bl,%ecx
+ 711:	0f b6 c3             	movzbl %bl,%eax
+    if(state == 0){
+ 714:	85 d2                	test   %edx,%edx
+ 716:	74 c8                	je     6e0 <printf+0x30>
+      }
+    } else if(state == '%'){
+ 718:	83 fa 25             	cmp    $0x25,%edx
+ 71b:	75 e7                	jne    704 <printf+0x54>
+      if(c == 'd'){
+ 71d:	83 f8 64             	cmp    $0x64,%eax
+ 720:	0f 84 9a 00 00 00    	je     7c0 <printf+0x110>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+ 726:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
+ 72c:	83 f9 70             	cmp    $0x70,%ecx
+ 72f:	74 5f                	je     790 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+ 731:	83 f8 73             	cmp    $0x73,%eax
+ 734:	0f 84 d6 00 00 00    	je     810 <printf+0x160>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 73a:	83 f8 63             	cmp    $0x63,%eax
+ 73d:	0f 84 8d 00 00 00    	je     7d0 <printf+0x120>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+ 743:	83 f8 25             	cmp    $0x25,%eax
+ 746:	0f 84 b4 00 00 00    	je     800 <printf+0x150>
+  write(fd, &c, 1);
+ 74c:	83 ec 04             	sub    $0x4,%esp
+ 74f:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
+ 753:	6a 01                	push   $0x1
+ 755:	57                   	push   %edi
+ 756:	ff 75 08             	pushl  0x8(%ebp)
+ 759:	e8 f5 fd ff ff       	call   553 <write>
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+ 75e:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 761:	83 c4 0c             	add    $0xc,%esp
+ 764:	6a 01                	push   $0x1
+ 766:	83 c6 01             	add    $0x1,%esi
+ 769:	57                   	push   %edi
+ 76a:	ff 75 08             	pushl  0x8(%ebp)
+ 76d:	e8 e1 fd ff ff       	call   553 <write>
+  for(i = 0; fmt[i]; i++){
+ 772:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
+        putc(fd, c);
+ 776:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 779:	31 d2                	xor    %edx,%edx
+  for(i = 0; fmt[i]; i++){
+ 77b:	84 db                	test   %bl,%bl
+ 77d:	75 8f                	jne    70e <printf+0x5e>
+    }
+  }
+}
+ 77f:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 782:	5b                   	pop    %ebx
+ 783:	5e                   	pop    %esi
+ 784:	5f                   	pop    %edi
+ 785:	5d                   	pop    %ebp
+ 786:	c3                   	ret    
+ 787:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 78e:	66 90                	xchg   %ax,%ax
+        printint(fd, *ap, 16, 0);
+ 790:	83 ec 0c             	sub    $0xc,%esp
+ 793:	b9 10 00 00 00       	mov    $0x10,%ecx
+ 798:	6a 00                	push   $0x0
+ 79a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+ 79d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 7a0:	8b 13                	mov    (%ebx),%edx
+ 7a2:	e8 59 fe ff ff       	call   600 <printint>
+        ap++;
+ 7a7:	89 d8                	mov    %ebx,%eax
+ 7a9:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 7ac:	31 d2                	xor    %edx,%edx
+        ap++;
+ 7ae:	83 c0 04             	add    $0x4,%eax
+ 7b1:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 7b4:	e9 4b ff ff ff       	jmp    704 <printf+0x54>
+ 7b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        printint(fd, *ap, 10, 1);
+ 7c0:	83 ec 0c             	sub    $0xc,%esp
+ 7c3:	b9 0a 00 00 00       	mov    $0xa,%ecx
+ 7c8:	6a 01                	push   $0x1
+ 7ca:	eb ce                	jmp    79a <printf+0xea>
+ 7cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        putc(fd, *ap);
+ 7d0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+  write(fd, &c, 1);
+ 7d3:	83 ec 04             	sub    $0x4,%esp
+        putc(fd, *ap);
+ 7d6:	8b 03                	mov    (%ebx),%eax
+  write(fd, &c, 1);
+ 7d8:	6a 01                	push   $0x1
+        ap++;
+ 7da:	83 c3 04             	add    $0x4,%ebx
+  write(fd, &c, 1);
+ 7dd:	57                   	push   %edi
+ 7de:	ff 75 08             	pushl  0x8(%ebp)
+        putc(fd, *ap);
+ 7e1:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 7e4:	e8 6a fd ff ff       	call   553 <write>
+        ap++;
+ 7e9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+ 7ec:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 7ef:	31 d2                	xor    %edx,%edx
+ 7f1:	e9 0e ff ff ff       	jmp    704 <printf+0x54>
+ 7f6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 7fd:	8d 76 00             	lea    0x0(%esi),%esi
+        putc(fd, c);
+ 800:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 803:	83 ec 04             	sub    $0x4,%esp
+ 806:	e9 59 ff ff ff       	jmp    764 <printf+0xb4>
+ 80b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 80f:	90                   	nop
+        s = (char*)*ap;
+ 810:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 813:	8b 18                	mov    (%eax),%ebx
+        ap++;
+ 815:	83 c0 04             	add    $0x4,%eax
+ 818:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        if(s == 0)
+ 81b:	85 db                	test   %ebx,%ebx
+ 81d:	74 17                	je     836 <printf+0x186>
+        while(*s != 0){
+ 81f:	0f b6 03             	movzbl (%ebx),%eax
+      state = 0;
+ 822:	31 d2                	xor    %edx,%edx
+        while(*s != 0){
+ 824:	84 c0                	test   %al,%al
+ 826:	0f 84 d8 fe ff ff    	je     704 <printf+0x54>
+ 82c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 82f:	89 de                	mov    %ebx,%esi
+ 831:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 834:	eb 1a                	jmp    850 <printf+0x1a0>
+          s = "(null)";
+ 836:	bb 7b 0a 00 00       	mov    $0xa7b,%ebx
+        while(*s != 0){
+ 83b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 83e:	b8 28 00 00 00       	mov    $0x28,%eax
+ 843:	89 de                	mov    %ebx,%esi
+ 845:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 848:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 84f:	90                   	nop
+  write(fd, &c, 1);
+ 850:	83 ec 04             	sub    $0x4,%esp
+          s++;
+ 853:	83 c6 01             	add    $0x1,%esi
+ 856:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 859:	6a 01                	push   $0x1
+ 85b:	57                   	push   %edi
+ 85c:	53                   	push   %ebx
+ 85d:	e8 f1 fc ff ff       	call   553 <write>
+        while(*s != 0){
+ 862:	0f b6 06             	movzbl (%esi),%eax
+ 865:	83 c4 10             	add    $0x10,%esp
+ 868:	84 c0                	test   %al,%al
+ 86a:	75 e4                	jne    850 <printf+0x1a0>
+ 86c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+      state = 0;
+ 86f:	31 d2                	xor    %edx,%edx
+ 871:	e9 8e fe ff ff       	jmp    704 <printf+0x54>
+ 876:	66 90                	xchg   %ax,%ax
+ 878:	66 90                	xchg   %ax,%ax
+ 87a:	66 90                	xchg   %ax,%ax
+ 87c:	66 90                	xchg   %ax,%ax
+ 87e:	66 90                	xchg   %ax,%ax
+
+00000880 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 880:	f3 0f 1e fb          	endbr32 
+ 884:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 885:	a1 4c 0e 00 00       	mov    0xe4c,%eax
+{
+ 88a:	89 e5                	mov    %esp,%ebp
+ 88c:	57                   	push   %edi
+ 88d:	56                   	push   %esi
+ 88e:	53                   	push   %ebx
+ 88f:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 892:	8b 10                	mov    (%eax),%edx
+  bp = (Header*)ap - 1;
+ 894:	8d 4b f8             	lea    -0x8(%ebx),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 897:	39 c8                	cmp    %ecx,%eax
+ 899:	73 15                	jae    8b0 <free+0x30>
+ 89b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 89f:	90                   	nop
+ 8a0:	39 d1                	cmp    %edx,%ecx
+ 8a2:	72 14                	jb     8b8 <free+0x38>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 8a4:	39 d0                	cmp    %edx,%eax
+ 8a6:	73 10                	jae    8b8 <free+0x38>
+{
+ 8a8:	89 d0                	mov    %edx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 8aa:	8b 10                	mov    (%eax),%edx
+ 8ac:	39 c8                	cmp    %ecx,%eax
+ 8ae:	72 f0                	jb     8a0 <free+0x20>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 8b0:	39 d0                	cmp    %edx,%eax
+ 8b2:	72 f4                	jb     8a8 <free+0x28>
+ 8b4:	39 d1                	cmp    %edx,%ecx
+ 8b6:	73 f0                	jae    8a8 <free+0x28>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 8b8:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ 8bb:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
+ 8be:	39 fa                	cmp    %edi,%edx
+ 8c0:	74 1e                	je     8e0 <free+0x60>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+ 8c2:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 8c5:	8b 50 04             	mov    0x4(%eax),%edx
+ 8c8:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 8cb:	39 f1                	cmp    %esi,%ecx
+ 8cd:	74 28                	je     8f7 <free+0x77>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+ 8cf:	89 08                	mov    %ecx,(%eax)
+  freep = p;
+}
+ 8d1:	5b                   	pop    %ebx
+  freep = p;
+ 8d2:	a3 4c 0e 00 00       	mov    %eax,0xe4c
+}
+ 8d7:	5e                   	pop    %esi
+ 8d8:	5f                   	pop    %edi
+ 8d9:	5d                   	pop    %ebp
+ 8da:	c3                   	ret    
+ 8db:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 8df:	90                   	nop
+    bp->s.size += p->s.ptr->s.size;
+ 8e0:	03 72 04             	add    0x4(%edx),%esi
+ 8e3:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 8e6:	8b 10                	mov    (%eax),%edx
+ 8e8:	8b 12                	mov    (%edx),%edx
+ 8ea:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 8ed:	8b 50 04             	mov    0x4(%eax),%edx
+ 8f0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 8f3:	39 f1                	cmp    %esi,%ecx
+ 8f5:	75 d8                	jne    8cf <free+0x4f>
+    p->s.size += bp->s.size;
+ 8f7:	03 53 fc             	add    -0x4(%ebx),%edx
+  freep = p;
+ 8fa:	a3 4c 0e 00 00       	mov    %eax,0xe4c
+    p->s.size += bp->s.size;
+ 8ff:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 902:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ 905:	89 10                	mov    %edx,(%eax)
+}
+ 907:	5b                   	pop    %ebx
+ 908:	5e                   	pop    %esi
+ 909:	5f                   	pop    %edi
+ 90a:	5d                   	pop    %ebp
+ 90b:	c3                   	ret    
+ 90c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000910 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 910:	f3 0f 1e fb          	endbr32 
+ 914:	55                   	push   %ebp
+ 915:	89 e5                	mov    %esp,%ebp
+ 917:	57                   	push   %edi
+ 918:	56                   	push   %esi
+ 919:	53                   	push   %ebx
+ 91a:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 91d:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+ 920:	8b 3d 4c 0e 00 00    	mov    0xe4c,%edi
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 926:	8d 70 07             	lea    0x7(%eax),%esi
+ 929:	c1 ee 03             	shr    $0x3,%esi
+ 92c:	83 c6 01             	add    $0x1,%esi
+  if((prevp = freep) == 0){
+ 92f:	85 ff                	test   %edi,%edi
+ 931:	0f 84 a9 00 00 00    	je     9e0 <malloc+0xd0>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 937:	8b 07                	mov    (%edi),%eax
+    if(p->s.size >= nunits){
+ 939:	8b 48 04             	mov    0x4(%eax),%ecx
+ 93c:	39 f1                	cmp    %esi,%ecx
+ 93e:	73 6d                	jae    9ad <malloc+0x9d>
+ 940:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+ 946:	bb 00 10 00 00       	mov    $0x1000,%ebx
+ 94b:	0f 43 de             	cmovae %esi,%ebx
+  p = sbrk(nu * sizeof(Header));
+ 94e:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
+ 955:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+ 958:	eb 17                	jmp    971 <malloc+0x61>
+ 95a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 960:	8b 10                	mov    (%eax),%edx
+    if(p->s.size >= nunits){
+ 962:	8b 4a 04             	mov    0x4(%edx),%ecx
+ 965:	39 f1                	cmp    %esi,%ecx
+ 967:	73 4f                	jae    9b8 <malloc+0xa8>
+ 969:	8b 3d 4c 0e 00 00    	mov    0xe4c,%edi
+ 96f:	89 d0                	mov    %edx,%eax
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 971:	39 c7                	cmp    %eax,%edi
+ 973:	75 eb                	jne    960 <malloc+0x50>
+  p = sbrk(nu * sizeof(Header));
+ 975:	83 ec 0c             	sub    $0xc,%esp
+ 978:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 97b:	e8 3b fc ff ff       	call   5bb <sbrk>
+  if(p == (char*)-1)
+ 980:	83 c4 10             	add    $0x10,%esp
+ 983:	83 f8 ff             	cmp    $0xffffffff,%eax
+ 986:	74 1b                	je     9a3 <malloc+0x93>
+  hp->s.size = nu;
+ 988:	89 58 04             	mov    %ebx,0x4(%eax)
+  free((void*)(hp + 1));
+ 98b:	83 ec 0c             	sub    $0xc,%esp
+ 98e:	83 c0 08             	add    $0x8,%eax
+ 991:	50                   	push   %eax
+ 992:	e8 e9 fe ff ff       	call   880 <free>
+  return freep;
+ 997:	a1 4c 0e 00 00       	mov    0xe4c,%eax
+      if((p = morecore(nunits)) == 0)
+ 99c:	83 c4 10             	add    $0x10,%esp
+ 99f:	85 c0                	test   %eax,%eax
+ 9a1:	75 bd                	jne    960 <malloc+0x50>
+        return 0;
+  }
+}
+ 9a3:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return 0;
+ 9a6:	31 c0                	xor    %eax,%eax
+}
+ 9a8:	5b                   	pop    %ebx
+ 9a9:	5e                   	pop    %esi
+ 9aa:	5f                   	pop    %edi
+ 9ab:	5d                   	pop    %ebp
+ 9ac:	c3                   	ret    
+    if(p->s.size >= nunits){
+ 9ad:	89 c2                	mov    %eax,%edx
+ 9af:	89 f8                	mov    %edi,%eax
+ 9b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+ 9b8:	39 ce                	cmp    %ecx,%esi
+ 9ba:	74 54                	je     a10 <malloc+0x100>
+        p->s.size -= nunits;
+ 9bc:	29 f1                	sub    %esi,%ecx
+ 9be:	89 4a 04             	mov    %ecx,0x4(%edx)
+        p += p->s.size;
+ 9c1:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
+        p->s.size = nunits;
+ 9c4:	89 72 04             	mov    %esi,0x4(%edx)
+      freep = prevp;
+ 9c7:	a3 4c 0e 00 00       	mov    %eax,0xe4c
+}
+ 9cc:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return (void*)(p + 1);
+ 9cf:	8d 42 08             	lea    0x8(%edx),%eax
+}
+ 9d2:	5b                   	pop    %ebx
+ 9d3:	5e                   	pop    %esi
+ 9d4:	5f                   	pop    %edi
+ 9d5:	5d                   	pop    %ebp
+ 9d6:	c3                   	ret    
+ 9d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 9de:	66 90                	xchg   %ax,%ax
+    base.s.ptr = freep = prevp = &base;
+ 9e0:	c7 05 4c 0e 00 00 50 	movl   $0xe50,0xe4c
+ 9e7:	0e 00 00 
+    base.s.size = 0;
+ 9ea:	bf 50 0e 00 00       	mov    $0xe50,%edi
+    base.s.ptr = freep = prevp = &base;
+ 9ef:	c7 05 50 0e 00 00 50 	movl   $0xe50,0xe50
+ 9f6:	0e 00 00 
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 9f9:	89 f8                	mov    %edi,%eax
+    base.s.size = 0;
+ 9fb:	c7 05 54 0e 00 00 00 	movl   $0x0,0xe54
+ a02:	00 00 00 
+    if(p->s.size >= nunits){
+ a05:	e9 36 ff ff ff       	jmp    940 <malloc+0x30>
+ a0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        prevp->s.ptr = p->s.ptr;
+ a10:	8b 0a                	mov    (%edx),%ecx
+ a12:	89 08                	mov    %ecx,(%eax)
+ a14:	eb b1                	jmp    9c7 <malloc+0xb7>
diff -ruN xv6-public/thread.c copy-xv6/thread.c
--- xv6-public/thread.c	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/thread.c	2022-09-05 23:04:01.556546426 +0530
@@ -0,0 +1,138 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "x86.h"
+// #include "proc.c"
+struct balance
+{
+  char name[32];
+  int amount;
+};
+
+
+struct thread_spinlock
+{
+  uint locked; // Is the lock held?
+
+  // For debugging:
+  char *name; // Name of lock.
+};
+
+struct mutex_lock
+{
+  char* name;
+  uint locked;
+};
+
+volatile int total_balance = 0;
+struct thread_spinlock lock;
+struct mutex_lock m_lock;
+
+volatile unsigned int delay(unsigned int d)
+{
+  unsigned int i;
+  for (i = 0; i < d; i++)
+  {
+    __asm volatile("nop" ::
+                       :);
+  }
+
+  return i;
+}
+
+void thread_initlock(struct thread_spinlock *lk, char *name)
+{
+  lk->name = name;
+  lk->locked = 0;
+}
+void mutex_initlock(struct mutex_lock *lk,char* name)
+{
+  lk->name=name;
+  lk->locked = 0;
+}
+
+void thread_spin_lock(struct thread_spinlock *lk)
+{
+
+  // The xchg is atomic.
+  while (xchg(&lk->locked, 1) != 0)
+    ;
+  __sync_synchronize();
+}
+void mutex_lock(struct mutex_lock *lk)
+{
+  while (xchg(&lk->locked, 1) != 0)
+    sleep(1);
+  __sync_synchronize();
+}
+
+void thread_spin_unlock(struct thread_spinlock *lk)
+{
+
+  __sync_synchronize();
+
+  asm volatile("movl $0, %0"
+               : "+m"(lk->locked)
+               :);
+}
+void mutex_unlock(struct mutex_lock *lk)
+{
+  __sync_synchronize();
+
+  asm volatile("movl $0, %0"
+               : "+m"(lk->locked)
+               :);
+}
+
+void do_work(void *arg)
+{
+  int i;
+  int old;
+
+  struct balance *b = (struct balance *)arg;
+  printf(1, "Starting do_work: s:%s\n", b->name);
+
+  for (i = 0; i < b->amount; i++)
+  {
+    // thread_spin_lock(&lock);
+     mutex_lock(&m_lock);
+    old = total_balance;
+    delay(100000);
+    total_balance = old + 1;
+     mutex_unlock(&m_lock);
+    // thread_spin_unlock(&lock);
+  }
+
+  printf(1, "Done s:%s\n", b->name);
+
+  thread_exit();
+  return;
+}
+
+int main(int argc, char *argv[])
+{
+
+  struct balance b1 = {"b1", 3200};
+  struct balance b2 = {"b2", 2800};
+
+  void *s1, *s2;
+  int t1, t2, r1, r2;
+
+  s1 = malloc(4096);
+  s2 = malloc(4096);
+
+  // Initialize thread_spin_lock
+  // thread_initlock(&lock,"do work");
+  mutex_initlock(&m_lock,"do work");
+
+  t1 = thread_create(do_work, (void *)&b1, s1);
+  t2 = thread_create(do_work, (void *)&b2, s2);
+
+  r1 = thread_join();
+  r2 = thread_join();
+
+  printf(1, "Threads finished: (%d):%d, (%d):%d, shared balance:%d\n",
+         t1, r1, t2, r2, total_balance);
+
+  exit();
+}
diff -ruN xv6-public/thread.d copy-xv6/thread.d
--- xv6-public/thread.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/thread.d	2022-09-05 23:26:12.620781078 +0530
@@ -0,0 +1 @@
+thread.o: thread.c /usr/include/stdc-predef.h types.h stat.h user.h x86.h
Binary files xv6-public/thread.o and copy-xv6/thread.o differ
diff -ruN xv6-public/thread.sym copy-xv6/thread.sym
--- xv6-public/thread.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/thread.sym	2022-09-05 23:26:12.636781079 +0530
@@ -0,0 +1,72 @@
+00000000 .text
+00000a18 .rodata
+00000a98 .eh_frame
+00000e48 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 thread.c
+00000000 ulib.c
+00000000 printf.c
+00000600 printint
+00000a84 digits.1097
+00000000 umalloc.c
+00000e4c freep
+00000e50 base
+000002d0 strcpy
+000006b0 printf
+000005eb thread_exit
+00000500 memmove
+0000057b mknod
+00000e58 lock
+000003f0 gets
+000005b3 getpid
+00000910 malloc
+000005c3 sleep
+00000290 thread_spin_unlock
+00000543 pipe
+00000553 write
+00000180 thread_spin_lock
+0000058b fstat
+00000563 kill
+000005a3 chdir
+0000056b exec
+0000053b wait
+0000054b read
+000001a0 mutex_lock
+00000583 unlink
+0000052b fork
+000005bb sbrk
+000005cb uptime
+00000e48 __bss_start
+000001f0 do_work
+00000390 memset
+00000000 main
+00000e48 total_balance
+00000160 mutex_initlock
+00000e60 m_lock
+00000300 strcmp
+000005ab dup
+00000120 delay
+00000140 thread_initlock
+000002b0 mutex_unlock
+00000470 stat
+00000e48 _edata
+00000e68 _end
+00000593 link
+00000533 exit
+000004c0 atoi
+000005d3 draw
+00000350 strlen
+00000573 open
+000003b0 strchr
+000005db thread_create
+0000059b mkdir
+0000055b close
+000005e3 thread_join
+00000880 free
Binary files xv6-public/trapasm.o and copy-xv6/trapasm.o differ
diff -ruN xv6-public/trap.d copy-xv6/trap.d
--- xv6-public/trap.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/trap.d	2022-09-05 23:26:13.708781053 +0530
@@ -0,0 +1,2 @@
+trap.o: trap.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h proc.h x86.h traps.h spinlock.h
Binary files xv6-public/trap.o and copy-xv6/trap.o differ
diff -ruN xv6-public/uart.d copy-xv6/uart.d
--- xv6-public/uart.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/uart.d	2022-09-05 23:26:13.736781052 +0530
@@ -0,0 +1,2 @@
+uart.o: uart.c /usr/include/stdc-predef.h types.h defs.h param.h traps.h \
+ spinlock.h sleeplock.h fs.h file.h mmu.h proc.h x86.h
Binary files xv6-public/uart.o and copy-xv6/uart.o differ
diff -ruN xv6-public/ulib.d copy-xv6/ulib.d
--- xv6-public/ulib.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/ulib.d	2022-09-05 23:26:11.716781094 +0530
@@ -0,0 +1,2 @@
+ulib.o: ulib.c /usr/include/stdc-predef.h types.h stat.h fcntl.h user.h \
+ x86.h
Binary files xv6-public/ulib.o and copy-xv6/ulib.o differ
diff -ruN xv6-public/umalloc.d copy-xv6/umalloc.d
--- xv6-public/umalloc.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/umalloc.d	2022-09-05 23:26:11.784781094 +0530
@@ -0,0 +1,2 @@
+umalloc.o: umalloc.c /usr/include/stdc-predef.h types.h stat.h user.h \
+ param.h
Binary files xv6-public/umalloc.o and copy-xv6/umalloc.o differ
diff -ruN xv6-public/user.h copy-xv6/user.h
--- xv6-public/user.h	2022-09-05 23:23:48.536715198 +0530
+++ copy-xv6/user.h	2022-09-05 21:40:37.989063899 +0530
@@ -23,7 +23,11 @@
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int draw(void*, uint);
 
+int thread_create(void(*)(void*), void*, void*);
+int thread_join(void);
+void thread_exit(void);
 // ulib.c
 int stat(const char*, struct stat*);
 char* strcpy(char*, const char*);
Binary files xv6-public/_usertests and copy-xv6/_usertests differ
diff -ruN xv6-public/usertests.asm copy-xv6/usertests.asm
--- xv6-public/usertests.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/usertests.asm	2022-09-05 23:26:12.512781080 +0530
@@ -0,0 +1,6713 @@
+
+_usertests:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+  return randstate;
+}
+
+int
+main(int argc, char *argv[])
+{
+       0:	f3 0f 1e fb          	endbr32 
+       4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+       8:	83 e4 f0             	and    $0xfffffff0,%esp
+       b:	ff 71 fc             	pushl  -0x4(%ecx)
+       e:	55                   	push   %ebp
+       f:	89 e5                	mov    %esp,%ebp
+      11:	51                   	push   %ecx
+      12:	83 ec 0c             	sub    $0xc,%esp
+  printf(1, "usertests starting\n");
+      15:	68 56 4e 00 00       	push   $0x4e56
+      1a:	6a 01                	push   $0x1
+      1c:	e8 df 3a 00 00       	call   3b00 <printf>
+
+  if(open("usertests.ran", 0) >= 0){
+      21:	59                   	pop    %ecx
+      22:	58                   	pop    %eax
+      23:	6a 00                	push   $0x0
+      25:	68 6a 4e 00 00       	push   $0x4e6a
+      2a:	e8 94 39 00 00       	call   39c3 <open>
+      2f:	83 c4 10             	add    $0x10,%esp
+      32:	85 c0                	test   %eax,%eax
+      34:	78 13                	js     49 <main+0x49>
+    printf(1, "already ran user tests -- rebuild fs.img\n");
+      36:	52                   	push   %edx
+      37:	52                   	push   %edx
+      38:	68 d4 55 00 00       	push   $0x55d4
+      3d:	6a 01                	push   $0x1
+      3f:	e8 bc 3a 00 00       	call   3b00 <printf>
+    exit();
+      44:	e8 3a 39 00 00       	call   3983 <exit>
+  }
+  close(open("usertests.ran", O_CREATE));
+      49:	50                   	push   %eax
+      4a:	50                   	push   %eax
+      4b:	68 00 02 00 00       	push   $0x200
+      50:	68 6a 4e 00 00       	push   $0x4e6a
+      55:	e8 69 39 00 00       	call   39c3 <open>
+      5a:	89 04 24             	mov    %eax,(%esp)
+      5d:	e8 49 39 00 00       	call   39ab <close>
+
+  argptest();
+      62:	e8 29 36 00 00       	call   3690 <argptest>
+  createdelete();
+      67:	e8 04 12 00 00       	call   1270 <createdelete>
+  linkunlink();
+      6c:	e8 df 1a 00 00       	call   1b50 <linkunlink>
+  concreate();
+      71:	e8 da 17 00 00       	call   1850 <concreate>
+  fourfiles();
+      76:	e8 f5 0f 00 00       	call   1070 <fourfiles>
+  sharedfd();
+      7b:	e8 30 0e 00 00       	call   eb0 <sharedfd>
+
+  bigargtest();
+      80:	e8 ab 32 00 00       	call   3330 <bigargtest>
+  bigwrite();
+      85:	e8 06 24 00 00       	call   2490 <bigwrite>
+  bigargtest();
+      8a:	e8 a1 32 00 00       	call   3330 <bigargtest>
+  bsstest();
+      8f:	e8 2c 32 00 00       	call   32c0 <bsstest>
+  sbrktest();
+      94:	e8 37 2d 00 00       	call   2dd0 <sbrktest>
+  validatetest();
+      99:	e8 62 31 00 00       	call   3200 <validatetest>
+
+  opentest();
+      9e:	e8 6d 03 00 00       	call   410 <opentest>
+  writetest();
+      a3:	e8 08 04 00 00       	call   4b0 <writetest>
+  writetest1();
+      a8:	e8 e3 05 00 00       	call   690 <writetest1>
+  createtest();
+      ad:	e8 ae 07 00 00       	call   860 <createtest>
+
+  openiputtest();
+      b2:	e8 59 02 00 00       	call   310 <openiputtest>
+  exitiputtest();
+      b7:	e8 54 01 00 00       	call   210 <exitiputtest>
+  iputtest();
+      bc:	e8 5f 00 00 00       	call   120 <iputtest>
+
+  mem();
+      c1:	e8 1a 0d 00 00       	call   de0 <mem>
+  pipe1();
+      c6:	e8 95 09 00 00       	call   a60 <pipe1>
+  preempt();
+      cb:	e8 30 0b 00 00       	call   c00 <preempt>
+  exitwait();
+      d0:	e8 8b 0c 00 00       	call   d60 <exitwait>
+
+  rmdot();
+      d5:	e8 a6 27 00 00       	call   2880 <rmdot>
+  fourteen();
+      da:	e8 61 26 00 00       	call   2740 <fourteen>
+  bigfile();
+      df:	e8 8c 24 00 00       	call   2570 <bigfile>
+  subdir();
+      e4:	e8 b7 1c 00 00       	call   1da0 <subdir>
+  linktest();
+      e9:	e8 42 15 00 00       	call   1630 <linktest>
+  unlinkread();
+      ee:	e8 ad 13 00 00       	call   14a0 <unlinkread>
+  dirfile();
+      f3:	e8 08 29 00 00       	call   2a00 <dirfile>
+  iref();
+      f8:	e8 03 2b 00 00       	call   2c00 <iref>
+  forktest();
+      fd:	e8 1e 2c 00 00       	call   2d20 <forktest>
+  bigdir(); // slow
+     102:	e8 59 1b 00 00       	call   1c60 <bigdir>
+
+  uio();
+     107:	e8 04 35 00 00       	call   3610 <uio>
+
+  exectest();
+     10c:	e8 ff 08 00 00       	call   a10 <exectest>
+
+  exit();
+     111:	e8 6d 38 00 00       	call   3983 <exit>
+     116:	66 90                	xchg   %ax,%ax
+     118:	66 90                	xchg   %ax,%ax
+     11a:	66 90                	xchg   %ax,%ax
+     11c:	66 90                	xchg   %ax,%ax
+     11e:	66 90                	xchg   %ax,%ax
+
+00000120 <iputtest>:
+{
+     120:	f3 0f 1e fb          	endbr32 
+     124:	55                   	push   %ebp
+     125:	89 e5                	mov    %esp,%ebp
+     127:	83 ec 10             	sub    $0x10,%esp
+  printf(stdout, "iput test\n");
+     12a:	68 fc 3e 00 00       	push   $0x3efc
+     12f:	ff 35 00 5f 00 00    	pushl  0x5f00
+     135:	e8 c6 39 00 00       	call   3b00 <printf>
+  if(mkdir("iputdir") < 0){
+     13a:	c7 04 24 8f 3e 00 00 	movl   $0x3e8f,(%esp)
+     141:	e8 a5 38 00 00       	call   39eb <mkdir>
+     146:	83 c4 10             	add    $0x10,%esp
+     149:	85 c0                	test   %eax,%eax
+     14b:	78 58                	js     1a5 <iputtest+0x85>
+  if(chdir("iputdir") < 0){
+     14d:	83 ec 0c             	sub    $0xc,%esp
+     150:	68 8f 3e 00 00       	push   $0x3e8f
+     155:	e8 99 38 00 00       	call   39f3 <chdir>
+     15a:	83 c4 10             	add    $0x10,%esp
+     15d:	85 c0                	test   %eax,%eax
+     15f:	0f 88 85 00 00 00    	js     1ea <iputtest+0xca>
+  if(unlink("../iputdir") < 0){
+     165:	83 ec 0c             	sub    $0xc,%esp
+     168:	68 8c 3e 00 00       	push   $0x3e8c
+     16d:	e8 61 38 00 00       	call   39d3 <unlink>
+     172:	83 c4 10             	add    $0x10,%esp
+     175:	85 c0                	test   %eax,%eax
+     177:	78 5a                	js     1d3 <iputtest+0xb3>
+  if(chdir("/") < 0){
+     179:	83 ec 0c             	sub    $0xc,%esp
+     17c:	68 b1 3e 00 00       	push   $0x3eb1
+     181:	e8 6d 38 00 00       	call   39f3 <chdir>
+     186:	83 c4 10             	add    $0x10,%esp
+     189:	85 c0                	test   %eax,%eax
+     18b:	78 2f                	js     1bc <iputtest+0x9c>
+  printf(stdout, "iput test ok\n");
+     18d:	83 ec 08             	sub    $0x8,%esp
+     190:	68 34 3f 00 00       	push   $0x3f34
+     195:	ff 35 00 5f 00 00    	pushl  0x5f00
+     19b:	e8 60 39 00 00       	call   3b00 <printf>
+}
+     1a0:	83 c4 10             	add    $0x10,%esp
+     1a3:	c9                   	leave  
+     1a4:	c3                   	ret    
+    printf(stdout, "mkdir failed\n");
+     1a5:	50                   	push   %eax
+     1a6:	50                   	push   %eax
+     1a7:	68 68 3e 00 00       	push   $0x3e68
+     1ac:	ff 35 00 5f 00 00    	pushl  0x5f00
+     1b2:	e8 49 39 00 00       	call   3b00 <printf>
+    exit();
+     1b7:	e8 c7 37 00 00       	call   3983 <exit>
+    printf(stdout, "chdir / failed\n");
+     1bc:	50                   	push   %eax
+     1bd:	50                   	push   %eax
+     1be:	68 b3 3e 00 00       	push   $0x3eb3
+     1c3:	ff 35 00 5f 00 00    	pushl  0x5f00
+     1c9:	e8 32 39 00 00       	call   3b00 <printf>
+    exit();
+     1ce:	e8 b0 37 00 00       	call   3983 <exit>
+    printf(stdout, "unlink ../iputdir failed\n");
+     1d3:	52                   	push   %edx
+     1d4:	52                   	push   %edx
+     1d5:	68 97 3e 00 00       	push   $0x3e97
+     1da:	ff 35 00 5f 00 00    	pushl  0x5f00
+     1e0:	e8 1b 39 00 00       	call   3b00 <printf>
+    exit();
+     1e5:	e8 99 37 00 00       	call   3983 <exit>
+    printf(stdout, "chdir iputdir failed\n");
+     1ea:	51                   	push   %ecx
+     1eb:	51                   	push   %ecx
+     1ec:	68 76 3e 00 00       	push   $0x3e76
+     1f1:	ff 35 00 5f 00 00    	pushl  0x5f00
+     1f7:	e8 04 39 00 00       	call   3b00 <printf>
+    exit();
+     1fc:	e8 82 37 00 00       	call   3983 <exit>
+     201:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     208:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     20f:	90                   	nop
+
+00000210 <exitiputtest>:
+{
+     210:	f3 0f 1e fb          	endbr32 
+     214:	55                   	push   %ebp
+     215:	89 e5                	mov    %esp,%ebp
+     217:	83 ec 10             	sub    $0x10,%esp
+  printf(stdout, "exitiput test\n");
+     21a:	68 c3 3e 00 00       	push   $0x3ec3
+     21f:	ff 35 00 5f 00 00    	pushl  0x5f00
+     225:	e8 d6 38 00 00       	call   3b00 <printf>
+  pid = fork();
+     22a:	e8 4c 37 00 00       	call   397b <fork>
+  if(pid < 0){
+     22f:	83 c4 10             	add    $0x10,%esp
+     232:	85 c0                	test   %eax,%eax
+     234:	0f 88 86 00 00 00    	js     2c0 <exitiputtest+0xb0>
+  if(pid == 0){
+     23a:	75 4c                	jne    288 <exitiputtest+0x78>
+    if(mkdir("iputdir") < 0){
+     23c:	83 ec 0c             	sub    $0xc,%esp
+     23f:	68 8f 3e 00 00       	push   $0x3e8f
+     244:	e8 a2 37 00 00       	call   39eb <mkdir>
+     249:	83 c4 10             	add    $0x10,%esp
+     24c:	85 c0                	test   %eax,%eax
+     24e:	0f 88 83 00 00 00    	js     2d7 <exitiputtest+0xc7>
+    if(chdir("iputdir") < 0){
+     254:	83 ec 0c             	sub    $0xc,%esp
+     257:	68 8f 3e 00 00       	push   $0x3e8f
+     25c:	e8 92 37 00 00       	call   39f3 <chdir>
+     261:	83 c4 10             	add    $0x10,%esp
+     264:	85 c0                	test   %eax,%eax
+     266:	0f 88 82 00 00 00    	js     2ee <exitiputtest+0xde>
+    if(unlink("../iputdir") < 0){
+     26c:	83 ec 0c             	sub    $0xc,%esp
+     26f:	68 8c 3e 00 00       	push   $0x3e8c
+     274:	e8 5a 37 00 00       	call   39d3 <unlink>
+     279:	83 c4 10             	add    $0x10,%esp
+     27c:	85 c0                	test   %eax,%eax
+     27e:	78 28                	js     2a8 <exitiputtest+0x98>
+    exit();
+     280:	e8 fe 36 00 00       	call   3983 <exit>
+     285:	8d 76 00             	lea    0x0(%esi),%esi
+  wait();
+     288:	e8 fe 36 00 00       	call   398b <wait>
+  printf(stdout, "exitiput test ok\n");
+     28d:	83 ec 08             	sub    $0x8,%esp
+     290:	68 e6 3e 00 00       	push   $0x3ee6
+     295:	ff 35 00 5f 00 00    	pushl  0x5f00
+     29b:	e8 60 38 00 00       	call   3b00 <printf>
+}
+     2a0:	83 c4 10             	add    $0x10,%esp
+     2a3:	c9                   	leave  
+     2a4:	c3                   	ret    
+     2a5:	8d 76 00             	lea    0x0(%esi),%esi
+      printf(stdout, "unlink ../iputdir failed\n");
+     2a8:	83 ec 08             	sub    $0x8,%esp
+     2ab:	68 97 3e 00 00       	push   $0x3e97
+     2b0:	ff 35 00 5f 00 00    	pushl  0x5f00
+     2b6:	e8 45 38 00 00       	call   3b00 <printf>
+      exit();
+     2bb:	e8 c3 36 00 00       	call   3983 <exit>
+    printf(stdout, "fork failed\n");
+     2c0:	51                   	push   %ecx
+     2c1:	51                   	push   %ecx
+     2c2:	68 a9 4d 00 00       	push   $0x4da9
+     2c7:	ff 35 00 5f 00 00    	pushl  0x5f00
+     2cd:	e8 2e 38 00 00       	call   3b00 <printf>
+    exit();
+     2d2:	e8 ac 36 00 00       	call   3983 <exit>
+      printf(stdout, "mkdir failed\n");
+     2d7:	52                   	push   %edx
+     2d8:	52                   	push   %edx
+     2d9:	68 68 3e 00 00       	push   $0x3e68
+     2de:	ff 35 00 5f 00 00    	pushl  0x5f00
+     2e4:	e8 17 38 00 00       	call   3b00 <printf>
+      exit();
+     2e9:	e8 95 36 00 00       	call   3983 <exit>
+      printf(stdout, "child chdir failed\n");
+     2ee:	50                   	push   %eax
+     2ef:	50                   	push   %eax
+     2f0:	68 d2 3e 00 00       	push   $0x3ed2
+     2f5:	ff 35 00 5f 00 00    	pushl  0x5f00
+     2fb:	e8 00 38 00 00       	call   3b00 <printf>
+      exit();
+     300:	e8 7e 36 00 00       	call   3983 <exit>
+     305:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     30c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000310 <openiputtest>:
+{
+     310:	f3 0f 1e fb          	endbr32 
+     314:	55                   	push   %ebp
+     315:	89 e5                	mov    %esp,%ebp
+     317:	83 ec 10             	sub    $0x10,%esp
+  printf(stdout, "openiput test\n");
+     31a:	68 f8 3e 00 00       	push   $0x3ef8
+     31f:	ff 35 00 5f 00 00    	pushl  0x5f00
+     325:	e8 d6 37 00 00       	call   3b00 <printf>
+  if(mkdir("oidir") < 0){
+     32a:	c7 04 24 07 3f 00 00 	movl   $0x3f07,(%esp)
+     331:	e8 b5 36 00 00       	call   39eb <mkdir>
+     336:	83 c4 10             	add    $0x10,%esp
+     339:	85 c0                	test   %eax,%eax
+     33b:	0f 88 9b 00 00 00    	js     3dc <openiputtest+0xcc>
+  pid = fork();
+     341:	e8 35 36 00 00       	call   397b <fork>
+  if(pid < 0){
+     346:	85 c0                	test   %eax,%eax
+     348:	78 7b                	js     3c5 <openiputtest+0xb5>
+  if(pid == 0){
+     34a:	75 34                	jne    380 <openiputtest+0x70>
+    int fd = open("oidir", O_RDWR);
+     34c:	83 ec 08             	sub    $0x8,%esp
+     34f:	6a 02                	push   $0x2
+     351:	68 07 3f 00 00       	push   $0x3f07
+     356:	e8 68 36 00 00       	call   39c3 <open>
+    if(fd >= 0){
+     35b:	83 c4 10             	add    $0x10,%esp
+     35e:	85 c0                	test   %eax,%eax
+     360:	78 5e                	js     3c0 <openiputtest+0xb0>
+      printf(stdout, "open directory for write succeeded\n");
+     362:	83 ec 08             	sub    $0x8,%esp
+     365:	68 8c 4e 00 00       	push   $0x4e8c
+     36a:	ff 35 00 5f 00 00    	pushl  0x5f00
+     370:	e8 8b 37 00 00       	call   3b00 <printf>
+      exit();
+     375:	e8 09 36 00 00       	call   3983 <exit>
+     37a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  sleep(1);
+     380:	83 ec 0c             	sub    $0xc,%esp
+     383:	6a 01                	push   $0x1
+     385:	e8 89 36 00 00       	call   3a13 <sleep>
+  if(unlink("oidir") != 0){
+     38a:	c7 04 24 07 3f 00 00 	movl   $0x3f07,(%esp)
+     391:	e8 3d 36 00 00       	call   39d3 <unlink>
+     396:	83 c4 10             	add    $0x10,%esp
+     399:	85 c0                	test   %eax,%eax
+     39b:	75 56                	jne    3f3 <openiputtest+0xe3>
+  wait();
+     39d:	e8 e9 35 00 00       	call   398b <wait>
+  printf(stdout, "openiput test ok\n");
+     3a2:	83 ec 08             	sub    $0x8,%esp
+     3a5:	68 30 3f 00 00       	push   $0x3f30
+     3aa:	ff 35 00 5f 00 00    	pushl  0x5f00
+     3b0:	e8 4b 37 00 00       	call   3b00 <printf>
+     3b5:	83 c4 10             	add    $0x10,%esp
+}
+     3b8:	c9                   	leave  
+     3b9:	c3                   	ret    
+     3ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    exit();
+     3c0:	e8 be 35 00 00       	call   3983 <exit>
+    printf(stdout, "fork failed\n");
+     3c5:	52                   	push   %edx
+     3c6:	52                   	push   %edx
+     3c7:	68 a9 4d 00 00       	push   $0x4da9
+     3cc:	ff 35 00 5f 00 00    	pushl  0x5f00
+     3d2:	e8 29 37 00 00       	call   3b00 <printf>
+    exit();
+     3d7:	e8 a7 35 00 00       	call   3983 <exit>
+    printf(stdout, "mkdir oidir failed\n");
+     3dc:	51                   	push   %ecx
+     3dd:	51                   	push   %ecx
+     3de:	68 0d 3f 00 00       	push   $0x3f0d
+     3e3:	ff 35 00 5f 00 00    	pushl  0x5f00
+     3e9:	e8 12 37 00 00       	call   3b00 <printf>
+    exit();
+     3ee:	e8 90 35 00 00       	call   3983 <exit>
+    printf(stdout, "unlink failed\n");
+     3f3:	50                   	push   %eax
+     3f4:	50                   	push   %eax
+     3f5:	68 21 3f 00 00       	push   $0x3f21
+     3fa:	ff 35 00 5f 00 00    	pushl  0x5f00
+     400:	e8 fb 36 00 00       	call   3b00 <printf>
+    exit();
+     405:	e8 79 35 00 00       	call   3983 <exit>
+     40a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000410 <opentest>:
+{
+     410:	f3 0f 1e fb          	endbr32 
+     414:	55                   	push   %ebp
+     415:	89 e5                	mov    %esp,%ebp
+     417:	83 ec 10             	sub    $0x10,%esp
+  printf(stdout, "open test\n");
+     41a:	68 42 3f 00 00       	push   $0x3f42
+     41f:	ff 35 00 5f 00 00    	pushl  0x5f00
+     425:	e8 d6 36 00 00       	call   3b00 <printf>
+  fd = open("echo", 0);
+     42a:	58                   	pop    %eax
+     42b:	5a                   	pop    %edx
+     42c:	6a 00                	push   $0x0
+     42e:	68 4d 3f 00 00       	push   $0x3f4d
+     433:	e8 8b 35 00 00       	call   39c3 <open>
+  if(fd < 0){
+     438:	83 c4 10             	add    $0x10,%esp
+     43b:	85 c0                	test   %eax,%eax
+     43d:	78 36                	js     475 <opentest+0x65>
+  close(fd);
+     43f:	83 ec 0c             	sub    $0xc,%esp
+     442:	50                   	push   %eax
+     443:	e8 63 35 00 00       	call   39ab <close>
+  fd = open("doesnotexist", 0);
+     448:	5a                   	pop    %edx
+     449:	59                   	pop    %ecx
+     44a:	6a 00                	push   $0x0
+     44c:	68 65 3f 00 00       	push   $0x3f65
+     451:	e8 6d 35 00 00       	call   39c3 <open>
+  if(fd >= 0){
+     456:	83 c4 10             	add    $0x10,%esp
+     459:	85 c0                	test   %eax,%eax
+     45b:	79 2f                	jns    48c <opentest+0x7c>
+  printf(stdout, "open test ok\n");
+     45d:	83 ec 08             	sub    $0x8,%esp
+     460:	68 90 3f 00 00       	push   $0x3f90
+     465:	ff 35 00 5f 00 00    	pushl  0x5f00
+     46b:	e8 90 36 00 00       	call   3b00 <printf>
+}
+     470:	83 c4 10             	add    $0x10,%esp
+     473:	c9                   	leave  
+     474:	c3                   	ret    
+    printf(stdout, "open echo failed!\n");
+     475:	50                   	push   %eax
+     476:	50                   	push   %eax
+     477:	68 52 3f 00 00       	push   $0x3f52
+     47c:	ff 35 00 5f 00 00    	pushl  0x5f00
+     482:	e8 79 36 00 00       	call   3b00 <printf>
+    exit();
+     487:	e8 f7 34 00 00       	call   3983 <exit>
+    printf(stdout, "open doesnotexist succeeded!\n");
+     48c:	50                   	push   %eax
+     48d:	50                   	push   %eax
+     48e:	68 72 3f 00 00       	push   $0x3f72
+     493:	ff 35 00 5f 00 00    	pushl  0x5f00
+     499:	e8 62 36 00 00       	call   3b00 <printf>
+    exit();
+     49e:	e8 e0 34 00 00       	call   3983 <exit>
+     4a3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     4aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000004b0 <writetest>:
+{
+     4b0:	f3 0f 1e fb          	endbr32 
+     4b4:	55                   	push   %ebp
+     4b5:	89 e5                	mov    %esp,%ebp
+     4b7:	56                   	push   %esi
+     4b8:	53                   	push   %ebx
+  printf(stdout, "small file test\n");
+     4b9:	83 ec 08             	sub    $0x8,%esp
+     4bc:	68 9e 3f 00 00       	push   $0x3f9e
+     4c1:	ff 35 00 5f 00 00    	pushl  0x5f00
+     4c7:	e8 34 36 00 00       	call   3b00 <printf>
+  fd = open("small", O_CREATE|O_RDWR);
+     4cc:	58                   	pop    %eax
+     4cd:	5a                   	pop    %edx
+     4ce:	68 02 02 00 00       	push   $0x202
+     4d3:	68 af 3f 00 00       	push   $0x3faf
+     4d8:	e8 e6 34 00 00       	call   39c3 <open>
+  if(fd >= 0){
+     4dd:	83 c4 10             	add    $0x10,%esp
+     4e0:	85 c0                	test   %eax,%eax
+     4e2:	0f 88 8c 01 00 00    	js     674 <writetest+0x1c4>
+    printf(stdout, "creat small succeeded; ok\n");
+     4e8:	83 ec 08             	sub    $0x8,%esp
+     4eb:	89 c6                	mov    %eax,%esi
+  for(i = 0; i < 100; i++){
+     4ed:	31 db                	xor    %ebx,%ebx
+    printf(stdout, "creat small succeeded; ok\n");
+     4ef:	68 b5 3f 00 00       	push   $0x3fb5
+     4f4:	ff 35 00 5f 00 00    	pushl  0x5f00
+     4fa:	e8 01 36 00 00       	call   3b00 <printf>
+     4ff:	83 c4 10             	add    $0x10,%esp
+     502:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    if(write(fd, "aaaaaaaaaa", 10) != 10){
+     508:	83 ec 04             	sub    $0x4,%esp
+     50b:	6a 0a                	push   $0xa
+     50d:	68 ec 3f 00 00       	push   $0x3fec
+     512:	56                   	push   %esi
+     513:	e8 8b 34 00 00       	call   39a3 <write>
+     518:	83 c4 10             	add    $0x10,%esp
+     51b:	83 f8 0a             	cmp    $0xa,%eax
+     51e:	0f 85 d9 00 00 00    	jne    5fd <writetest+0x14d>
+    if(write(fd, "bbbbbbbbbb", 10) != 10){
+     524:	83 ec 04             	sub    $0x4,%esp
+     527:	6a 0a                	push   $0xa
+     529:	68 f7 3f 00 00       	push   $0x3ff7
+     52e:	56                   	push   %esi
+     52f:	e8 6f 34 00 00       	call   39a3 <write>
+     534:	83 c4 10             	add    $0x10,%esp
+     537:	83 f8 0a             	cmp    $0xa,%eax
+     53a:	0f 85 d6 00 00 00    	jne    616 <writetest+0x166>
+  for(i = 0; i < 100; i++){
+     540:	83 c3 01             	add    $0x1,%ebx
+     543:	83 fb 64             	cmp    $0x64,%ebx
+     546:	75 c0                	jne    508 <writetest+0x58>
+  printf(stdout, "writes ok\n");
+     548:	83 ec 08             	sub    $0x8,%esp
+     54b:	68 02 40 00 00       	push   $0x4002
+     550:	ff 35 00 5f 00 00    	pushl  0x5f00
+     556:	e8 a5 35 00 00       	call   3b00 <printf>
+  close(fd);
+     55b:	89 34 24             	mov    %esi,(%esp)
+     55e:	e8 48 34 00 00       	call   39ab <close>
+  fd = open("small", O_RDONLY);
+     563:	5b                   	pop    %ebx
+     564:	5e                   	pop    %esi
+     565:	6a 00                	push   $0x0
+     567:	68 af 3f 00 00       	push   $0x3faf
+     56c:	e8 52 34 00 00       	call   39c3 <open>
+  if(fd >= 0){
+     571:	83 c4 10             	add    $0x10,%esp
+  fd = open("small", O_RDONLY);
+     574:	89 c3                	mov    %eax,%ebx
+  if(fd >= 0){
+     576:	85 c0                	test   %eax,%eax
+     578:	0f 88 b1 00 00 00    	js     62f <writetest+0x17f>
+    printf(stdout, "open small succeeded ok\n");
+     57e:	83 ec 08             	sub    $0x8,%esp
+     581:	68 0d 40 00 00       	push   $0x400d
+     586:	ff 35 00 5f 00 00    	pushl  0x5f00
+     58c:	e8 6f 35 00 00       	call   3b00 <printf>
+  i = read(fd, buf, 2000);
+     591:	83 c4 0c             	add    $0xc,%esp
+     594:	68 d0 07 00 00       	push   $0x7d0
+     599:	68 e0 86 00 00       	push   $0x86e0
+     59e:	53                   	push   %ebx
+     59f:	e8 f7 33 00 00       	call   399b <read>
+  if(i == 2000){
+     5a4:	83 c4 10             	add    $0x10,%esp
+     5a7:	3d d0 07 00 00       	cmp    $0x7d0,%eax
+     5ac:	0f 85 94 00 00 00    	jne    646 <writetest+0x196>
+    printf(stdout, "read succeeded ok\n");
+     5b2:	83 ec 08             	sub    $0x8,%esp
+     5b5:	68 41 40 00 00       	push   $0x4041
+     5ba:	ff 35 00 5f 00 00    	pushl  0x5f00
+     5c0:	e8 3b 35 00 00       	call   3b00 <printf>
+  close(fd);
+     5c5:	89 1c 24             	mov    %ebx,(%esp)
+     5c8:	e8 de 33 00 00       	call   39ab <close>
+  if(unlink("small") < 0){
+     5cd:	c7 04 24 af 3f 00 00 	movl   $0x3faf,(%esp)
+     5d4:	e8 fa 33 00 00       	call   39d3 <unlink>
+     5d9:	83 c4 10             	add    $0x10,%esp
+     5dc:	85 c0                	test   %eax,%eax
+     5de:	78 7d                	js     65d <writetest+0x1ad>
+  printf(stdout, "small file test ok\n");
+     5e0:	83 ec 08             	sub    $0x8,%esp
+     5e3:	68 69 40 00 00       	push   $0x4069
+     5e8:	ff 35 00 5f 00 00    	pushl  0x5f00
+     5ee:	e8 0d 35 00 00       	call   3b00 <printf>
+}
+     5f3:	83 c4 10             	add    $0x10,%esp
+     5f6:	8d 65 f8             	lea    -0x8(%ebp),%esp
+     5f9:	5b                   	pop    %ebx
+     5fa:	5e                   	pop    %esi
+     5fb:	5d                   	pop    %ebp
+     5fc:	c3                   	ret    
+      printf(stdout, "error: write aa %d new file failed\n", i);
+     5fd:	83 ec 04             	sub    $0x4,%esp
+     600:	53                   	push   %ebx
+     601:	68 b0 4e 00 00       	push   $0x4eb0
+     606:	ff 35 00 5f 00 00    	pushl  0x5f00
+     60c:	e8 ef 34 00 00       	call   3b00 <printf>
+      exit();
+     611:	e8 6d 33 00 00       	call   3983 <exit>
+      printf(stdout, "error: write bb %d new file failed\n", i);
+     616:	83 ec 04             	sub    $0x4,%esp
+     619:	53                   	push   %ebx
+     61a:	68 d4 4e 00 00       	push   $0x4ed4
+     61f:	ff 35 00 5f 00 00    	pushl  0x5f00
+     625:	e8 d6 34 00 00       	call   3b00 <printf>
+      exit();
+     62a:	e8 54 33 00 00       	call   3983 <exit>
+    printf(stdout, "error: open small failed!\n");
+     62f:	51                   	push   %ecx
+     630:	51                   	push   %ecx
+     631:	68 26 40 00 00       	push   $0x4026
+     636:	ff 35 00 5f 00 00    	pushl  0x5f00
+     63c:	e8 bf 34 00 00       	call   3b00 <printf>
+    exit();
+     641:	e8 3d 33 00 00       	call   3983 <exit>
+    printf(stdout, "read failed\n");
+     646:	52                   	push   %edx
+     647:	52                   	push   %edx
+     648:	68 6d 43 00 00       	push   $0x436d
+     64d:	ff 35 00 5f 00 00    	pushl  0x5f00
+     653:	e8 a8 34 00 00       	call   3b00 <printf>
+    exit();
+     658:	e8 26 33 00 00       	call   3983 <exit>
+    printf(stdout, "unlink small failed\n");
+     65d:	50                   	push   %eax
+     65e:	50                   	push   %eax
+     65f:	68 54 40 00 00       	push   $0x4054
+     664:	ff 35 00 5f 00 00    	pushl  0x5f00
+     66a:	e8 91 34 00 00       	call   3b00 <printf>
+    exit();
+     66f:	e8 0f 33 00 00       	call   3983 <exit>
+    printf(stdout, "error: creat small failed!\n");
+     674:	50                   	push   %eax
+     675:	50                   	push   %eax
+     676:	68 d0 3f 00 00       	push   $0x3fd0
+     67b:	ff 35 00 5f 00 00    	pushl  0x5f00
+     681:	e8 7a 34 00 00       	call   3b00 <printf>
+    exit();
+     686:	e8 f8 32 00 00       	call   3983 <exit>
+     68b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+     68f:	90                   	nop
+
+00000690 <writetest1>:
+{
+     690:	f3 0f 1e fb          	endbr32 
+     694:	55                   	push   %ebp
+     695:	89 e5                	mov    %esp,%ebp
+     697:	56                   	push   %esi
+     698:	53                   	push   %ebx
+  printf(stdout, "big files test\n");
+     699:	83 ec 08             	sub    $0x8,%esp
+     69c:	68 7d 40 00 00       	push   $0x407d
+     6a1:	ff 35 00 5f 00 00    	pushl  0x5f00
+     6a7:	e8 54 34 00 00       	call   3b00 <printf>
+  fd = open("big", O_CREATE|O_RDWR);
+     6ac:	58                   	pop    %eax
+     6ad:	5a                   	pop    %edx
+     6ae:	68 02 02 00 00       	push   $0x202
+     6b3:	68 f7 40 00 00       	push   $0x40f7
+     6b8:	e8 06 33 00 00       	call   39c3 <open>
+  if(fd < 0){
+     6bd:	83 c4 10             	add    $0x10,%esp
+     6c0:	85 c0                	test   %eax,%eax
+     6c2:	0f 88 5d 01 00 00    	js     825 <writetest1+0x195>
+     6c8:	89 c6                	mov    %eax,%esi
+  for(i = 0; i < MAXFILE; i++){
+     6ca:	31 db                	xor    %ebx,%ebx
+     6cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    if(write(fd, buf, 512) != 512){
+     6d0:	83 ec 04             	sub    $0x4,%esp
+    ((int*)buf)[0] = i;
+     6d3:	89 1d e0 86 00 00    	mov    %ebx,0x86e0
+    if(write(fd, buf, 512) != 512){
+     6d9:	68 00 02 00 00       	push   $0x200
+     6de:	68 e0 86 00 00       	push   $0x86e0
+     6e3:	56                   	push   %esi
+     6e4:	e8 ba 32 00 00       	call   39a3 <write>
+     6e9:	83 c4 10             	add    $0x10,%esp
+     6ec:	3d 00 02 00 00       	cmp    $0x200,%eax
+     6f1:	0f 85 b3 00 00 00    	jne    7aa <writetest1+0x11a>
+  for(i = 0; i < MAXFILE; i++){
+     6f7:	83 c3 01             	add    $0x1,%ebx
+     6fa:	81 fb 8c 00 00 00    	cmp    $0x8c,%ebx
+     700:	75 ce                	jne    6d0 <writetest1+0x40>
+  close(fd);
+     702:	83 ec 0c             	sub    $0xc,%esp
+     705:	56                   	push   %esi
+     706:	e8 a0 32 00 00       	call   39ab <close>
+  fd = open("big", O_RDONLY);
+     70b:	5b                   	pop    %ebx
+     70c:	5e                   	pop    %esi
+     70d:	6a 00                	push   $0x0
+     70f:	68 f7 40 00 00       	push   $0x40f7
+     714:	e8 aa 32 00 00       	call   39c3 <open>
+  if(fd < 0){
+     719:	83 c4 10             	add    $0x10,%esp
+  fd = open("big", O_RDONLY);
+     71c:	89 c3                	mov    %eax,%ebx
+  if(fd < 0){
+     71e:	85 c0                	test   %eax,%eax
+     720:	0f 88 e8 00 00 00    	js     80e <writetest1+0x17e>
+  n = 0;
+     726:	31 f6                	xor    %esi,%esi
+     728:	eb 1d                	jmp    747 <writetest1+0xb7>
+     72a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    } else if(i != 512){
+     730:	3d 00 02 00 00       	cmp    $0x200,%eax
+     735:	0f 85 9f 00 00 00    	jne    7da <writetest1+0x14a>
+    if(((int*)buf)[0] != n){
+     73b:	a1 e0 86 00 00       	mov    0x86e0,%eax
+     740:	39 f0                	cmp    %esi,%eax
+     742:	75 7f                	jne    7c3 <writetest1+0x133>
+    n++;
+     744:	83 c6 01             	add    $0x1,%esi
+    i = read(fd, buf, 512);
+     747:	83 ec 04             	sub    $0x4,%esp
+     74a:	68 00 02 00 00       	push   $0x200
+     74f:	68 e0 86 00 00       	push   $0x86e0
+     754:	53                   	push   %ebx
+     755:	e8 41 32 00 00       	call   399b <read>
+    if(i == 0){
+     75a:	83 c4 10             	add    $0x10,%esp
+     75d:	85 c0                	test   %eax,%eax
+     75f:	75 cf                	jne    730 <writetest1+0xa0>
+      if(n == MAXFILE - 1){
+     761:	81 fe 8b 00 00 00    	cmp    $0x8b,%esi
+     767:	0f 84 86 00 00 00    	je     7f3 <writetest1+0x163>
+  close(fd);
+     76d:	83 ec 0c             	sub    $0xc,%esp
+     770:	53                   	push   %ebx
+     771:	e8 35 32 00 00       	call   39ab <close>
+  if(unlink("big") < 0){
+     776:	c7 04 24 f7 40 00 00 	movl   $0x40f7,(%esp)
+     77d:	e8 51 32 00 00       	call   39d3 <unlink>
+     782:	83 c4 10             	add    $0x10,%esp
+     785:	85 c0                	test   %eax,%eax
+     787:	0f 88 af 00 00 00    	js     83c <writetest1+0x1ac>
+  printf(stdout, "big files ok\n");
+     78d:	83 ec 08             	sub    $0x8,%esp
+     790:	68 1e 41 00 00       	push   $0x411e
+     795:	ff 35 00 5f 00 00    	pushl  0x5f00
+     79b:	e8 60 33 00 00       	call   3b00 <printf>
+}
+     7a0:	83 c4 10             	add    $0x10,%esp
+     7a3:	8d 65 f8             	lea    -0x8(%ebp),%esp
+     7a6:	5b                   	pop    %ebx
+     7a7:	5e                   	pop    %esi
+     7a8:	5d                   	pop    %ebp
+     7a9:	c3                   	ret    
+      printf(stdout, "error: write big file failed\n", i);
+     7aa:	83 ec 04             	sub    $0x4,%esp
+     7ad:	53                   	push   %ebx
+     7ae:	68 a7 40 00 00       	push   $0x40a7
+     7b3:	ff 35 00 5f 00 00    	pushl  0x5f00
+     7b9:	e8 42 33 00 00       	call   3b00 <printf>
+      exit();
+     7be:	e8 c0 31 00 00       	call   3983 <exit>
+      printf(stdout, "read content of block %d is %d\n",
+     7c3:	50                   	push   %eax
+     7c4:	56                   	push   %esi
+     7c5:	68 f8 4e 00 00       	push   $0x4ef8
+     7ca:	ff 35 00 5f 00 00    	pushl  0x5f00
+     7d0:	e8 2b 33 00 00       	call   3b00 <printf>
+      exit();
+     7d5:	e8 a9 31 00 00       	call   3983 <exit>
+      printf(stdout, "read failed %d\n", i);
+     7da:	83 ec 04             	sub    $0x4,%esp
+     7dd:	50                   	push   %eax
+     7de:	68 fb 40 00 00       	push   $0x40fb
+     7e3:	ff 35 00 5f 00 00    	pushl  0x5f00
+     7e9:	e8 12 33 00 00       	call   3b00 <printf>
+      exit();
+     7ee:	e8 90 31 00 00       	call   3983 <exit>
+        printf(stdout, "read only %d blocks from big", n);
+     7f3:	52                   	push   %edx
+     7f4:	68 8b 00 00 00       	push   $0x8b
+     7f9:	68 de 40 00 00       	push   $0x40de
+     7fe:	ff 35 00 5f 00 00    	pushl  0x5f00
+     804:	e8 f7 32 00 00       	call   3b00 <printf>
+        exit();
+     809:	e8 75 31 00 00       	call   3983 <exit>
+    printf(stdout, "error: open big failed!\n");
+     80e:	51                   	push   %ecx
+     80f:	51                   	push   %ecx
+     810:	68 c5 40 00 00       	push   $0x40c5
+     815:	ff 35 00 5f 00 00    	pushl  0x5f00
+     81b:	e8 e0 32 00 00       	call   3b00 <printf>
+    exit();
+     820:	e8 5e 31 00 00       	call   3983 <exit>
+    printf(stdout, "error: creat big failed!\n");
+     825:	50                   	push   %eax
+     826:	50                   	push   %eax
+     827:	68 8d 40 00 00       	push   $0x408d
+     82c:	ff 35 00 5f 00 00    	pushl  0x5f00
+     832:	e8 c9 32 00 00       	call   3b00 <printf>
+    exit();
+     837:	e8 47 31 00 00       	call   3983 <exit>
+    printf(stdout, "unlink big failed\n");
+     83c:	50                   	push   %eax
+     83d:	50                   	push   %eax
+     83e:	68 0b 41 00 00       	push   $0x410b
+     843:	ff 35 00 5f 00 00    	pushl  0x5f00
+     849:	e8 b2 32 00 00       	call   3b00 <printf>
+    exit();
+     84e:	e8 30 31 00 00       	call   3983 <exit>
+     853:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     85a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000860 <createtest>:
+{
+     860:	f3 0f 1e fb          	endbr32 
+     864:	55                   	push   %ebp
+     865:	89 e5                	mov    %esp,%ebp
+     867:	53                   	push   %ebx
+  name[2] = '\0';
+     868:	bb 30 00 00 00       	mov    $0x30,%ebx
+{
+     86d:	83 ec 0c             	sub    $0xc,%esp
+  printf(stdout, "many creates, followed by unlink test\n");
+     870:	68 18 4f 00 00       	push   $0x4f18
+     875:	ff 35 00 5f 00 00    	pushl  0x5f00
+     87b:	e8 80 32 00 00       	call   3b00 <printf>
+  name[0] = 'a';
+     880:	c6 05 e0 a6 00 00 61 	movb   $0x61,0xa6e0
+  name[2] = '\0';
+     887:	83 c4 10             	add    $0x10,%esp
+     88a:	c6 05 e2 a6 00 00 00 	movb   $0x0,0xa6e2
+  for(i = 0; i < 52; i++){
+     891:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    fd = open(name, O_CREATE|O_RDWR);
+     898:	83 ec 08             	sub    $0x8,%esp
+    name[1] = '0' + i;
+     89b:	88 1d e1 a6 00 00    	mov    %bl,0xa6e1
+    fd = open(name, O_CREATE|O_RDWR);
+     8a1:	83 c3 01             	add    $0x1,%ebx
+     8a4:	68 02 02 00 00       	push   $0x202
+     8a9:	68 e0 a6 00 00       	push   $0xa6e0
+     8ae:	e8 10 31 00 00       	call   39c3 <open>
+    close(fd);
+     8b3:	89 04 24             	mov    %eax,(%esp)
+     8b6:	e8 f0 30 00 00       	call   39ab <close>
+  for(i = 0; i < 52; i++){
+     8bb:	83 c4 10             	add    $0x10,%esp
+     8be:	80 fb 64             	cmp    $0x64,%bl
+     8c1:	75 d5                	jne    898 <createtest+0x38>
+  name[0] = 'a';
+     8c3:	c6 05 e0 a6 00 00 61 	movb   $0x61,0xa6e0
+  name[2] = '\0';
+     8ca:	bb 30 00 00 00       	mov    $0x30,%ebx
+     8cf:	c6 05 e2 a6 00 00 00 	movb   $0x0,0xa6e2
+  for(i = 0; i < 52; i++){
+     8d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     8dd:	8d 76 00             	lea    0x0(%esi),%esi
+    unlink(name);
+     8e0:	83 ec 0c             	sub    $0xc,%esp
+    name[1] = '0' + i;
+     8e3:	88 1d e1 a6 00 00    	mov    %bl,0xa6e1
+    unlink(name);
+     8e9:	83 c3 01             	add    $0x1,%ebx
+     8ec:	68 e0 a6 00 00       	push   $0xa6e0
+     8f1:	e8 dd 30 00 00       	call   39d3 <unlink>
+  for(i = 0; i < 52; i++){
+     8f6:	83 c4 10             	add    $0x10,%esp
+     8f9:	80 fb 64             	cmp    $0x64,%bl
+     8fc:	75 e2                	jne    8e0 <createtest+0x80>
+  printf(stdout, "many creates, followed by unlink; ok\n");
+     8fe:	83 ec 08             	sub    $0x8,%esp
+     901:	68 40 4f 00 00       	push   $0x4f40
+     906:	ff 35 00 5f 00 00    	pushl  0x5f00
+     90c:	e8 ef 31 00 00       	call   3b00 <printf>
+}
+     911:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+     914:	83 c4 10             	add    $0x10,%esp
+     917:	c9                   	leave  
+     918:	c3                   	ret    
+     919:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00000920 <dirtest>:
+{
+     920:	f3 0f 1e fb          	endbr32 
+     924:	55                   	push   %ebp
+     925:	89 e5                	mov    %esp,%ebp
+     927:	83 ec 10             	sub    $0x10,%esp
+  printf(stdout, "mkdir test\n");
+     92a:	68 2c 41 00 00       	push   $0x412c
+     92f:	ff 35 00 5f 00 00    	pushl  0x5f00
+     935:	e8 c6 31 00 00       	call   3b00 <printf>
+  if(mkdir("dir0") < 0){
+     93a:	c7 04 24 38 41 00 00 	movl   $0x4138,(%esp)
+     941:	e8 a5 30 00 00       	call   39eb <mkdir>
+     946:	83 c4 10             	add    $0x10,%esp
+     949:	85 c0                	test   %eax,%eax
+     94b:	78 58                	js     9a5 <dirtest+0x85>
+  if(chdir("dir0") < 0){
+     94d:	83 ec 0c             	sub    $0xc,%esp
+     950:	68 38 41 00 00       	push   $0x4138
+     955:	e8 99 30 00 00       	call   39f3 <chdir>
+     95a:	83 c4 10             	add    $0x10,%esp
+     95d:	85 c0                	test   %eax,%eax
+     95f:	0f 88 85 00 00 00    	js     9ea <dirtest+0xca>
+  if(chdir("..") < 0){
+     965:	83 ec 0c             	sub    $0xc,%esp
+     968:	68 dd 46 00 00       	push   $0x46dd
+     96d:	e8 81 30 00 00       	call   39f3 <chdir>
+     972:	83 c4 10             	add    $0x10,%esp
+     975:	85 c0                	test   %eax,%eax
+     977:	78 5a                	js     9d3 <dirtest+0xb3>
+  if(unlink("dir0") < 0){
+     979:	83 ec 0c             	sub    $0xc,%esp
+     97c:	68 38 41 00 00       	push   $0x4138
+     981:	e8 4d 30 00 00       	call   39d3 <unlink>
+     986:	83 c4 10             	add    $0x10,%esp
+     989:	85 c0                	test   %eax,%eax
+     98b:	78 2f                	js     9bc <dirtest+0x9c>
+  printf(stdout, "mkdir test ok\n");
+     98d:	83 ec 08             	sub    $0x8,%esp
+     990:	68 75 41 00 00       	push   $0x4175
+     995:	ff 35 00 5f 00 00    	pushl  0x5f00
+     99b:	e8 60 31 00 00       	call   3b00 <printf>
+}
+     9a0:	83 c4 10             	add    $0x10,%esp
+     9a3:	c9                   	leave  
+     9a4:	c3                   	ret    
+    printf(stdout, "mkdir failed\n");
+     9a5:	50                   	push   %eax
+     9a6:	50                   	push   %eax
+     9a7:	68 68 3e 00 00       	push   $0x3e68
+     9ac:	ff 35 00 5f 00 00    	pushl  0x5f00
+     9b2:	e8 49 31 00 00       	call   3b00 <printf>
+    exit();
+     9b7:	e8 c7 2f 00 00       	call   3983 <exit>
+    printf(stdout, "unlink dir0 failed\n");
+     9bc:	50                   	push   %eax
+     9bd:	50                   	push   %eax
+     9be:	68 61 41 00 00       	push   $0x4161
+     9c3:	ff 35 00 5f 00 00    	pushl  0x5f00
+     9c9:	e8 32 31 00 00       	call   3b00 <printf>
+    exit();
+     9ce:	e8 b0 2f 00 00       	call   3983 <exit>
+    printf(stdout, "chdir .. failed\n");
+     9d3:	52                   	push   %edx
+     9d4:	52                   	push   %edx
+     9d5:	68 50 41 00 00       	push   $0x4150
+     9da:	ff 35 00 5f 00 00    	pushl  0x5f00
+     9e0:	e8 1b 31 00 00       	call   3b00 <printf>
+    exit();
+     9e5:	e8 99 2f 00 00       	call   3983 <exit>
+    printf(stdout, "chdir dir0 failed\n");
+     9ea:	51                   	push   %ecx
+     9eb:	51                   	push   %ecx
+     9ec:	68 3d 41 00 00       	push   $0x413d
+     9f1:	ff 35 00 5f 00 00    	pushl  0x5f00
+     9f7:	e8 04 31 00 00       	call   3b00 <printf>
+    exit();
+     9fc:	e8 82 2f 00 00       	call   3983 <exit>
+     a01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     a08:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     a0f:	90                   	nop
+
+00000a10 <exectest>:
+{
+     a10:	f3 0f 1e fb          	endbr32 
+     a14:	55                   	push   %ebp
+     a15:	89 e5                	mov    %esp,%ebp
+     a17:	83 ec 10             	sub    $0x10,%esp
+  printf(stdout, "exec test\n");
+     a1a:	68 84 41 00 00       	push   $0x4184
+     a1f:	ff 35 00 5f 00 00    	pushl  0x5f00
+     a25:	e8 d6 30 00 00       	call   3b00 <printf>
+  if(exec("echo", echoargv) < 0){
+     a2a:	5a                   	pop    %edx
+     a2b:	59                   	pop    %ecx
+     a2c:	68 04 5f 00 00       	push   $0x5f04
+     a31:	68 4d 3f 00 00       	push   $0x3f4d
+     a36:	e8 80 2f 00 00       	call   39bb <exec>
+     a3b:	83 c4 10             	add    $0x10,%esp
+     a3e:	85 c0                	test   %eax,%eax
+     a40:	78 02                	js     a44 <exectest+0x34>
+}
+     a42:	c9                   	leave  
+     a43:	c3                   	ret    
+    printf(stdout, "exec echo failed\n");
+     a44:	50                   	push   %eax
+     a45:	50                   	push   %eax
+     a46:	68 8f 41 00 00       	push   $0x418f
+     a4b:	ff 35 00 5f 00 00    	pushl  0x5f00
+     a51:	e8 aa 30 00 00       	call   3b00 <printf>
+    exit();
+     a56:	e8 28 2f 00 00       	call   3983 <exit>
+     a5b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+     a5f:	90                   	nop
+
+00000a60 <pipe1>:
+{
+     a60:	f3 0f 1e fb          	endbr32 
+     a64:	55                   	push   %ebp
+     a65:	89 e5                	mov    %esp,%ebp
+     a67:	57                   	push   %edi
+     a68:	56                   	push   %esi
+  if(pipe(fds) != 0){
+     a69:	8d 45 e0             	lea    -0x20(%ebp),%eax
+{
+     a6c:	53                   	push   %ebx
+     a6d:	83 ec 38             	sub    $0x38,%esp
+  if(pipe(fds) != 0){
+     a70:	50                   	push   %eax
+     a71:	e8 1d 2f 00 00       	call   3993 <pipe>
+     a76:	83 c4 10             	add    $0x10,%esp
+     a79:	85 c0                	test   %eax,%eax
+     a7b:	0f 85 38 01 00 00    	jne    bb9 <pipe1+0x159>
+  pid = fork();
+     a81:	e8 f5 2e 00 00       	call   397b <fork>
+  if(pid == 0){
+     a86:	85 c0                	test   %eax,%eax
+     a88:	0f 84 8d 00 00 00    	je     b1b <pipe1+0xbb>
+  } else if(pid > 0){
+     a8e:	0f 8e 38 01 00 00    	jle    bcc <pipe1+0x16c>
+    close(fds[1]);
+     a94:	83 ec 0c             	sub    $0xc,%esp
+     a97:	ff 75 e4             	pushl  -0x1c(%ebp)
+  seq = 0;
+     a9a:	31 db                	xor    %ebx,%ebx
+    cc = 1;
+     a9c:	be 01 00 00 00       	mov    $0x1,%esi
+    close(fds[1]);
+     aa1:	e8 05 2f 00 00       	call   39ab <close>
+    total = 0;
+     aa6:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
+    while((n = read(fds[0], buf, cc)) > 0){
+     aad:	83 c4 10             	add    $0x10,%esp
+     ab0:	83 ec 04             	sub    $0x4,%esp
+     ab3:	56                   	push   %esi
+     ab4:	68 e0 86 00 00       	push   $0x86e0
+     ab9:	ff 75 e0             	pushl  -0x20(%ebp)
+     abc:	e8 da 2e 00 00       	call   399b <read>
+     ac1:	83 c4 10             	add    $0x10,%esp
+     ac4:	89 c7                	mov    %eax,%edi
+     ac6:	85 c0                	test   %eax,%eax
+     ac8:	0f 8e a7 00 00 00    	jle    b75 <pipe1+0x115>
+     ace:	8d 0c 3b             	lea    (%ebx,%edi,1),%ecx
+      for(i = 0; i < n; i++){
+     ad1:	31 c0                	xor    %eax,%eax
+     ad3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+     ad7:	90                   	nop
+        if((buf[i] & 0xff) != (seq++ & 0xff)){
+     ad8:	89 da                	mov    %ebx,%edx
+     ada:	83 c3 01             	add    $0x1,%ebx
+     add:	38 90 e0 86 00 00    	cmp    %dl,0x86e0(%eax)
+     ae3:	75 1c                	jne    b01 <pipe1+0xa1>
+      for(i = 0; i < n; i++){
+     ae5:	83 c0 01             	add    $0x1,%eax
+     ae8:	39 d9                	cmp    %ebx,%ecx
+     aea:	75 ec                	jne    ad8 <pipe1+0x78>
+      cc = cc * 2;
+     aec:	01 f6                	add    %esi,%esi
+      total += n;
+     aee:	01 7d d4             	add    %edi,-0x2c(%ebp)
+     af1:	b8 00 20 00 00       	mov    $0x2000,%eax
+     af6:	81 fe 00 20 00 00    	cmp    $0x2000,%esi
+     afc:	0f 4f f0             	cmovg  %eax,%esi
+     aff:	eb af                	jmp    ab0 <pipe1+0x50>
+          printf(1, "pipe1 oops 2\n");
+     b01:	83 ec 08             	sub    $0x8,%esp
+     b04:	68 be 41 00 00       	push   $0x41be
+     b09:	6a 01                	push   $0x1
+     b0b:	e8 f0 2f 00 00       	call   3b00 <printf>
+          return;
+     b10:	83 c4 10             	add    $0x10,%esp
+}
+     b13:	8d 65 f4             	lea    -0xc(%ebp),%esp
+     b16:	5b                   	pop    %ebx
+     b17:	5e                   	pop    %esi
+     b18:	5f                   	pop    %edi
+     b19:	5d                   	pop    %ebp
+     b1a:	c3                   	ret    
+    close(fds[0]);
+     b1b:	83 ec 0c             	sub    $0xc,%esp
+     b1e:	ff 75 e0             	pushl  -0x20(%ebp)
+  seq = 0;
+     b21:	31 db                	xor    %ebx,%ebx
+    close(fds[0]);
+     b23:	e8 83 2e 00 00       	call   39ab <close>
+     b28:	83 c4 10             	add    $0x10,%esp
+      for(i = 0; i < 1033; i++)
+     b2b:	31 c0                	xor    %eax,%eax
+     b2d:	8d 76 00             	lea    0x0(%esi),%esi
+        buf[i] = seq++;
+     b30:	8d 14 18             	lea    (%eax,%ebx,1),%edx
+      for(i = 0; i < 1033; i++)
+     b33:	83 c0 01             	add    $0x1,%eax
+        buf[i] = seq++;
+     b36:	88 90 df 86 00 00    	mov    %dl,0x86df(%eax)
+      for(i = 0; i < 1033; i++)
+     b3c:	3d 09 04 00 00       	cmp    $0x409,%eax
+     b41:	75 ed                	jne    b30 <pipe1+0xd0>
+      if(write(fds[1], buf, 1033) != 1033){
+     b43:	83 ec 04             	sub    $0x4,%esp
+     b46:	81 c3 09 04 00 00    	add    $0x409,%ebx
+     b4c:	68 09 04 00 00       	push   $0x409
+     b51:	68 e0 86 00 00       	push   $0x86e0
+     b56:	ff 75 e4             	pushl  -0x1c(%ebp)
+     b59:	e8 45 2e 00 00       	call   39a3 <write>
+     b5e:	83 c4 10             	add    $0x10,%esp
+     b61:	3d 09 04 00 00       	cmp    $0x409,%eax
+     b66:	75 77                	jne    bdf <pipe1+0x17f>
+    for(n = 0; n < 5; n++){
+     b68:	81 fb 2d 14 00 00    	cmp    $0x142d,%ebx
+     b6e:	75 bb                	jne    b2b <pipe1+0xcb>
+    exit();
+     b70:	e8 0e 2e 00 00       	call   3983 <exit>
+    if(total != 5 * 1033){
+     b75:	81 7d d4 2d 14 00 00 	cmpl   $0x142d,-0x2c(%ebp)
+     b7c:	75 26                	jne    ba4 <pipe1+0x144>
+    close(fds[0]);
+     b7e:	83 ec 0c             	sub    $0xc,%esp
+     b81:	ff 75 e0             	pushl  -0x20(%ebp)
+     b84:	e8 22 2e 00 00       	call   39ab <close>
+    wait();
+     b89:	e8 fd 2d 00 00       	call   398b <wait>
+  printf(1, "pipe1 ok\n");
+     b8e:	5a                   	pop    %edx
+     b8f:	59                   	pop    %ecx
+     b90:	68 e3 41 00 00       	push   $0x41e3
+     b95:	6a 01                	push   $0x1
+     b97:	e8 64 2f 00 00       	call   3b00 <printf>
+     b9c:	83 c4 10             	add    $0x10,%esp
+     b9f:	e9 6f ff ff ff       	jmp    b13 <pipe1+0xb3>
+      printf(1, "pipe1 oops 3 total %d\n", total);
+     ba4:	53                   	push   %ebx
+     ba5:	ff 75 d4             	pushl  -0x2c(%ebp)
+     ba8:	68 cc 41 00 00       	push   $0x41cc
+     bad:	6a 01                	push   $0x1
+     baf:	e8 4c 2f 00 00       	call   3b00 <printf>
+      exit();
+     bb4:	e8 ca 2d 00 00       	call   3983 <exit>
+    printf(1, "pipe() failed\n");
+     bb9:	57                   	push   %edi
+     bba:	57                   	push   %edi
+     bbb:	68 a1 41 00 00       	push   $0x41a1
+     bc0:	6a 01                	push   $0x1
+     bc2:	e8 39 2f 00 00       	call   3b00 <printf>
+    exit();
+     bc7:	e8 b7 2d 00 00       	call   3983 <exit>
+    printf(1, "fork() failed\n");
+     bcc:	50                   	push   %eax
+     bcd:	50                   	push   %eax
+     bce:	68 ed 41 00 00       	push   $0x41ed
+     bd3:	6a 01                	push   $0x1
+     bd5:	e8 26 2f 00 00       	call   3b00 <printf>
+    exit();
+     bda:	e8 a4 2d 00 00       	call   3983 <exit>
+        printf(1, "pipe1 oops 1\n");
+     bdf:	56                   	push   %esi
+     be0:	56                   	push   %esi
+     be1:	68 b0 41 00 00       	push   $0x41b0
+     be6:	6a 01                	push   $0x1
+     be8:	e8 13 2f 00 00       	call   3b00 <printf>
+        exit();
+     bed:	e8 91 2d 00 00       	call   3983 <exit>
+     bf2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     bf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00000c00 <preempt>:
+{
+     c00:	f3 0f 1e fb          	endbr32 
+     c04:	55                   	push   %ebp
+     c05:	89 e5                	mov    %esp,%ebp
+     c07:	57                   	push   %edi
+     c08:	56                   	push   %esi
+     c09:	53                   	push   %ebx
+     c0a:	83 ec 24             	sub    $0x24,%esp
+  printf(1, "preempt: ");
+     c0d:	68 fc 41 00 00       	push   $0x41fc
+     c12:	6a 01                	push   $0x1
+     c14:	e8 e7 2e 00 00       	call   3b00 <printf>
+  pid1 = fork();
+     c19:	e8 5d 2d 00 00       	call   397b <fork>
+  if(pid1 == 0)
+     c1e:	83 c4 10             	add    $0x10,%esp
+     c21:	85 c0                	test   %eax,%eax
+     c23:	75 0b                	jne    c30 <preempt+0x30>
+    for(;;)
+     c25:	eb fe                	jmp    c25 <preempt+0x25>
+     c27:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     c2e:	66 90                	xchg   %ax,%ax
+     c30:	89 c7                	mov    %eax,%edi
+  pid2 = fork();
+     c32:	e8 44 2d 00 00       	call   397b <fork>
+     c37:	89 c6                	mov    %eax,%esi
+  if(pid2 == 0)
+     c39:	85 c0                	test   %eax,%eax
+     c3b:	75 03                	jne    c40 <preempt+0x40>
+    for(;;)
+     c3d:	eb fe                	jmp    c3d <preempt+0x3d>
+     c3f:	90                   	nop
+  pipe(pfds);
+     c40:	83 ec 0c             	sub    $0xc,%esp
+     c43:	8d 45 e0             	lea    -0x20(%ebp),%eax
+     c46:	50                   	push   %eax
+     c47:	e8 47 2d 00 00       	call   3993 <pipe>
+  pid3 = fork();
+     c4c:	e8 2a 2d 00 00       	call   397b <fork>
+  if(pid3 == 0){
+     c51:	83 c4 10             	add    $0x10,%esp
+  pid3 = fork();
+     c54:	89 c3                	mov    %eax,%ebx
+  if(pid3 == 0){
+     c56:	85 c0                	test   %eax,%eax
+     c58:	75 3e                	jne    c98 <preempt+0x98>
+    close(pfds[0]);
+     c5a:	83 ec 0c             	sub    $0xc,%esp
+     c5d:	ff 75 e0             	pushl  -0x20(%ebp)
+     c60:	e8 46 2d 00 00       	call   39ab <close>
+    if(write(pfds[1], "x", 1) != 1)
+     c65:	83 c4 0c             	add    $0xc,%esp
+     c68:	6a 01                	push   $0x1
+     c6a:	68 c1 47 00 00       	push   $0x47c1
+     c6f:	ff 75 e4             	pushl  -0x1c(%ebp)
+     c72:	e8 2c 2d 00 00       	call   39a3 <write>
+     c77:	83 c4 10             	add    $0x10,%esp
+     c7a:	83 f8 01             	cmp    $0x1,%eax
+     c7d:	0f 85 a4 00 00 00    	jne    d27 <preempt+0x127>
+    close(pfds[1]);
+     c83:	83 ec 0c             	sub    $0xc,%esp
+     c86:	ff 75 e4             	pushl  -0x1c(%ebp)
+     c89:	e8 1d 2d 00 00       	call   39ab <close>
+     c8e:	83 c4 10             	add    $0x10,%esp
+    for(;;)
+     c91:	eb fe                	jmp    c91 <preempt+0x91>
+     c93:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+     c97:	90                   	nop
+  close(pfds[1]);
+     c98:	83 ec 0c             	sub    $0xc,%esp
+     c9b:	ff 75 e4             	pushl  -0x1c(%ebp)
+     c9e:	e8 08 2d 00 00       	call   39ab <close>
+  if(read(pfds[0], buf, sizeof(buf)) != 1){
+     ca3:	83 c4 0c             	add    $0xc,%esp
+     ca6:	68 00 20 00 00       	push   $0x2000
+     cab:	68 e0 86 00 00       	push   $0x86e0
+     cb0:	ff 75 e0             	pushl  -0x20(%ebp)
+     cb3:	e8 e3 2c 00 00       	call   399b <read>
+     cb8:	83 c4 10             	add    $0x10,%esp
+     cbb:	83 f8 01             	cmp    $0x1,%eax
+     cbe:	75 7e                	jne    d3e <preempt+0x13e>
+  close(pfds[0]);
+     cc0:	83 ec 0c             	sub    $0xc,%esp
+     cc3:	ff 75 e0             	pushl  -0x20(%ebp)
+     cc6:	e8 e0 2c 00 00       	call   39ab <close>
+  printf(1, "kill... ");
+     ccb:	58                   	pop    %eax
+     ccc:	5a                   	pop    %edx
+     ccd:	68 2d 42 00 00       	push   $0x422d
+     cd2:	6a 01                	push   $0x1
+     cd4:	e8 27 2e 00 00       	call   3b00 <printf>
+  kill(pid1);
+     cd9:	89 3c 24             	mov    %edi,(%esp)
+     cdc:	e8 d2 2c 00 00       	call   39b3 <kill>
+  kill(pid2);
+     ce1:	89 34 24             	mov    %esi,(%esp)
+     ce4:	e8 ca 2c 00 00       	call   39b3 <kill>
+  kill(pid3);
+     ce9:	89 1c 24             	mov    %ebx,(%esp)
+     cec:	e8 c2 2c 00 00       	call   39b3 <kill>
+  printf(1, "wait... ");
+     cf1:	59                   	pop    %ecx
+     cf2:	5b                   	pop    %ebx
+     cf3:	68 36 42 00 00       	push   $0x4236
+     cf8:	6a 01                	push   $0x1
+     cfa:	e8 01 2e 00 00       	call   3b00 <printf>
+  wait();
+     cff:	e8 87 2c 00 00       	call   398b <wait>
+  wait();
+     d04:	e8 82 2c 00 00       	call   398b <wait>
+  wait();
+     d09:	e8 7d 2c 00 00       	call   398b <wait>
+  printf(1, "preempt ok\n");
+     d0e:	5e                   	pop    %esi
+     d0f:	5f                   	pop    %edi
+     d10:	68 3f 42 00 00       	push   $0x423f
+     d15:	6a 01                	push   $0x1
+     d17:	e8 e4 2d 00 00       	call   3b00 <printf>
+     d1c:	83 c4 10             	add    $0x10,%esp
+}
+     d1f:	8d 65 f4             	lea    -0xc(%ebp),%esp
+     d22:	5b                   	pop    %ebx
+     d23:	5e                   	pop    %esi
+     d24:	5f                   	pop    %edi
+     d25:	5d                   	pop    %ebp
+     d26:	c3                   	ret    
+      printf(1, "preempt write error");
+     d27:	83 ec 08             	sub    $0x8,%esp
+     d2a:	68 06 42 00 00       	push   $0x4206
+     d2f:	6a 01                	push   $0x1
+     d31:	e8 ca 2d 00 00       	call   3b00 <printf>
+     d36:	83 c4 10             	add    $0x10,%esp
+     d39:	e9 45 ff ff ff       	jmp    c83 <preempt+0x83>
+    printf(1, "preempt read error");
+     d3e:	83 ec 08             	sub    $0x8,%esp
+     d41:	68 1a 42 00 00       	push   $0x421a
+     d46:	6a 01                	push   $0x1
+     d48:	e8 b3 2d 00 00       	call   3b00 <printf>
+    return;
+     d4d:	83 c4 10             	add    $0x10,%esp
+     d50:	eb cd                	jmp    d1f <preempt+0x11f>
+     d52:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     d59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00000d60 <exitwait>:
+{
+     d60:	f3 0f 1e fb          	endbr32 
+     d64:	55                   	push   %ebp
+     d65:	89 e5                	mov    %esp,%ebp
+     d67:	56                   	push   %esi
+     d68:	be 64 00 00 00       	mov    $0x64,%esi
+     d6d:	53                   	push   %ebx
+     d6e:	eb 10                	jmp    d80 <exitwait+0x20>
+    if(pid){
+     d70:	74 68                	je     dda <exitwait+0x7a>
+      if(wait() != pid){
+     d72:	e8 14 2c 00 00       	call   398b <wait>
+     d77:	39 d8                	cmp    %ebx,%eax
+     d79:	75 2d                	jne    da8 <exitwait+0x48>
+  for(i = 0; i < 100; i++){
+     d7b:	83 ee 01             	sub    $0x1,%esi
+     d7e:	74 41                	je     dc1 <exitwait+0x61>
+    pid = fork();
+     d80:	e8 f6 2b 00 00       	call   397b <fork>
+     d85:	89 c3                	mov    %eax,%ebx
+    if(pid < 0){
+     d87:	85 c0                	test   %eax,%eax
+     d89:	79 e5                	jns    d70 <exitwait+0x10>
+      printf(1, "fork failed\n");
+     d8b:	83 ec 08             	sub    $0x8,%esp
+     d8e:	68 a9 4d 00 00       	push   $0x4da9
+     d93:	6a 01                	push   $0x1
+     d95:	e8 66 2d 00 00       	call   3b00 <printf>
+      return;
+     d9a:	83 c4 10             	add    $0x10,%esp
+}
+     d9d:	8d 65 f8             	lea    -0x8(%ebp),%esp
+     da0:	5b                   	pop    %ebx
+     da1:	5e                   	pop    %esi
+     da2:	5d                   	pop    %ebp
+     da3:	c3                   	ret    
+     da4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        printf(1, "wait wrong pid\n");
+     da8:	83 ec 08             	sub    $0x8,%esp
+     dab:	68 4b 42 00 00       	push   $0x424b
+     db0:	6a 01                	push   $0x1
+     db2:	e8 49 2d 00 00       	call   3b00 <printf>
+        return;
+     db7:	83 c4 10             	add    $0x10,%esp
+}
+     dba:	8d 65 f8             	lea    -0x8(%ebp),%esp
+     dbd:	5b                   	pop    %ebx
+     dbe:	5e                   	pop    %esi
+     dbf:	5d                   	pop    %ebp
+     dc0:	c3                   	ret    
+  printf(1, "exitwait ok\n");
+     dc1:	83 ec 08             	sub    $0x8,%esp
+     dc4:	68 5b 42 00 00       	push   $0x425b
+     dc9:	6a 01                	push   $0x1
+     dcb:	e8 30 2d 00 00       	call   3b00 <printf>
+     dd0:	83 c4 10             	add    $0x10,%esp
+}
+     dd3:	8d 65 f8             	lea    -0x8(%ebp),%esp
+     dd6:	5b                   	pop    %ebx
+     dd7:	5e                   	pop    %esi
+     dd8:	5d                   	pop    %ebp
+     dd9:	c3                   	ret    
+      exit();
+     dda:	e8 a4 2b 00 00       	call   3983 <exit>
+     ddf:	90                   	nop
+
+00000de0 <mem>:
+{
+     de0:	f3 0f 1e fb          	endbr32 
+     de4:	55                   	push   %ebp
+     de5:	89 e5                	mov    %esp,%ebp
+     de7:	56                   	push   %esi
+     de8:	31 f6                	xor    %esi,%esi
+     dea:	53                   	push   %ebx
+  printf(1, "mem test\n");
+     deb:	83 ec 08             	sub    $0x8,%esp
+     dee:	68 68 42 00 00       	push   $0x4268
+     df3:	6a 01                	push   $0x1
+     df5:	e8 06 2d 00 00       	call   3b00 <printf>
+  ppid = getpid();
+     dfa:	e8 04 2c 00 00       	call   3a03 <getpid>
+     dff:	89 c3                	mov    %eax,%ebx
+  if((pid = fork()) == 0){
+     e01:	e8 75 2b 00 00       	call   397b <fork>
+     e06:	83 c4 10             	add    $0x10,%esp
+     e09:	85 c0                	test   %eax,%eax
+     e0b:	74 0f                	je     e1c <mem+0x3c>
+     e0d:	e9 8e 00 00 00       	jmp    ea0 <mem+0xc0>
+     e12:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      *(char**)m2 = m1;
+     e18:	89 30                	mov    %esi,(%eax)
+     e1a:	89 c6                	mov    %eax,%esi
+    while((m2 = malloc(10001)) != 0){
+     e1c:	83 ec 0c             	sub    $0xc,%esp
+     e1f:	68 11 27 00 00       	push   $0x2711
+     e24:	e8 37 2f 00 00       	call   3d60 <malloc>
+     e29:	83 c4 10             	add    $0x10,%esp
+     e2c:	85 c0                	test   %eax,%eax
+     e2e:	75 e8                	jne    e18 <mem+0x38>
+    while(m1){
+     e30:	85 f6                	test   %esi,%esi
+     e32:	74 18                	je     e4c <mem+0x6c>
+     e34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      m2 = *(char**)m1;
+     e38:	89 f0                	mov    %esi,%eax
+      free(m1);
+     e3a:	83 ec 0c             	sub    $0xc,%esp
+      m2 = *(char**)m1;
+     e3d:	8b 36                	mov    (%esi),%esi
+      free(m1);
+     e3f:	50                   	push   %eax
+     e40:	e8 8b 2e 00 00       	call   3cd0 <free>
+    while(m1){
+     e45:	83 c4 10             	add    $0x10,%esp
+     e48:	85 f6                	test   %esi,%esi
+     e4a:	75 ec                	jne    e38 <mem+0x58>
+    m1 = malloc(1024*20);
+     e4c:	83 ec 0c             	sub    $0xc,%esp
+     e4f:	68 00 50 00 00       	push   $0x5000
+     e54:	e8 07 2f 00 00       	call   3d60 <malloc>
+    if(m1 == 0){
+     e59:	83 c4 10             	add    $0x10,%esp
+     e5c:	85 c0                	test   %eax,%eax
+     e5e:	74 20                	je     e80 <mem+0xa0>
+    free(m1);
+     e60:	83 ec 0c             	sub    $0xc,%esp
+     e63:	50                   	push   %eax
+     e64:	e8 67 2e 00 00       	call   3cd0 <free>
+    printf(1, "mem ok\n");
+     e69:	58                   	pop    %eax
+     e6a:	5a                   	pop    %edx
+     e6b:	68 8c 42 00 00       	push   $0x428c
+     e70:	6a 01                	push   $0x1
+     e72:	e8 89 2c 00 00       	call   3b00 <printf>
+    exit();
+     e77:	e8 07 2b 00 00       	call   3983 <exit>
+     e7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+      printf(1, "couldn't allocate mem?!!\n");
+     e80:	83 ec 08             	sub    $0x8,%esp
+     e83:	68 72 42 00 00       	push   $0x4272
+     e88:	6a 01                	push   $0x1
+     e8a:	e8 71 2c 00 00       	call   3b00 <printf>
+      kill(ppid);
+     e8f:	89 1c 24             	mov    %ebx,(%esp)
+     e92:	e8 1c 2b 00 00       	call   39b3 <kill>
+      exit();
+     e97:	e8 e7 2a 00 00       	call   3983 <exit>
+     e9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+}
+     ea0:	8d 65 f8             	lea    -0x8(%ebp),%esp
+     ea3:	5b                   	pop    %ebx
+     ea4:	5e                   	pop    %esi
+     ea5:	5d                   	pop    %ebp
+    wait();
+     ea6:	e9 e0 2a 00 00       	jmp    398b <wait>
+     eab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+     eaf:	90                   	nop
+
+00000eb0 <sharedfd>:
+{
+     eb0:	f3 0f 1e fb          	endbr32 
+     eb4:	55                   	push   %ebp
+     eb5:	89 e5                	mov    %esp,%ebp
+     eb7:	57                   	push   %edi
+     eb8:	56                   	push   %esi
+     eb9:	53                   	push   %ebx
+     eba:	83 ec 34             	sub    $0x34,%esp
+  printf(1, "sharedfd test\n");
+     ebd:	68 94 42 00 00       	push   $0x4294
+     ec2:	6a 01                	push   $0x1
+     ec4:	e8 37 2c 00 00       	call   3b00 <printf>
+  unlink("sharedfd");
+     ec9:	c7 04 24 a3 42 00 00 	movl   $0x42a3,(%esp)
+     ed0:	e8 fe 2a 00 00       	call   39d3 <unlink>
+  fd = open("sharedfd", O_CREATE|O_RDWR);
+     ed5:	5b                   	pop    %ebx
+     ed6:	5e                   	pop    %esi
+     ed7:	68 02 02 00 00       	push   $0x202
+     edc:	68 a3 42 00 00       	push   $0x42a3
+     ee1:	e8 dd 2a 00 00       	call   39c3 <open>
+  if(fd < 0){
+     ee6:	83 c4 10             	add    $0x10,%esp
+     ee9:	85 c0                	test   %eax,%eax
+     eeb:	0f 88 26 01 00 00    	js     1017 <sharedfd+0x167>
+     ef1:	89 c7                	mov    %eax,%edi
+  memset(buf, pid==0?'c':'p', sizeof(buf));
+     ef3:	8d 75 de             	lea    -0x22(%ebp),%esi
+     ef6:	bb e8 03 00 00       	mov    $0x3e8,%ebx
+  pid = fork();
+     efb:	e8 7b 2a 00 00       	call   397b <fork>
+  memset(buf, pid==0?'c':'p', sizeof(buf));
+     f00:	83 f8 01             	cmp    $0x1,%eax
+  pid = fork();
+     f03:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  memset(buf, pid==0?'c':'p', sizeof(buf));
+     f06:	19 c0                	sbb    %eax,%eax
+     f08:	83 ec 04             	sub    $0x4,%esp
+     f0b:	83 e0 f3             	and    $0xfffffff3,%eax
+     f0e:	6a 0a                	push   $0xa
+     f10:	83 c0 70             	add    $0x70,%eax
+     f13:	50                   	push   %eax
+     f14:	56                   	push   %esi
+     f15:	e8 c6 28 00 00       	call   37e0 <memset>
+     f1a:	83 c4 10             	add    $0x10,%esp
+     f1d:	eb 06                	jmp    f25 <sharedfd+0x75>
+     f1f:	90                   	nop
+  for(i = 0; i < 1000; i++){
+     f20:	83 eb 01             	sub    $0x1,%ebx
+     f23:	74 26                	je     f4b <sharedfd+0x9b>
+    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
+     f25:	83 ec 04             	sub    $0x4,%esp
+     f28:	6a 0a                	push   $0xa
+     f2a:	56                   	push   %esi
+     f2b:	57                   	push   %edi
+     f2c:	e8 72 2a 00 00       	call   39a3 <write>
+     f31:	83 c4 10             	add    $0x10,%esp
+     f34:	83 f8 0a             	cmp    $0xa,%eax
+     f37:	74 e7                	je     f20 <sharedfd+0x70>
+      printf(1, "fstests: write sharedfd failed\n");
+     f39:	83 ec 08             	sub    $0x8,%esp
+     f3c:	68 94 4f 00 00       	push   $0x4f94
+     f41:	6a 01                	push   $0x1
+     f43:	e8 b8 2b 00 00       	call   3b00 <printf>
+      break;
+     f48:	83 c4 10             	add    $0x10,%esp
+  if(pid == 0)
+     f4b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
+     f4e:	85 c9                	test   %ecx,%ecx
+     f50:	0f 84 f5 00 00 00    	je     104b <sharedfd+0x19b>
+    wait();
+     f56:	e8 30 2a 00 00       	call   398b <wait>
+  close(fd);
+     f5b:	83 ec 0c             	sub    $0xc,%esp
+  nc = np = 0;
+     f5e:	31 db                	xor    %ebx,%ebx
+  close(fd);
+     f60:	57                   	push   %edi
+     f61:	8d 7d e8             	lea    -0x18(%ebp),%edi
+     f64:	e8 42 2a 00 00       	call   39ab <close>
+  fd = open("sharedfd", 0);
+     f69:	58                   	pop    %eax
+     f6a:	5a                   	pop    %edx
+     f6b:	6a 00                	push   $0x0
+     f6d:	68 a3 42 00 00       	push   $0x42a3
+     f72:	e8 4c 2a 00 00       	call   39c3 <open>
+  if(fd < 0){
+     f77:	83 c4 10             	add    $0x10,%esp
+  nc = np = 0;
+     f7a:	31 d2                	xor    %edx,%edx
+  fd = open("sharedfd", 0);
+     f7c:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  if(fd < 0){
+     f7f:	85 c0                	test   %eax,%eax
+     f81:	0f 88 aa 00 00 00    	js     1031 <sharedfd+0x181>
+     f87:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+     f8e:	66 90                	xchg   %ax,%ax
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+     f90:	83 ec 04             	sub    $0x4,%esp
+     f93:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+     f96:	6a 0a                	push   $0xa
+     f98:	56                   	push   %esi
+     f99:	ff 75 d0             	pushl  -0x30(%ebp)
+     f9c:	e8 fa 29 00 00       	call   399b <read>
+     fa1:	83 c4 10             	add    $0x10,%esp
+     fa4:	85 c0                	test   %eax,%eax
+     fa6:	7e 28                	jle    fd0 <sharedfd+0x120>
+    for(i = 0; i < sizeof(buf); i++){
+     fa8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+     fab:	89 f0                	mov    %esi,%eax
+     fad:	eb 13                	jmp    fc2 <sharedfd+0x112>
+     faf:	90                   	nop
+        np++;
+     fb0:	80 f9 70             	cmp    $0x70,%cl
+     fb3:	0f 94 c1             	sete   %cl
+     fb6:	0f b6 c9             	movzbl %cl,%ecx
+     fb9:	01 cb                	add    %ecx,%ebx
+    for(i = 0; i < sizeof(buf); i++){
+     fbb:	83 c0 01             	add    $0x1,%eax
+     fbe:	39 c7                	cmp    %eax,%edi
+     fc0:	74 ce                	je     f90 <sharedfd+0xe0>
+      if(buf[i] == 'c')
+     fc2:	0f b6 08             	movzbl (%eax),%ecx
+     fc5:	80 f9 63             	cmp    $0x63,%cl
+     fc8:	75 e6                	jne    fb0 <sharedfd+0x100>
+        nc++;
+     fca:	83 c2 01             	add    $0x1,%edx
+      if(buf[i] == 'p')
+     fcd:	eb ec                	jmp    fbb <sharedfd+0x10b>
+     fcf:	90                   	nop
+  close(fd);
+     fd0:	83 ec 0c             	sub    $0xc,%esp
+     fd3:	ff 75 d0             	pushl  -0x30(%ebp)
+     fd6:	e8 d0 29 00 00       	call   39ab <close>
+  unlink("sharedfd");
+     fdb:	c7 04 24 a3 42 00 00 	movl   $0x42a3,(%esp)
+     fe2:	e8 ec 29 00 00       	call   39d3 <unlink>
+  if(nc == 10000 && np == 10000){
+     fe7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+     fea:	83 c4 10             	add    $0x10,%esp
+     fed:	81 fa 10 27 00 00    	cmp    $0x2710,%edx
+     ff3:	75 5b                	jne    1050 <sharedfd+0x1a0>
+     ff5:	81 fb 10 27 00 00    	cmp    $0x2710,%ebx
+     ffb:	75 53                	jne    1050 <sharedfd+0x1a0>
+    printf(1, "sharedfd ok\n");
+     ffd:	83 ec 08             	sub    $0x8,%esp
+    1000:	68 ac 42 00 00       	push   $0x42ac
+    1005:	6a 01                	push   $0x1
+    1007:	e8 f4 2a 00 00       	call   3b00 <printf>
+    100c:	83 c4 10             	add    $0x10,%esp
+}
+    100f:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    1012:	5b                   	pop    %ebx
+    1013:	5e                   	pop    %esi
+    1014:	5f                   	pop    %edi
+    1015:	5d                   	pop    %ebp
+    1016:	c3                   	ret    
+    printf(1, "fstests: cannot open sharedfd for writing");
+    1017:	83 ec 08             	sub    $0x8,%esp
+    101a:	68 68 4f 00 00       	push   $0x4f68
+    101f:	6a 01                	push   $0x1
+    1021:	e8 da 2a 00 00       	call   3b00 <printf>
+    return;
+    1026:	83 c4 10             	add    $0x10,%esp
+}
+    1029:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    102c:	5b                   	pop    %ebx
+    102d:	5e                   	pop    %esi
+    102e:	5f                   	pop    %edi
+    102f:	5d                   	pop    %ebp
+    1030:	c3                   	ret    
+    printf(1, "fstests: cannot open sharedfd for reading\n");
+    1031:	83 ec 08             	sub    $0x8,%esp
+    1034:	68 b4 4f 00 00       	push   $0x4fb4
+    1039:	6a 01                	push   $0x1
+    103b:	e8 c0 2a 00 00       	call   3b00 <printf>
+    return;
+    1040:	83 c4 10             	add    $0x10,%esp
+}
+    1043:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    1046:	5b                   	pop    %ebx
+    1047:	5e                   	pop    %esi
+    1048:	5f                   	pop    %edi
+    1049:	5d                   	pop    %ebp
+    104a:	c3                   	ret    
+    exit();
+    104b:	e8 33 29 00 00       	call   3983 <exit>
+    printf(1, "sharedfd oops %d %d\n", nc, np);
+    1050:	53                   	push   %ebx
+    1051:	52                   	push   %edx
+    1052:	68 b9 42 00 00       	push   $0x42b9
+    1057:	6a 01                	push   $0x1
+    1059:	e8 a2 2a 00 00       	call   3b00 <printf>
+    exit();
+    105e:	e8 20 29 00 00       	call   3983 <exit>
+    1063:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    106a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00001070 <fourfiles>:
+{
+    1070:	f3 0f 1e fb          	endbr32 
+    1074:	55                   	push   %ebp
+    1075:	89 e5                	mov    %esp,%ebp
+    1077:	57                   	push   %edi
+    1078:	56                   	push   %esi
+  printf(1, "fourfiles test\n");
+    1079:	be ce 42 00 00       	mov    $0x42ce,%esi
+{
+    107e:	53                   	push   %ebx
+  for(pi = 0; pi < 4; pi++){
+    107f:	31 db                	xor    %ebx,%ebx
+{
+    1081:	83 ec 34             	sub    $0x34,%esp
+  char *names[] = { "f0", "f1", "f2", "f3" };
+    1084:	c7 45 d8 ce 42 00 00 	movl   $0x42ce,-0x28(%ebp)
+  printf(1, "fourfiles test\n");
+    108b:	68 d4 42 00 00       	push   $0x42d4
+    1090:	6a 01                	push   $0x1
+  char *names[] = { "f0", "f1", "f2", "f3" };
+    1092:	c7 45 dc 17 44 00 00 	movl   $0x4417,-0x24(%ebp)
+    1099:	c7 45 e0 1b 44 00 00 	movl   $0x441b,-0x20(%ebp)
+    10a0:	c7 45 e4 d1 42 00 00 	movl   $0x42d1,-0x1c(%ebp)
+  printf(1, "fourfiles test\n");
+    10a7:	e8 54 2a 00 00       	call   3b00 <printf>
+    10ac:	83 c4 10             	add    $0x10,%esp
+    unlink(fname);
+    10af:	83 ec 0c             	sub    $0xc,%esp
+    10b2:	56                   	push   %esi
+    10b3:	e8 1b 29 00 00       	call   39d3 <unlink>
+    pid = fork();
+    10b8:	e8 be 28 00 00       	call   397b <fork>
+    if(pid < 0){
+    10bd:	83 c4 10             	add    $0x10,%esp
+    10c0:	85 c0                	test   %eax,%eax
+    10c2:	0f 88 60 01 00 00    	js     1228 <fourfiles+0x1b8>
+    if(pid == 0){
+    10c8:	0f 84 e5 00 00 00    	je     11b3 <fourfiles+0x143>
+  for(pi = 0; pi < 4; pi++){
+    10ce:	83 c3 01             	add    $0x1,%ebx
+    10d1:	83 fb 04             	cmp    $0x4,%ebx
+    10d4:	74 06                	je     10dc <fourfiles+0x6c>
+    10d6:	8b 74 9d d8          	mov    -0x28(%ebp,%ebx,4),%esi
+    10da:	eb d3                	jmp    10af <fourfiles+0x3f>
+    wait();
+    10dc:	e8 aa 28 00 00       	call   398b <wait>
+  for(i = 0; i < 2; i++){
+    10e1:	31 f6                	xor    %esi,%esi
+    wait();
+    10e3:	e8 a3 28 00 00       	call   398b <wait>
+    10e8:	e8 9e 28 00 00       	call   398b <wait>
+    10ed:	e8 99 28 00 00       	call   398b <wait>
+    fname = names[i];
+    10f2:	8b 44 b5 d8          	mov    -0x28(%ebp,%esi,4),%eax
+    fd = open(fname, 0);
+    10f6:	83 ec 08             	sub    $0x8,%esp
+    total = 0;
+    10f9:	31 db                	xor    %ebx,%ebx
+    fd = open(fname, 0);
+    10fb:	6a 00                	push   $0x0
+    10fd:	50                   	push   %eax
+    fname = names[i];
+    10fe:	89 45 d0             	mov    %eax,-0x30(%ebp)
+    fd = open(fname, 0);
+    1101:	e8 bd 28 00 00       	call   39c3 <open>
+    while((n = read(fd, buf, sizeof(buf))) > 0){
+    1106:	83 c4 10             	add    $0x10,%esp
+    fd = open(fname, 0);
+    1109:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    while((n = read(fd, buf, sizeof(buf))) > 0){
+    110c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    1110:	83 ec 04             	sub    $0x4,%esp
+    1113:	68 00 20 00 00       	push   $0x2000
+    1118:	68 e0 86 00 00       	push   $0x86e0
+    111d:	ff 75 d4             	pushl  -0x2c(%ebp)
+    1120:	e8 76 28 00 00       	call   399b <read>
+    1125:	83 c4 10             	add    $0x10,%esp
+    1128:	85 c0                	test   %eax,%eax
+    112a:	7e 22                	jle    114e <fourfiles+0xde>
+      for(j = 0; j < n; j++){
+    112c:	31 d2                	xor    %edx,%edx
+    112e:	66 90                	xchg   %ax,%ax
+        if(buf[j] != '0'+i){
+    1130:	83 fe 01             	cmp    $0x1,%esi
+    1133:	0f be ba e0 86 00 00 	movsbl 0x86e0(%edx),%edi
+    113a:	19 c9                	sbb    %ecx,%ecx
+    113c:	83 c1 31             	add    $0x31,%ecx
+    113f:	39 cf                	cmp    %ecx,%edi
+    1141:	75 5c                	jne    119f <fourfiles+0x12f>
+      for(j = 0; j < n; j++){
+    1143:	83 c2 01             	add    $0x1,%edx
+    1146:	39 d0                	cmp    %edx,%eax
+    1148:	75 e6                	jne    1130 <fourfiles+0xc0>
+      total += n;
+    114a:	01 c3                	add    %eax,%ebx
+    114c:	eb c2                	jmp    1110 <fourfiles+0xa0>
+    close(fd);
+    114e:	83 ec 0c             	sub    $0xc,%esp
+    1151:	ff 75 d4             	pushl  -0x2c(%ebp)
+    1154:	e8 52 28 00 00       	call   39ab <close>
+    if(total != 12*500){
+    1159:	83 c4 10             	add    $0x10,%esp
+    115c:	81 fb 70 17 00 00    	cmp    $0x1770,%ebx
+    1162:	0f 85 d4 00 00 00    	jne    123c <fourfiles+0x1cc>
+    unlink(fname);
+    1168:	83 ec 0c             	sub    $0xc,%esp
+    116b:	ff 75 d0             	pushl  -0x30(%ebp)
+    116e:	e8 60 28 00 00       	call   39d3 <unlink>
+  for(i = 0; i < 2; i++){
+    1173:	83 c4 10             	add    $0x10,%esp
+    1176:	83 fe 01             	cmp    $0x1,%esi
+    1179:	75 1a                	jne    1195 <fourfiles+0x125>
+  printf(1, "fourfiles ok\n");
+    117b:	83 ec 08             	sub    $0x8,%esp
+    117e:	68 12 43 00 00       	push   $0x4312
+    1183:	6a 01                	push   $0x1
+    1185:	e8 76 29 00 00       	call   3b00 <printf>
+}
+    118a:	83 c4 10             	add    $0x10,%esp
+    118d:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    1190:	5b                   	pop    %ebx
+    1191:	5e                   	pop    %esi
+    1192:	5f                   	pop    %edi
+    1193:	5d                   	pop    %ebp
+    1194:	c3                   	ret    
+    1195:	be 01 00 00 00       	mov    $0x1,%esi
+    119a:	e9 53 ff ff ff       	jmp    10f2 <fourfiles+0x82>
+          printf(1, "wrong char\n");
+    119f:	83 ec 08             	sub    $0x8,%esp
+    11a2:	68 f5 42 00 00       	push   $0x42f5
+    11a7:	6a 01                	push   $0x1
+    11a9:	e8 52 29 00 00       	call   3b00 <printf>
+          exit();
+    11ae:	e8 d0 27 00 00       	call   3983 <exit>
+      fd = open(fname, O_CREATE | O_RDWR);
+    11b3:	83 ec 08             	sub    $0x8,%esp
+    11b6:	68 02 02 00 00       	push   $0x202
+    11bb:	56                   	push   %esi
+    11bc:	e8 02 28 00 00       	call   39c3 <open>
+      if(fd < 0){
+    11c1:	83 c4 10             	add    $0x10,%esp
+      fd = open(fname, O_CREATE | O_RDWR);
+    11c4:	89 c6                	mov    %eax,%esi
+      if(fd < 0){
+    11c6:	85 c0                	test   %eax,%eax
+    11c8:	78 45                	js     120f <fourfiles+0x19f>
+      memset(buf, '0'+pi, 512);
+    11ca:	83 ec 04             	sub    $0x4,%esp
+    11cd:	83 c3 30             	add    $0x30,%ebx
+    11d0:	68 00 02 00 00       	push   $0x200
+    11d5:	53                   	push   %ebx
+    11d6:	bb 0c 00 00 00       	mov    $0xc,%ebx
+    11db:	68 e0 86 00 00       	push   $0x86e0
+    11e0:	e8 fb 25 00 00       	call   37e0 <memset>
+    11e5:	83 c4 10             	add    $0x10,%esp
+        if((n = write(fd, buf, 500)) != 500){
+    11e8:	83 ec 04             	sub    $0x4,%esp
+    11eb:	68 f4 01 00 00       	push   $0x1f4
+    11f0:	68 e0 86 00 00       	push   $0x86e0
+    11f5:	56                   	push   %esi
+    11f6:	e8 a8 27 00 00       	call   39a3 <write>
+    11fb:	83 c4 10             	add    $0x10,%esp
+    11fe:	3d f4 01 00 00       	cmp    $0x1f4,%eax
+    1203:	75 4a                	jne    124f <fourfiles+0x1df>
+      for(i = 0; i < 12; i++){
+    1205:	83 eb 01             	sub    $0x1,%ebx
+    1208:	75 de                	jne    11e8 <fourfiles+0x178>
+      exit();
+    120a:	e8 74 27 00 00       	call   3983 <exit>
+        printf(1, "create failed\n");
+    120f:	51                   	push   %ecx
+    1210:	51                   	push   %ecx
+    1211:	68 6f 45 00 00       	push   $0x456f
+    1216:	6a 01                	push   $0x1
+    1218:	e8 e3 28 00 00       	call   3b00 <printf>
+        exit();
+    121d:	e8 61 27 00 00       	call   3983 <exit>
+    1222:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      printf(1, "fork failed\n");
+    1228:	83 ec 08             	sub    $0x8,%esp
+    122b:	68 a9 4d 00 00       	push   $0x4da9
+    1230:	6a 01                	push   $0x1
+    1232:	e8 c9 28 00 00       	call   3b00 <printf>
+      exit();
+    1237:	e8 47 27 00 00       	call   3983 <exit>
+      printf(1, "wrong length %d\n", total);
+    123c:	50                   	push   %eax
+    123d:	53                   	push   %ebx
+    123e:	68 01 43 00 00       	push   $0x4301
+    1243:	6a 01                	push   $0x1
+    1245:	e8 b6 28 00 00       	call   3b00 <printf>
+      exit();
+    124a:	e8 34 27 00 00       	call   3983 <exit>
+          printf(1, "write failed %d\n", n);
+    124f:	52                   	push   %edx
+    1250:	50                   	push   %eax
+    1251:	68 e4 42 00 00       	push   $0x42e4
+    1256:	6a 01                	push   $0x1
+    1258:	e8 a3 28 00 00       	call   3b00 <printf>
+          exit();
+    125d:	e8 21 27 00 00       	call   3983 <exit>
+    1262:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1269:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00001270 <createdelete>:
+{
+    1270:	f3 0f 1e fb          	endbr32 
+    1274:	55                   	push   %ebp
+    1275:	89 e5                	mov    %esp,%ebp
+    1277:	57                   	push   %edi
+    1278:	56                   	push   %esi
+    1279:	53                   	push   %ebx
+  for(pi = 0; pi < 4; pi++){
+    127a:	31 db                	xor    %ebx,%ebx
+{
+    127c:	83 ec 44             	sub    $0x44,%esp
+  printf(1, "createdelete test\n");
+    127f:	68 20 43 00 00       	push   $0x4320
+    1284:	6a 01                	push   $0x1
+    1286:	e8 75 28 00 00       	call   3b00 <printf>
+    128b:	83 c4 10             	add    $0x10,%esp
+    pid = fork();
+    128e:	e8 e8 26 00 00       	call   397b <fork>
+    if(pid < 0){
+    1293:	85 c0                	test   %eax,%eax
+    1295:	0f 88 ce 01 00 00    	js     1469 <createdelete+0x1f9>
+    if(pid == 0){
+    129b:	0f 84 17 01 00 00    	je     13b8 <createdelete+0x148>
+  for(pi = 0; pi < 4; pi++){
+    12a1:	83 c3 01             	add    $0x1,%ebx
+    12a4:	83 fb 04             	cmp    $0x4,%ebx
+    12a7:	75 e5                	jne    128e <createdelete+0x1e>
+    wait();
+    12a9:	e8 dd 26 00 00       	call   398b <wait>
+    12ae:	8d 7d c8             	lea    -0x38(%ebp),%edi
+  name[0] = name[1] = name[2] = 0;
+    12b1:	be ff ff ff ff       	mov    $0xffffffff,%esi
+    wait();
+    12b6:	e8 d0 26 00 00       	call   398b <wait>
+    12bb:	e8 cb 26 00 00       	call   398b <wait>
+    12c0:	e8 c6 26 00 00       	call   398b <wait>
+  name[0] = name[1] = name[2] = 0;
+    12c5:	c6 45 ca 00          	movb   $0x0,-0x36(%ebp)
+  for(i = 0; i < N; i++){
+    12c9:	89 7d c0             	mov    %edi,-0x40(%ebp)
+    12cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    for(pi = 0; pi < 4; pi++){
+    12d0:	8d 46 31             	lea    0x31(%esi),%eax
+    12d3:	89 f7                	mov    %esi,%edi
+    12d5:	83 c6 01             	add    $0x1,%esi
+    12d8:	83 fe 09             	cmp    $0x9,%esi
+    12db:	88 45 c7             	mov    %al,-0x39(%ebp)
+    12de:	0f 9f c3             	setg   %bl
+    12e1:	85 f6                	test   %esi,%esi
+    12e3:	0f 94 c0             	sete   %al
+    12e6:	09 c3                	or     %eax,%ebx
+    12e8:	88 5d c6             	mov    %bl,-0x3a(%ebp)
+      name[2] = '\0';
+    12eb:	bb 70 00 00 00       	mov    $0x70,%ebx
+      fd = open(name, 0);
+    12f0:	83 ec 08             	sub    $0x8,%esp
+      name[1] = '0' + i;
+    12f3:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
+      name[0] = 'p' + pi;
+    12f7:	88 5d c8             	mov    %bl,-0x38(%ebp)
+      fd = open(name, 0);
+    12fa:	6a 00                	push   $0x0
+    12fc:	ff 75 c0             	pushl  -0x40(%ebp)
+      name[1] = '0' + i;
+    12ff:	88 45 c9             	mov    %al,-0x37(%ebp)
+      fd = open(name, 0);
+    1302:	e8 bc 26 00 00       	call   39c3 <open>
+      if((i == 0 || i >= N/2) && fd < 0){
+    1307:	83 c4 10             	add    $0x10,%esp
+    130a:	80 7d c6 00          	cmpb   $0x0,-0x3a(%ebp)
+    130e:	0f 84 8c 00 00 00    	je     13a0 <createdelete+0x130>
+    1314:	85 c0                	test   %eax,%eax
+    1316:	0f 88 21 01 00 00    	js     143d <createdelete+0x1cd>
+      } else if((i >= 1 && i < N/2) && fd >= 0){
+    131c:	83 ff 08             	cmp    $0x8,%edi
+    131f:	0f 86 60 01 00 00    	jbe    1485 <createdelete+0x215>
+        close(fd);
+    1325:	83 ec 0c             	sub    $0xc,%esp
+    1328:	50                   	push   %eax
+    1329:	e8 7d 26 00 00       	call   39ab <close>
+    132e:	83 c4 10             	add    $0x10,%esp
+    for(pi = 0; pi < 4; pi++){
+    1331:	83 c3 01             	add    $0x1,%ebx
+    1334:	80 fb 74             	cmp    $0x74,%bl
+    1337:	75 b7                	jne    12f0 <createdelete+0x80>
+  for(i = 0; i < N; i++){
+    1339:	83 fe 13             	cmp    $0x13,%esi
+    133c:	75 92                	jne    12d0 <createdelete+0x60>
+    133e:	8b 7d c0             	mov    -0x40(%ebp),%edi
+    1341:	be 70 00 00 00       	mov    $0x70,%esi
+    1346:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    134d:	8d 76 00             	lea    0x0(%esi),%esi
+    for(pi = 0; pi < 4; pi++){
+    1350:	8d 46 c0             	lea    -0x40(%esi),%eax
+  name[0] = name[1] = name[2] = 0;
+    1353:	bb 04 00 00 00       	mov    $0x4,%ebx
+    1358:	88 45 c7             	mov    %al,-0x39(%ebp)
+      unlink(name);
+    135b:	83 ec 0c             	sub    $0xc,%esp
+      name[0] = 'p' + i;
+    135e:	89 f0                	mov    %esi,%eax
+      unlink(name);
+    1360:	57                   	push   %edi
+      name[0] = 'p' + i;
+    1361:	88 45 c8             	mov    %al,-0x38(%ebp)
+      name[1] = '0' + i;
+    1364:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
+    1368:	88 45 c9             	mov    %al,-0x37(%ebp)
+      unlink(name);
+    136b:	e8 63 26 00 00       	call   39d3 <unlink>
+    for(pi = 0; pi < 4; pi++){
+    1370:	83 c4 10             	add    $0x10,%esp
+    1373:	83 eb 01             	sub    $0x1,%ebx
+    1376:	75 e3                	jne    135b <createdelete+0xeb>
+  for(i = 0; i < N; i++){
+    1378:	83 c6 01             	add    $0x1,%esi
+    137b:	89 f0                	mov    %esi,%eax
+    137d:	3c 84                	cmp    $0x84,%al
+    137f:	75 cf                	jne    1350 <createdelete+0xe0>
+  printf(1, "createdelete ok\n");
+    1381:	83 ec 08             	sub    $0x8,%esp
+    1384:	68 33 43 00 00       	push   $0x4333
+    1389:	6a 01                	push   $0x1
+    138b:	e8 70 27 00 00       	call   3b00 <printf>
+}
+    1390:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    1393:	5b                   	pop    %ebx
+    1394:	5e                   	pop    %esi
+    1395:	5f                   	pop    %edi
+    1396:	5d                   	pop    %ebp
+    1397:	c3                   	ret    
+    1398:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    139f:	90                   	nop
+      } else if((i >= 1 && i < N/2) && fd >= 0){
+    13a0:	83 ff 08             	cmp    $0x8,%edi
+    13a3:	0f 86 d4 00 00 00    	jbe    147d <createdelete+0x20d>
+      if(fd >= 0)
+    13a9:	85 c0                	test   %eax,%eax
+    13ab:	78 84                	js     1331 <createdelete+0xc1>
+    13ad:	e9 73 ff ff ff       	jmp    1325 <createdelete+0xb5>
+    13b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      name[0] = 'p' + pi;
+    13b8:	83 c3 70             	add    $0x70,%ebx
+      name[2] = '\0';
+    13bb:	c6 45 ca 00          	movb   $0x0,-0x36(%ebp)
+    13bf:	8d 7d c8             	lea    -0x38(%ebp),%edi
+      name[0] = 'p' + pi;
+    13c2:	88 5d c8             	mov    %bl,-0x38(%ebp)
+      name[2] = '\0';
+    13c5:	31 db                	xor    %ebx,%ebx
+    13c7:	eb 0f                	jmp    13d8 <createdelete+0x168>
+    13c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      for(i = 0; i < N; i++){
+    13d0:	83 fb 13             	cmp    $0x13,%ebx
+    13d3:	74 63                	je     1438 <createdelete+0x1c8>
+    13d5:	83 c3 01             	add    $0x1,%ebx
+        fd = open(name, O_CREATE | O_RDWR);
+    13d8:	83 ec 08             	sub    $0x8,%esp
+        name[1] = '0' + i;
+    13db:	8d 43 30             	lea    0x30(%ebx),%eax
+        fd = open(name, O_CREATE | O_RDWR);
+    13de:	68 02 02 00 00       	push   $0x202
+    13e3:	57                   	push   %edi
+        name[1] = '0' + i;
+    13e4:	88 45 c9             	mov    %al,-0x37(%ebp)
+        fd = open(name, O_CREATE | O_RDWR);
+    13e7:	e8 d7 25 00 00       	call   39c3 <open>
+        if(fd < 0){
+    13ec:	83 c4 10             	add    $0x10,%esp
+    13ef:	85 c0                	test   %eax,%eax
+    13f1:	78 62                	js     1455 <createdelete+0x1e5>
+        close(fd);
+    13f3:	83 ec 0c             	sub    $0xc,%esp
+    13f6:	50                   	push   %eax
+    13f7:	e8 af 25 00 00       	call   39ab <close>
+        if(i > 0 && (i % 2 ) == 0){
+    13fc:	83 c4 10             	add    $0x10,%esp
+    13ff:	85 db                	test   %ebx,%ebx
+    1401:	74 d2                	je     13d5 <createdelete+0x165>
+    1403:	f6 c3 01             	test   $0x1,%bl
+    1406:	75 c8                	jne    13d0 <createdelete+0x160>
+          if(unlink(name) < 0){
+    1408:	83 ec 0c             	sub    $0xc,%esp
+          name[1] = '0' + (i / 2);
+    140b:	89 d8                	mov    %ebx,%eax
+          if(unlink(name) < 0){
+    140d:	57                   	push   %edi
+          name[1] = '0' + (i / 2);
+    140e:	d1 f8                	sar    %eax
+    1410:	83 c0 30             	add    $0x30,%eax
+    1413:	88 45 c9             	mov    %al,-0x37(%ebp)
+          if(unlink(name) < 0){
+    1416:	e8 b8 25 00 00       	call   39d3 <unlink>
+    141b:	83 c4 10             	add    $0x10,%esp
+    141e:	85 c0                	test   %eax,%eax
+    1420:	79 ae                	jns    13d0 <createdelete+0x160>
+            printf(1, "unlink failed\n");
+    1422:	52                   	push   %edx
+    1423:	52                   	push   %edx
+    1424:	68 21 3f 00 00       	push   $0x3f21
+    1429:	6a 01                	push   $0x1
+    142b:	e8 d0 26 00 00       	call   3b00 <printf>
+            exit();
+    1430:	e8 4e 25 00 00       	call   3983 <exit>
+    1435:	8d 76 00             	lea    0x0(%esi),%esi
+      exit();
+    1438:	e8 46 25 00 00       	call   3983 <exit>
+    143d:	8b 7d c0             	mov    -0x40(%ebp),%edi
+        printf(1, "oops createdelete %s didn't exist\n", name);
+    1440:	83 ec 04             	sub    $0x4,%esp
+    1443:	57                   	push   %edi
+    1444:	68 e0 4f 00 00       	push   $0x4fe0
+    1449:	6a 01                	push   $0x1
+    144b:	e8 b0 26 00 00       	call   3b00 <printf>
+        exit();
+    1450:	e8 2e 25 00 00       	call   3983 <exit>
+          printf(1, "create failed\n");
+    1455:	83 ec 08             	sub    $0x8,%esp
+    1458:	68 6f 45 00 00       	push   $0x456f
+    145d:	6a 01                	push   $0x1
+    145f:	e8 9c 26 00 00       	call   3b00 <printf>
+          exit();
+    1464:	e8 1a 25 00 00       	call   3983 <exit>
+      printf(1, "fork failed\n");
+    1469:	83 ec 08             	sub    $0x8,%esp
+    146c:	68 a9 4d 00 00       	push   $0x4da9
+    1471:	6a 01                	push   $0x1
+    1473:	e8 88 26 00 00       	call   3b00 <printf>
+      exit();
+    1478:	e8 06 25 00 00       	call   3983 <exit>
+      } else if((i >= 1 && i < N/2) && fd >= 0){
+    147d:	85 c0                	test   %eax,%eax
+    147f:	0f 88 ac fe ff ff    	js     1331 <createdelete+0xc1>
+    1485:	8b 7d c0             	mov    -0x40(%ebp),%edi
+        printf(1, "oops createdelete %s did exist\n", name);
+    1488:	50                   	push   %eax
+    1489:	57                   	push   %edi
+    148a:	68 04 50 00 00       	push   $0x5004
+    148f:	6a 01                	push   $0x1
+    1491:	e8 6a 26 00 00       	call   3b00 <printf>
+        exit();
+    1496:	e8 e8 24 00 00       	call   3983 <exit>
+    149b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    149f:	90                   	nop
+
+000014a0 <unlinkread>:
+{
+    14a0:	f3 0f 1e fb          	endbr32 
+    14a4:	55                   	push   %ebp
+    14a5:	89 e5                	mov    %esp,%ebp
+    14a7:	56                   	push   %esi
+    14a8:	53                   	push   %ebx
+  printf(1, "unlinkread test\n");
+    14a9:	83 ec 08             	sub    $0x8,%esp
+    14ac:	68 44 43 00 00       	push   $0x4344
+    14b1:	6a 01                	push   $0x1
+    14b3:	e8 48 26 00 00       	call   3b00 <printf>
+  fd = open("unlinkread", O_CREATE | O_RDWR);
+    14b8:	5b                   	pop    %ebx
+    14b9:	5e                   	pop    %esi
+    14ba:	68 02 02 00 00       	push   $0x202
+    14bf:	68 55 43 00 00       	push   $0x4355
+    14c4:	e8 fa 24 00 00       	call   39c3 <open>
+  if(fd < 0){
+    14c9:	83 c4 10             	add    $0x10,%esp
+    14cc:	85 c0                	test   %eax,%eax
+    14ce:	0f 88 e6 00 00 00    	js     15ba <unlinkread+0x11a>
+  write(fd, "hello", 5);
+    14d4:	83 ec 04             	sub    $0x4,%esp
+    14d7:	89 c3                	mov    %eax,%ebx
+    14d9:	6a 05                	push   $0x5
+    14db:	68 7a 43 00 00       	push   $0x437a
+    14e0:	50                   	push   %eax
+    14e1:	e8 bd 24 00 00       	call   39a3 <write>
+  close(fd);
+    14e6:	89 1c 24             	mov    %ebx,(%esp)
+    14e9:	e8 bd 24 00 00       	call   39ab <close>
+  fd = open("unlinkread", O_RDWR);
+    14ee:	58                   	pop    %eax
+    14ef:	5a                   	pop    %edx
+    14f0:	6a 02                	push   $0x2
+    14f2:	68 55 43 00 00       	push   $0x4355
+    14f7:	e8 c7 24 00 00       	call   39c3 <open>
+  if(fd < 0){
+    14fc:	83 c4 10             	add    $0x10,%esp
+  fd = open("unlinkread", O_RDWR);
+    14ff:	89 c3                	mov    %eax,%ebx
+  if(fd < 0){
+    1501:	85 c0                	test   %eax,%eax
+    1503:	0f 88 10 01 00 00    	js     1619 <unlinkread+0x179>
+  if(unlink("unlinkread") != 0){
+    1509:	83 ec 0c             	sub    $0xc,%esp
+    150c:	68 55 43 00 00       	push   $0x4355
+    1511:	e8 bd 24 00 00       	call   39d3 <unlink>
+    1516:	83 c4 10             	add    $0x10,%esp
+    1519:	85 c0                	test   %eax,%eax
+    151b:	0f 85 e5 00 00 00    	jne    1606 <unlinkread+0x166>
+  fd1 = open("unlinkread", O_CREATE | O_RDWR);
+    1521:	83 ec 08             	sub    $0x8,%esp
+    1524:	68 02 02 00 00       	push   $0x202
+    1529:	68 55 43 00 00       	push   $0x4355
+    152e:	e8 90 24 00 00       	call   39c3 <open>
+  write(fd1, "yyy", 3);
+    1533:	83 c4 0c             	add    $0xc,%esp
+    1536:	6a 03                	push   $0x3
+  fd1 = open("unlinkread", O_CREATE | O_RDWR);
+    1538:	89 c6                	mov    %eax,%esi
+  write(fd1, "yyy", 3);
+    153a:	68 b2 43 00 00       	push   $0x43b2
+    153f:	50                   	push   %eax
+    1540:	e8 5e 24 00 00       	call   39a3 <write>
+  close(fd1);
+    1545:	89 34 24             	mov    %esi,(%esp)
+    1548:	e8 5e 24 00 00       	call   39ab <close>
+  if(read(fd, buf, sizeof(buf)) != 5){
+    154d:	83 c4 0c             	add    $0xc,%esp
+    1550:	68 00 20 00 00       	push   $0x2000
+    1555:	68 e0 86 00 00       	push   $0x86e0
+    155a:	53                   	push   %ebx
+    155b:	e8 3b 24 00 00       	call   399b <read>
+    1560:	83 c4 10             	add    $0x10,%esp
+    1563:	83 f8 05             	cmp    $0x5,%eax
+    1566:	0f 85 87 00 00 00    	jne    15f3 <unlinkread+0x153>
+  if(buf[0] != 'h'){
+    156c:	80 3d e0 86 00 00 68 	cmpb   $0x68,0x86e0
+    1573:	75 6b                	jne    15e0 <unlinkread+0x140>
+  if(write(fd, buf, 10) != 10){
+    1575:	83 ec 04             	sub    $0x4,%esp
+    1578:	6a 0a                	push   $0xa
+    157a:	68 e0 86 00 00       	push   $0x86e0
+    157f:	53                   	push   %ebx
+    1580:	e8 1e 24 00 00       	call   39a3 <write>
+    1585:	83 c4 10             	add    $0x10,%esp
+    1588:	83 f8 0a             	cmp    $0xa,%eax
+    158b:	75 40                	jne    15cd <unlinkread+0x12d>
+  close(fd);
+    158d:	83 ec 0c             	sub    $0xc,%esp
+    1590:	53                   	push   %ebx
+    1591:	e8 15 24 00 00       	call   39ab <close>
+  unlink("unlinkread");
+    1596:	c7 04 24 55 43 00 00 	movl   $0x4355,(%esp)
+    159d:	e8 31 24 00 00       	call   39d3 <unlink>
+  printf(1, "unlinkread ok\n");
+    15a2:	58                   	pop    %eax
+    15a3:	5a                   	pop    %edx
+    15a4:	68 fd 43 00 00       	push   $0x43fd
+    15a9:	6a 01                	push   $0x1
+    15ab:	e8 50 25 00 00       	call   3b00 <printf>
+}
+    15b0:	83 c4 10             	add    $0x10,%esp
+    15b3:	8d 65 f8             	lea    -0x8(%ebp),%esp
+    15b6:	5b                   	pop    %ebx
+    15b7:	5e                   	pop    %esi
+    15b8:	5d                   	pop    %ebp
+    15b9:	c3                   	ret    
+    printf(1, "create unlinkread failed\n");
+    15ba:	51                   	push   %ecx
+    15bb:	51                   	push   %ecx
+    15bc:	68 60 43 00 00       	push   $0x4360
+    15c1:	6a 01                	push   $0x1
+    15c3:	e8 38 25 00 00       	call   3b00 <printf>
+    exit();
+    15c8:	e8 b6 23 00 00       	call   3983 <exit>
+    printf(1, "unlinkread write failed\n");
+    15cd:	51                   	push   %ecx
+    15ce:	51                   	push   %ecx
+    15cf:	68 e4 43 00 00       	push   $0x43e4
+    15d4:	6a 01                	push   $0x1
+    15d6:	e8 25 25 00 00       	call   3b00 <printf>
+    exit();
+    15db:	e8 a3 23 00 00       	call   3983 <exit>
+    printf(1, "unlinkread wrong data\n");
+    15e0:	53                   	push   %ebx
+    15e1:	53                   	push   %ebx
+    15e2:	68 cd 43 00 00       	push   $0x43cd
+    15e7:	6a 01                	push   $0x1
+    15e9:	e8 12 25 00 00       	call   3b00 <printf>
+    exit();
+    15ee:	e8 90 23 00 00       	call   3983 <exit>
+    printf(1, "unlinkread read failed");
+    15f3:	56                   	push   %esi
+    15f4:	56                   	push   %esi
+    15f5:	68 b6 43 00 00       	push   $0x43b6
+    15fa:	6a 01                	push   $0x1
+    15fc:	e8 ff 24 00 00       	call   3b00 <printf>
+    exit();
+    1601:	e8 7d 23 00 00       	call   3983 <exit>
+    printf(1, "unlink unlinkread failed\n");
+    1606:	50                   	push   %eax
+    1607:	50                   	push   %eax
+    1608:	68 98 43 00 00       	push   $0x4398
+    160d:	6a 01                	push   $0x1
+    160f:	e8 ec 24 00 00       	call   3b00 <printf>
+    exit();
+    1614:	e8 6a 23 00 00       	call   3983 <exit>
+    printf(1, "open unlinkread failed\n");
+    1619:	50                   	push   %eax
+    161a:	50                   	push   %eax
+    161b:	68 80 43 00 00       	push   $0x4380
+    1620:	6a 01                	push   $0x1
+    1622:	e8 d9 24 00 00       	call   3b00 <printf>
+    exit();
+    1627:	e8 57 23 00 00       	call   3983 <exit>
+    162c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00001630 <linktest>:
+{
+    1630:	f3 0f 1e fb          	endbr32 
+    1634:	55                   	push   %ebp
+    1635:	89 e5                	mov    %esp,%ebp
+    1637:	53                   	push   %ebx
+    1638:	83 ec 0c             	sub    $0xc,%esp
+  printf(1, "linktest\n");
+    163b:	68 0c 44 00 00       	push   $0x440c
+    1640:	6a 01                	push   $0x1
+    1642:	e8 b9 24 00 00       	call   3b00 <printf>
+  unlink("lf1");
+    1647:	c7 04 24 16 44 00 00 	movl   $0x4416,(%esp)
+    164e:	e8 80 23 00 00       	call   39d3 <unlink>
+  unlink("lf2");
+    1653:	c7 04 24 1a 44 00 00 	movl   $0x441a,(%esp)
+    165a:	e8 74 23 00 00       	call   39d3 <unlink>
+  fd = open("lf1", O_CREATE|O_RDWR);
+    165f:	58                   	pop    %eax
+    1660:	5a                   	pop    %edx
+    1661:	68 02 02 00 00       	push   $0x202
+    1666:	68 16 44 00 00       	push   $0x4416
+    166b:	e8 53 23 00 00       	call   39c3 <open>
+  if(fd < 0){
+    1670:	83 c4 10             	add    $0x10,%esp
+    1673:	85 c0                	test   %eax,%eax
+    1675:	0f 88 1e 01 00 00    	js     1799 <linktest+0x169>
+  if(write(fd, "hello", 5) != 5){
+    167b:	83 ec 04             	sub    $0x4,%esp
+    167e:	89 c3                	mov    %eax,%ebx
+    1680:	6a 05                	push   $0x5
+    1682:	68 7a 43 00 00       	push   $0x437a
+    1687:	50                   	push   %eax
+    1688:	e8 16 23 00 00       	call   39a3 <write>
+    168d:	83 c4 10             	add    $0x10,%esp
+    1690:	83 f8 05             	cmp    $0x5,%eax
+    1693:	0f 85 98 01 00 00    	jne    1831 <linktest+0x201>
+  close(fd);
+    1699:	83 ec 0c             	sub    $0xc,%esp
+    169c:	53                   	push   %ebx
+    169d:	e8 09 23 00 00       	call   39ab <close>
+  if(link("lf1", "lf2") < 0){
+    16a2:	5b                   	pop    %ebx
+    16a3:	58                   	pop    %eax
+    16a4:	68 1a 44 00 00       	push   $0x441a
+    16a9:	68 16 44 00 00       	push   $0x4416
+    16ae:	e8 30 23 00 00       	call   39e3 <link>
+    16b3:	83 c4 10             	add    $0x10,%esp
+    16b6:	85 c0                	test   %eax,%eax
+    16b8:	0f 88 60 01 00 00    	js     181e <linktest+0x1ee>
+  unlink("lf1");
+    16be:	83 ec 0c             	sub    $0xc,%esp
+    16c1:	68 16 44 00 00       	push   $0x4416
+    16c6:	e8 08 23 00 00       	call   39d3 <unlink>
+  if(open("lf1", 0) >= 0){
+    16cb:	58                   	pop    %eax
+    16cc:	5a                   	pop    %edx
+    16cd:	6a 00                	push   $0x0
+    16cf:	68 16 44 00 00       	push   $0x4416
+    16d4:	e8 ea 22 00 00       	call   39c3 <open>
+    16d9:	83 c4 10             	add    $0x10,%esp
+    16dc:	85 c0                	test   %eax,%eax
+    16de:	0f 89 27 01 00 00    	jns    180b <linktest+0x1db>
+  fd = open("lf2", 0);
+    16e4:	83 ec 08             	sub    $0x8,%esp
+    16e7:	6a 00                	push   $0x0
+    16e9:	68 1a 44 00 00       	push   $0x441a
+    16ee:	e8 d0 22 00 00       	call   39c3 <open>
+  if(fd < 0){
+    16f3:	83 c4 10             	add    $0x10,%esp
+  fd = open("lf2", 0);
+    16f6:	89 c3                	mov    %eax,%ebx
+  if(fd < 0){
+    16f8:	85 c0                	test   %eax,%eax
+    16fa:	0f 88 f8 00 00 00    	js     17f8 <linktest+0x1c8>
+  if(read(fd, buf, sizeof(buf)) != 5){
+    1700:	83 ec 04             	sub    $0x4,%esp
+    1703:	68 00 20 00 00       	push   $0x2000
+    1708:	68 e0 86 00 00       	push   $0x86e0
+    170d:	50                   	push   %eax
+    170e:	e8 88 22 00 00       	call   399b <read>
+    1713:	83 c4 10             	add    $0x10,%esp
+    1716:	83 f8 05             	cmp    $0x5,%eax
+    1719:	0f 85 c6 00 00 00    	jne    17e5 <linktest+0x1b5>
+  close(fd);
+    171f:	83 ec 0c             	sub    $0xc,%esp
+    1722:	53                   	push   %ebx
+    1723:	e8 83 22 00 00       	call   39ab <close>
+  if(link("lf2", "lf2") >= 0){
+    1728:	58                   	pop    %eax
+    1729:	5a                   	pop    %edx
+    172a:	68 1a 44 00 00       	push   $0x441a
+    172f:	68 1a 44 00 00       	push   $0x441a
+    1734:	e8 aa 22 00 00       	call   39e3 <link>
+    1739:	83 c4 10             	add    $0x10,%esp
+    173c:	85 c0                	test   %eax,%eax
+    173e:	0f 89 8e 00 00 00    	jns    17d2 <linktest+0x1a2>
+  unlink("lf2");
+    1744:	83 ec 0c             	sub    $0xc,%esp
+    1747:	68 1a 44 00 00       	push   $0x441a
+    174c:	e8 82 22 00 00       	call   39d3 <unlink>
+  if(link("lf2", "lf1") >= 0){
+    1751:	59                   	pop    %ecx
+    1752:	5b                   	pop    %ebx
+    1753:	68 16 44 00 00       	push   $0x4416
+    1758:	68 1a 44 00 00       	push   $0x441a
+    175d:	e8 81 22 00 00       	call   39e3 <link>
+    1762:	83 c4 10             	add    $0x10,%esp
+    1765:	85 c0                	test   %eax,%eax
+    1767:	79 56                	jns    17bf <linktest+0x18f>
+  if(link(".", "lf1") >= 0){
+    1769:	83 ec 08             	sub    $0x8,%esp
+    176c:	68 16 44 00 00       	push   $0x4416
+    1771:	68 de 46 00 00       	push   $0x46de
+    1776:	e8 68 22 00 00       	call   39e3 <link>
+    177b:	83 c4 10             	add    $0x10,%esp
+    177e:	85 c0                	test   %eax,%eax
+    1780:	79 2a                	jns    17ac <linktest+0x17c>
+  printf(1, "linktest ok\n");
+    1782:	83 ec 08             	sub    $0x8,%esp
+    1785:	68 b4 44 00 00       	push   $0x44b4
+    178a:	6a 01                	push   $0x1
+    178c:	e8 6f 23 00 00       	call   3b00 <printf>
+}
+    1791:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+    1794:	83 c4 10             	add    $0x10,%esp
+    1797:	c9                   	leave  
+    1798:	c3                   	ret    
+    printf(1, "create lf1 failed\n");
+    1799:	50                   	push   %eax
+    179a:	50                   	push   %eax
+    179b:	68 1e 44 00 00       	push   $0x441e
+    17a0:	6a 01                	push   $0x1
+    17a2:	e8 59 23 00 00       	call   3b00 <printf>
+    exit();
+    17a7:	e8 d7 21 00 00       	call   3983 <exit>
+    printf(1, "link . lf1 succeeded! oops\n");
+    17ac:	50                   	push   %eax
+    17ad:	50                   	push   %eax
+    17ae:	68 98 44 00 00       	push   $0x4498
+    17b3:	6a 01                	push   $0x1
+    17b5:	e8 46 23 00 00       	call   3b00 <printf>
+    exit();
+    17ba:	e8 c4 21 00 00       	call   3983 <exit>
+    printf(1, "link non-existant succeeded! oops\n");
+    17bf:	52                   	push   %edx
+    17c0:	52                   	push   %edx
+    17c1:	68 4c 50 00 00       	push   $0x504c
+    17c6:	6a 01                	push   $0x1
+    17c8:	e8 33 23 00 00       	call   3b00 <printf>
+    exit();
+    17cd:	e8 b1 21 00 00       	call   3983 <exit>
+    printf(1, "link lf2 lf2 succeeded! oops\n");
+    17d2:	50                   	push   %eax
+    17d3:	50                   	push   %eax
+    17d4:	68 7a 44 00 00       	push   $0x447a
+    17d9:	6a 01                	push   $0x1
+    17db:	e8 20 23 00 00       	call   3b00 <printf>
+    exit();
+    17e0:	e8 9e 21 00 00       	call   3983 <exit>
+    printf(1, "read lf2 failed\n");
+    17e5:	51                   	push   %ecx
+    17e6:	51                   	push   %ecx
+    17e7:	68 69 44 00 00       	push   $0x4469
+    17ec:	6a 01                	push   $0x1
+    17ee:	e8 0d 23 00 00       	call   3b00 <printf>
+    exit();
+    17f3:	e8 8b 21 00 00       	call   3983 <exit>
+    printf(1, "open lf2 failed\n");
+    17f8:	53                   	push   %ebx
+    17f9:	53                   	push   %ebx
+    17fa:	68 58 44 00 00       	push   $0x4458
+    17ff:	6a 01                	push   $0x1
+    1801:	e8 fa 22 00 00       	call   3b00 <printf>
+    exit();
+    1806:	e8 78 21 00 00       	call   3983 <exit>
+    printf(1, "unlinked lf1 but it is still there!\n");
+    180b:	50                   	push   %eax
+    180c:	50                   	push   %eax
+    180d:	68 24 50 00 00       	push   $0x5024
+    1812:	6a 01                	push   $0x1
+    1814:	e8 e7 22 00 00       	call   3b00 <printf>
+    exit();
+    1819:	e8 65 21 00 00       	call   3983 <exit>
+    printf(1, "link lf1 lf2 failed\n");
+    181e:	51                   	push   %ecx
+    181f:	51                   	push   %ecx
+    1820:	68 43 44 00 00       	push   $0x4443
+    1825:	6a 01                	push   $0x1
+    1827:	e8 d4 22 00 00       	call   3b00 <printf>
+    exit();
+    182c:	e8 52 21 00 00       	call   3983 <exit>
+    printf(1, "write lf1 failed\n");
+    1831:	50                   	push   %eax
+    1832:	50                   	push   %eax
+    1833:	68 31 44 00 00       	push   $0x4431
+    1838:	6a 01                	push   $0x1
+    183a:	e8 c1 22 00 00       	call   3b00 <printf>
+    exit();
+    183f:	e8 3f 21 00 00       	call   3983 <exit>
+    1844:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    184b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    184f:	90                   	nop
+
+00001850 <concreate>:
+{
+    1850:	f3 0f 1e fb          	endbr32 
+    1854:	55                   	push   %ebp
+    1855:	89 e5                	mov    %esp,%ebp
+    1857:	57                   	push   %edi
+    1858:	56                   	push   %esi
+  for(i = 0; i < 40; i++){
+    1859:	31 f6                	xor    %esi,%esi
+{
+    185b:	53                   	push   %ebx
+    185c:	8d 5d ad             	lea    -0x53(%ebp),%ebx
+    185f:	83 ec 64             	sub    $0x64,%esp
+  printf(1, "concreate test\n");
+    1862:	68 c1 44 00 00       	push   $0x44c1
+    1867:	6a 01                	push   $0x1
+    1869:	e8 92 22 00 00       	call   3b00 <printf>
+  file[0] = 'C';
+    186e:	c6 45 ad 43          	movb   $0x43,-0x53(%ebp)
+  file[2] = '\0';
+    1872:	83 c4 10             	add    $0x10,%esp
+    1875:	c6 45 af 00          	movb   $0x0,-0x51(%ebp)
+  for(i = 0; i < 40; i++){
+    1879:	eb 48                	jmp    18c3 <concreate+0x73>
+    187b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    187f:	90                   	nop
+    1880:	69 c6 ab aa aa aa    	imul   $0xaaaaaaab,%esi,%eax
+    if(pid && (i % 3) == 1){
+    1886:	3d ab aa aa aa       	cmp    $0xaaaaaaab,%eax
+    188b:	0f 83 af 00 00 00    	jae    1940 <concreate+0xf0>
+      fd = open(file, O_CREATE | O_RDWR);
+    1891:	83 ec 08             	sub    $0x8,%esp
+    1894:	68 02 02 00 00       	push   $0x202
+    1899:	53                   	push   %ebx
+    189a:	e8 24 21 00 00       	call   39c3 <open>
+      if(fd < 0){
+    189f:	83 c4 10             	add    $0x10,%esp
+    18a2:	85 c0                	test   %eax,%eax
+    18a4:	78 5f                	js     1905 <concreate+0xb5>
+      close(fd);
+    18a6:	83 ec 0c             	sub    $0xc,%esp
+  for(i = 0; i < 40; i++){
+    18a9:	83 c6 01             	add    $0x1,%esi
+      close(fd);
+    18ac:	50                   	push   %eax
+    18ad:	e8 f9 20 00 00       	call   39ab <close>
+    18b2:	83 c4 10             	add    $0x10,%esp
+      wait();
+    18b5:	e8 d1 20 00 00       	call   398b <wait>
+  for(i = 0; i < 40; i++){
+    18ba:	83 fe 28             	cmp    $0x28,%esi
+    18bd:	0f 84 9f 00 00 00    	je     1962 <concreate+0x112>
+    unlink(file);
+    18c3:	83 ec 0c             	sub    $0xc,%esp
+    file[1] = '0' + i;
+    18c6:	8d 46 30             	lea    0x30(%esi),%eax
+    unlink(file);
+    18c9:	53                   	push   %ebx
+    file[1] = '0' + i;
+    18ca:	88 45 ae             	mov    %al,-0x52(%ebp)
+    unlink(file);
+    18cd:	e8 01 21 00 00       	call   39d3 <unlink>
+    pid = fork();
+    18d2:	e8 a4 20 00 00       	call   397b <fork>
+    if(pid && (i % 3) == 1){
+    18d7:	83 c4 10             	add    $0x10,%esp
+    18da:	85 c0                	test   %eax,%eax
+    18dc:	75 a2                	jne    1880 <concreate+0x30>
+      link("C0", file);
+    18de:	69 f6 cd cc cc cc    	imul   $0xcccccccd,%esi,%esi
+    } else if(pid == 0 && (i % 5) == 1){
+    18e4:	81 fe cd cc cc cc    	cmp    $0xcccccccd,%esi
+    18ea:	73 34                	jae    1920 <concreate+0xd0>
+      fd = open(file, O_CREATE | O_RDWR);
+    18ec:	83 ec 08             	sub    $0x8,%esp
+    18ef:	68 02 02 00 00       	push   $0x202
+    18f4:	53                   	push   %ebx
+    18f5:	e8 c9 20 00 00       	call   39c3 <open>
+      if(fd < 0){
+    18fa:	83 c4 10             	add    $0x10,%esp
+    18fd:	85 c0                	test   %eax,%eax
+    18ff:	0f 89 39 02 00 00    	jns    1b3e <concreate+0x2ee>
+        printf(1, "concreate create %s failed\n", file);
+    1905:	83 ec 04             	sub    $0x4,%esp
+    1908:	53                   	push   %ebx
+    1909:	68 d4 44 00 00       	push   $0x44d4
+    190e:	6a 01                	push   $0x1
+    1910:	e8 eb 21 00 00       	call   3b00 <printf>
+        exit();
+    1915:	e8 69 20 00 00       	call   3983 <exit>
+    191a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+      link("C0", file);
+    1920:	83 ec 08             	sub    $0x8,%esp
+    1923:	53                   	push   %ebx
+    1924:	68 d1 44 00 00       	push   $0x44d1
+    1929:	e8 b5 20 00 00       	call   39e3 <link>
+    192e:	83 c4 10             	add    $0x10,%esp
+      exit();
+    1931:	e8 4d 20 00 00       	call   3983 <exit>
+    1936:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    193d:	8d 76 00             	lea    0x0(%esi),%esi
+      link("C0", file);
+    1940:	83 ec 08             	sub    $0x8,%esp
+  for(i = 0; i < 40; i++){
+    1943:	83 c6 01             	add    $0x1,%esi
+      link("C0", file);
+    1946:	53                   	push   %ebx
+    1947:	68 d1 44 00 00       	push   $0x44d1
+    194c:	e8 92 20 00 00       	call   39e3 <link>
+    1951:	83 c4 10             	add    $0x10,%esp
+      wait();
+    1954:	e8 32 20 00 00       	call   398b <wait>
+  for(i = 0; i < 40; i++){
+    1959:	83 fe 28             	cmp    $0x28,%esi
+    195c:	0f 85 61 ff ff ff    	jne    18c3 <concreate+0x73>
+  memset(fa, 0, sizeof(fa));
+    1962:	83 ec 04             	sub    $0x4,%esp
+    1965:	8d 45 c0             	lea    -0x40(%ebp),%eax
+    1968:	6a 28                	push   $0x28
+    196a:	6a 00                	push   $0x0
+    196c:	50                   	push   %eax
+    196d:	e8 6e 1e 00 00       	call   37e0 <memset>
+  fd = open(".", 0);
+    1972:	5e                   	pop    %esi
+    1973:	5f                   	pop    %edi
+    1974:	6a 00                	push   $0x0
+    1976:	68 de 46 00 00       	push   $0x46de
+    197b:	8d 7d b0             	lea    -0x50(%ebp),%edi
+    197e:	e8 40 20 00 00       	call   39c3 <open>
+  n = 0;
+    1983:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
+  while(read(fd, &de, sizeof(de)) > 0){
+    198a:	83 c4 10             	add    $0x10,%esp
+  fd = open(".", 0);
+    198d:	89 c6                	mov    %eax,%esi
+  while(read(fd, &de, sizeof(de)) > 0){
+    198f:	90                   	nop
+    1990:	83 ec 04             	sub    $0x4,%esp
+    1993:	6a 10                	push   $0x10
+    1995:	57                   	push   %edi
+    1996:	56                   	push   %esi
+    1997:	e8 ff 1f 00 00       	call   399b <read>
+    199c:	83 c4 10             	add    $0x10,%esp
+    199f:	85 c0                	test   %eax,%eax
+    19a1:	7e 3d                	jle    19e0 <concreate+0x190>
+    if(de.inum == 0)
+    19a3:	66 83 7d b0 00       	cmpw   $0x0,-0x50(%ebp)
+    19a8:	74 e6                	je     1990 <concreate+0x140>
+    if(de.name[0] == 'C' && de.name[2] == '\0'){
+    19aa:	80 7d b2 43          	cmpb   $0x43,-0x4e(%ebp)
+    19ae:	75 e0                	jne    1990 <concreate+0x140>
+    19b0:	80 7d b4 00          	cmpb   $0x0,-0x4c(%ebp)
+    19b4:	75 da                	jne    1990 <concreate+0x140>
+      i = de.name[1] - '0';
+    19b6:	0f be 45 b3          	movsbl -0x4d(%ebp),%eax
+    19ba:	83 e8 30             	sub    $0x30,%eax
+      if(i < 0 || i >= sizeof(fa)){
+    19bd:	83 f8 27             	cmp    $0x27,%eax
+    19c0:	0f 87 60 01 00 00    	ja     1b26 <concreate+0x2d6>
+      if(fa[i]){
+    19c6:	80 7c 05 c0 00       	cmpb   $0x0,-0x40(%ebp,%eax,1)
+    19cb:	0f 85 3d 01 00 00    	jne    1b0e <concreate+0x2be>
+      n++;
+    19d1:	83 45 a4 01          	addl   $0x1,-0x5c(%ebp)
+      fa[i] = 1;
+    19d5:	c6 44 05 c0 01       	movb   $0x1,-0x40(%ebp,%eax,1)
+      n++;
+    19da:	eb b4                	jmp    1990 <concreate+0x140>
+    19dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  close(fd);
+    19e0:	83 ec 0c             	sub    $0xc,%esp
+    19e3:	56                   	push   %esi
+    19e4:	e8 c2 1f 00 00       	call   39ab <close>
+  if(n != 40){
+    19e9:	83 c4 10             	add    $0x10,%esp
+    19ec:	83 7d a4 28          	cmpl   $0x28,-0x5c(%ebp)
+    19f0:	0f 85 05 01 00 00    	jne    1afb <concreate+0x2ab>
+  for(i = 0; i < 40; i++){
+    19f6:	31 f6                	xor    %esi,%esi
+    19f8:	eb 4c                	jmp    1a46 <concreate+0x1f6>
+    19fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+       ((i % 3) == 1 && pid != 0)){
+    1a00:	85 ff                	test   %edi,%edi
+    1a02:	74 05                	je     1a09 <concreate+0x1b9>
+    1a04:	83 f8 01             	cmp    $0x1,%eax
+    1a07:	74 6c                	je     1a75 <concreate+0x225>
+      unlink(file);
+    1a09:	83 ec 0c             	sub    $0xc,%esp
+    1a0c:	53                   	push   %ebx
+    1a0d:	e8 c1 1f 00 00       	call   39d3 <unlink>
+      unlink(file);
+    1a12:	89 1c 24             	mov    %ebx,(%esp)
+    1a15:	e8 b9 1f 00 00       	call   39d3 <unlink>
+      unlink(file);
+    1a1a:	89 1c 24             	mov    %ebx,(%esp)
+    1a1d:	e8 b1 1f 00 00       	call   39d3 <unlink>
+      unlink(file);
+    1a22:	89 1c 24             	mov    %ebx,(%esp)
+    1a25:	e8 a9 1f 00 00       	call   39d3 <unlink>
+    1a2a:	83 c4 10             	add    $0x10,%esp
+    if(pid == 0)
+    1a2d:	85 ff                	test   %edi,%edi
+    1a2f:	0f 84 fc fe ff ff    	je     1931 <concreate+0xe1>
+      wait();
+    1a35:	e8 51 1f 00 00       	call   398b <wait>
+  for(i = 0; i < 40; i++){
+    1a3a:	83 c6 01             	add    $0x1,%esi
+    1a3d:	83 fe 28             	cmp    $0x28,%esi
+    1a40:	0f 84 8a 00 00 00    	je     1ad0 <concreate+0x280>
+    file[1] = '0' + i;
+    1a46:	8d 46 30             	lea    0x30(%esi),%eax
+    1a49:	88 45 ae             	mov    %al,-0x52(%ebp)
+    pid = fork();
+    1a4c:	e8 2a 1f 00 00       	call   397b <fork>
+    1a51:	89 c7                	mov    %eax,%edi
+    if(pid < 0){
+    1a53:	85 c0                	test   %eax,%eax
+    1a55:	0f 88 8c 00 00 00    	js     1ae7 <concreate+0x297>
+    if(((i % 3) == 0 && pid == 0) ||
+    1a5b:	b8 ab aa aa aa       	mov    $0xaaaaaaab,%eax
+    1a60:	f7 e6                	mul    %esi
+    1a62:	89 d0                	mov    %edx,%eax
+    1a64:	83 e2 fe             	and    $0xfffffffe,%edx
+    1a67:	d1 e8                	shr    %eax
+    1a69:	01 c2                	add    %eax,%edx
+    1a6b:	89 f0                	mov    %esi,%eax
+    1a6d:	29 d0                	sub    %edx,%eax
+    1a6f:	89 c1                	mov    %eax,%ecx
+    1a71:	09 f9                	or     %edi,%ecx
+    1a73:	75 8b                	jne    1a00 <concreate+0x1b0>
+      close(open(file, 0));
+    1a75:	83 ec 08             	sub    $0x8,%esp
+    1a78:	6a 00                	push   $0x0
+    1a7a:	53                   	push   %ebx
+    1a7b:	e8 43 1f 00 00       	call   39c3 <open>
+    1a80:	89 04 24             	mov    %eax,(%esp)
+    1a83:	e8 23 1f 00 00       	call   39ab <close>
+      close(open(file, 0));
+    1a88:	58                   	pop    %eax
+    1a89:	5a                   	pop    %edx
+    1a8a:	6a 00                	push   $0x0
+    1a8c:	53                   	push   %ebx
+    1a8d:	e8 31 1f 00 00       	call   39c3 <open>
+    1a92:	89 04 24             	mov    %eax,(%esp)
+    1a95:	e8 11 1f 00 00       	call   39ab <close>
+      close(open(file, 0));
+    1a9a:	59                   	pop    %ecx
+    1a9b:	58                   	pop    %eax
+    1a9c:	6a 00                	push   $0x0
+    1a9e:	53                   	push   %ebx
+    1a9f:	e8 1f 1f 00 00       	call   39c3 <open>
+    1aa4:	89 04 24             	mov    %eax,(%esp)
+    1aa7:	e8 ff 1e 00 00       	call   39ab <close>
+      close(open(file, 0));
+    1aac:	58                   	pop    %eax
+    1aad:	5a                   	pop    %edx
+    1aae:	6a 00                	push   $0x0
+    1ab0:	53                   	push   %ebx
+    1ab1:	e8 0d 1f 00 00       	call   39c3 <open>
+    1ab6:	89 04 24             	mov    %eax,(%esp)
+    1ab9:	e8 ed 1e 00 00       	call   39ab <close>
+    1abe:	83 c4 10             	add    $0x10,%esp
+    1ac1:	e9 67 ff ff ff       	jmp    1a2d <concreate+0x1dd>
+    1ac6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1acd:	8d 76 00             	lea    0x0(%esi),%esi
+  printf(1, "concreate ok\n");
+    1ad0:	83 ec 08             	sub    $0x8,%esp
+    1ad3:	68 26 45 00 00       	push   $0x4526
+    1ad8:	6a 01                	push   $0x1
+    1ada:	e8 21 20 00 00       	call   3b00 <printf>
+}
+    1adf:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    1ae2:	5b                   	pop    %ebx
+    1ae3:	5e                   	pop    %esi
+    1ae4:	5f                   	pop    %edi
+    1ae5:	5d                   	pop    %ebp
+    1ae6:	c3                   	ret    
+      printf(1, "fork failed\n");
+    1ae7:	83 ec 08             	sub    $0x8,%esp
+    1aea:	68 a9 4d 00 00       	push   $0x4da9
+    1aef:	6a 01                	push   $0x1
+    1af1:	e8 0a 20 00 00       	call   3b00 <printf>
+      exit();
+    1af6:	e8 88 1e 00 00       	call   3983 <exit>
+    printf(1, "concreate not enough files in directory listing\n");
+    1afb:	51                   	push   %ecx
+    1afc:	51                   	push   %ecx
+    1afd:	68 70 50 00 00       	push   $0x5070
+    1b02:	6a 01                	push   $0x1
+    1b04:	e8 f7 1f 00 00       	call   3b00 <printf>
+    exit();
+    1b09:	e8 75 1e 00 00       	call   3983 <exit>
+        printf(1, "concreate duplicate file %s\n", de.name);
+    1b0e:	83 ec 04             	sub    $0x4,%esp
+    1b11:	8d 45 b2             	lea    -0x4e(%ebp),%eax
+    1b14:	50                   	push   %eax
+    1b15:	68 09 45 00 00       	push   $0x4509
+    1b1a:	6a 01                	push   $0x1
+    1b1c:	e8 df 1f 00 00       	call   3b00 <printf>
+        exit();
+    1b21:	e8 5d 1e 00 00       	call   3983 <exit>
+        printf(1, "concreate weird file %s\n", de.name);
+    1b26:	83 ec 04             	sub    $0x4,%esp
+    1b29:	8d 45 b2             	lea    -0x4e(%ebp),%eax
+    1b2c:	50                   	push   %eax
+    1b2d:	68 f0 44 00 00       	push   $0x44f0
+    1b32:	6a 01                	push   $0x1
+    1b34:	e8 c7 1f 00 00       	call   3b00 <printf>
+        exit();
+    1b39:	e8 45 1e 00 00       	call   3983 <exit>
+      close(fd);
+    1b3e:	83 ec 0c             	sub    $0xc,%esp
+    1b41:	50                   	push   %eax
+    1b42:	e8 64 1e 00 00       	call   39ab <close>
+    1b47:	83 c4 10             	add    $0x10,%esp
+    1b4a:	e9 e2 fd ff ff       	jmp    1931 <concreate+0xe1>
+    1b4f:	90                   	nop
+
+00001b50 <linkunlink>:
+{
+    1b50:	f3 0f 1e fb          	endbr32 
+    1b54:	55                   	push   %ebp
+    1b55:	89 e5                	mov    %esp,%ebp
+    1b57:	57                   	push   %edi
+    1b58:	56                   	push   %esi
+    1b59:	53                   	push   %ebx
+    1b5a:	83 ec 24             	sub    $0x24,%esp
+  printf(1, "linkunlink test\n");
+    1b5d:	68 34 45 00 00       	push   $0x4534
+    1b62:	6a 01                	push   $0x1
+    1b64:	e8 97 1f 00 00       	call   3b00 <printf>
+  unlink("x");
+    1b69:	c7 04 24 c1 47 00 00 	movl   $0x47c1,(%esp)
+    1b70:	e8 5e 1e 00 00       	call   39d3 <unlink>
+  pid = fork();
+    1b75:	e8 01 1e 00 00       	call   397b <fork>
+  if(pid < 0){
+    1b7a:	83 c4 10             	add    $0x10,%esp
+  pid = fork();
+    1b7d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  if(pid < 0){
+    1b80:	85 c0                	test   %eax,%eax
+    1b82:	0f 88 b2 00 00 00    	js     1c3a <linkunlink+0xea>
+  unsigned int x = (pid ? 1 : 97);
+    1b88:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
+    1b8c:	bb 64 00 00 00       	mov    $0x64,%ebx
+    if((x % 3) == 0){
+    1b91:	be ab aa aa aa       	mov    $0xaaaaaaab,%esi
+  unsigned int x = (pid ? 1 : 97);
+    1b96:	19 ff                	sbb    %edi,%edi
+    1b98:	83 e7 60             	and    $0x60,%edi
+    1b9b:	83 c7 01             	add    $0x1,%edi
+    1b9e:	eb 1a                	jmp    1bba <linkunlink+0x6a>
+    } else if((x % 3) == 1){
+    1ba0:	83 f8 01             	cmp    $0x1,%eax
+    1ba3:	74 7b                	je     1c20 <linkunlink+0xd0>
+      unlink("x");
+    1ba5:	83 ec 0c             	sub    $0xc,%esp
+    1ba8:	68 c1 47 00 00       	push   $0x47c1
+    1bad:	e8 21 1e 00 00       	call   39d3 <unlink>
+    1bb2:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < 100; i++){
+    1bb5:	83 eb 01             	sub    $0x1,%ebx
+    1bb8:	74 41                	je     1bfb <linkunlink+0xab>
+    x = x * 1103515245 + 12345;
+    1bba:	69 cf 6d 4e c6 41    	imul   $0x41c64e6d,%edi,%ecx
+    1bc0:	8d b9 39 30 00 00    	lea    0x3039(%ecx),%edi
+    if((x % 3) == 0){
+    1bc6:	89 f8                	mov    %edi,%eax
+    1bc8:	f7 e6                	mul    %esi
+    1bca:	89 d0                	mov    %edx,%eax
+    1bcc:	83 e2 fe             	and    $0xfffffffe,%edx
+    1bcf:	d1 e8                	shr    %eax
+    1bd1:	01 c2                	add    %eax,%edx
+    1bd3:	89 f8                	mov    %edi,%eax
+    1bd5:	29 d0                	sub    %edx,%eax
+    1bd7:	75 c7                	jne    1ba0 <linkunlink+0x50>
+      close(open("x", O_RDWR | O_CREATE));
+    1bd9:	83 ec 08             	sub    $0x8,%esp
+    1bdc:	68 02 02 00 00       	push   $0x202
+    1be1:	68 c1 47 00 00       	push   $0x47c1
+    1be6:	e8 d8 1d 00 00       	call   39c3 <open>
+    1beb:	89 04 24             	mov    %eax,(%esp)
+    1bee:	e8 b8 1d 00 00       	call   39ab <close>
+    1bf3:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < 100; i++){
+    1bf6:	83 eb 01             	sub    $0x1,%ebx
+    1bf9:	75 bf                	jne    1bba <linkunlink+0x6a>
+  if(pid)
+    1bfb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1bfe:	85 c0                	test   %eax,%eax
+    1c00:	74 4b                	je     1c4d <linkunlink+0xfd>
+    wait();
+    1c02:	e8 84 1d 00 00       	call   398b <wait>
+  printf(1, "linkunlink ok\n");
+    1c07:	83 ec 08             	sub    $0x8,%esp
+    1c0a:	68 49 45 00 00       	push   $0x4549
+    1c0f:	6a 01                	push   $0x1
+    1c11:	e8 ea 1e 00 00       	call   3b00 <printf>
+}
+    1c16:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    1c19:	5b                   	pop    %ebx
+    1c1a:	5e                   	pop    %esi
+    1c1b:	5f                   	pop    %edi
+    1c1c:	5d                   	pop    %ebp
+    1c1d:	c3                   	ret    
+    1c1e:	66 90                	xchg   %ax,%ax
+      link("cat", "x");
+    1c20:	83 ec 08             	sub    $0x8,%esp
+    1c23:	68 c1 47 00 00       	push   $0x47c1
+    1c28:	68 45 45 00 00       	push   $0x4545
+    1c2d:	e8 b1 1d 00 00       	call   39e3 <link>
+    1c32:	83 c4 10             	add    $0x10,%esp
+    1c35:	e9 7b ff ff ff       	jmp    1bb5 <linkunlink+0x65>
+    printf(1, "fork failed\n");
+    1c3a:	52                   	push   %edx
+    1c3b:	52                   	push   %edx
+    1c3c:	68 a9 4d 00 00       	push   $0x4da9
+    1c41:	6a 01                	push   $0x1
+    1c43:	e8 b8 1e 00 00       	call   3b00 <printf>
+    exit();
+    1c48:	e8 36 1d 00 00       	call   3983 <exit>
+    exit();
+    1c4d:	e8 31 1d 00 00       	call   3983 <exit>
+    1c52:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1c59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+
+00001c60 <bigdir>:
+{
+    1c60:	f3 0f 1e fb          	endbr32 
+    1c64:	55                   	push   %ebp
+    1c65:	89 e5                	mov    %esp,%ebp
+    1c67:	57                   	push   %edi
+    1c68:	56                   	push   %esi
+    1c69:	53                   	push   %ebx
+    1c6a:	83 ec 24             	sub    $0x24,%esp
+  printf(1, "bigdir test\n");
+    1c6d:	68 58 45 00 00       	push   $0x4558
+    1c72:	6a 01                	push   $0x1
+    1c74:	e8 87 1e 00 00       	call   3b00 <printf>
+  unlink("bd");
+    1c79:	c7 04 24 65 45 00 00 	movl   $0x4565,(%esp)
+    1c80:	e8 4e 1d 00 00       	call   39d3 <unlink>
+  fd = open("bd", O_CREATE);
+    1c85:	5a                   	pop    %edx
+    1c86:	59                   	pop    %ecx
+    1c87:	68 00 02 00 00       	push   $0x200
+    1c8c:	68 65 45 00 00       	push   $0x4565
+    1c91:	e8 2d 1d 00 00       	call   39c3 <open>
+  if(fd < 0){
+    1c96:	83 c4 10             	add    $0x10,%esp
+    1c99:	85 c0                	test   %eax,%eax
+    1c9b:	0f 88 ea 00 00 00    	js     1d8b <bigdir+0x12b>
+  close(fd);
+    1ca1:	83 ec 0c             	sub    $0xc,%esp
+  for(i = 0; i < 500; i++){
+    1ca4:	31 f6                	xor    %esi,%esi
+    1ca6:	8d 7d de             	lea    -0x22(%ebp),%edi
+  close(fd);
+    1ca9:	50                   	push   %eax
+    1caa:	e8 fc 1c 00 00       	call   39ab <close>
+    1caf:	83 c4 10             	add    $0x10,%esp
+    1cb2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    name[1] = '0' + (i / 64);
+    1cb8:	89 f0                	mov    %esi,%eax
+    if(link("bd", name) != 0){
+    1cba:	83 ec 08             	sub    $0x8,%esp
+    name[0] = 'x';
+    1cbd:	c6 45 de 78          	movb   $0x78,-0x22(%ebp)
+    name[1] = '0' + (i / 64);
+    1cc1:	c1 f8 06             	sar    $0x6,%eax
+    if(link("bd", name) != 0){
+    1cc4:	57                   	push   %edi
+    name[1] = '0' + (i / 64);
+    1cc5:	83 c0 30             	add    $0x30,%eax
+    if(link("bd", name) != 0){
+    1cc8:	68 65 45 00 00       	push   $0x4565
+    name[1] = '0' + (i / 64);
+    1ccd:	88 45 df             	mov    %al,-0x21(%ebp)
+    name[2] = '0' + (i % 64);
+    1cd0:	89 f0                	mov    %esi,%eax
+    1cd2:	83 e0 3f             	and    $0x3f,%eax
+    name[3] = '\0';
+    1cd5:	c6 45 e1 00          	movb   $0x0,-0x1f(%ebp)
+    name[2] = '0' + (i % 64);
+    1cd9:	83 c0 30             	add    $0x30,%eax
+    1cdc:	88 45 e0             	mov    %al,-0x20(%ebp)
+    if(link("bd", name) != 0){
+    1cdf:	e8 ff 1c 00 00       	call   39e3 <link>
+    1ce4:	83 c4 10             	add    $0x10,%esp
+    1ce7:	89 c3                	mov    %eax,%ebx
+    1ce9:	85 c0                	test   %eax,%eax
+    1ceb:	75 76                	jne    1d63 <bigdir+0x103>
+  for(i = 0; i < 500; i++){
+    1ced:	83 c6 01             	add    $0x1,%esi
+    1cf0:	81 fe f4 01 00 00    	cmp    $0x1f4,%esi
+    1cf6:	75 c0                	jne    1cb8 <bigdir+0x58>
+  unlink("bd");
+    1cf8:	83 ec 0c             	sub    $0xc,%esp
+    1cfb:	68 65 45 00 00       	push   $0x4565
+    1d00:	e8 ce 1c 00 00       	call   39d3 <unlink>
+    1d05:	83 c4 10             	add    $0x10,%esp
+    1d08:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    1d0f:	90                   	nop
+    name[1] = '0' + (i / 64);
+    1d10:	89 d8                	mov    %ebx,%eax
+    if(unlink(name) != 0){
+    1d12:	83 ec 0c             	sub    $0xc,%esp
+    name[0] = 'x';
+    1d15:	c6 45 de 78          	movb   $0x78,-0x22(%ebp)
+    name[1] = '0' + (i / 64);
+    1d19:	c1 f8 06             	sar    $0x6,%eax
+    if(unlink(name) != 0){
+    1d1c:	57                   	push   %edi
+    name[1] = '0' + (i / 64);
+    1d1d:	83 c0 30             	add    $0x30,%eax
+    name[3] = '\0';
+    1d20:	c6 45 e1 00          	movb   $0x0,-0x1f(%ebp)
+    name[1] = '0' + (i / 64);
+    1d24:	88 45 df             	mov    %al,-0x21(%ebp)
+    name[2] = '0' + (i % 64);
+    1d27:	89 d8                	mov    %ebx,%eax
+    1d29:	83 e0 3f             	and    $0x3f,%eax
+    1d2c:	83 c0 30             	add    $0x30,%eax
+    1d2f:	88 45 e0             	mov    %al,-0x20(%ebp)
+    if(unlink(name) != 0){
+    1d32:	e8 9c 1c 00 00       	call   39d3 <unlink>
+    1d37:	83 c4 10             	add    $0x10,%esp
+    1d3a:	85 c0                	test   %eax,%eax
+    1d3c:	75 39                	jne    1d77 <bigdir+0x117>
+  for(i = 0; i < 500; i++){
+    1d3e:	83 c3 01             	add    $0x1,%ebx
+    1d41:	81 fb f4 01 00 00    	cmp    $0x1f4,%ebx
+    1d47:	75 c7                	jne    1d10 <bigdir+0xb0>
+  printf(1, "bigdir ok\n");
+    1d49:	83 ec 08             	sub    $0x8,%esp
+    1d4c:	68 a7 45 00 00       	push   $0x45a7
+    1d51:	6a 01                	push   $0x1
+    1d53:	e8 a8 1d 00 00       	call   3b00 <printf>
+    1d58:	83 c4 10             	add    $0x10,%esp
+}
+    1d5b:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    1d5e:	5b                   	pop    %ebx
+    1d5f:	5e                   	pop    %esi
+    1d60:	5f                   	pop    %edi
+    1d61:	5d                   	pop    %ebp
+    1d62:	c3                   	ret    
+      printf(1, "bigdir link failed\n");
+    1d63:	83 ec 08             	sub    $0x8,%esp
+    1d66:	68 7e 45 00 00       	push   $0x457e
+    1d6b:	6a 01                	push   $0x1
+    1d6d:	e8 8e 1d 00 00       	call   3b00 <printf>
+      exit();
+    1d72:	e8 0c 1c 00 00       	call   3983 <exit>
+      printf(1, "bigdir unlink failed");
+    1d77:	83 ec 08             	sub    $0x8,%esp
+    1d7a:	68 92 45 00 00       	push   $0x4592
+    1d7f:	6a 01                	push   $0x1
+    1d81:	e8 7a 1d 00 00       	call   3b00 <printf>
+      exit();
+    1d86:	e8 f8 1b 00 00       	call   3983 <exit>
+    printf(1, "bigdir create failed\n");
+    1d8b:	50                   	push   %eax
+    1d8c:	50                   	push   %eax
+    1d8d:	68 68 45 00 00       	push   $0x4568
+    1d92:	6a 01                	push   $0x1
+    1d94:	e8 67 1d 00 00       	call   3b00 <printf>
+    exit();
+    1d99:	e8 e5 1b 00 00       	call   3983 <exit>
+    1d9e:	66 90                	xchg   %ax,%ax
+
+00001da0 <subdir>:
+{
+    1da0:	f3 0f 1e fb          	endbr32 
+    1da4:	55                   	push   %ebp
+    1da5:	89 e5                	mov    %esp,%ebp
+    1da7:	53                   	push   %ebx
+    1da8:	83 ec 0c             	sub    $0xc,%esp
+  printf(1, "subdir test\n");
+    1dab:	68 b2 45 00 00       	push   $0x45b2
+    1db0:	6a 01                	push   $0x1
+    1db2:	e8 49 1d 00 00       	call   3b00 <printf>
+  unlink("ff");
+    1db7:	c7 04 24 3b 46 00 00 	movl   $0x463b,(%esp)
+    1dbe:	e8 10 1c 00 00       	call   39d3 <unlink>
+  if(mkdir("dd") != 0){
+    1dc3:	c7 04 24 d8 46 00 00 	movl   $0x46d8,(%esp)
+    1dca:	e8 1c 1c 00 00       	call   39eb <mkdir>
+    1dcf:	83 c4 10             	add    $0x10,%esp
+    1dd2:	85 c0                	test   %eax,%eax
+    1dd4:	0f 85 b3 05 00 00    	jne    238d <subdir+0x5ed>
+  fd = open("dd/ff", O_CREATE | O_RDWR);
+    1dda:	83 ec 08             	sub    $0x8,%esp
+    1ddd:	68 02 02 00 00       	push   $0x202
+    1de2:	68 11 46 00 00       	push   $0x4611
+    1de7:	e8 d7 1b 00 00       	call   39c3 <open>
+  if(fd < 0){
+    1dec:	83 c4 10             	add    $0x10,%esp
+  fd = open("dd/ff", O_CREATE | O_RDWR);
+    1def:	89 c3                	mov    %eax,%ebx
+  if(fd < 0){
+    1df1:	85 c0                	test   %eax,%eax
+    1df3:	0f 88 81 05 00 00    	js     237a <subdir+0x5da>
+  write(fd, "ff", 2);
+    1df9:	83 ec 04             	sub    $0x4,%esp
+    1dfc:	6a 02                	push   $0x2
+    1dfe:	68 3b 46 00 00       	push   $0x463b
+    1e03:	50                   	push   %eax
+    1e04:	e8 9a 1b 00 00       	call   39a3 <write>
+  close(fd);
+    1e09:	89 1c 24             	mov    %ebx,(%esp)
+    1e0c:	e8 9a 1b 00 00       	call   39ab <close>
+  if(unlink("dd") >= 0){
+    1e11:	c7 04 24 d8 46 00 00 	movl   $0x46d8,(%esp)
+    1e18:	e8 b6 1b 00 00       	call   39d3 <unlink>
+    1e1d:	83 c4 10             	add    $0x10,%esp
+    1e20:	85 c0                	test   %eax,%eax
+    1e22:	0f 89 3f 05 00 00    	jns    2367 <subdir+0x5c7>
+  if(mkdir("/dd/dd") != 0){
+    1e28:	83 ec 0c             	sub    $0xc,%esp
+    1e2b:	68 ec 45 00 00       	push   $0x45ec
+    1e30:	e8 b6 1b 00 00       	call   39eb <mkdir>
+    1e35:	83 c4 10             	add    $0x10,%esp
+    1e38:	85 c0                	test   %eax,%eax
+    1e3a:	0f 85 14 05 00 00    	jne    2354 <subdir+0x5b4>
+  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+    1e40:	83 ec 08             	sub    $0x8,%esp
+    1e43:	68 02 02 00 00       	push   $0x202
+    1e48:	68 0e 46 00 00       	push   $0x460e
+    1e4d:	e8 71 1b 00 00       	call   39c3 <open>
+  if(fd < 0){
+    1e52:	83 c4 10             	add    $0x10,%esp
+  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+    1e55:	89 c3                	mov    %eax,%ebx
+  if(fd < 0){
+    1e57:	85 c0                	test   %eax,%eax
+    1e59:	0f 88 24 04 00 00    	js     2283 <subdir+0x4e3>
+  write(fd, "FF", 2);
+    1e5f:	83 ec 04             	sub    $0x4,%esp
+    1e62:	6a 02                	push   $0x2
+    1e64:	68 2f 46 00 00       	push   $0x462f
+    1e69:	50                   	push   %eax
+    1e6a:	e8 34 1b 00 00       	call   39a3 <write>
+  close(fd);
+    1e6f:	89 1c 24             	mov    %ebx,(%esp)
+    1e72:	e8 34 1b 00 00       	call   39ab <close>
+  fd = open("dd/dd/../ff", 0);
+    1e77:	58                   	pop    %eax
+    1e78:	5a                   	pop    %edx
+    1e79:	6a 00                	push   $0x0
+    1e7b:	68 32 46 00 00       	push   $0x4632
+    1e80:	e8 3e 1b 00 00       	call   39c3 <open>
+  if(fd < 0){
+    1e85:	83 c4 10             	add    $0x10,%esp
+  fd = open("dd/dd/../ff", 0);
+    1e88:	89 c3                	mov    %eax,%ebx
+  if(fd < 0){
+    1e8a:	85 c0                	test   %eax,%eax
+    1e8c:	0f 88 de 03 00 00    	js     2270 <subdir+0x4d0>
+  cc = read(fd, buf, sizeof(buf));
+    1e92:	83 ec 04             	sub    $0x4,%esp
+    1e95:	68 00 20 00 00       	push   $0x2000
+    1e9a:	68 e0 86 00 00       	push   $0x86e0
+    1e9f:	50                   	push   %eax
+    1ea0:	e8 f6 1a 00 00       	call   399b <read>
+  if(cc != 2 || buf[0] != 'f'){
+    1ea5:	83 c4 10             	add    $0x10,%esp
+    1ea8:	83 f8 02             	cmp    $0x2,%eax
+    1eab:	0f 85 3a 03 00 00    	jne    21eb <subdir+0x44b>
+    1eb1:	80 3d e0 86 00 00 66 	cmpb   $0x66,0x86e0
+    1eb8:	0f 85 2d 03 00 00    	jne    21eb <subdir+0x44b>
+  close(fd);
+    1ebe:	83 ec 0c             	sub    $0xc,%esp
+    1ec1:	53                   	push   %ebx
+    1ec2:	e8 e4 1a 00 00       	call   39ab <close>
+  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+    1ec7:	59                   	pop    %ecx
+    1ec8:	5b                   	pop    %ebx
+    1ec9:	68 72 46 00 00       	push   $0x4672
+    1ece:	68 0e 46 00 00       	push   $0x460e
+    1ed3:	e8 0b 1b 00 00       	call   39e3 <link>
+    1ed8:	83 c4 10             	add    $0x10,%esp
+    1edb:	85 c0                	test   %eax,%eax
+    1edd:	0f 85 c6 03 00 00    	jne    22a9 <subdir+0x509>
+  if(unlink("dd/dd/ff") != 0){
+    1ee3:	83 ec 0c             	sub    $0xc,%esp
+    1ee6:	68 0e 46 00 00       	push   $0x460e
+    1eeb:	e8 e3 1a 00 00       	call   39d3 <unlink>
+    1ef0:	83 c4 10             	add    $0x10,%esp
+    1ef3:	85 c0                	test   %eax,%eax
+    1ef5:	0f 85 16 03 00 00    	jne    2211 <subdir+0x471>
+  if(open("dd/dd/ff", O_RDONLY) >= 0){
+    1efb:	83 ec 08             	sub    $0x8,%esp
+    1efe:	6a 00                	push   $0x0
+    1f00:	68 0e 46 00 00       	push   $0x460e
+    1f05:	e8 b9 1a 00 00       	call   39c3 <open>
+    1f0a:	83 c4 10             	add    $0x10,%esp
+    1f0d:	85 c0                	test   %eax,%eax
+    1f0f:	0f 89 2c 04 00 00    	jns    2341 <subdir+0x5a1>
+  if(chdir("dd") != 0){
+    1f15:	83 ec 0c             	sub    $0xc,%esp
+    1f18:	68 d8 46 00 00       	push   $0x46d8
+    1f1d:	e8 d1 1a 00 00       	call   39f3 <chdir>
+    1f22:	83 c4 10             	add    $0x10,%esp
+    1f25:	85 c0                	test   %eax,%eax
+    1f27:	0f 85 01 04 00 00    	jne    232e <subdir+0x58e>
+  if(chdir("dd/../../dd") != 0){
+    1f2d:	83 ec 0c             	sub    $0xc,%esp
+    1f30:	68 a6 46 00 00       	push   $0x46a6
+    1f35:	e8 b9 1a 00 00       	call   39f3 <chdir>
+    1f3a:	83 c4 10             	add    $0x10,%esp
+    1f3d:	85 c0                	test   %eax,%eax
+    1f3f:	0f 85 b9 02 00 00    	jne    21fe <subdir+0x45e>
+  if(chdir("dd/../../../dd") != 0){
+    1f45:	83 ec 0c             	sub    $0xc,%esp
+    1f48:	68 cc 46 00 00       	push   $0x46cc
+    1f4d:	e8 a1 1a 00 00       	call   39f3 <chdir>
+    1f52:	83 c4 10             	add    $0x10,%esp
+    1f55:	85 c0                	test   %eax,%eax
+    1f57:	0f 85 a1 02 00 00    	jne    21fe <subdir+0x45e>
+  if(chdir("./..") != 0){
+    1f5d:	83 ec 0c             	sub    $0xc,%esp
+    1f60:	68 db 46 00 00       	push   $0x46db
+    1f65:	e8 89 1a 00 00       	call   39f3 <chdir>
+    1f6a:	83 c4 10             	add    $0x10,%esp
+    1f6d:	85 c0                	test   %eax,%eax
+    1f6f:	0f 85 21 03 00 00    	jne    2296 <subdir+0x4f6>
+  fd = open("dd/dd/ffff", 0);
+    1f75:	83 ec 08             	sub    $0x8,%esp
+    1f78:	6a 00                	push   $0x0
+    1f7a:	68 72 46 00 00       	push   $0x4672
+    1f7f:	e8 3f 1a 00 00       	call   39c3 <open>
+  if(fd < 0){
+    1f84:	83 c4 10             	add    $0x10,%esp
+  fd = open("dd/dd/ffff", 0);
+    1f87:	89 c3                	mov    %eax,%ebx
+  if(fd < 0){
+    1f89:	85 c0                	test   %eax,%eax
+    1f8b:	0f 88 e0 04 00 00    	js     2471 <subdir+0x6d1>
+  if(read(fd, buf, sizeof(buf)) != 2){
+    1f91:	83 ec 04             	sub    $0x4,%esp
+    1f94:	68 00 20 00 00       	push   $0x2000
+    1f99:	68 e0 86 00 00       	push   $0x86e0
+    1f9e:	50                   	push   %eax
+    1f9f:	e8 f7 19 00 00       	call   399b <read>
+    1fa4:	83 c4 10             	add    $0x10,%esp
+    1fa7:	83 f8 02             	cmp    $0x2,%eax
+    1faa:	0f 85 ae 04 00 00    	jne    245e <subdir+0x6be>
+  close(fd);
+    1fb0:	83 ec 0c             	sub    $0xc,%esp
+    1fb3:	53                   	push   %ebx
+    1fb4:	e8 f2 19 00 00       	call   39ab <close>
+  if(open("dd/dd/ff", O_RDONLY) >= 0){
+    1fb9:	58                   	pop    %eax
+    1fba:	5a                   	pop    %edx
+    1fbb:	6a 00                	push   $0x0
+    1fbd:	68 0e 46 00 00       	push   $0x460e
+    1fc2:	e8 fc 19 00 00       	call   39c3 <open>
+    1fc7:	83 c4 10             	add    $0x10,%esp
+    1fca:	85 c0                	test   %eax,%eax
+    1fcc:	0f 89 65 02 00 00    	jns    2237 <subdir+0x497>
+  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+    1fd2:	83 ec 08             	sub    $0x8,%esp
+    1fd5:	68 02 02 00 00       	push   $0x202
+    1fda:	68 26 47 00 00       	push   $0x4726
+    1fdf:	e8 df 19 00 00       	call   39c3 <open>
+    1fe4:	83 c4 10             	add    $0x10,%esp
+    1fe7:	85 c0                	test   %eax,%eax
+    1fe9:	0f 89 35 02 00 00    	jns    2224 <subdir+0x484>
+  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+    1fef:	83 ec 08             	sub    $0x8,%esp
+    1ff2:	68 02 02 00 00       	push   $0x202
+    1ff7:	68 4b 47 00 00       	push   $0x474b
+    1ffc:	e8 c2 19 00 00       	call   39c3 <open>
+    2001:	83 c4 10             	add    $0x10,%esp
+    2004:	85 c0                	test   %eax,%eax
+    2006:	0f 89 0f 03 00 00    	jns    231b <subdir+0x57b>
+  if(open("dd", O_CREATE) >= 0){
+    200c:	83 ec 08             	sub    $0x8,%esp
+    200f:	68 00 02 00 00       	push   $0x200
+    2014:	68 d8 46 00 00       	push   $0x46d8
+    2019:	e8 a5 19 00 00       	call   39c3 <open>
+    201e:	83 c4 10             	add    $0x10,%esp
+    2021:	85 c0                	test   %eax,%eax
+    2023:	0f 89 df 02 00 00    	jns    2308 <subdir+0x568>
+  if(open("dd", O_RDWR) >= 0){
+    2029:	83 ec 08             	sub    $0x8,%esp
+    202c:	6a 02                	push   $0x2
+    202e:	68 d8 46 00 00       	push   $0x46d8
+    2033:	e8 8b 19 00 00       	call   39c3 <open>
+    2038:	83 c4 10             	add    $0x10,%esp
+    203b:	85 c0                	test   %eax,%eax
+    203d:	0f 89 b2 02 00 00    	jns    22f5 <subdir+0x555>
+  if(open("dd", O_WRONLY) >= 0){
+    2043:	83 ec 08             	sub    $0x8,%esp
+    2046:	6a 01                	push   $0x1
+    2048:	68 d8 46 00 00       	push   $0x46d8
+    204d:	e8 71 19 00 00       	call   39c3 <open>
+    2052:	83 c4 10             	add    $0x10,%esp
+    2055:	85 c0                	test   %eax,%eax
+    2057:	0f 89 85 02 00 00    	jns    22e2 <subdir+0x542>
+  if(link("dd/ff/ff", "dd/dd/xx") == 0){
+    205d:	83 ec 08             	sub    $0x8,%esp
+    2060:	68 ba 47 00 00       	push   $0x47ba
+    2065:	68 26 47 00 00       	push   $0x4726
+    206a:	e8 74 19 00 00       	call   39e3 <link>
+    206f:	83 c4 10             	add    $0x10,%esp
+    2072:	85 c0                	test   %eax,%eax
+    2074:	0f 84 55 02 00 00    	je     22cf <subdir+0x52f>
+  if(link("dd/xx/ff", "dd/dd/xx") == 0){
+    207a:	83 ec 08             	sub    $0x8,%esp
+    207d:	68 ba 47 00 00       	push   $0x47ba
+    2082:	68 4b 47 00 00       	push   $0x474b
+    2087:	e8 57 19 00 00       	call   39e3 <link>
+    208c:	83 c4 10             	add    $0x10,%esp
+    208f:	85 c0                	test   %eax,%eax
+    2091:	0f 84 25 02 00 00    	je     22bc <subdir+0x51c>
+  if(link("dd/ff", "dd/dd/ffff") == 0){
+    2097:	83 ec 08             	sub    $0x8,%esp
+    209a:	68 72 46 00 00       	push   $0x4672
+    209f:	68 11 46 00 00       	push   $0x4611
+    20a4:	e8 3a 19 00 00       	call   39e3 <link>
+    20a9:	83 c4 10             	add    $0x10,%esp
+    20ac:	85 c0                	test   %eax,%eax
+    20ae:	0f 84 a9 01 00 00    	je     225d <subdir+0x4bd>
+  if(mkdir("dd/ff/ff") == 0){
+    20b4:	83 ec 0c             	sub    $0xc,%esp
+    20b7:	68 26 47 00 00       	push   $0x4726
+    20bc:	e8 2a 19 00 00       	call   39eb <mkdir>
+    20c1:	83 c4 10             	add    $0x10,%esp
+    20c4:	85 c0                	test   %eax,%eax
+    20c6:	0f 84 7e 01 00 00    	je     224a <subdir+0x4aa>
+  if(mkdir("dd/xx/ff") == 0){
+    20cc:	83 ec 0c             	sub    $0xc,%esp
+    20cf:	68 4b 47 00 00       	push   $0x474b
+    20d4:	e8 12 19 00 00       	call   39eb <mkdir>
+    20d9:	83 c4 10             	add    $0x10,%esp
+    20dc:	85 c0                	test   %eax,%eax
+    20de:	0f 84 67 03 00 00    	je     244b <subdir+0x6ab>
+  if(mkdir("dd/dd/ffff") == 0){
+    20e4:	83 ec 0c             	sub    $0xc,%esp
+    20e7:	68 72 46 00 00       	push   $0x4672
+    20ec:	e8 fa 18 00 00       	call   39eb <mkdir>
+    20f1:	83 c4 10             	add    $0x10,%esp
+    20f4:	85 c0                	test   %eax,%eax
+    20f6:	0f 84 3c 03 00 00    	je     2438 <subdir+0x698>
+  if(unlink("dd/xx/ff") == 0){
+    20fc:	83 ec 0c             	sub    $0xc,%esp
+    20ff:	68 4b 47 00 00       	push   $0x474b
+    2104:	e8 ca 18 00 00       	call   39d3 <unlink>
+    2109:	83 c4 10             	add    $0x10,%esp
+    210c:	85 c0                	test   %eax,%eax
+    210e:	0f 84 11 03 00 00    	je     2425 <subdir+0x685>
+  if(unlink("dd/ff/ff") == 0){
+    2114:	83 ec 0c             	sub    $0xc,%esp
+    2117:	68 26 47 00 00       	push   $0x4726
+    211c:	e8 b2 18 00 00       	call   39d3 <unlink>
+    2121:	83 c4 10             	add    $0x10,%esp
+    2124:	85 c0                	test   %eax,%eax
+    2126:	0f 84 e6 02 00 00    	je     2412 <subdir+0x672>
+  if(chdir("dd/ff") == 0){
+    212c:	83 ec 0c             	sub    $0xc,%esp
+    212f:	68 11 46 00 00       	push   $0x4611
+    2134:	e8 ba 18 00 00       	call   39f3 <chdir>
+    2139:	83 c4 10             	add    $0x10,%esp
+    213c:	85 c0                	test   %eax,%eax
+    213e:	0f 84 bb 02 00 00    	je     23ff <subdir+0x65f>
+  if(chdir("dd/xx") == 0){
+    2144:	83 ec 0c             	sub    $0xc,%esp
+    2147:	68 bd 47 00 00       	push   $0x47bd
+    214c:	e8 a2 18 00 00       	call   39f3 <chdir>
+    2151:	83 c4 10             	add    $0x10,%esp
+    2154:	85 c0                	test   %eax,%eax
+    2156:	0f 84 90 02 00 00    	je     23ec <subdir+0x64c>
+  if(unlink("dd/dd/ffff") != 0){
+    215c:	83 ec 0c             	sub    $0xc,%esp
+    215f:	68 72 46 00 00       	push   $0x4672
+    2164:	e8 6a 18 00 00       	call   39d3 <unlink>
+    2169:	83 c4 10             	add    $0x10,%esp
+    216c:	85 c0                	test   %eax,%eax
+    216e:	0f 85 9d 00 00 00    	jne    2211 <subdir+0x471>
+  if(unlink("dd/ff") != 0){
+    2174:	83 ec 0c             	sub    $0xc,%esp
+    2177:	68 11 46 00 00       	push   $0x4611
+    217c:	e8 52 18 00 00       	call   39d3 <unlink>
+    2181:	83 c4 10             	add    $0x10,%esp
+    2184:	85 c0                	test   %eax,%eax
+    2186:	0f 85 4d 02 00 00    	jne    23d9 <subdir+0x639>
+  if(unlink("dd") == 0){
+    218c:	83 ec 0c             	sub    $0xc,%esp
+    218f:	68 d8 46 00 00       	push   $0x46d8
+    2194:	e8 3a 18 00 00       	call   39d3 <unlink>
+    2199:	83 c4 10             	add    $0x10,%esp
+    219c:	85 c0                	test   %eax,%eax
+    219e:	0f 84 22 02 00 00    	je     23c6 <subdir+0x626>
+  if(unlink("dd/dd") < 0){
+    21a4:	83 ec 0c             	sub    $0xc,%esp
+    21a7:	68 ed 45 00 00       	push   $0x45ed
+    21ac:	e8 22 18 00 00       	call   39d3 <unlink>
+    21b1:	83 c4 10             	add    $0x10,%esp
+    21b4:	85 c0                	test   %eax,%eax
+    21b6:	0f 88 f7 01 00 00    	js     23b3 <subdir+0x613>
+  if(unlink("dd") < 0){
+    21bc:	83 ec 0c             	sub    $0xc,%esp
+    21bf:	68 d8 46 00 00       	push   $0x46d8
+    21c4:	e8 0a 18 00 00       	call   39d3 <unlink>
+    21c9:	83 c4 10             	add    $0x10,%esp
+    21cc:	85 c0                	test   %eax,%eax
+    21ce:	0f 88 cc 01 00 00    	js     23a0 <subdir+0x600>
+  printf(1, "subdir ok\n");
+    21d4:	83 ec 08             	sub    $0x8,%esp
+    21d7:	68 ba 48 00 00       	push   $0x48ba
+    21dc:	6a 01                	push   $0x1
+    21de:	e8 1d 19 00 00       	call   3b00 <printf>
+}
+    21e3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+    21e6:	83 c4 10             	add    $0x10,%esp
+    21e9:	c9                   	leave  
+    21ea:	c3                   	ret    
+    printf(1, "dd/dd/../ff wrong content\n");
+    21eb:	50                   	push   %eax
+    21ec:	50                   	push   %eax
+    21ed:	68 57 46 00 00       	push   $0x4657
+    21f2:	6a 01                	push   $0x1
+    21f4:	e8 07 19 00 00       	call   3b00 <printf>
+    exit();
+    21f9:	e8 85 17 00 00       	call   3983 <exit>
+    printf(1, "chdir dd/../../dd failed\n");
+    21fe:	50                   	push   %eax
+    21ff:	50                   	push   %eax
+    2200:	68 b2 46 00 00       	push   $0x46b2
+    2205:	6a 01                	push   $0x1
+    2207:	e8 f4 18 00 00       	call   3b00 <printf>
+    exit();
+    220c:	e8 72 17 00 00       	call   3983 <exit>
+    printf(1, "unlink dd/dd/ff failed\n");
+    2211:	50                   	push   %eax
+    2212:	50                   	push   %eax
+    2213:	68 7d 46 00 00       	push   $0x467d
+    2218:	6a 01                	push   $0x1
+    221a:	e8 e1 18 00 00       	call   3b00 <printf>
+    exit();
+    221f:	e8 5f 17 00 00       	call   3983 <exit>
+    printf(1, "create dd/ff/ff succeeded!\n");
+    2224:	51                   	push   %ecx
+    2225:	51                   	push   %ecx
+    2226:	68 2f 47 00 00       	push   $0x472f
+    222b:	6a 01                	push   $0x1
+    222d:	e8 ce 18 00 00       	call   3b00 <printf>
+    exit();
+    2232:	e8 4c 17 00 00       	call   3983 <exit>
+    printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
+    2237:	53                   	push   %ebx
+    2238:	53                   	push   %ebx
+    2239:	68 14 51 00 00       	push   $0x5114
+    223e:	6a 01                	push   $0x1
+    2240:	e8 bb 18 00 00       	call   3b00 <printf>
+    exit();
+    2245:	e8 39 17 00 00       	call   3983 <exit>
+    printf(1, "mkdir dd/ff/ff succeeded!\n");
+    224a:	51                   	push   %ecx
+    224b:	51                   	push   %ecx
+    224c:	68 c3 47 00 00       	push   $0x47c3
+    2251:	6a 01                	push   $0x1
+    2253:	e8 a8 18 00 00       	call   3b00 <printf>
+    exit();
+    2258:	e8 26 17 00 00       	call   3983 <exit>
+    printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
+    225d:	53                   	push   %ebx
+    225e:	53                   	push   %ebx
+    225f:	68 84 51 00 00       	push   $0x5184
+    2264:	6a 01                	push   $0x1
+    2266:	e8 95 18 00 00       	call   3b00 <printf>
+    exit();
+    226b:	e8 13 17 00 00       	call   3983 <exit>
+    printf(1, "open dd/dd/../ff failed\n");
+    2270:	50                   	push   %eax
+    2271:	50                   	push   %eax
+    2272:	68 3e 46 00 00       	push   $0x463e
+    2277:	6a 01                	push   $0x1
+    2279:	e8 82 18 00 00       	call   3b00 <printf>
+    exit();
+    227e:	e8 00 17 00 00       	call   3983 <exit>
+    printf(1, "create dd/dd/ff failed\n");
+    2283:	51                   	push   %ecx
+    2284:	51                   	push   %ecx
+    2285:	68 17 46 00 00       	push   $0x4617
+    228a:	6a 01                	push   $0x1
+    228c:	e8 6f 18 00 00       	call   3b00 <printf>
+    exit();
+    2291:	e8 ed 16 00 00       	call   3983 <exit>
+    printf(1, "chdir ./.. failed\n");
+    2296:	50                   	push   %eax
+    2297:	50                   	push   %eax
+    2298:	68 e0 46 00 00       	push   $0x46e0
+    229d:	6a 01                	push   $0x1
+    229f:	e8 5c 18 00 00       	call   3b00 <printf>
+    exit();
+    22a4:	e8 da 16 00 00       	call   3983 <exit>
+    printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
+    22a9:	52                   	push   %edx
+    22aa:	52                   	push   %edx
+    22ab:	68 cc 50 00 00       	push   $0x50cc
+    22b0:	6a 01                	push   $0x1
+    22b2:	e8 49 18 00 00       	call   3b00 <printf>
+    exit();
+    22b7:	e8 c7 16 00 00       	call   3983 <exit>
+    printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
+    22bc:	50                   	push   %eax
+    22bd:	50                   	push   %eax
+    22be:	68 60 51 00 00       	push   $0x5160
+    22c3:	6a 01                	push   $0x1
+    22c5:	e8 36 18 00 00       	call   3b00 <printf>
+    exit();
+    22ca:	e8 b4 16 00 00       	call   3983 <exit>
+    printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
+    22cf:	50                   	push   %eax
+    22d0:	50                   	push   %eax
+    22d1:	68 3c 51 00 00       	push   $0x513c
+    22d6:	6a 01                	push   $0x1
+    22d8:	e8 23 18 00 00       	call   3b00 <printf>
+    exit();
+    22dd:	e8 a1 16 00 00       	call   3983 <exit>
+    printf(1, "open dd wronly succeeded!\n");
+    22e2:	50                   	push   %eax
+    22e3:	50                   	push   %eax
+    22e4:	68 9f 47 00 00       	push   $0x479f
+    22e9:	6a 01                	push   $0x1
+    22eb:	e8 10 18 00 00       	call   3b00 <printf>
+    exit();
+    22f0:	e8 8e 16 00 00       	call   3983 <exit>
+    printf(1, "open dd rdwr succeeded!\n");
+    22f5:	50                   	push   %eax
+    22f6:	50                   	push   %eax
+    22f7:	68 86 47 00 00       	push   $0x4786
+    22fc:	6a 01                	push   $0x1
+    22fe:	e8 fd 17 00 00       	call   3b00 <printf>
+    exit();
+    2303:	e8 7b 16 00 00       	call   3983 <exit>
+    printf(1, "create dd succeeded!\n");
+    2308:	50                   	push   %eax
+    2309:	50                   	push   %eax
+    230a:	68 70 47 00 00       	push   $0x4770
+    230f:	6a 01                	push   $0x1
+    2311:	e8 ea 17 00 00       	call   3b00 <printf>
+    exit();
+    2316:	e8 68 16 00 00       	call   3983 <exit>
+    printf(1, "create dd/xx/ff succeeded!\n");
+    231b:	52                   	push   %edx
+    231c:	52                   	push   %edx
+    231d:	68 54 47 00 00       	push   $0x4754
+    2322:	6a 01                	push   $0x1
+    2324:	e8 d7 17 00 00       	call   3b00 <printf>
+    exit();
+    2329:	e8 55 16 00 00       	call   3983 <exit>
+    printf(1, "chdir dd failed\n");
+    232e:	50                   	push   %eax
+    232f:	50                   	push   %eax
+    2330:	68 95 46 00 00       	push   $0x4695
+    2335:	6a 01                	push   $0x1
+    2337:	e8 c4 17 00 00       	call   3b00 <printf>
+    exit();
+    233c:	e8 42 16 00 00       	call   3983 <exit>
+    printf(1, "open (unlinked) dd/dd/ff succeeded\n");
+    2341:	50                   	push   %eax
+    2342:	50                   	push   %eax
+    2343:	68 f0 50 00 00       	push   $0x50f0
+    2348:	6a 01                	push   $0x1
+    234a:	e8 b1 17 00 00       	call   3b00 <printf>
+    exit();
+    234f:	e8 2f 16 00 00       	call   3983 <exit>
+    printf(1, "subdir mkdir dd/dd failed\n");
+    2354:	53                   	push   %ebx
+    2355:	53                   	push   %ebx
+    2356:	68 f3 45 00 00       	push   $0x45f3
+    235b:	6a 01                	push   $0x1
+    235d:	e8 9e 17 00 00       	call   3b00 <printf>
+    exit();
+    2362:	e8 1c 16 00 00       	call   3983 <exit>
+    printf(1, "unlink dd (non-empty dir) succeeded!\n");
+    2367:	50                   	push   %eax
+    2368:	50                   	push   %eax
+    2369:	68 a4 50 00 00       	push   $0x50a4
+    236e:	6a 01                	push   $0x1
+    2370:	e8 8b 17 00 00       	call   3b00 <printf>
+    exit();
+    2375:	e8 09 16 00 00       	call   3983 <exit>
+    printf(1, "create dd/ff failed\n");
+    237a:	50                   	push   %eax
+    237b:	50                   	push   %eax
+    237c:	68 d7 45 00 00       	push   $0x45d7
+    2381:	6a 01                	push   $0x1
+    2383:	e8 78 17 00 00       	call   3b00 <printf>
+    exit();
+    2388:	e8 f6 15 00 00       	call   3983 <exit>
+    printf(1, "subdir mkdir dd failed\n");
+    238d:	50                   	push   %eax
+    238e:	50                   	push   %eax
+    238f:	68 bf 45 00 00       	push   $0x45bf
+    2394:	6a 01                	push   $0x1
+    2396:	e8 65 17 00 00       	call   3b00 <printf>
+    exit();
+    239b:	e8 e3 15 00 00       	call   3983 <exit>
+    printf(1, "unlink dd failed\n");
+    23a0:	50                   	push   %eax
+    23a1:	50                   	push   %eax
+    23a2:	68 a8 48 00 00       	push   $0x48a8
+    23a7:	6a 01                	push   $0x1
+    23a9:	e8 52 17 00 00       	call   3b00 <printf>
+    exit();
+    23ae:	e8 d0 15 00 00       	call   3983 <exit>
+    printf(1, "unlink dd/dd failed\n");
+    23b3:	52                   	push   %edx
+    23b4:	52                   	push   %edx
+    23b5:	68 93 48 00 00       	push   $0x4893
+    23ba:	6a 01                	push   $0x1
+    23bc:	e8 3f 17 00 00       	call   3b00 <printf>
+    exit();
+    23c1:	e8 bd 15 00 00       	call   3983 <exit>
+    printf(1, "unlink non-empty dd succeeded!\n");
+    23c6:	51                   	push   %ecx
+    23c7:	51                   	push   %ecx
+    23c8:	68 a8 51 00 00       	push   $0x51a8
+    23cd:	6a 01                	push   $0x1
+    23cf:	e8 2c 17 00 00       	call   3b00 <printf>
+    exit();
+    23d4:	e8 aa 15 00 00       	call   3983 <exit>
+    printf(1, "unlink dd/ff failed\n");
+    23d9:	53                   	push   %ebx
+    23da:	53                   	push   %ebx
+    23db:	68 7e 48 00 00       	push   $0x487e
+    23e0:	6a 01                	push   $0x1
+    23e2:	e8 19 17 00 00       	call   3b00 <printf>
+    exit();
+    23e7:	e8 97 15 00 00       	call   3983 <exit>
+    printf(1, "chdir dd/xx succeeded!\n");
+    23ec:	50                   	push   %eax
+    23ed:	50                   	push   %eax
+    23ee:	68 66 48 00 00       	push   $0x4866
+    23f3:	6a 01                	push   $0x1
+    23f5:	e8 06 17 00 00       	call   3b00 <printf>
+    exit();
+    23fa:	e8 84 15 00 00       	call   3983 <exit>
+    printf(1, "chdir dd/ff succeeded!\n");
+    23ff:	50                   	push   %eax
+    2400:	50                   	push   %eax
+    2401:	68 4e 48 00 00       	push   $0x484e
+    2406:	6a 01                	push   $0x1
+    2408:	e8 f3 16 00 00       	call   3b00 <printf>
+    exit();
+    240d:	e8 71 15 00 00       	call   3983 <exit>
+    printf(1, "unlink dd/ff/ff succeeded!\n");
+    2412:	50                   	push   %eax
+    2413:	50                   	push   %eax
+    2414:	68 32 48 00 00       	push   $0x4832
+    2419:	6a 01                	push   $0x1
+    241b:	e8 e0 16 00 00       	call   3b00 <printf>
+    exit();
+    2420:	e8 5e 15 00 00       	call   3983 <exit>
+    printf(1, "unlink dd/xx/ff succeeded!\n");
+    2425:	50                   	push   %eax
+    2426:	50                   	push   %eax
+    2427:	68 16 48 00 00       	push   $0x4816
+    242c:	6a 01                	push   $0x1
+    242e:	e8 cd 16 00 00       	call   3b00 <printf>
+    exit();
+    2433:	e8 4b 15 00 00       	call   3983 <exit>
+    printf(1, "mkdir dd/dd/ffff succeeded!\n");
+    2438:	50                   	push   %eax
+    2439:	50                   	push   %eax
+    243a:	68 f9 47 00 00       	push   $0x47f9
+    243f:	6a 01                	push   $0x1
+    2441:	e8 ba 16 00 00       	call   3b00 <printf>
+    exit();
+    2446:	e8 38 15 00 00       	call   3983 <exit>
+    printf(1, "mkdir dd/xx/ff succeeded!\n");
+    244b:	52                   	push   %edx
+    244c:	52                   	push   %edx
+    244d:	68 de 47 00 00       	push   $0x47de
+    2452:	6a 01                	push   $0x1
+    2454:	e8 a7 16 00 00       	call   3b00 <printf>
+    exit();
+    2459:	e8 25 15 00 00       	call   3983 <exit>
+    printf(1, "read dd/dd/ffff wrong len\n");
+    245e:	51                   	push   %ecx
+    245f:	51                   	push   %ecx
+    2460:	68 0b 47 00 00       	push   $0x470b
+    2465:	6a 01                	push   $0x1
+    2467:	e8 94 16 00 00       	call   3b00 <printf>
+    exit();
+    246c:	e8 12 15 00 00       	call   3983 <exit>
+    printf(1, "open dd/dd/ffff failed\n");
+    2471:	53                   	push   %ebx
+    2472:	53                   	push   %ebx
+    2473:	68 f3 46 00 00       	push   $0x46f3
+    2478:	6a 01                	push   $0x1
+    247a:	e8 81 16 00 00       	call   3b00 <printf>
+    exit();
+    247f:	e8 ff 14 00 00       	call   3983 <exit>
+    2484:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    248b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    248f:	90                   	nop
+
+00002490 <bigwrite>:
+{
+    2490:	f3 0f 1e fb          	endbr32 
+    2494:	55                   	push   %ebp
+    2495:	89 e5                	mov    %esp,%ebp
+    2497:	56                   	push   %esi
+    2498:	53                   	push   %ebx
+  for(sz = 499; sz < 12*512; sz += 471){
+    2499:	bb f3 01 00 00       	mov    $0x1f3,%ebx
+  printf(1, "bigwrite test\n");
+    249e:	83 ec 08             	sub    $0x8,%esp
+    24a1:	68 c5 48 00 00       	push   $0x48c5
+    24a6:	6a 01                	push   $0x1
+    24a8:	e8 53 16 00 00       	call   3b00 <printf>
+  unlink("bigwrite");
+    24ad:	c7 04 24 d4 48 00 00 	movl   $0x48d4,(%esp)
+    24b4:	e8 1a 15 00 00       	call   39d3 <unlink>
+    24b9:	83 c4 10             	add    $0x10,%esp
+    24bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    fd = open("bigwrite", O_CREATE | O_RDWR);
+    24c0:	83 ec 08             	sub    $0x8,%esp
+    24c3:	68 02 02 00 00       	push   $0x202
+    24c8:	68 d4 48 00 00       	push   $0x48d4
+    24cd:	e8 f1 14 00 00       	call   39c3 <open>
+    if(fd < 0){
+    24d2:	83 c4 10             	add    $0x10,%esp
+    fd = open("bigwrite", O_CREATE | O_RDWR);
+    24d5:	89 c6                	mov    %eax,%esi
+    if(fd < 0){
+    24d7:	85 c0                	test   %eax,%eax
+    24d9:	78 7e                	js     2559 <bigwrite+0xc9>
+      int cc = write(fd, buf, sz);
+    24db:	83 ec 04             	sub    $0x4,%esp
+    24de:	53                   	push   %ebx
+    24df:	68 e0 86 00 00       	push   $0x86e0
+    24e4:	50                   	push   %eax
+    24e5:	e8 b9 14 00 00       	call   39a3 <write>
+      if(cc != sz){
+    24ea:	83 c4 10             	add    $0x10,%esp
+    24ed:	39 d8                	cmp    %ebx,%eax
+    24ef:	75 55                	jne    2546 <bigwrite+0xb6>
+      int cc = write(fd, buf, sz);
+    24f1:	83 ec 04             	sub    $0x4,%esp
+    24f4:	53                   	push   %ebx
+    24f5:	68 e0 86 00 00       	push   $0x86e0
+    24fa:	56                   	push   %esi
+    24fb:	e8 a3 14 00 00       	call   39a3 <write>
+      if(cc != sz){
+    2500:	83 c4 10             	add    $0x10,%esp
+    2503:	39 d8                	cmp    %ebx,%eax
+    2505:	75 3f                	jne    2546 <bigwrite+0xb6>
+    close(fd);
+    2507:	83 ec 0c             	sub    $0xc,%esp
+  for(sz = 499; sz < 12*512; sz += 471){
+    250a:	81 c3 d7 01 00 00    	add    $0x1d7,%ebx
+    close(fd);
+    2510:	56                   	push   %esi
+    2511:	e8 95 14 00 00       	call   39ab <close>
+    unlink("bigwrite");
+    2516:	c7 04 24 d4 48 00 00 	movl   $0x48d4,(%esp)
+    251d:	e8 b1 14 00 00       	call   39d3 <unlink>
+  for(sz = 499; sz < 12*512; sz += 471){
+    2522:	83 c4 10             	add    $0x10,%esp
+    2525:	81 fb 07 18 00 00    	cmp    $0x1807,%ebx
+    252b:	75 93                	jne    24c0 <bigwrite+0x30>
+  printf(1, "bigwrite ok\n");
+    252d:	83 ec 08             	sub    $0x8,%esp
+    2530:	68 07 49 00 00       	push   $0x4907
+    2535:	6a 01                	push   $0x1
+    2537:	e8 c4 15 00 00       	call   3b00 <printf>
+}
+    253c:	83 c4 10             	add    $0x10,%esp
+    253f:	8d 65 f8             	lea    -0x8(%ebp),%esp
+    2542:	5b                   	pop    %ebx
+    2543:	5e                   	pop    %esi
+    2544:	5d                   	pop    %ebp
+    2545:	c3                   	ret    
+        printf(1, "write(%d) ret %d\n", sz, cc);
+    2546:	50                   	push   %eax
+    2547:	53                   	push   %ebx
+    2548:	68 f5 48 00 00       	push   $0x48f5
+    254d:	6a 01                	push   $0x1
+    254f:	e8 ac 15 00 00       	call   3b00 <printf>
+        exit();
+    2554:	e8 2a 14 00 00       	call   3983 <exit>
+      printf(1, "cannot create bigwrite\n");
+    2559:	83 ec 08             	sub    $0x8,%esp
+    255c:	68 dd 48 00 00       	push   $0x48dd
+    2561:	6a 01                	push   $0x1
+    2563:	e8 98 15 00 00       	call   3b00 <printf>
+      exit();
+    2568:	e8 16 14 00 00       	call   3983 <exit>
+    256d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00002570 <bigfile>:
+{
+    2570:	f3 0f 1e fb          	endbr32 
+    2574:	55                   	push   %ebp
+    2575:	89 e5                	mov    %esp,%ebp
+    2577:	57                   	push   %edi
+    2578:	56                   	push   %esi
+    2579:	53                   	push   %ebx
+    257a:	83 ec 14             	sub    $0x14,%esp
+  printf(1, "bigfile test\n");
+    257d:	68 14 49 00 00       	push   $0x4914
+    2582:	6a 01                	push   $0x1
+    2584:	e8 77 15 00 00       	call   3b00 <printf>
+  unlink("bigfile");
+    2589:	c7 04 24 30 49 00 00 	movl   $0x4930,(%esp)
+    2590:	e8 3e 14 00 00       	call   39d3 <unlink>
+  fd = open("bigfile", O_CREATE | O_RDWR);
+    2595:	58                   	pop    %eax
+    2596:	5a                   	pop    %edx
+    2597:	68 02 02 00 00       	push   $0x202
+    259c:	68 30 49 00 00       	push   $0x4930
+    25a1:	e8 1d 14 00 00       	call   39c3 <open>
+  if(fd < 0){
+    25a6:	83 c4 10             	add    $0x10,%esp
+    25a9:	85 c0                	test   %eax,%eax
+    25ab:	0f 88 5a 01 00 00    	js     270b <bigfile+0x19b>
+    25b1:	89 c6                	mov    %eax,%esi
+  for(i = 0; i < 20; i++){
+    25b3:	31 db                	xor    %ebx,%ebx
+    25b5:	8d 76 00             	lea    0x0(%esi),%esi
+    memset(buf, i, 600);
+    25b8:	83 ec 04             	sub    $0x4,%esp
+    25bb:	68 58 02 00 00       	push   $0x258
+    25c0:	53                   	push   %ebx
+    25c1:	68 e0 86 00 00       	push   $0x86e0
+    25c6:	e8 15 12 00 00       	call   37e0 <memset>
+    if(write(fd, buf, 600) != 600){
+    25cb:	83 c4 0c             	add    $0xc,%esp
+    25ce:	68 58 02 00 00       	push   $0x258
+    25d3:	68 e0 86 00 00       	push   $0x86e0
+    25d8:	56                   	push   %esi
+    25d9:	e8 c5 13 00 00       	call   39a3 <write>
+    25de:	83 c4 10             	add    $0x10,%esp
+    25e1:	3d 58 02 00 00       	cmp    $0x258,%eax
+    25e6:	0f 85 f8 00 00 00    	jne    26e4 <bigfile+0x174>
+  for(i = 0; i < 20; i++){
+    25ec:	83 c3 01             	add    $0x1,%ebx
+    25ef:	83 fb 14             	cmp    $0x14,%ebx
+    25f2:	75 c4                	jne    25b8 <bigfile+0x48>
+  close(fd);
+    25f4:	83 ec 0c             	sub    $0xc,%esp
+    25f7:	56                   	push   %esi
+    25f8:	e8 ae 13 00 00       	call   39ab <close>
+  fd = open("bigfile", 0);
+    25fd:	5e                   	pop    %esi
+    25fe:	5f                   	pop    %edi
+    25ff:	6a 00                	push   $0x0
+    2601:	68 30 49 00 00       	push   $0x4930
+    2606:	e8 b8 13 00 00       	call   39c3 <open>
+  if(fd < 0){
+    260b:	83 c4 10             	add    $0x10,%esp
+  fd = open("bigfile", 0);
+    260e:	89 c6                	mov    %eax,%esi
+  if(fd < 0){
+    2610:	85 c0                	test   %eax,%eax
+    2612:	0f 88 e0 00 00 00    	js     26f8 <bigfile+0x188>
+  total = 0;
+    2618:	31 db                	xor    %ebx,%ebx
+  for(i = 0; ; i++){
+    261a:	31 ff                	xor    %edi,%edi
+    261c:	eb 30                	jmp    264e <bigfile+0xde>
+    261e:	66 90                	xchg   %ax,%ax
+    if(cc != 300){
+    2620:	3d 2c 01 00 00       	cmp    $0x12c,%eax
+    2625:	0f 85 91 00 00 00    	jne    26bc <bigfile+0x14c>
+    if(buf[0] != i/2 || buf[299] != i/2){
+    262b:	89 fa                	mov    %edi,%edx
+    262d:	0f be 05 e0 86 00 00 	movsbl 0x86e0,%eax
+    2634:	d1 fa                	sar    %edx
+    2636:	39 d0                	cmp    %edx,%eax
+    2638:	75 6e                	jne    26a8 <bigfile+0x138>
+    263a:	0f be 15 0b 88 00 00 	movsbl 0x880b,%edx
+    2641:	39 d0                	cmp    %edx,%eax
+    2643:	75 63                	jne    26a8 <bigfile+0x138>
+    total += cc;
+    2645:	81 c3 2c 01 00 00    	add    $0x12c,%ebx
+  for(i = 0; ; i++){
+    264b:	83 c7 01             	add    $0x1,%edi
+    cc = read(fd, buf, 300);
+    264e:	83 ec 04             	sub    $0x4,%esp
+    2651:	68 2c 01 00 00       	push   $0x12c
+    2656:	68 e0 86 00 00       	push   $0x86e0
+    265b:	56                   	push   %esi
+    265c:	e8 3a 13 00 00       	call   399b <read>
+    if(cc < 0){
+    2661:	83 c4 10             	add    $0x10,%esp
+    2664:	85 c0                	test   %eax,%eax
+    2666:	78 68                	js     26d0 <bigfile+0x160>
+    if(cc == 0)
+    2668:	75 b6                	jne    2620 <bigfile+0xb0>
+  close(fd);
+    266a:	83 ec 0c             	sub    $0xc,%esp
+    266d:	56                   	push   %esi
+    266e:	e8 38 13 00 00       	call   39ab <close>
+  if(total != 20*600){
+    2673:	83 c4 10             	add    $0x10,%esp
+    2676:	81 fb e0 2e 00 00    	cmp    $0x2ee0,%ebx
+    267c:	0f 85 9c 00 00 00    	jne    271e <bigfile+0x1ae>
+  unlink("bigfile");
+    2682:	83 ec 0c             	sub    $0xc,%esp
+    2685:	68 30 49 00 00       	push   $0x4930
+    268a:	e8 44 13 00 00       	call   39d3 <unlink>
+  printf(1, "bigfile test ok\n");
+    268f:	58                   	pop    %eax
+    2690:	5a                   	pop    %edx
+    2691:	68 bf 49 00 00       	push   $0x49bf
+    2696:	6a 01                	push   $0x1
+    2698:	e8 63 14 00 00       	call   3b00 <printf>
+}
+    269d:	83 c4 10             	add    $0x10,%esp
+    26a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    26a3:	5b                   	pop    %ebx
+    26a4:	5e                   	pop    %esi
+    26a5:	5f                   	pop    %edi
+    26a6:	5d                   	pop    %ebp
+    26a7:	c3                   	ret    
+      printf(1, "read bigfile wrong data\n");
+    26a8:	83 ec 08             	sub    $0x8,%esp
+    26ab:	68 8c 49 00 00       	push   $0x498c
+    26b0:	6a 01                	push   $0x1
+    26b2:	e8 49 14 00 00       	call   3b00 <printf>
+      exit();
+    26b7:	e8 c7 12 00 00       	call   3983 <exit>
+      printf(1, "short read bigfile\n");
+    26bc:	83 ec 08             	sub    $0x8,%esp
+    26bf:	68 78 49 00 00       	push   $0x4978
+    26c4:	6a 01                	push   $0x1
+    26c6:	e8 35 14 00 00       	call   3b00 <printf>
+      exit();
+    26cb:	e8 b3 12 00 00       	call   3983 <exit>
+      printf(1, "read bigfile failed\n");
+    26d0:	83 ec 08             	sub    $0x8,%esp
+    26d3:	68 63 49 00 00       	push   $0x4963
+    26d8:	6a 01                	push   $0x1
+    26da:	e8 21 14 00 00       	call   3b00 <printf>
+      exit();
+    26df:	e8 9f 12 00 00       	call   3983 <exit>
+      printf(1, "write bigfile failed\n");
+    26e4:	83 ec 08             	sub    $0x8,%esp
+    26e7:	68 38 49 00 00       	push   $0x4938
+    26ec:	6a 01                	push   $0x1
+    26ee:	e8 0d 14 00 00       	call   3b00 <printf>
+      exit();
+    26f3:	e8 8b 12 00 00       	call   3983 <exit>
+    printf(1, "cannot open bigfile\n");
+    26f8:	53                   	push   %ebx
+    26f9:	53                   	push   %ebx
+    26fa:	68 4e 49 00 00       	push   $0x494e
+    26ff:	6a 01                	push   $0x1
+    2701:	e8 fa 13 00 00       	call   3b00 <printf>
+    exit();
+    2706:	e8 78 12 00 00       	call   3983 <exit>
+    printf(1, "cannot create bigfile");
+    270b:	50                   	push   %eax
+    270c:	50                   	push   %eax
+    270d:	68 22 49 00 00       	push   $0x4922
+    2712:	6a 01                	push   $0x1
+    2714:	e8 e7 13 00 00       	call   3b00 <printf>
+    exit();
+    2719:	e8 65 12 00 00       	call   3983 <exit>
+    printf(1, "read bigfile wrong total\n");
+    271e:	51                   	push   %ecx
+    271f:	51                   	push   %ecx
+    2720:	68 a5 49 00 00       	push   $0x49a5
+    2725:	6a 01                	push   $0x1
+    2727:	e8 d4 13 00 00       	call   3b00 <printf>
+    exit();
+    272c:	e8 52 12 00 00       	call   3983 <exit>
+    2731:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    2738:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    273f:	90                   	nop
+
+00002740 <fourteen>:
+{
+    2740:	f3 0f 1e fb          	endbr32 
+    2744:	55                   	push   %ebp
+    2745:	89 e5                	mov    %esp,%ebp
+    2747:	83 ec 10             	sub    $0x10,%esp
+  printf(1, "fourteen test\n");
+    274a:	68 d0 49 00 00       	push   $0x49d0
+    274f:	6a 01                	push   $0x1
+    2751:	e8 aa 13 00 00       	call   3b00 <printf>
+  if(mkdir("12345678901234") != 0){
+    2756:	c7 04 24 0b 4a 00 00 	movl   $0x4a0b,(%esp)
+    275d:	e8 89 12 00 00       	call   39eb <mkdir>
+    2762:	83 c4 10             	add    $0x10,%esp
+    2765:	85 c0                	test   %eax,%eax
+    2767:	0f 85 97 00 00 00    	jne    2804 <fourteen+0xc4>
+  if(mkdir("12345678901234/123456789012345") != 0){
+    276d:	83 ec 0c             	sub    $0xc,%esp
+    2770:	68 c8 51 00 00       	push   $0x51c8
+    2775:	e8 71 12 00 00       	call   39eb <mkdir>
+    277a:	83 c4 10             	add    $0x10,%esp
+    277d:	85 c0                	test   %eax,%eax
+    277f:	0f 85 de 00 00 00    	jne    2863 <fourteen+0x123>
+  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+    2785:	83 ec 08             	sub    $0x8,%esp
+    2788:	68 00 02 00 00       	push   $0x200
+    278d:	68 18 52 00 00       	push   $0x5218
+    2792:	e8 2c 12 00 00       	call   39c3 <open>
+  if(fd < 0){
+    2797:	83 c4 10             	add    $0x10,%esp
+    279a:	85 c0                	test   %eax,%eax
+    279c:	0f 88 ae 00 00 00    	js     2850 <fourteen+0x110>
+  close(fd);
+    27a2:	83 ec 0c             	sub    $0xc,%esp
+    27a5:	50                   	push   %eax
+    27a6:	e8 00 12 00 00       	call   39ab <close>
+  fd = open("12345678901234/12345678901234/12345678901234", 0);
+    27ab:	58                   	pop    %eax
+    27ac:	5a                   	pop    %edx
+    27ad:	6a 00                	push   $0x0
+    27af:	68 88 52 00 00       	push   $0x5288
+    27b4:	e8 0a 12 00 00       	call   39c3 <open>
+  if(fd < 0){
+    27b9:	83 c4 10             	add    $0x10,%esp
+    27bc:	85 c0                	test   %eax,%eax
+    27be:	78 7d                	js     283d <fourteen+0xfd>
+  close(fd);
+    27c0:	83 ec 0c             	sub    $0xc,%esp
+    27c3:	50                   	push   %eax
+    27c4:	e8 e2 11 00 00       	call   39ab <close>
+  if(mkdir("12345678901234/12345678901234") == 0){
+    27c9:	c7 04 24 fc 49 00 00 	movl   $0x49fc,(%esp)
+    27d0:	e8 16 12 00 00       	call   39eb <mkdir>
+    27d5:	83 c4 10             	add    $0x10,%esp
+    27d8:	85 c0                	test   %eax,%eax
+    27da:	74 4e                	je     282a <fourteen+0xea>
+  if(mkdir("123456789012345/12345678901234") == 0){
+    27dc:	83 ec 0c             	sub    $0xc,%esp
+    27df:	68 24 53 00 00       	push   $0x5324
+    27e4:	e8 02 12 00 00       	call   39eb <mkdir>
+    27e9:	83 c4 10             	add    $0x10,%esp
+    27ec:	85 c0                	test   %eax,%eax
+    27ee:	74 27                	je     2817 <fourteen+0xd7>
+  printf(1, "fourteen ok\n");
+    27f0:	83 ec 08             	sub    $0x8,%esp
+    27f3:	68 1a 4a 00 00       	push   $0x4a1a
+    27f8:	6a 01                	push   $0x1
+    27fa:	e8 01 13 00 00       	call   3b00 <printf>
+}
+    27ff:	83 c4 10             	add    $0x10,%esp
+    2802:	c9                   	leave  
+    2803:	c3                   	ret    
+    printf(1, "mkdir 12345678901234 failed\n");
+    2804:	50                   	push   %eax
+    2805:	50                   	push   %eax
+    2806:	68 df 49 00 00       	push   $0x49df
+    280b:	6a 01                	push   $0x1
+    280d:	e8 ee 12 00 00       	call   3b00 <printf>
+    exit();
+    2812:	e8 6c 11 00 00       	call   3983 <exit>
+    printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
+    2817:	50                   	push   %eax
+    2818:	50                   	push   %eax
+    2819:	68 44 53 00 00       	push   $0x5344
+    281e:	6a 01                	push   $0x1
+    2820:	e8 db 12 00 00       	call   3b00 <printf>
+    exit();
+    2825:	e8 59 11 00 00       	call   3983 <exit>
+    printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
+    282a:	52                   	push   %edx
+    282b:	52                   	push   %edx
+    282c:	68 f4 52 00 00       	push   $0x52f4
+    2831:	6a 01                	push   $0x1
+    2833:	e8 c8 12 00 00       	call   3b00 <printf>
+    exit();
+    2838:	e8 46 11 00 00       	call   3983 <exit>
+    printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
+    283d:	51                   	push   %ecx
+    283e:	51                   	push   %ecx
+    283f:	68 b8 52 00 00       	push   $0x52b8
+    2844:	6a 01                	push   $0x1
+    2846:	e8 b5 12 00 00       	call   3b00 <printf>
+    exit();
+    284b:	e8 33 11 00 00       	call   3983 <exit>
+    printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
+    2850:	51                   	push   %ecx
+    2851:	51                   	push   %ecx
+    2852:	68 48 52 00 00       	push   $0x5248
+    2857:	6a 01                	push   $0x1
+    2859:	e8 a2 12 00 00       	call   3b00 <printf>
+    exit();
+    285e:	e8 20 11 00 00       	call   3983 <exit>
+    printf(1, "mkdir 12345678901234/123456789012345 failed\n");
+    2863:	50                   	push   %eax
+    2864:	50                   	push   %eax
+    2865:	68 e8 51 00 00       	push   $0x51e8
+    286a:	6a 01                	push   $0x1
+    286c:	e8 8f 12 00 00       	call   3b00 <printf>
+    exit();
+    2871:	e8 0d 11 00 00       	call   3983 <exit>
+    2876:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    287d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00002880 <rmdot>:
+{
+    2880:	f3 0f 1e fb          	endbr32 
+    2884:	55                   	push   %ebp
+    2885:	89 e5                	mov    %esp,%ebp
+    2887:	83 ec 10             	sub    $0x10,%esp
+  printf(1, "rmdot test\n");
+    288a:	68 27 4a 00 00       	push   $0x4a27
+    288f:	6a 01                	push   $0x1
+    2891:	e8 6a 12 00 00       	call   3b00 <printf>
+  if(mkdir("dots") != 0){
+    2896:	c7 04 24 33 4a 00 00 	movl   $0x4a33,(%esp)
+    289d:	e8 49 11 00 00       	call   39eb <mkdir>
+    28a2:	83 c4 10             	add    $0x10,%esp
+    28a5:	85 c0                	test   %eax,%eax
+    28a7:	0f 85 b0 00 00 00    	jne    295d <rmdot+0xdd>
+  if(chdir("dots") != 0){
+    28ad:	83 ec 0c             	sub    $0xc,%esp
+    28b0:	68 33 4a 00 00       	push   $0x4a33
+    28b5:	e8 39 11 00 00       	call   39f3 <chdir>
+    28ba:	83 c4 10             	add    $0x10,%esp
+    28bd:	85 c0                	test   %eax,%eax
+    28bf:	0f 85 1d 01 00 00    	jne    29e2 <rmdot+0x162>
+  if(unlink(".") == 0){
+    28c5:	83 ec 0c             	sub    $0xc,%esp
+    28c8:	68 de 46 00 00       	push   $0x46de
+    28cd:	e8 01 11 00 00       	call   39d3 <unlink>
+    28d2:	83 c4 10             	add    $0x10,%esp
+    28d5:	85 c0                	test   %eax,%eax
+    28d7:	0f 84 f2 00 00 00    	je     29cf <rmdot+0x14f>
+  if(unlink("..") == 0){
+    28dd:	83 ec 0c             	sub    $0xc,%esp
+    28e0:	68 dd 46 00 00       	push   $0x46dd
+    28e5:	e8 e9 10 00 00       	call   39d3 <unlink>
+    28ea:	83 c4 10             	add    $0x10,%esp
+    28ed:	85 c0                	test   %eax,%eax
+    28ef:	0f 84 c7 00 00 00    	je     29bc <rmdot+0x13c>
+  if(chdir("/") != 0){
+    28f5:	83 ec 0c             	sub    $0xc,%esp
+    28f8:	68 b1 3e 00 00       	push   $0x3eb1
+    28fd:	e8 f1 10 00 00       	call   39f3 <chdir>
+    2902:	83 c4 10             	add    $0x10,%esp
+    2905:	85 c0                	test   %eax,%eax
+    2907:	0f 85 9c 00 00 00    	jne    29a9 <rmdot+0x129>
+  if(unlink("dots/.") == 0){
+    290d:	83 ec 0c             	sub    $0xc,%esp
+    2910:	68 7b 4a 00 00       	push   $0x4a7b
+    2915:	e8 b9 10 00 00       	call   39d3 <unlink>
+    291a:	83 c4 10             	add    $0x10,%esp
+    291d:	85 c0                	test   %eax,%eax
+    291f:	74 75                	je     2996 <rmdot+0x116>
+  if(unlink("dots/..") == 0){
+    2921:	83 ec 0c             	sub    $0xc,%esp
+    2924:	68 99 4a 00 00       	push   $0x4a99
+    2929:	e8 a5 10 00 00       	call   39d3 <unlink>
+    292e:	83 c4 10             	add    $0x10,%esp
+    2931:	85 c0                	test   %eax,%eax
+    2933:	74 4e                	je     2983 <rmdot+0x103>
+  if(unlink("dots") != 0){
+    2935:	83 ec 0c             	sub    $0xc,%esp
+    2938:	68 33 4a 00 00       	push   $0x4a33
+    293d:	e8 91 10 00 00       	call   39d3 <unlink>
+    2942:	83 c4 10             	add    $0x10,%esp
+    2945:	85 c0                	test   %eax,%eax
+    2947:	75 27                	jne    2970 <rmdot+0xf0>
+  printf(1, "rmdot ok\n");
+    2949:	83 ec 08             	sub    $0x8,%esp
+    294c:	68 ce 4a 00 00       	push   $0x4ace
+    2951:	6a 01                	push   $0x1
+    2953:	e8 a8 11 00 00       	call   3b00 <printf>
+}
+    2958:	83 c4 10             	add    $0x10,%esp
+    295b:	c9                   	leave  
+    295c:	c3                   	ret    
+    printf(1, "mkdir dots failed\n");
+    295d:	50                   	push   %eax
+    295e:	50                   	push   %eax
+    295f:	68 38 4a 00 00       	push   $0x4a38
+    2964:	6a 01                	push   $0x1
+    2966:	e8 95 11 00 00       	call   3b00 <printf>
+    exit();
+    296b:	e8 13 10 00 00       	call   3983 <exit>
+    printf(1, "unlink dots failed!\n");
+    2970:	50                   	push   %eax
+    2971:	50                   	push   %eax
+    2972:	68 b9 4a 00 00       	push   $0x4ab9
+    2977:	6a 01                	push   $0x1
+    2979:	e8 82 11 00 00       	call   3b00 <printf>
+    exit();
+    297e:	e8 00 10 00 00       	call   3983 <exit>
+    printf(1, "unlink dots/.. worked!\n");
+    2983:	52                   	push   %edx
+    2984:	52                   	push   %edx
+    2985:	68 a1 4a 00 00       	push   $0x4aa1
+    298a:	6a 01                	push   $0x1
+    298c:	e8 6f 11 00 00       	call   3b00 <printf>
+    exit();
+    2991:	e8 ed 0f 00 00       	call   3983 <exit>
+    printf(1, "unlink dots/. worked!\n");
+    2996:	51                   	push   %ecx
+    2997:	51                   	push   %ecx
+    2998:	68 82 4a 00 00       	push   $0x4a82
+    299d:	6a 01                	push   $0x1
+    299f:	e8 5c 11 00 00       	call   3b00 <printf>
+    exit();
+    29a4:	e8 da 0f 00 00       	call   3983 <exit>
+    printf(1, "chdir / failed\n");
+    29a9:	50                   	push   %eax
+    29aa:	50                   	push   %eax
+    29ab:	68 b3 3e 00 00       	push   $0x3eb3
+    29b0:	6a 01                	push   $0x1
+    29b2:	e8 49 11 00 00       	call   3b00 <printf>
+    exit();
+    29b7:	e8 c7 0f 00 00       	call   3983 <exit>
+    printf(1, "rm .. worked!\n");
+    29bc:	50                   	push   %eax
+    29bd:	50                   	push   %eax
+    29be:	68 6c 4a 00 00       	push   $0x4a6c
+    29c3:	6a 01                	push   $0x1
+    29c5:	e8 36 11 00 00       	call   3b00 <printf>
+    exit();
+    29ca:	e8 b4 0f 00 00       	call   3983 <exit>
+    printf(1, "rm . worked!\n");
+    29cf:	50                   	push   %eax
+    29d0:	50                   	push   %eax
+    29d1:	68 5e 4a 00 00       	push   $0x4a5e
+    29d6:	6a 01                	push   $0x1
+    29d8:	e8 23 11 00 00       	call   3b00 <printf>
+    exit();
+    29dd:	e8 a1 0f 00 00       	call   3983 <exit>
+    printf(1, "chdir dots failed\n");
+    29e2:	50                   	push   %eax
+    29e3:	50                   	push   %eax
+    29e4:	68 4b 4a 00 00       	push   $0x4a4b
+    29e9:	6a 01                	push   $0x1
+    29eb:	e8 10 11 00 00       	call   3b00 <printf>
+    exit();
+    29f0:	e8 8e 0f 00 00       	call   3983 <exit>
+    29f5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    29fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00002a00 <dirfile>:
+{
+    2a00:	f3 0f 1e fb          	endbr32 
+    2a04:	55                   	push   %ebp
+    2a05:	89 e5                	mov    %esp,%ebp
+    2a07:	53                   	push   %ebx
+    2a08:	83 ec 0c             	sub    $0xc,%esp
+  printf(1, "dir vs file\n");
+    2a0b:	68 d8 4a 00 00       	push   $0x4ad8
+    2a10:	6a 01                	push   $0x1
+    2a12:	e8 e9 10 00 00       	call   3b00 <printf>
+  fd = open("dirfile", O_CREATE);
+    2a17:	5b                   	pop    %ebx
+    2a18:	58                   	pop    %eax
+    2a19:	68 00 02 00 00       	push   $0x200
+    2a1e:	68 e5 4a 00 00       	push   $0x4ae5
+    2a23:	e8 9b 0f 00 00       	call   39c3 <open>
+  if(fd < 0){
+    2a28:	83 c4 10             	add    $0x10,%esp
+    2a2b:	85 c0                	test   %eax,%eax
+    2a2d:	0f 88 43 01 00 00    	js     2b76 <dirfile+0x176>
+  close(fd);
+    2a33:	83 ec 0c             	sub    $0xc,%esp
+    2a36:	50                   	push   %eax
+    2a37:	e8 6f 0f 00 00       	call   39ab <close>
+  if(chdir("dirfile") == 0){
+    2a3c:	c7 04 24 e5 4a 00 00 	movl   $0x4ae5,(%esp)
+    2a43:	e8 ab 0f 00 00       	call   39f3 <chdir>
+    2a48:	83 c4 10             	add    $0x10,%esp
+    2a4b:	85 c0                	test   %eax,%eax
+    2a4d:	0f 84 10 01 00 00    	je     2b63 <dirfile+0x163>
+  fd = open("dirfile/xx", 0);
+    2a53:	83 ec 08             	sub    $0x8,%esp
+    2a56:	6a 00                	push   $0x0
+    2a58:	68 1e 4b 00 00       	push   $0x4b1e
+    2a5d:	e8 61 0f 00 00       	call   39c3 <open>
+  if(fd >= 0){
+    2a62:	83 c4 10             	add    $0x10,%esp
+    2a65:	85 c0                	test   %eax,%eax
+    2a67:	0f 89 e3 00 00 00    	jns    2b50 <dirfile+0x150>
+  fd = open("dirfile/xx", O_CREATE);
+    2a6d:	83 ec 08             	sub    $0x8,%esp
+    2a70:	68 00 02 00 00       	push   $0x200
+    2a75:	68 1e 4b 00 00       	push   $0x4b1e
+    2a7a:	e8 44 0f 00 00       	call   39c3 <open>
+  if(fd >= 0){
+    2a7f:	83 c4 10             	add    $0x10,%esp
+    2a82:	85 c0                	test   %eax,%eax
+    2a84:	0f 89 c6 00 00 00    	jns    2b50 <dirfile+0x150>
+  if(mkdir("dirfile/xx") == 0){
+    2a8a:	83 ec 0c             	sub    $0xc,%esp
+    2a8d:	68 1e 4b 00 00       	push   $0x4b1e
+    2a92:	e8 54 0f 00 00       	call   39eb <mkdir>
+    2a97:	83 c4 10             	add    $0x10,%esp
+    2a9a:	85 c0                	test   %eax,%eax
+    2a9c:	0f 84 46 01 00 00    	je     2be8 <dirfile+0x1e8>
+  if(unlink("dirfile/xx") == 0){
+    2aa2:	83 ec 0c             	sub    $0xc,%esp
+    2aa5:	68 1e 4b 00 00       	push   $0x4b1e
+    2aaa:	e8 24 0f 00 00       	call   39d3 <unlink>
+    2aaf:	83 c4 10             	add    $0x10,%esp
+    2ab2:	85 c0                	test   %eax,%eax
+    2ab4:	0f 84 1b 01 00 00    	je     2bd5 <dirfile+0x1d5>
+  if(link("README", "dirfile/xx") == 0){
+    2aba:	83 ec 08             	sub    $0x8,%esp
+    2abd:	68 1e 4b 00 00       	push   $0x4b1e
+    2ac2:	68 82 4b 00 00       	push   $0x4b82
+    2ac7:	e8 17 0f 00 00       	call   39e3 <link>
+    2acc:	83 c4 10             	add    $0x10,%esp
+    2acf:	85 c0                	test   %eax,%eax
+    2ad1:	0f 84 eb 00 00 00    	je     2bc2 <dirfile+0x1c2>
+  if(unlink("dirfile") != 0){
+    2ad7:	83 ec 0c             	sub    $0xc,%esp
+    2ada:	68 e5 4a 00 00       	push   $0x4ae5
+    2adf:	e8 ef 0e 00 00       	call   39d3 <unlink>
+    2ae4:	83 c4 10             	add    $0x10,%esp
+    2ae7:	85 c0                	test   %eax,%eax
+    2ae9:	0f 85 c0 00 00 00    	jne    2baf <dirfile+0x1af>
+  fd = open(".", O_RDWR);
+    2aef:	83 ec 08             	sub    $0x8,%esp
+    2af2:	6a 02                	push   $0x2
+    2af4:	68 de 46 00 00       	push   $0x46de
+    2af9:	e8 c5 0e 00 00       	call   39c3 <open>
+  if(fd >= 0){
+    2afe:	83 c4 10             	add    $0x10,%esp
+    2b01:	85 c0                	test   %eax,%eax
+    2b03:	0f 89 93 00 00 00    	jns    2b9c <dirfile+0x19c>
+  fd = open(".", 0);
+    2b09:	83 ec 08             	sub    $0x8,%esp
+    2b0c:	6a 00                	push   $0x0
+    2b0e:	68 de 46 00 00       	push   $0x46de
+    2b13:	e8 ab 0e 00 00       	call   39c3 <open>
+  if(write(fd, "x", 1) > 0){
+    2b18:	83 c4 0c             	add    $0xc,%esp
+    2b1b:	6a 01                	push   $0x1
+  fd = open(".", 0);
+    2b1d:	89 c3                	mov    %eax,%ebx
+  if(write(fd, "x", 1) > 0){
+    2b1f:	68 c1 47 00 00       	push   $0x47c1
+    2b24:	50                   	push   %eax
+    2b25:	e8 79 0e 00 00       	call   39a3 <write>
+    2b2a:	83 c4 10             	add    $0x10,%esp
+    2b2d:	85 c0                	test   %eax,%eax
+    2b2f:	7f 58                	jg     2b89 <dirfile+0x189>
+  close(fd);
+    2b31:	83 ec 0c             	sub    $0xc,%esp
+    2b34:	53                   	push   %ebx
+    2b35:	e8 71 0e 00 00       	call   39ab <close>
+  printf(1, "dir vs file OK\n");
+    2b3a:	58                   	pop    %eax
+    2b3b:	5a                   	pop    %edx
+    2b3c:	68 b5 4b 00 00       	push   $0x4bb5
+    2b41:	6a 01                	push   $0x1
+    2b43:	e8 b8 0f 00 00       	call   3b00 <printf>
+}
+    2b48:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+    2b4b:	83 c4 10             	add    $0x10,%esp
+    2b4e:	c9                   	leave  
+    2b4f:	c3                   	ret    
+    printf(1, "create dirfile/xx succeeded!\n");
+    2b50:	50                   	push   %eax
+    2b51:	50                   	push   %eax
+    2b52:	68 29 4b 00 00       	push   $0x4b29
+    2b57:	6a 01                	push   $0x1
+    2b59:	e8 a2 0f 00 00       	call   3b00 <printf>
+    exit();
+    2b5e:	e8 20 0e 00 00       	call   3983 <exit>
+    printf(1, "chdir dirfile succeeded!\n");
+    2b63:	52                   	push   %edx
+    2b64:	52                   	push   %edx
+    2b65:	68 04 4b 00 00       	push   $0x4b04
+    2b6a:	6a 01                	push   $0x1
+    2b6c:	e8 8f 0f 00 00       	call   3b00 <printf>
+    exit();
+    2b71:	e8 0d 0e 00 00       	call   3983 <exit>
+    printf(1, "create dirfile failed\n");
+    2b76:	51                   	push   %ecx
+    2b77:	51                   	push   %ecx
+    2b78:	68 ed 4a 00 00       	push   $0x4aed
+    2b7d:	6a 01                	push   $0x1
+    2b7f:	e8 7c 0f 00 00       	call   3b00 <printf>
+    exit();
+    2b84:	e8 fa 0d 00 00       	call   3983 <exit>
+    printf(1, "write . succeeded!\n");
+    2b89:	51                   	push   %ecx
+    2b8a:	51                   	push   %ecx
+    2b8b:	68 a1 4b 00 00       	push   $0x4ba1
+    2b90:	6a 01                	push   $0x1
+    2b92:	e8 69 0f 00 00       	call   3b00 <printf>
+    exit();
+    2b97:	e8 e7 0d 00 00       	call   3983 <exit>
+    printf(1, "open . for writing succeeded!\n");
+    2b9c:	53                   	push   %ebx
+    2b9d:	53                   	push   %ebx
+    2b9e:	68 98 53 00 00       	push   $0x5398
+    2ba3:	6a 01                	push   $0x1
+    2ba5:	e8 56 0f 00 00       	call   3b00 <printf>
+    exit();
+    2baa:	e8 d4 0d 00 00       	call   3983 <exit>
+    printf(1, "unlink dirfile failed!\n");
+    2baf:	50                   	push   %eax
+    2bb0:	50                   	push   %eax
+    2bb1:	68 89 4b 00 00       	push   $0x4b89
+    2bb6:	6a 01                	push   $0x1
+    2bb8:	e8 43 0f 00 00       	call   3b00 <printf>
+    exit();
+    2bbd:	e8 c1 0d 00 00       	call   3983 <exit>
+    printf(1, "link to dirfile/xx succeeded!\n");
+    2bc2:	50                   	push   %eax
+    2bc3:	50                   	push   %eax
+    2bc4:	68 78 53 00 00       	push   $0x5378
+    2bc9:	6a 01                	push   $0x1
+    2bcb:	e8 30 0f 00 00       	call   3b00 <printf>
+    exit();
+    2bd0:	e8 ae 0d 00 00       	call   3983 <exit>
+    printf(1, "unlink dirfile/xx succeeded!\n");
+    2bd5:	50                   	push   %eax
+    2bd6:	50                   	push   %eax
+    2bd7:	68 64 4b 00 00       	push   $0x4b64
+    2bdc:	6a 01                	push   $0x1
+    2bde:	e8 1d 0f 00 00       	call   3b00 <printf>
+    exit();
+    2be3:	e8 9b 0d 00 00       	call   3983 <exit>
+    printf(1, "mkdir dirfile/xx succeeded!\n");
+    2be8:	50                   	push   %eax
+    2be9:	50                   	push   %eax
+    2bea:	68 47 4b 00 00       	push   $0x4b47
+    2bef:	6a 01                	push   $0x1
+    2bf1:	e8 0a 0f 00 00       	call   3b00 <printf>
+    exit();
+    2bf6:	e8 88 0d 00 00       	call   3983 <exit>
+    2bfb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    2bff:	90                   	nop
+
+00002c00 <iref>:
+{
+    2c00:	f3 0f 1e fb          	endbr32 
+    2c04:	55                   	push   %ebp
+    2c05:	89 e5                	mov    %esp,%ebp
+    2c07:	53                   	push   %ebx
+  printf(1, "empty file name\n");
+    2c08:	bb 33 00 00 00       	mov    $0x33,%ebx
+{
+    2c0d:	83 ec 0c             	sub    $0xc,%esp
+  printf(1, "empty file name\n");
+    2c10:	68 c5 4b 00 00       	push   $0x4bc5
+    2c15:	6a 01                	push   $0x1
+    2c17:	e8 e4 0e 00 00       	call   3b00 <printf>
+    2c1c:	83 c4 10             	add    $0x10,%esp
+    2c1f:	90                   	nop
+    if(mkdir("irefd") != 0){
+    2c20:	83 ec 0c             	sub    $0xc,%esp
+    2c23:	68 d6 4b 00 00       	push   $0x4bd6
+    2c28:	e8 be 0d 00 00       	call   39eb <mkdir>
+    2c2d:	83 c4 10             	add    $0x10,%esp
+    2c30:	85 c0                	test   %eax,%eax
+    2c32:	0f 85 bb 00 00 00    	jne    2cf3 <iref+0xf3>
+    if(chdir("irefd") != 0){
+    2c38:	83 ec 0c             	sub    $0xc,%esp
+    2c3b:	68 d6 4b 00 00       	push   $0x4bd6
+    2c40:	e8 ae 0d 00 00       	call   39f3 <chdir>
+    2c45:	83 c4 10             	add    $0x10,%esp
+    2c48:	85 c0                	test   %eax,%eax
+    2c4a:	0f 85 b7 00 00 00    	jne    2d07 <iref+0x107>
+    mkdir("");
+    2c50:	83 ec 0c             	sub    $0xc,%esp
+    2c53:	68 8b 42 00 00       	push   $0x428b
+    2c58:	e8 8e 0d 00 00       	call   39eb <mkdir>
+    link("README", "");
+    2c5d:	59                   	pop    %ecx
+    2c5e:	58                   	pop    %eax
+    2c5f:	68 8b 42 00 00       	push   $0x428b
+    2c64:	68 82 4b 00 00       	push   $0x4b82
+    2c69:	e8 75 0d 00 00       	call   39e3 <link>
+    fd = open("", O_CREATE);
+    2c6e:	58                   	pop    %eax
+    2c6f:	5a                   	pop    %edx
+    2c70:	68 00 02 00 00       	push   $0x200
+    2c75:	68 8b 42 00 00       	push   $0x428b
+    2c7a:	e8 44 0d 00 00       	call   39c3 <open>
+    if(fd >= 0)
+    2c7f:	83 c4 10             	add    $0x10,%esp
+    2c82:	85 c0                	test   %eax,%eax
+    2c84:	78 0c                	js     2c92 <iref+0x92>
+      close(fd);
+    2c86:	83 ec 0c             	sub    $0xc,%esp
+    2c89:	50                   	push   %eax
+    2c8a:	e8 1c 0d 00 00       	call   39ab <close>
+    2c8f:	83 c4 10             	add    $0x10,%esp
+    fd = open("xx", O_CREATE);
+    2c92:	83 ec 08             	sub    $0x8,%esp
+    2c95:	68 00 02 00 00       	push   $0x200
+    2c9a:	68 c0 47 00 00       	push   $0x47c0
+    2c9f:	e8 1f 0d 00 00       	call   39c3 <open>
+    if(fd >= 0)
+    2ca4:	83 c4 10             	add    $0x10,%esp
+    2ca7:	85 c0                	test   %eax,%eax
+    2ca9:	78 0c                	js     2cb7 <iref+0xb7>
+      close(fd);
+    2cab:	83 ec 0c             	sub    $0xc,%esp
+    2cae:	50                   	push   %eax
+    2caf:	e8 f7 0c 00 00       	call   39ab <close>
+    2cb4:	83 c4 10             	add    $0x10,%esp
+    unlink("xx");
+    2cb7:	83 ec 0c             	sub    $0xc,%esp
+    2cba:	68 c0 47 00 00       	push   $0x47c0
+    2cbf:	e8 0f 0d 00 00       	call   39d3 <unlink>
+  for(i = 0; i < 50 + 1; i++){
+    2cc4:	83 c4 10             	add    $0x10,%esp
+    2cc7:	83 eb 01             	sub    $0x1,%ebx
+    2cca:	0f 85 50 ff ff ff    	jne    2c20 <iref+0x20>
+  chdir("/");
+    2cd0:	83 ec 0c             	sub    $0xc,%esp
+    2cd3:	68 b1 3e 00 00       	push   $0x3eb1
+    2cd8:	e8 16 0d 00 00       	call   39f3 <chdir>
+  printf(1, "empty file name OK\n");
+    2cdd:	58                   	pop    %eax
+    2cde:	5a                   	pop    %edx
+    2cdf:	68 04 4c 00 00       	push   $0x4c04
+    2ce4:	6a 01                	push   $0x1
+    2ce6:	e8 15 0e 00 00       	call   3b00 <printf>
+}
+    2ceb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+    2cee:	83 c4 10             	add    $0x10,%esp
+    2cf1:	c9                   	leave  
+    2cf2:	c3                   	ret    
+      printf(1, "mkdir irefd failed\n");
+    2cf3:	83 ec 08             	sub    $0x8,%esp
+    2cf6:	68 dc 4b 00 00       	push   $0x4bdc
+    2cfb:	6a 01                	push   $0x1
+    2cfd:	e8 fe 0d 00 00       	call   3b00 <printf>
+      exit();
+    2d02:	e8 7c 0c 00 00       	call   3983 <exit>
+      printf(1, "chdir irefd failed\n");
+    2d07:	83 ec 08             	sub    $0x8,%esp
+    2d0a:	68 f0 4b 00 00       	push   $0x4bf0
+    2d0f:	6a 01                	push   $0x1
+    2d11:	e8 ea 0d 00 00       	call   3b00 <printf>
+      exit();
+    2d16:	e8 68 0c 00 00       	call   3983 <exit>
+    2d1b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    2d1f:	90                   	nop
+
+00002d20 <forktest>:
+{
+    2d20:	f3 0f 1e fb          	endbr32 
+    2d24:	55                   	push   %ebp
+    2d25:	89 e5                	mov    %esp,%ebp
+    2d27:	53                   	push   %ebx
+  for(n=0; n<1000; n++){
+    2d28:	31 db                	xor    %ebx,%ebx
+{
+    2d2a:	83 ec 0c             	sub    $0xc,%esp
+  printf(1, "fork test\n");
+    2d2d:	68 18 4c 00 00       	push   $0x4c18
+    2d32:	6a 01                	push   $0x1
+    2d34:	e8 c7 0d 00 00       	call   3b00 <printf>
+    2d39:	83 c4 10             	add    $0x10,%esp
+    2d3c:	eb 0f                	jmp    2d4d <forktest+0x2d>
+    2d3e:	66 90                	xchg   %ax,%ax
+    if(pid == 0)
+    2d40:	74 4a                	je     2d8c <forktest+0x6c>
+  for(n=0; n<1000; n++){
+    2d42:	83 c3 01             	add    $0x1,%ebx
+    2d45:	81 fb e8 03 00 00    	cmp    $0x3e8,%ebx
+    2d4b:	74 6b                	je     2db8 <forktest+0x98>
+    pid = fork();
+    2d4d:	e8 29 0c 00 00       	call   397b <fork>
+    if(pid < 0)
+    2d52:	85 c0                	test   %eax,%eax
+    2d54:	79 ea                	jns    2d40 <forktest+0x20>
+  for(; n > 0; n--){
+    2d56:	85 db                	test   %ebx,%ebx
+    2d58:	74 14                	je     2d6e <forktest+0x4e>
+    2d5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    if(wait() < 0){
+    2d60:	e8 26 0c 00 00       	call   398b <wait>
+    2d65:	85 c0                	test   %eax,%eax
+    2d67:	78 28                	js     2d91 <forktest+0x71>
+  for(; n > 0; n--){
+    2d69:	83 eb 01             	sub    $0x1,%ebx
+    2d6c:	75 f2                	jne    2d60 <forktest+0x40>
+  if(wait() != -1){
+    2d6e:	e8 18 0c 00 00       	call   398b <wait>
+    2d73:	83 f8 ff             	cmp    $0xffffffff,%eax
+    2d76:	75 2d                	jne    2da5 <forktest+0x85>
+  printf(1, "fork test OK\n");
+    2d78:	83 ec 08             	sub    $0x8,%esp
+    2d7b:	68 4a 4c 00 00       	push   $0x4c4a
+    2d80:	6a 01                	push   $0x1
+    2d82:	e8 79 0d 00 00       	call   3b00 <printf>
+}
+    2d87:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+    2d8a:	c9                   	leave  
+    2d8b:	c3                   	ret    
+      exit();
+    2d8c:	e8 f2 0b 00 00       	call   3983 <exit>
+      printf(1, "wait stopped early\n");
+    2d91:	83 ec 08             	sub    $0x8,%esp
+    2d94:	68 23 4c 00 00       	push   $0x4c23
+    2d99:	6a 01                	push   $0x1
+    2d9b:	e8 60 0d 00 00       	call   3b00 <printf>
+      exit();
+    2da0:	e8 de 0b 00 00       	call   3983 <exit>
+    printf(1, "wait got too many\n");
+    2da5:	52                   	push   %edx
+    2da6:	52                   	push   %edx
+    2da7:	68 37 4c 00 00       	push   $0x4c37
+    2dac:	6a 01                	push   $0x1
+    2dae:	e8 4d 0d 00 00       	call   3b00 <printf>
+    exit();
+    2db3:	e8 cb 0b 00 00       	call   3983 <exit>
+    printf(1, "fork claimed to work 1000 times!\n");
+    2db8:	50                   	push   %eax
+    2db9:	50                   	push   %eax
+    2dba:	68 b8 53 00 00       	push   $0x53b8
+    2dbf:	6a 01                	push   $0x1
+    2dc1:	e8 3a 0d 00 00       	call   3b00 <printf>
+    exit();
+    2dc6:	e8 b8 0b 00 00       	call   3983 <exit>
+    2dcb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    2dcf:	90                   	nop
+
+00002dd0 <sbrktest>:
+{
+    2dd0:	f3 0f 1e fb          	endbr32 
+    2dd4:	55                   	push   %ebp
+    2dd5:	89 e5                	mov    %esp,%ebp
+    2dd7:	57                   	push   %edi
+  for(i = 0; i < 5000; i++){
+    2dd8:	31 ff                	xor    %edi,%edi
+{
+    2dda:	56                   	push   %esi
+    2ddb:	53                   	push   %ebx
+    2ddc:	83 ec 54             	sub    $0x54,%esp
+  printf(stdout, "sbrk test\n");
+    2ddf:	68 58 4c 00 00       	push   $0x4c58
+    2de4:	ff 35 00 5f 00 00    	pushl  0x5f00
+    2dea:	e8 11 0d 00 00       	call   3b00 <printf>
+  oldbrk = sbrk(0);
+    2def:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    2df6:	e8 10 0c 00 00       	call   3a0b <sbrk>
+  a = sbrk(0);
+    2dfb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  oldbrk = sbrk(0);
+    2e02:	89 c3                	mov    %eax,%ebx
+  a = sbrk(0);
+    2e04:	e8 02 0c 00 00       	call   3a0b <sbrk>
+    2e09:	83 c4 10             	add    $0x10,%esp
+    2e0c:	89 c6                	mov    %eax,%esi
+  for(i = 0; i < 5000; i++){
+    2e0e:	eb 02                	jmp    2e12 <sbrktest+0x42>
+    a = b + 1;
+    2e10:	89 c6                	mov    %eax,%esi
+    b = sbrk(1);
+    2e12:	83 ec 0c             	sub    $0xc,%esp
+    2e15:	6a 01                	push   $0x1
+    2e17:	e8 ef 0b 00 00       	call   3a0b <sbrk>
+    if(b != a){
+    2e1c:	83 c4 10             	add    $0x10,%esp
+    2e1f:	39 f0                	cmp    %esi,%eax
+    2e21:	0f 85 84 02 00 00    	jne    30ab <sbrktest+0x2db>
+  for(i = 0; i < 5000; i++){
+    2e27:	83 c7 01             	add    $0x1,%edi
+    *b = 1;
+    2e2a:	c6 06 01             	movb   $0x1,(%esi)
+    a = b + 1;
+    2e2d:	8d 46 01             	lea    0x1(%esi),%eax
+  for(i = 0; i < 5000; i++){
+    2e30:	81 ff 88 13 00 00    	cmp    $0x1388,%edi
+    2e36:	75 d8                	jne    2e10 <sbrktest+0x40>
+  pid = fork();
+    2e38:	e8 3e 0b 00 00       	call   397b <fork>
+    2e3d:	89 c7                	mov    %eax,%edi
+  if(pid < 0){
+    2e3f:	85 c0                	test   %eax,%eax
+    2e41:	0f 88 91 03 00 00    	js     31d8 <sbrktest+0x408>
+  c = sbrk(1);
+    2e47:	83 ec 0c             	sub    $0xc,%esp
+  if(c != a + 1){
+    2e4a:	83 c6 02             	add    $0x2,%esi
+  c = sbrk(1);
+    2e4d:	6a 01                	push   $0x1
+    2e4f:	e8 b7 0b 00 00       	call   3a0b <sbrk>
+  c = sbrk(1);
+    2e54:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+    2e5b:	e8 ab 0b 00 00       	call   3a0b <sbrk>
+  if(c != a + 1){
+    2e60:	83 c4 10             	add    $0x10,%esp
+    2e63:	39 c6                	cmp    %eax,%esi
+    2e65:	0f 85 56 03 00 00    	jne    31c1 <sbrktest+0x3f1>
+  if(pid == 0)
+    2e6b:	85 ff                	test   %edi,%edi
+    2e6d:	0f 84 49 03 00 00    	je     31bc <sbrktest+0x3ec>
+  wait();
+    2e73:	e8 13 0b 00 00       	call   398b <wait>
+  a = sbrk(0);
+    2e78:	83 ec 0c             	sub    $0xc,%esp
+    2e7b:	6a 00                	push   $0x0
+    2e7d:	e8 89 0b 00 00       	call   3a0b <sbrk>
+    2e82:	89 c6                	mov    %eax,%esi
+  amt = (BIG) - (uint)a;
+    2e84:	b8 00 00 40 06       	mov    $0x6400000,%eax
+    2e89:	29 f0                	sub    %esi,%eax
+  p = sbrk(amt);
+    2e8b:	89 04 24             	mov    %eax,(%esp)
+    2e8e:	e8 78 0b 00 00       	call   3a0b <sbrk>
+  if (p != a) {
+    2e93:	83 c4 10             	add    $0x10,%esp
+    2e96:	39 c6                	cmp    %eax,%esi
+    2e98:	0f 85 07 03 00 00    	jne    31a5 <sbrktest+0x3d5>
+  a = sbrk(0);
+    2e9e:	83 ec 0c             	sub    $0xc,%esp
+  *lastaddr = 99;
+    2ea1:	c6 05 ff ff 3f 06 63 	movb   $0x63,0x63fffff
+  a = sbrk(0);
+    2ea8:	6a 00                	push   $0x0
+    2eaa:	e8 5c 0b 00 00       	call   3a0b <sbrk>
+  c = sbrk(-4096);
+    2eaf:	c7 04 24 00 f0 ff ff 	movl   $0xfffff000,(%esp)
+  a = sbrk(0);
+    2eb6:	89 c6                	mov    %eax,%esi
+  c = sbrk(-4096);
+    2eb8:	e8 4e 0b 00 00       	call   3a0b <sbrk>
+  if(c == (char*)0xffffffff){
+    2ebd:	83 c4 10             	add    $0x10,%esp
+    2ec0:	83 f8 ff             	cmp    $0xffffffff,%eax
+    2ec3:	0f 84 c5 02 00 00    	je     318e <sbrktest+0x3be>
+  c = sbrk(0);
+    2ec9:	83 ec 0c             	sub    $0xc,%esp
+    2ecc:	6a 00                	push   $0x0
+    2ece:	e8 38 0b 00 00       	call   3a0b <sbrk>
+  if(c != a - 4096){
+    2ed3:	8d 96 00 f0 ff ff    	lea    -0x1000(%esi),%edx
+    2ed9:	83 c4 10             	add    $0x10,%esp
+    2edc:	39 d0                	cmp    %edx,%eax
+    2ede:	0f 85 93 02 00 00    	jne    3177 <sbrktest+0x3a7>
+  a = sbrk(0);
+    2ee4:	83 ec 0c             	sub    $0xc,%esp
+    2ee7:	6a 00                	push   $0x0
+    2ee9:	e8 1d 0b 00 00       	call   3a0b <sbrk>
+  c = sbrk(4096);
+    2eee:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
+  a = sbrk(0);
+    2ef5:	89 c6                	mov    %eax,%esi
+  c = sbrk(4096);
+    2ef7:	e8 0f 0b 00 00       	call   3a0b <sbrk>
+  if(c != a || sbrk(0) != a + 4096){
+    2efc:	83 c4 10             	add    $0x10,%esp
+  c = sbrk(4096);
+    2eff:	89 c7                	mov    %eax,%edi
+  if(c != a || sbrk(0) != a + 4096){
+    2f01:	39 c6                	cmp    %eax,%esi
+    2f03:	0f 85 57 02 00 00    	jne    3160 <sbrktest+0x390>
+    2f09:	83 ec 0c             	sub    $0xc,%esp
+    2f0c:	6a 00                	push   $0x0
+    2f0e:	e8 f8 0a 00 00       	call   3a0b <sbrk>
+    2f13:	8d 96 00 10 00 00    	lea    0x1000(%esi),%edx
+    2f19:	83 c4 10             	add    $0x10,%esp
+    2f1c:	39 c2                	cmp    %eax,%edx
+    2f1e:	0f 85 3c 02 00 00    	jne    3160 <sbrktest+0x390>
+  if(*lastaddr == 99){
+    2f24:	80 3d ff ff 3f 06 63 	cmpb   $0x63,0x63fffff
+    2f2b:	0f 84 18 02 00 00    	je     3149 <sbrktest+0x379>
+  a = sbrk(0);
+    2f31:	83 ec 0c             	sub    $0xc,%esp
+    2f34:	6a 00                	push   $0x0
+    2f36:	e8 d0 0a 00 00       	call   3a0b <sbrk>
+  c = sbrk(-(sbrk(0) - oldbrk));
+    2f3b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  a = sbrk(0);
+    2f42:	89 c6                	mov    %eax,%esi
+  c = sbrk(-(sbrk(0) - oldbrk));
+    2f44:	e8 c2 0a 00 00       	call   3a0b <sbrk>
+    2f49:	89 d9                	mov    %ebx,%ecx
+    2f4b:	29 c1                	sub    %eax,%ecx
+    2f4d:	89 0c 24             	mov    %ecx,(%esp)
+    2f50:	e8 b6 0a 00 00       	call   3a0b <sbrk>
+  if(c != a){
+    2f55:	83 c4 10             	add    $0x10,%esp
+    2f58:	39 c6                	cmp    %eax,%esi
+    2f5a:	0f 85 d2 01 00 00    	jne    3132 <sbrktest+0x362>
+  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+    2f60:	be 00 00 00 80       	mov    $0x80000000,%esi
+    2f65:	8d 76 00             	lea    0x0(%esi),%esi
+    ppid = getpid();
+    2f68:	e8 96 0a 00 00       	call   3a03 <getpid>
+    2f6d:	89 c7                	mov    %eax,%edi
+    pid = fork();
+    2f6f:	e8 07 0a 00 00       	call   397b <fork>
+    if(pid < 0){
+    2f74:	85 c0                	test   %eax,%eax
+    2f76:	0f 88 9e 01 00 00    	js     311a <sbrktest+0x34a>
+    if(pid == 0){
+    2f7c:	0f 84 76 01 00 00    	je     30f8 <sbrktest+0x328>
+    wait();
+    2f82:	e8 04 0a 00 00       	call   398b <wait>
+  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+    2f87:	81 c6 50 c3 00 00    	add    $0xc350,%esi
+    2f8d:	81 fe 80 84 1e 80    	cmp    $0x801e8480,%esi
+    2f93:	75 d3                	jne    2f68 <sbrktest+0x198>
+  if(pipe(fds) != 0){
+    2f95:	83 ec 0c             	sub    $0xc,%esp
+    2f98:	8d 45 b8             	lea    -0x48(%ebp),%eax
+    2f9b:	50                   	push   %eax
+    2f9c:	e8 f2 09 00 00       	call   3993 <pipe>
+    2fa1:	83 c4 10             	add    $0x10,%esp
+    2fa4:	85 c0                	test   %eax,%eax
+    2fa6:	0f 85 34 01 00 00    	jne    30e0 <sbrktest+0x310>
+    2fac:	8d 75 c0             	lea    -0x40(%ebp),%esi
+    2faf:	89 f7                	mov    %esi,%edi
+    if((pids[i] = fork()) == 0){
+    2fb1:	e8 c5 09 00 00       	call   397b <fork>
+    2fb6:	89 07                	mov    %eax,(%edi)
+    2fb8:	85 c0                	test   %eax,%eax
+    2fba:	0f 84 8f 00 00 00    	je     304f <sbrktest+0x27f>
+    if(pids[i] != -1)
+    2fc0:	83 f8 ff             	cmp    $0xffffffff,%eax
+    2fc3:	74 14                	je     2fd9 <sbrktest+0x209>
+      read(fds[0], &scratch, 1);
+    2fc5:	83 ec 04             	sub    $0x4,%esp
+    2fc8:	8d 45 b7             	lea    -0x49(%ebp),%eax
+    2fcb:	6a 01                	push   $0x1
+    2fcd:	50                   	push   %eax
+    2fce:	ff 75 b8             	pushl  -0x48(%ebp)
+    2fd1:	e8 c5 09 00 00       	call   399b <read>
+    2fd6:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    2fd9:	83 c7 04             	add    $0x4,%edi
+    2fdc:	8d 45 e8             	lea    -0x18(%ebp),%eax
+    2fdf:	39 c7                	cmp    %eax,%edi
+    2fe1:	75 ce                	jne    2fb1 <sbrktest+0x1e1>
+  c = sbrk(4096);
+    2fe3:	83 ec 0c             	sub    $0xc,%esp
+    2fe6:	68 00 10 00 00       	push   $0x1000
+    2feb:	e8 1b 0a 00 00       	call   3a0b <sbrk>
+    2ff0:	83 c4 10             	add    $0x10,%esp
+    2ff3:	89 c7                	mov    %eax,%edi
+    if(pids[i] == -1)
+    2ff5:	8b 06                	mov    (%esi),%eax
+    2ff7:	83 f8 ff             	cmp    $0xffffffff,%eax
+    2ffa:	74 11                	je     300d <sbrktest+0x23d>
+    kill(pids[i]);
+    2ffc:	83 ec 0c             	sub    $0xc,%esp
+    2fff:	50                   	push   %eax
+    3000:	e8 ae 09 00 00       	call   39b3 <kill>
+    wait();
+    3005:	e8 81 09 00 00       	call   398b <wait>
+    300a:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    300d:	83 c6 04             	add    $0x4,%esi
+    3010:	8d 45 e8             	lea    -0x18(%ebp),%eax
+    3013:	39 f0                	cmp    %esi,%eax
+    3015:	75 de                	jne    2ff5 <sbrktest+0x225>
+  if(c == (char*)0xffffffff){
+    3017:	83 ff ff             	cmp    $0xffffffff,%edi
+    301a:	0f 84 a9 00 00 00    	je     30c9 <sbrktest+0x2f9>
+  if(sbrk(0) > oldbrk)
+    3020:	83 ec 0c             	sub    $0xc,%esp
+    3023:	6a 00                	push   $0x0
+    3025:	e8 e1 09 00 00       	call   3a0b <sbrk>
+    302a:	83 c4 10             	add    $0x10,%esp
+    302d:	39 c3                	cmp    %eax,%ebx
+    302f:	72 61                	jb     3092 <sbrktest+0x2c2>
+  printf(stdout, "sbrk test OK\n");
+    3031:	83 ec 08             	sub    $0x8,%esp
+    3034:	68 00 4d 00 00       	push   $0x4d00
+    3039:	ff 35 00 5f 00 00    	pushl  0x5f00
+    303f:	e8 bc 0a 00 00       	call   3b00 <printf>
+}
+    3044:	83 c4 10             	add    $0x10,%esp
+    3047:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    304a:	5b                   	pop    %ebx
+    304b:	5e                   	pop    %esi
+    304c:	5f                   	pop    %edi
+    304d:	5d                   	pop    %ebp
+    304e:	c3                   	ret    
+      sbrk(BIG - (uint)sbrk(0));
+    304f:	83 ec 0c             	sub    $0xc,%esp
+    3052:	6a 00                	push   $0x0
+    3054:	e8 b2 09 00 00       	call   3a0b <sbrk>
+    3059:	89 c2                	mov    %eax,%edx
+    305b:	b8 00 00 40 06       	mov    $0x6400000,%eax
+    3060:	29 d0                	sub    %edx,%eax
+    3062:	89 04 24             	mov    %eax,(%esp)
+    3065:	e8 a1 09 00 00       	call   3a0b <sbrk>
+      write(fds[1], "x", 1);
+    306a:	83 c4 0c             	add    $0xc,%esp
+    306d:	6a 01                	push   $0x1
+    306f:	68 c1 47 00 00       	push   $0x47c1
+    3074:	ff 75 bc             	pushl  -0x44(%ebp)
+    3077:	e8 27 09 00 00       	call   39a3 <write>
+    307c:	83 c4 10             	add    $0x10,%esp
+    307f:	90                   	nop
+      for(;;) sleep(1000);
+    3080:	83 ec 0c             	sub    $0xc,%esp
+    3083:	68 e8 03 00 00       	push   $0x3e8
+    3088:	e8 86 09 00 00       	call   3a13 <sleep>
+    308d:	83 c4 10             	add    $0x10,%esp
+    3090:	eb ee                	jmp    3080 <sbrktest+0x2b0>
+    sbrk(-(sbrk(0) - oldbrk));
+    3092:	83 ec 0c             	sub    $0xc,%esp
+    3095:	6a 00                	push   $0x0
+    3097:	e8 6f 09 00 00       	call   3a0b <sbrk>
+    309c:	29 c3                	sub    %eax,%ebx
+    309e:	89 1c 24             	mov    %ebx,(%esp)
+    30a1:	e8 65 09 00 00       	call   3a0b <sbrk>
+    30a6:	83 c4 10             	add    $0x10,%esp
+    30a9:	eb 86                	jmp    3031 <sbrktest+0x261>
+      printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
+    30ab:	83 ec 0c             	sub    $0xc,%esp
+    30ae:	50                   	push   %eax
+    30af:	56                   	push   %esi
+    30b0:	57                   	push   %edi
+    30b1:	68 63 4c 00 00       	push   $0x4c63
+    30b6:	ff 35 00 5f 00 00    	pushl  0x5f00
+    30bc:	e8 3f 0a 00 00       	call   3b00 <printf>
+      exit();
+    30c1:	83 c4 20             	add    $0x20,%esp
+    30c4:	e8 ba 08 00 00       	call   3983 <exit>
+    printf(stdout, "failed sbrk leaked memory\n");
+    30c9:	50                   	push   %eax
+    30ca:	50                   	push   %eax
+    30cb:	68 e5 4c 00 00       	push   $0x4ce5
+    30d0:	ff 35 00 5f 00 00    	pushl  0x5f00
+    30d6:	e8 25 0a 00 00       	call   3b00 <printf>
+    exit();
+    30db:	e8 a3 08 00 00       	call   3983 <exit>
+    printf(1, "pipe() failed\n");
+    30e0:	52                   	push   %edx
+    30e1:	52                   	push   %edx
+    30e2:	68 a1 41 00 00       	push   $0x41a1
+    30e7:	6a 01                	push   $0x1
+    30e9:	e8 12 0a 00 00       	call   3b00 <printf>
+    exit();
+    30ee:	e8 90 08 00 00       	call   3983 <exit>
+    30f3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    30f7:	90                   	nop
+      printf(stdout, "oops could read %x = %x\n", a, *a);
+    30f8:	0f be 06             	movsbl (%esi),%eax
+    30fb:	50                   	push   %eax
+    30fc:	56                   	push   %esi
+    30fd:	68 cc 4c 00 00       	push   $0x4ccc
+    3102:	ff 35 00 5f 00 00    	pushl  0x5f00
+    3108:	e8 f3 09 00 00       	call   3b00 <printf>
+      kill(ppid);
+    310d:	89 3c 24             	mov    %edi,(%esp)
+    3110:	e8 9e 08 00 00       	call   39b3 <kill>
+      exit();
+    3115:	e8 69 08 00 00       	call   3983 <exit>
+      printf(stdout, "fork failed\n");
+    311a:	83 ec 08             	sub    $0x8,%esp
+    311d:	68 a9 4d 00 00       	push   $0x4da9
+    3122:	ff 35 00 5f 00 00    	pushl  0x5f00
+    3128:	e8 d3 09 00 00       	call   3b00 <printf>
+      exit();
+    312d:	e8 51 08 00 00       	call   3983 <exit>
+    printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
+    3132:	50                   	push   %eax
+    3133:	56                   	push   %esi
+    3134:	68 ac 54 00 00       	push   $0x54ac
+    3139:	ff 35 00 5f 00 00    	pushl  0x5f00
+    313f:	e8 bc 09 00 00       	call   3b00 <printf>
+    exit();
+    3144:	e8 3a 08 00 00       	call   3983 <exit>
+    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
+    3149:	51                   	push   %ecx
+    314a:	51                   	push   %ecx
+    314b:	68 7c 54 00 00       	push   $0x547c
+    3150:	ff 35 00 5f 00 00    	pushl  0x5f00
+    3156:	e8 a5 09 00 00       	call   3b00 <printf>
+    exit();
+    315b:	e8 23 08 00 00       	call   3983 <exit>
+    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
+    3160:	57                   	push   %edi
+    3161:	56                   	push   %esi
+    3162:	68 54 54 00 00       	push   $0x5454
+    3167:	ff 35 00 5f 00 00    	pushl  0x5f00
+    316d:	e8 8e 09 00 00       	call   3b00 <printf>
+    exit();
+    3172:	e8 0c 08 00 00       	call   3983 <exit>
+    printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
+    3177:	50                   	push   %eax
+    3178:	56                   	push   %esi
+    3179:	68 1c 54 00 00       	push   $0x541c
+    317e:	ff 35 00 5f 00 00    	pushl  0x5f00
+    3184:	e8 77 09 00 00       	call   3b00 <printf>
+    exit();
+    3189:	e8 f5 07 00 00       	call   3983 <exit>
+    printf(stdout, "sbrk could not deallocate\n");
+    318e:	53                   	push   %ebx
+    318f:	53                   	push   %ebx
+    3190:	68 b1 4c 00 00       	push   $0x4cb1
+    3195:	ff 35 00 5f 00 00    	pushl  0x5f00
+    319b:	e8 60 09 00 00       	call   3b00 <printf>
+    exit();
+    31a0:	e8 de 07 00 00       	call   3983 <exit>
+    printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
+    31a5:	56                   	push   %esi
+    31a6:	56                   	push   %esi
+    31a7:	68 dc 53 00 00       	push   $0x53dc
+    31ac:	ff 35 00 5f 00 00    	pushl  0x5f00
+    31b2:	e8 49 09 00 00       	call   3b00 <printf>
+    exit();
+    31b7:	e8 c7 07 00 00       	call   3983 <exit>
+    exit();
+    31bc:	e8 c2 07 00 00       	call   3983 <exit>
+    printf(stdout, "sbrk test failed post-fork\n");
+    31c1:	57                   	push   %edi
+    31c2:	57                   	push   %edi
+    31c3:	68 95 4c 00 00       	push   $0x4c95
+    31c8:	ff 35 00 5f 00 00    	pushl  0x5f00
+    31ce:	e8 2d 09 00 00       	call   3b00 <printf>
+    exit();
+    31d3:	e8 ab 07 00 00       	call   3983 <exit>
+    printf(stdout, "sbrk test fork failed\n");
+    31d8:	50                   	push   %eax
+    31d9:	50                   	push   %eax
+    31da:	68 7e 4c 00 00       	push   $0x4c7e
+    31df:	ff 35 00 5f 00 00    	pushl  0x5f00
+    31e5:	e8 16 09 00 00       	call   3b00 <printf>
+    exit();
+    31ea:	e8 94 07 00 00       	call   3983 <exit>
+    31ef:	90                   	nop
+
+000031f0 <validateint>:
+{
+    31f0:	f3 0f 1e fb          	endbr32 
+}
+    31f4:	c3                   	ret    
+    31f5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    31fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00003200 <validatetest>:
+{
+    3200:	f3 0f 1e fb          	endbr32 
+    3204:	55                   	push   %ebp
+    3205:	89 e5                	mov    %esp,%ebp
+    3207:	56                   	push   %esi
+  for(p = 0; p <= (uint)hi; p += 4096){
+    3208:	31 f6                	xor    %esi,%esi
+{
+    320a:	53                   	push   %ebx
+  printf(stdout, "validate test\n");
+    320b:	83 ec 08             	sub    $0x8,%esp
+    320e:	68 0e 4d 00 00       	push   $0x4d0e
+    3213:	ff 35 00 5f 00 00    	pushl  0x5f00
+    3219:	e8 e2 08 00 00       	call   3b00 <printf>
+    321e:	83 c4 10             	add    $0x10,%esp
+    3221:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    if((pid = fork()) == 0){
+    3228:	e8 4e 07 00 00       	call   397b <fork>
+    322d:	89 c3                	mov    %eax,%ebx
+    322f:	85 c0                	test   %eax,%eax
+    3231:	74 63                	je     3296 <validatetest+0x96>
+    sleep(0);
+    3233:	83 ec 0c             	sub    $0xc,%esp
+    3236:	6a 00                	push   $0x0
+    3238:	e8 d6 07 00 00       	call   3a13 <sleep>
+    sleep(0);
+    323d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+    3244:	e8 ca 07 00 00       	call   3a13 <sleep>
+    kill(pid);
+    3249:	89 1c 24             	mov    %ebx,(%esp)
+    324c:	e8 62 07 00 00       	call   39b3 <kill>
+    wait();
+    3251:	e8 35 07 00 00       	call   398b <wait>
+    if(link("nosuchfile", (char*)p) != -1){
+    3256:	58                   	pop    %eax
+    3257:	5a                   	pop    %edx
+    3258:	56                   	push   %esi
+    3259:	68 1d 4d 00 00       	push   $0x4d1d
+    325e:	e8 80 07 00 00       	call   39e3 <link>
+    3263:	83 c4 10             	add    $0x10,%esp
+    3266:	83 f8 ff             	cmp    $0xffffffff,%eax
+    3269:	75 30                	jne    329b <validatetest+0x9b>
+  for(p = 0; p <= (uint)hi; p += 4096){
+    326b:	81 c6 00 10 00 00    	add    $0x1000,%esi
+    3271:	81 fe 00 40 11 00    	cmp    $0x114000,%esi
+    3277:	75 af                	jne    3228 <validatetest+0x28>
+  printf(stdout, "validate ok\n");
+    3279:	83 ec 08             	sub    $0x8,%esp
+    327c:	68 41 4d 00 00       	push   $0x4d41
+    3281:	ff 35 00 5f 00 00    	pushl  0x5f00
+    3287:	e8 74 08 00 00       	call   3b00 <printf>
+}
+    328c:	83 c4 10             	add    $0x10,%esp
+    328f:	8d 65 f8             	lea    -0x8(%ebp),%esp
+    3292:	5b                   	pop    %ebx
+    3293:	5e                   	pop    %esi
+    3294:	5d                   	pop    %ebp
+    3295:	c3                   	ret    
+      exit();
+    3296:	e8 e8 06 00 00       	call   3983 <exit>
+      printf(stdout, "link should not succeed\n");
+    329b:	83 ec 08             	sub    $0x8,%esp
+    329e:	68 28 4d 00 00       	push   $0x4d28
+    32a3:	ff 35 00 5f 00 00    	pushl  0x5f00
+    32a9:	e8 52 08 00 00       	call   3b00 <printf>
+      exit();
+    32ae:	e8 d0 06 00 00       	call   3983 <exit>
+    32b3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    32ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000032c0 <bsstest>:
+{
+    32c0:	f3 0f 1e fb          	endbr32 
+    32c4:	55                   	push   %ebp
+    32c5:	89 e5                	mov    %esp,%ebp
+    32c7:	83 ec 10             	sub    $0x10,%esp
+  printf(stdout, "bss test\n");
+    32ca:	68 4e 4d 00 00       	push   $0x4d4e
+    32cf:	ff 35 00 5f 00 00    	pushl  0x5f00
+    32d5:	e8 26 08 00 00       	call   3b00 <printf>
+    32da:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < sizeof(uninit); i++){
+    32dd:	31 c0                	xor    %eax,%eax
+    32df:	90                   	nop
+    if(uninit[i] != '\0'){
+    32e0:	80 b8 c0 5f 00 00 00 	cmpb   $0x0,0x5fc0(%eax)
+    32e7:	75 22                	jne    330b <bsstest+0x4b>
+  for(i = 0; i < sizeof(uninit); i++){
+    32e9:	83 c0 01             	add    $0x1,%eax
+    32ec:	3d 10 27 00 00       	cmp    $0x2710,%eax
+    32f1:	75 ed                	jne    32e0 <bsstest+0x20>
+  printf(stdout, "bss test ok\n");
+    32f3:	83 ec 08             	sub    $0x8,%esp
+    32f6:	68 69 4d 00 00       	push   $0x4d69
+    32fb:	ff 35 00 5f 00 00    	pushl  0x5f00
+    3301:	e8 fa 07 00 00       	call   3b00 <printf>
+}
+    3306:	83 c4 10             	add    $0x10,%esp
+    3309:	c9                   	leave  
+    330a:	c3                   	ret    
+      printf(stdout, "bss test failed\n");
+    330b:	83 ec 08             	sub    $0x8,%esp
+    330e:	68 58 4d 00 00       	push   $0x4d58
+    3313:	ff 35 00 5f 00 00    	pushl  0x5f00
+    3319:	e8 e2 07 00 00       	call   3b00 <printf>
+      exit();
+    331e:	e8 60 06 00 00       	call   3983 <exit>
+    3323:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    332a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00003330 <bigargtest>:
+{
+    3330:	f3 0f 1e fb          	endbr32 
+    3334:	55                   	push   %ebp
+    3335:	89 e5                	mov    %esp,%ebp
+    3337:	83 ec 14             	sub    $0x14,%esp
+  unlink("bigarg-ok");
+    333a:	68 76 4d 00 00       	push   $0x4d76
+    333f:	e8 8f 06 00 00       	call   39d3 <unlink>
+  pid = fork();
+    3344:	e8 32 06 00 00       	call   397b <fork>
+  if(pid == 0){
+    3349:	83 c4 10             	add    $0x10,%esp
+    334c:	85 c0                	test   %eax,%eax
+    334e:	74 40                	je     3390 <bigargtest+0x60>
+  } else if(pid < 0){
+    3350:	0f 88 c1 00 00 00    	js     3417 <bigargtest+0xe7>
+  wait();
+    3356:	e8 30 06 00 00       	call   398b <wait>
+  fd = open("bigarg-ok", 0);
+    335b:	83 ec 08             	sub    $0x8,%esp
+    335e:	6a 00                	push   $0x0
+    3360:	68 76 4d 00 00       	push   $0x4d76
+    3365:	e8 59 06 00 00       	call   39c3 <open>
+  if(fd < 0){
+    336a:	83 c4 10             	add    $0x10,%esp
+    336d:	85 c0                	test   %eax,%eax
+    336f:	0f 88 8b 00 00 00    	js     3400 <bigargtest+0xd0>
+  close(fd);
+    3375:	83 ec 0c             	sub    $0xc,%esp
+    3378:	50                   	push   %eax
+    3379:	e8 2d 06 00 00       	call   39ab <close>
+  unlink("bigarg-ok");
+    337e:	c7 04 24 76 4d 00 00 	movl   $0x4d76,(%esp)
+    3385:	e8 49 06 00 00       	call   39d3 <unlink>
+}
+    338a:	83 c4 10             	add    $0x10,%esp
+    338d:	c9                   	leave  
+    338e:	c3                   	ret    
+    338f:	90                   	nop
+      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
+    3390:	c7 04 85 20 5f 00 00 	movl   $0x54d0,0x5f20(,%eax,4)
+    3397:	d0 54 00 00 
+    for(i = 0; i < MAXARG-1; i++)
+    339b:	83 c0 01             	add    $0x1,%eax
+    339e:	83 f8 1f             	cmp    $0x1f,%eax
+    33a1:	75 ed                	jne    3390 <bigargtest+0x60>
+    printf(stdout, "bigarg test\n");
+    33a3:	51                   	push   %ecx
+    33a4:	51                   	push   %ecx
+    33a5:	68 80 4d 00 00       	push   $0x4d80
+    33aa:	ff 35 00 5f 00 00    	pushl  0x5f00
+    args[MAXARG-1] = 0;
+    33b0:	c7 05 9c 5f 00 00 00 	movl   $0x0,0x5f9c
+    33b7:	00 00 00 
+    printf(stdout, "bigarg test\n");
+    33ba:	e8 41 07 00 00       	call   3b00 <printf>
+    exec("echo", args);
+    33bf:	58                   	pop    %eax
+    33c0:	5a                   	pop    %edx
+    33c1:	68 20 5f 00 00       	push   $0x5f20
+    33c6:	68 4d 3f 00 00       	push   $0x3f4d
+    33cb:	e8 eb 05 00 00       	call   39bb <exec>
+    printf(stdout, "bigarg test ok\n");
+    33d0:	59                   	pop    %ecx
+    33d1:	58                   	pop    %eax
+    33d2:	68 8d 4d 00 00       	push   $0x4d8d
+    33d7:	ff 35 00 5f 00 00    	pushl  0x5f00
+    33dd:	e8 1e 07 00 00       	call   3b00 <printf>
+    fd = open("bigarg-ok", O_CREATE);
+    33e2:	58                   	pop    %eax
+    33e3:	5a                   	pop    %edx
+    33e4:	68 00 02 00 00       	push   $0x200
+    33e9:	68 76 4d 00 00       	push   $0x4d76
+    33ee:	e8 d0 05 00 00       	call   39c3 <open>
+    close(fd);
+    33f3:	89 04 24             	mov    %eax,(%esp)
+    33f6:	e8 b0 05 00 00       	call   39ab <close>
+    exit();
+    33fb:	e8 83 05 00 00       	call   3983 <exit>
+    printf(stdout, "bigarg test failed!\n");
+    3400:	50                   	push   %eax
+    3401:	50                   	push   %eax
+    3402:	68 b6 4d 00 00       	push   $0x4db6
+    3407:	ff 35 00 5f 00 00    	pushl  0x5f00
+    340d:	e8 ee 06 00 00       	call   3b00 <printf>
+    exit();
+    3412:	e8 6c 05 00 00       	call   3983 <exit>
+    printf(stdout, "bigargtest: fork failed\n");
+    3417:	52                   	push   %edx
+    3418:	52                   	push   %edx
+    3419:	68 9d 4d 00 00       	push   $0x4d9d
+    341e:	ff 35 00 5f 00 00    	pushl  0x5f00
+    3424:	e8 d7 06 00 00       	call   3b00 <printf>
+    exit();
+    3429:	e8 55 05 00 00       	call   3983 <exit>
+    342e:	66 90                	xchg   %ax,%ax
+
+00003430 <fsfull>:
+{
+    3430:	f3 0f 1e fb          	endbr32 
+    3434:	55                   	push   %ebp
+    3435:	89 e5                	mov    %esp,%ebp
+    3437:	57                   	push   %edi
+    3438:	56                   	push   %esi
+  for(nfiles = 0; ; nfiles++){
+    3439:	31 f6                	xor    %esi,%esi
+{
+    343b:	53                   	push   %ebx
+    343c:	83 ec 54             	sub    $0x54,%esp
+  printf(1, "fsfull test\n");
+    343f:	68 cb 4d 00 00       	push   $0x4dcb
+    3444:	6a 01                	push   $0x1
+    3446:	e8 b5 06 00 00       	call   3b00 <printf>
+    344b:	83 c4 10             	add    $0x10,%esp
+    344e:	66 90                	xchg   %ax,%ax
+    name[1] = '0' + nfiles / 1000;
+    3450:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
+    name[3] = '0' + (nfiles % 100) / 10;
+    3455:	b9 cd cc cc cc       	mov    $0xcccccccd,%ecx
+    printf(1, "writing %s\n", name);
+    345a:	83 ec 04             	sub    $0x4,%esp
+    name[0] = 'f';
+    345d:	c6 45 a8 66          	movb   $0x66,-0x58(%ebp)
+    name[1] = '0' + nfiles / 1000;
+    3461:	f7 e6                	mul    %esi
+    name[5] = '\0';
+    3463:	c6 45 ad 00          	movb   $0x0,-0x53(%ebp)
+    name[1] = '0' + nfiles / 1000;
+    3467:	c1 ea 06             	shr    $0x6,%edx
+    346a:	8d 42 30             	lea    0x30(%edx),%eax
+    name[2] = '0' + (nfiles % 1000) / 100;
+    346d:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
+    name[1] = '0' + nfiles / 1000;
+    3473:	88 45 a9             	mov    %al,-0x57(%ebp)
+    name[2] = '0' + (nfiles % 1000) / 100;
+    3476:	89 f0                	mov    %esi,%eax
+    3478:	29 d0                	sub    %edx,%eax
+    347a:	89 c2                	mov    %eax,%edx
+    347c:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
+    3481:	f7 e2                	mul    %edx
+    name[3] = '0' + (nfiles % 100) / 10;
+    3483:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
+    name[2] = '0' + (nfiles % 1000) / 100;
+    3488:	c1 ea 05             	shr    $0x5,%edx
+    348b:	83 c2 30             	add    $0x30,%edx
+    348e:	88 55 aa             	mov    %dl,-0x56(%ebp)
+    name[3] = '0' + (nfiles % 100) / 10;
+    3491:	f7 e6                	mul    %esi
+    3493:	89 f0                	mov    %esi,%eax
+    3495:	c1 ea 05             	shr    $0x5,%edx
+    3498:	6b d2 64             	imul   $0x64,%edx,%edx
+    349b:	29 d0                	sub    %edx,%eax
+    349d:	f7 e1                	mul    %ecx
+    name[4] = '0' + (nfiles % 10);
+    349f:	89 f0                	mov    %esi,%eax
+    name[3] = '0' + (nfiles % 100) / 10;
+    34a1:	c1 ea 03             	shr    $0x3,%edx
+    34a4:	83 c2 30             	add    $0x30,%edx
+    34a7:	88 55 ab             	mov    %dl,-0x55(%ebp)
+    name[4] = '0' + (nfiles % 10);
+    34aa:	f7 e1                	mul    %ecx
+    34ac:	89 f1                	mov    %esi,%ecx
+    34ae:	c1 ea 03             	shr    $0x3,%edx
+    34b1:	8d 04 92             	lea    (%edx,%edx,4),%eax
+    34b4:	01 c0                	add    %eax,%eax
+    34b6:	29 c1                	sub    %eax,%ecx
+    34b8:	89 c8                	mov    %ecx,%eax
+    34ba:	83 c0 30             	add    $0x30,%eax
+    34bd:	88 45 ac             	mov    %al,-0x54(%ebp)
+    printf(1, "writing %s\n", name);
+    34c0:	8d 45 a8             	lea    -0x58(%ebp),%eax
+    34c3:	50                   	push   %eax
+    34c4:	68 d8 4d 00 00       	push   $0x4dd8
+    34c9:	6a 01                	push   $0x1
+    34cb:	e8 30 06 00 00       	call   3b00 <printf>
+    int fd = open(name, O_CREATE|O_RDWR);
+    34d0:	58                   	pop    %eax
+    34d1:	8d 45 a8             	lea    -0x58(%ebp),%eax
+    34d4:	5a                   	pop    %edx
+    34d5:	68 02 02 00 00       	push   $0x202
+    34da:	50                   	push   %eax
+    34db:	e8 e3 04 00 00       	call   39c3 <open>
+    if(fd < 0){
+    34e0:	83 c4 10             	add    $0x10,%esp
+    int fd = open(name, O_CREATE|O_RDWR);
+    34e3:	89 c7                	mov    %eax,%edi
+    if(fd < 0){
+    34e5:	85 c0                	test   %eax,%eax
+    34e7:	78 4d                	js     3536 <fsfull+0x106>
+    int total = 0;
+    34e9:	31 db                	xor    %ebx,%ebx
+    34eb:	eb 05                	jmp    34f2 <fsfull+0xc2>
+    34ed:	8d 76 00             	lea    0x0(%esi),%esi
+      total += cc;
+    34f0:	01 c3                	add    %eax,%ebx
+      int cc = write(fd, buf, 512);
+    34f2:	83 ec 04             	sub    $0x4,%esp
+    34f5:	68 00 02 00 00       	push   $0x200
+    34fa:	68 e0 86 00 00       	push   $0x86e0
+    34ff:	57                   	push   %edi
+    3500:	e8 9e 04 00 00       	call   39a3 <write>
+      if(cc < 512)
+    3505:	83 c4 10             	add    $0x10,%esp
+    3508:	3d ff 01 00 00       	cmp    $0x1ff,%eax
+    350d:	7f e1                	jg     34f0 <fsfull+0xc0>
+    printf(1, "wrote %d bytes\n", total);
+    350f:	83 ec 04             	sub    $0x4,%esp
+    3512:	53                   	push   %ebx
+    3513:	68 f4 4d 00 00       	push   $0x4df4
+    3518:	6a 01                	push   $0x1
+    351a:	e8 e1 05 00 00       	call   3b00 <printf>
+    close(fd);
+    351f:	89 3c 24             	mov    %edi,(%esp)
+    3522:	e8 84 04 00 00       	call   39ab <close>
+    if(total == 0)
+    3527:	83 c4 10             	add    $0x10,%esp
+    352a:	85 db                	test   %ebx,%ebx
+    352c:	74 1e                	je     354c <fsfull+0x11c>
+  for(nfiles = 0; ; nfiles++){
+    352e:	83 c6 01             	add    $0x1,%esi
+    3531:	e9 1a ff ff ff       	jmp    3450 <fsfull+0x20>
+      printf(1, "open %s failed\n", name);
+    3536:	83 ec 04             	sub    $0x4,%esp
+    3539:	8d 45 a8             	lea    -0x58(%ebp),%eax
+    353c:	50                   	push   %eax
+    353d:	68 e4 4d 00 00       	push   $0x4de4
+    3542:	6a 01                	push   $0x1
+    3544:	e8 b7 05 00 00       	call   3b00 <printf>
+      break;
+    3549:	83 c4 10             	add    $0x10,%esp
+    name[1] = '0' + nfiles / 1000;
+    354c:	bf d3 4d 62 10       	mov    $0x10624dd3,%edi
+    name[2] = '0' + (nfiles % 1000) / 100;
+    3551:	bb 1f 85 eb 51       	mov    $0x51eb851f,%ebx
+    3556:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    355d:	8d 76 00             	lea    0x0(%esi),%esi
+    name[1] = '0' + nfiles / 1000;
+    3560:	89 f0                	mov    %esi,%eax
+    3562:	89 f1                	mov    %esi,%ecx
+    unlink(name);
+    3564:	83 ec 0c             	sub    $0xc,%esp
+    name[0] = 'f';
+    3567:	c6 45 a8 66          	movb   $0x66,-0x58(%ebp)
+    name[1] = '0' + nfiles / 1000;
+    356b:	f7 ef                	imul   %edi
+    356d:	c1 f9 1f             	sar    $0x1f,%ecx
+    name[5] = '\0';
+    3570:	c6 45 ad 00          	movb   $0x0,-0x53(%ebp)
+    name[1] = '0' + nfiles / 1000;
+    3574:	c1 fa 06             	sar    $0x6,%edx
+    3577:	29 ca                	sub    %ecx,%edx
+    3579:	8d 42 30             	lea    0x30(%edx),%eax
+    name[2] = '0' + (nfiles % 1000) / 100;
+    357c:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
+    name[1] = '0' + nfiles / 1000;
+    3582:	88 45 a9             	mov    %al,-0x57(%ebp)
+    name[2] = '0' + (nfiles % 1000) / 100;
+    3585:	89 f0                	mov    %esi,%eax
+    3587:	29 d0                	sub    %edx,%eax
+    3589:	f7 e3                	mul    %ebx
+    name[3] = '0' + (nfiles % 100) / 10;
+    358b:	89 f0                	mov    %esi,%eax
+    name[2] = '0' + (nfiles % 1000) / 100;
+    358d:	c1 ea 05             	shr    $0x5,%edx
+    3590:	83 c2 30             	add    $0x30,%edx
+    3593:	88 55 aa             	mov    %dl,-0x56(%ebp)
+    name[3] = '0' + (nfiles % 100) / 10;
+    3596:	f7 eb                	imul   %ebx
+    3598:	89 f0                	mov    %esi,%eax
+    359a:	c1 fa 05             	sar    $0x5,%edx
+    359d:	29 ca                	sub    %ecx,%edx
+    359f:	6b d2 64             	imul   $0x64,%edx,%edx
+    35a2:	29 d0                	sub    %edx,%eax
+    35a4:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
+    35a9:	f7 e2                	mul    %edx
+    name[4] = '0' + (nfiles % 10);
+    35ab:	89 f0                	mov    %esi,%eax
+    name[3] = '0' + (nfiles % 100) / 10;
+    35ad:	c1 ea 03             	shr    $0x3,%edx
+    35b0:	83 c2 30             	add    $0x30,%edx
+    35b3:	88 55 ab             	mov    %dl,-0x55(%ebp)
+    name[4] = '0' + (nfiles % 10);
+    35b6:	ba 67 66 66 66       	mov    $0x66666667,%edx
+    35bb:	f7 ea                	imul   %edx
+    35bd:	c1 fa 02             	sar    $0x2,%edx
+    35c0:	29 ca                	sub    %ecx,%edx
+    35c2:	89 f1                	mov    %esi,%ecx
+    nfiles--;
+    35c4:	83 ee 01             	sub    $0x1,%esi
+    name[4] = '0' + (nfiles % 10);
+    35c7:	8d 04 92             	lea    (%edx,%edx,4),%eax
+    35ca:	01 c0                	add    %eax,%eax
+    35cc:	29 c1                	sub    %eax,%ecx
+    35ce:	89 c8                	mov    %ecx,%eax
+    35d0:	83 c0 30             	add    $0x30,%eax
+    35d3:	88 45 ac             	mov    %al,-0x54(%ebp)
+    unlink(name);
+    35d6:	8d 45 a8             	lea    -0x58(%ebp),%eax
+    35d9:	50                   	push   %eax
+    35da:	e8 f4 03 00 00       	call   39d3 <unlink>
+  while(nfiles >= 0){
+    35df:	83 c4 10             	add    $0x10,%esp
+    35e2:	83 fe ff             	cmp    $0xffffffff,%esi
+    35e5:	0f 85 75 ff ff ff    	jne    3560 <fsfull+0x130>
+  printf(1, "fsfull test finished\n");
+    35eb:	83 ec 08             	sub    $0x8,%esp
+    35ee:	68 04 4e 00 00       	push   $0x4e04
+    35f3:	6a 01                	push   $0x1
+    35f5:	e8 06 05 00 00       	call   3b00 <printf>
+}
+    35fa:	83 c4 10             	add    $0x10,%esp
+    35fd:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    3600:	5b                   	pop    %ebx
+    3601:	5e                   	pop    %esi
+    3602:	5f                   	pop    %edi
+    3603:	5d                   	pop    %ebp
+    3604:	c3                   	ret    
+    3605:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    360c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00003610 <uio>:
+{
+    3610:	f3 0f 1e fb          	endbr32 
+    3614:	55                   	push   %ebp
+    3615:	89 e5                	mov    %esp,%ebp
+    3617:	83 ec 10             	sub    $0x10,%esp
+  printf(1, "uio test\n");
+    361a:	68 1a 4e 00 00       	push   $0x4e1a
+    361f:	6a 01                	push   $0x1
+    3621:	e8 da 04 00 00       	call   3b00 <printf>
+  pid = fork();
+    3626:	e8 50 03 00 00       	call   397b <fork>
+  if(pid == 0){
+    362b:	83 c4 10             	add    $0x10,%esp
+    362e:	85 c0                	test   %eax,%eax
+    3630:	74 1b                	je     364d <uio+0x3d>
+  } else if(pid < 0){
+    3632:	78 3d                	js     3671 <uio+0x61>
+  wait();
+    3634:	e8 52 03 00 00       	call   398b <wait>
+  printf(1, "uio test done\n");
+    3639:	83 ec 08             	sub    $0x8,%esp
+    363c:	68 24 4e 00 00       	push   $0x4e24
+    3641:	6a 01                	push   $0x1
+    3643:	e8 b8 04 00 00       	call   3b00 <printf>
+}
+    3648:	83 c4 10             	add    $0x10,%esp
+    364b:	c9                   	leave  
+    364c:	c3                   	ret    
+    asm volatile("outb %0,%1"::"a"(val), "d" (port));
+    364d:	b8 09 00 00 00       	mov    $0x9,%eax
+    3652:	ba 70 00 00 00       	mov    $0x70,%edx
+    3657:	ee                   	out    %al,(%dx)
+    asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
+    3658:	ba 71 00 00 00       	mov    $0x71,%edx
+    365d:	ec                   	in     (%dx),%al
+    printf(1, "uio: uio succeeded; test FAILED\n");
+    365e:	52                   	push   %edx
+    365f:	52                   	push   %edx
+    3660:	68 b0 55 00 00       	push   $0x55b0
+    3665:	6a 01                	push   $0x1
+    3667:	e8 94 04 00 00       	call   3b00 <printf>
+    exit();
+    366c:	e8 12 03 00 00       	call   3983 <exit>
+    printf (1, "fork failed\n");
+    3671:	50                   	push   %eax
+    3672:	50                   	push   %eax
+    3673:	68 a9 4d 00 00       	push   $0x4da9
+    3678:	6a 01                	push   $0x1
+    367a:	e8 81 04 00 00       	call   3b00 <printf>
+    exit();
+    367f:	e8 ff 02 00 00       	call   3983 <exit>
+    3684:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    368b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    368f:	90                   	nop
+
+00003690 <argptest>:
+{
+    3690:	f3 0f 1e fb          	endbr32 
+    3694:	55                   	push   %ebp
+    3695:	89 e5                	mov    %esp,%ebp
+    3697:	53                   	push   %ebx
+    3698:	83 ec 0c             	sub    $0xc,%esp
+  fd = open("init", O_RDONLY);
+    369b:	6a 00                	push   $0x0
+    369d:	68 33 4e 00 00       	push   $0x4e33
+    36a2:	e8 1c 03 00 00       	call   39c3 <open>
+  if (fd < 0) {
+    36a7:	83 c4 10             	add    $0x10,%esp
+    36aa:	85 c0                	test   %eax,%eax
+    36ac:	78 39                	js     36e7 <argptest+0x57>
+  read(fd, sbrk(0) - 1, -1);
+    36ae:	83 ec 0c             	sub    $0xc,%esp
+    36b1:	89 c3                	mov    %eax,%ebx
+    36b3:	6a 00                	push   $0x0
+    36b5:	e8 51 03 00 00       	call   3a0b <sbrk>
+    36ba:	83 c4 0c             	add    $0xc,%esp
+    36bd:	83 e8 01             	sub    $0x1,%eax
+    36c0:	6a ff                	push   $0xffffffff
+    36c2:	50                   	push   %eax
+    36c3:	53                   	push   %ebx
+    36c4:	e8 d2 02 00 00       	call   399b <read>
+  close(fd);
+    36c9:	89 1c 24             	mov    %ebx,(%esp)
+    36cc:	e8 da 02 00 00       	call   39ab <close>
+  printf(1, "arg test passed\n");
+    36d1:	58                   	pop    %eax
+    36d2:	5a                   	pop    %edx
+    36d3:	68 45 4e 00 00       	push   $0x4e45
+    36d8:	6a 01                	push   $0x1
+    36da:	e8 21 04 00 00       	call   3b00 <printf>
+}
+    36df:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+    36e2:	83 c4 10             	add    $0x10,%esp
+    36e5:	c9                   	leave  
+    36e6:	c3                   	ret    
+    printf(2, "open failed\n");
+    36e7:	51                   	push   %ecx
+    36e8:	51                   	push   %ecx
+    36e9:	68 38 4e 00 00       	push   $0x4e38
+    36ee:	6a 02                	push   $0x2
+    36f0:	e8 0b 04 00 00       	call   3b00 <printf>
+    exit();
+    36f5:	e8 89 02 00 00       	call   3983 <exit>
+    36fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00003700 <rand>:
+{
+    3700:	f3 0f 1e fb          	endbr32 
+  randstate = randstate * 1664525 + 1013904223;
+    3704:	69 05 fc 5e 00 00 0d 	imul   $0x19660d,0x5efc,%eax
+    370b:	66 19 00 
+    370e:	05 5f f3 6e 3c       	add    $0x3c6ef35f,%eax
+    3713:	a3 fc 5e 00 00       	mov    %eax,0x5efc
+}
+    3718:	c3                   	ret    
+    3719:	66 90                	xchg   %ax,%ax
+    371b:	66 90                	xchg   %ax,%ax
+    371d:	66 90                	xchg   %ax,%ax
+    371f:	90                   	nop
+
+00003720 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+    3720:	f3 0f 1e fb          	endbr32 
+    3724:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    3725:	31 c0                	xor    %eax,%eax
+{
+    3727:	89 e5                	mov    %esp,%ebp
+    3729:	53                   	push   %ebx
+    372a:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    372d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+    3730:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+    3734:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+    3737:	83 c0 01             	add    $0x1,%eax
+    373a:	84 d2                	test   %dl,%dl
+    373c:	75 f2                	jne    3730 <strcpy+0x10>
+    ;
+  return os;
+}
+    373e:	89 c8                	mov    %ecx,%eax
+    3740:	5b                   	pop    %ebx
+    3741:	5d                   	pop    %ebp
+    3742:	c3                   	ret    
+    3743:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    374a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00003750 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    3750:	f3 0f 1e fb          	endbr32 
+    3754:	55                   	push   %ebp
+    3755:	89 e5                	mov    %esp,%ebp
+    3757:	53                   	push   %ebx
+    3758:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    375b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+    375e:	0f b6 01             	movzbl (%ecx),%eax
+    3761:	0f b6 1a             	movzbl (%edx),%ebx
+    3764:	84 c0                	test   %al,%al
+    3766:	75 19                	jne    3781 <strcmp+0x31>
+    3768:	eb 26                	jmp    3790 <strcmp+0x40>
+    376a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    3770:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+    3774:	83 c1 01             	add    $0x1,%ecx
+    3777:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+    377a:	0f b6 1a             	movzbl (%edx),%ebx
+    377d:	84 c0                	test   %al,%al
+    377f:	74 0f                	je     3790 <strcmp+0x40>
+    3781:	38 d8                	cmp    %bl,%al
+    3783:	74 eb                	je     3770 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+    3785:	29 d8                	sub    %ebx,%eax
+}
+    3787:	5b                   	pop    %ebx
+    3788:	5d                   	pop    %ebp
+    3789:	c3                   	ret    
+    378a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    3790:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+    3792:	29 d8                	sub    %ebx,%eax
+}
+    3794:	5b                   	pop    %ebx
+    3795:	5d                   	pop    %ebp
+    3796:	c3                   	ret    
+    3797:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    379e:	66 90                	xchg   %ax,%ax
+
+000037a0 <strlen>:
+
+uint
+strlen(const char *s)
+{
+    37a0:	f3 0f 1e fb          	endbr32 
+    37a4:	55                   	push   %ebp
+    37a5:	89 e5                	mov    %esp,%ebp
+    37a7:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+    37aa:	80 3a 00             	cmpb   $0x0,(%edx)
+    37ad:	74 21                	je     37d0 <strlen+0x30>
+    37af:	31 c0                	xor    %eax,%eax
+    37b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    37b8:	83 c0 01             	add    $0x1,%eax
+    37bb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+    37bf:	89 c1                	mov    %eax,%ecx
+    37c1:	75 f5                	jne    37b8 <strlen+0x18>
+    ;
+  return n;
+}
+    37c3:	89 c8                	mov    %ecx,%eax
+    37c5:	5d                   	pop    %ebp
+    37c6:	c3                   	ret    
+    37c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    37ce:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+    37d0:	31 c9                	xor    %ecx,%ecx
+}
+    37d2:	5d                   	pop    %ebp
+    37d3:	89 c8                	mov    %ecx,%eax
+    37d5:	c3                   	ret    
+    37d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    37dd:	8d 76 00             	lea    0x0(%esi),%esi
+
+000037e0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    37e0:	f3 0f 1e fb          	endbr32 
+    37e4:	55                   	push   %ebp
+    37e5:	89 e5                	mov    %esp,%ebp
+    37e7:	57                   	push   %edi
+    37e8:	8b 55 08             	mov    0x8(%ebp),%edx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    37eb:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    37ee:	8b 45 0c             	mov    0xc(%ebp),%eax
+    37f1:	89 d7                	mov    %edx,%edi
+    37f3:	fc                   	cld    
+    37f4:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+    37f6:	89 d0                	mov    %edx,%eax
+    37f8:	5f                   	pop    %edi
+    37f9:	5d                   	pop    %ebp
+    37fa:	c3                   	ret    
+    37fb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    37ff:	90                   	nop
+
+00003800 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    3800:	f3 0f 1e fb          	endbr32 
+    3804:	55                   	push   %ebp
+    3805:	89 e5                	mov    %esp,%ebp
+    3807:	8b 45 08             	mov    0x8(%ebp),%eax
+    380a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+    380e:	0f b6 10             	movzbl (%eax),%edx
+    3811:	84 d2                	test   %dl,%dl
+    3813:	75 16                	jne    382b <strchr+0x2b>
+    3815:	eb 21                	jmp    3838 <strchr+0x38>
+    3817:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    381e:	66 90                	xchg   %ax,%ax
+    3820:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+    3824:	83 c0 01             	add    $0x1,%eax
+    3827:	84 d2                	test   %dl,%dl
+    3829:	74 0d                	je     3838 <strchr+0x38>
+    if(*s == c)
+    382b:	38 d1                	cmp    %dl,%cl
+    382d:	75 f1                	jne    3820 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+    382f:	5d                   	pop    %ebp
+    3830:	c3                   	ret    
+    3831:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+    3838:	31 c0                	xor    %eax,%eax
+}
+    383a:	5d                   	pop    %ebp
+    383b:	c3                   	ret    
+    383c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00003840 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    3840:	f3 0f 1e fb          	endbr32 
+    3844:	55                   	push   %ebp
+    3845:	89 e5                	mov    %esp,%ebp
+    3847:	57                   	push   %edi
+    3848:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    3849:	31 f6                	xor    %esi,%esi
+{
+    384b:	53                   	push   %ebx
+    384c:	89 f3                	mov    %esi,%ebx
+    384e:	83 ec 1c             	sub    $0x1c,%esp
+    3851:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+    3854:	eb 33                	jmp    3889 <gets+0x49>
+    3856:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    385d:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+    3860:	83 ec 04             	sub    $0x4,%esp
+    3863:	8d 45 e7             	lea    -0x19(%ebp),%eax
+    3866:	6a 01                	push   $0x1
+    3868:	50                   	push   %eax
+    3869:	6a 00                	push   $0x0
+    386b:	e8 2b 01 00 00       	call   399b <read>
+    if(cc < 1)
+    3870:	83 c4 10             	add    $0x10,%esp
+    3873:	85 c0                	test   %eax,%eax
+    3875:	7e 1c                	jle    3893 <gets+0x53>
+      break;
+    buf[i++] = c;
+    3877:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+    387b:	83 c7 01             	add    $0x1,%edi
+    387e:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+    3881:	3c 0a                	cmp    $0xa,%al
+    3883:	74 23                	je     38a8 <gets+0x68>
+    3885:	3c 0d                	cmp    $0xd,%al
+    3887:	74 1f                	je     38a8 <gets+0x68>
+  for(i=0; i+1 < max; ){
+    3889:	83 c3 01             	add    $0x1,%ebx
+    388c:	89 fe                	mov    %edi,%esi
+    388e:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+    3891:	7c cd                	jl     3860 <gets+0x20>
+    3893:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+    3895:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+    3898:	c6 03 00             	movb   $0x0,(%ebx)
+}
+    389b:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    389e:	5b                   	pop    %ebx
+    389f:	5e                   	pop    %esi
+    38a0:	5f                   	pop    %edi
+    38a1:	5d                   	pop    %ebp
+    38a2:	c3                   	ret    
+    38a3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    38a7:	90                   	nop
+    38a8:	8b 75 08             	mov    0x8(%ebp),%esi
+    38ab:	8b 45 08             	mov    0x8(%ebp),%eax
+    38ae:	01 de                	add    %ebx,%esi
+    38b0:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+    38b2:	c6 03 00             	movb   $0x0,(%ebx)
+}
+    38b5:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    38b8:	5b                   	pop    %ebx
+    38b9:	5e                   	pop    %esi
+    38ba:	5f                   	pop    %edi
+    38bb:	5d                   	pop    %ebp
+    38bc:	c3                   	ret    
+    38bd:	8d 76 00             	lea    0x0(%esi),%esi
+
+000038c0 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+    38c0:	f3 0f 1e fb          	endbr32 
+    38c4:	55                   	push   %ebp
+    38c5:	89 e5                	mov    %esp,%ebp
+    38c7:	56                   	push   %esi
+    38c8:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    38c9:	83 ec 08             	sub    $0x8,%esp
+    38cc:	6a 00                	push   $0x0
+    38ce:	ff 75 08             	pushl  0x8(%ebp)
+    38d1:	e8 ed 00 00 00       	call   39c3 <open>
+  if(fd < 0)
+    38d6:	83 c4 10             	add    $0x10,%esp
+    38d9:	85 c0                	test   %eax,%eax
+    38db:	78 2b                	js     3908 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+    38dd:	83 ec 08             	sub    $0x8,%esp
+    38e0:	ff 75 0c             	pushl  0xc(%ebp)
+    38e3:	89 c3                	mov    %eax,%ebx
+    38e5:	50                   	push   %eax
+    38e6:	e8 f0 00 00 00       	call   39db <fstat>
+  close(fd);
+    38eb:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+    38ee:	89 c6                	mov    %eax,%esi
+  close(fd);
+    38f0:	e8 b6 00 00 00       	call   39ab <close>
+  return r;
+    38f5:	83 c4 10             	add    $0x10,%esp
+}
+    38f8:	8d 65 f8             	lea    -0x8(%ebp),%esp
+    38fb:	89 f0                	mov    %esi,%eax
+    38fd:	5b                   	pop    %ebx
+    38fe:	5e                   	pop    %esi
+    38ff:	5d                   	pop    %ebp
+    3900:	c3                   	ret    
+    3901:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+    3908:	be ff ff ff ff       	mov    $0xffffffff,%esi
+    390d:	eb e9                	jmp    38f8 <stat+0x38>
+    390f:	90                   	nop
+
+00003910 <atoi>:
+
+int
+atoi(const char *s)
+{
+    3910:	f3 0f 1e fb          	endbr32 
+    3914:	55                   	push   %ebp
+    3915:	89 e5                	mov    %esp,%ebp
+    3917:	53                   	push   %ebx
+    3918:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    391b:	0f be 02             	movsbl (%edx),%eax
+    391e:	8d 48 d0             	lea    -0x30(%eax),%ecx
+    3921:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+    3924:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+    3929:	77 1a                	ja     3945 <atoi+0x35>
+    392b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    392f:	90                   	nop
+    n = n*10 + *s++ - '0';
+    3930:	83 c2 01             	add    $0x1,%edx
+    3933:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+    3936:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+    393a:	0f be 02             	movsbl (%edx),%eax
+    393d:	8d 58 d0             	lea    -0x30(%eax),%ebx
+    3940:	80 fb 09             	cmp    $0x9,%bl
+    3943:	76 eb                	jbe    3930 <atoi+0x20>
+  return n;
+}
+    3945:	89 c8                	mov    %ecx,%eax
+    3947:	5b                   	pop    %ebx
+    3948:	5d                   	pop    %ebp
+    3949:	c3                   	ret    
+    394a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00003950 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+    3950:	f3 0f 1e fb          	endbr32 
+    3954:	55                   	push   %ebp
+    3955:	89 e5                	mov    %esp,%ebp
+    3957:	57                   	push   %edi
+    3958:	8b 45 10             	mov    0x10(%ebp),%eax
+    395b:	8b 55 08             	mov    0x8(%ebp),%edx
+    395e:	56                   	push   %esi
+    395f:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    3962:	85 c0                	test   %eax,%eax
+    3964:	7e 0f                	jle    3975 <memmove+0x25>
+    3966:	01 d0                	add    %edx,%eax
+  dst = vdst;
+    3968:	89 d7                	mov    %edx,%edi
+    396a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+    3970:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+    3971:	39 f8                	cmp    %edi,%eax
+    3973:	75 fb                	jne    3970 <memmove+0x20>
+  return vdst;
+}
+    3975:	5e                   	pop    %esi
+    3976:	89 d0                	mov    %edx,%eax
+    3978:	5f                   	pop    %edi
+    3979:	5d                   	pop    %ebp
+    397a:	c3                   	ret    
+
+0000397b <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    397b:	b8 01 00 00 00       	mov    $0x1,%eax
+    3980:	cd 40                	int    $0x40
+    3982:	c3                   	ret    
+
+00003983 <exit>:
+SYSCALL(exit)
+    3983:	b8 02 00 00 00       	mov    $0x2,%eax
+    3988:	cd 40                	int    $0x40
+    398a:	c3                   	ret    
+
+0000398b <wait>:
+SYSCALL(wait)
+    398b:	b8 03 00 00 00       	mov    $0x3,%eax
+    3990:	cd 40                	int    $0x40
+    3992:	c3                   	ret    
+
+00003993 <pipe>:
+SYSCALL(pipe)
+    3993:	b8 04 00 00 00       	mov    $0x4,%eax
+    3998:	cd 40                	int    $0x40
+    399a:	c3                   	ret    
+
+0000399b <read>:
+SYSCALL(read)
+    399b:	b8 05 00 00 00       	mov    $0x5,%eax
+    39a0:	cd 40                	int    $0x40
+    39a2:	c3                   	ret    
+
+000039a3 <write>:
+SYSCALL(write)
+    39a3:	b8 10 00 00 00       	mov    $0x10,%eax
+    39a8:	cd 40                	int    $0x40
+    39aa:	c3                   	ret    
+
+000039ab <close>:
+SYSCALL(close)
+    39ab:	b8 15 00 00 00       	mov    $0x15,%eax
+    39b0:	cd 40                	int    $0x40
+    39b2:	c3                   	ret    
+
+000039b3 <kill>:
+SYSCALL(kill)
+    39b3:	b8 06 00 00 00       	mov    $0x6,%eax
+    39b8:	cd 40                	int    $0x40
+    39ba:	c3                   	ret    
+
+000039bb <exec>:
+SYSCALL(exec)
+    39bb:	b8 07 00 00 00       	mov    $0x7,%eax
+    39c0:	cd 40                	int    $0x40
+    39c2:	c3                   	ret    
+
+000039c3 <open>:
+SYSCALL(open)
+    39c3:	b8 0f 00 00 00       	mov    $0xf,%eax
+    39c8:	cd 40                	int    $0x40
+    39ca:	c3                   	ret    
+
+000039cb <mknod>:
+SYSCALL(mknod)
+    39cb:	b8 11 00 00 00       	mov    $0x11,%eax
+    39d0:	cd 40                	int    $0x40
+    39d2:	c3                   	ret    
+
+000039d3 <unlink>:
+SYSCALL(unlink)
+    39d3:	b8 12 00 00 00       	mov    $0x12,%eax
+    39d8:	cd 40                	int    $0x40
+    39da:	c3                   	ret    
+
+000039db <fstat>:
+SYSCALL(fstat)
+    39db:	b8 08 00 00 00       	mov    $0x8,%eax
+    39e0:	cd 40                	int    $0x40
+    39e2:	c3                   	ret    
+
+000039e3 <link>:
+SYSCALL(link)
+    39e3:	b8 13 00 00 00       	mov    $0x13,%eax
+    39e8:	cd 40                	int    $0x40
+    39ea:	c3                   	ret    
+
+000039eb <mkdir>:
+SYSCALL(mkdir)
+    39eb:	b8 14 00 00 00       	mov    $0x14,%eax
+    39f0:	cd 40                	int    $0x40
+    39f2:	c3                   	ret    
+
+000039f3 <chdir>:
+SYSCALL(chdir)
+    39f3:	b8 09 00 00 00       	mov    $0x9,%eax
+    39f8:	cd 40                	int    $0x40
+    39fa:	c3                   	ret    
+
+000039fb <dup>:
+SYSCALL(dup)
+    39fb:	b8 0a 00 00 00       	mov    $0xa,%eax
+    3a00:	cd 40                	int    $0x40
+    3a02:	c3                   	ret    
+
+00003a03 <getpid>:
+SYSCALL(getpid)
+    3a03:	b8 0b 00 00 00       	mov    $0xb,%eax
+    3a08:	cd 40                	int    $0x40
+    3a0a:	c3                   	ret    
+
+00003a0b <sbrk>:
+SYSCALL(sbrk)
+    3a0b:	b8 0c 00 00 00       	mov    $0xc,%eax
+    3a10:	cd 40                	int    $0x40
+    3a12:	c3                   	ret    
+
+00003a13 <sleep>:
+SYSCALL(sleep)
+    3a13:	b8 0d 00 00 00       	mov    $0xd,%eax
+    3a18:	cd 40                	int    $0x40
+    3a1a:	c3                   	ret    
+
+00003a1b <uptime>:
+SYSCALL(uptime)
+    3a1b:	b8 0e 00 00 00       	mov    $0xe,%eax
+    3a20:	cd 40                	int    $0x40
+    3a22:	c3                   	ret    
+
+00003a23 <draw>:
+SYSCALL(draw)
+    3a23:	b8 16 00 00 00       	mov    $0x16,%eax
+    3a28:	cd 40                	int    $0x40
+    3a2a:	c3                   	ret    
+
+00003a2b <thread_create>:
+
+SYSCALL(thread_create)
+    3a2b:	b8 17 00 00 00       	mov    $0x17,%eax
+    3a30:	cd 40                	int    $0x40
+    3a32:	c3                   	ret    
+
+00003a33 <thread_join>:
+SYSCALL(thread_join)
+    3a33:	b8 18 00 00 00       	mov    $0x18,%eax
+    3a38:	cd 40                	int    $0x40
+    3a3a:	c3                   	ret    
+
+00003a3b <thread_exit>:
+SYSCALL(thread_exit)
+    3a3b:	b8 19 00 00 00       	mov    $0x19,%eax
+    3a40:	cd 40                	int    $0x40
+    3a42:	c3                   	ret    
+    3a43:	66 90                	xchg   %ax,%ax
+    3a45:	66 90                	xchg   %ax,%ax
+    3a47:	66 90                	xchg   %ax,%ax
+    3a49:	66 90                	xchg   %ax,%ax
+    3a4b:	66 90                	xchg   %ax,%ax
+    3a4d:	66 90                	xchg   %ax,%ax
+    3a4f:	90                   	nop
+
+00003a50 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    3a50:	55                   	push   %ebp
+    3a51:	89 e5                	mov    %esp,%ebp
+    3a53:	57                   	push   %edi
+    3a54:	56                   	push   %esi
+    3a55:	53                   	push   %ebx
+    3a56:	83 ec 3c             	sub    $0x3c,%esp
+    3a59:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+    3a5c:	89 d1                	mov    %edx,%ecx
+{
+    3a5e:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  if(sgn && xx < 0){
+    3a61:	85 d2                	test   %edx,%edx
+    3a63:	0f 89 7f 00 00 00    	jns    3ae8 <printint+0x98>
+    3a69:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
+    3a6d:	74 79                	je     3ae8 <printint+0x98>
+    neg = 1;
+    3a6f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+    x = -xx;
+    3a76:	f7 d9                	neg    %ecx
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+    3a78:	31 db                	xor    %ebx,%ebx
+    3a7a:	8d 75 d7             	lea    -0x29(%ebp),%esi
+    3a7d:	8d 76 00             	lea    0x0(%esi),%esi
+  do{
+    buf[i++] = digits[x % base];
+    3a80:	89 c8                	mov    %ecx,%eax
+    3a82:	31 d2                	xor    %edx,%edx
+    3a84:	89 cf                	mov    %ecx,%edi
+    3a86:	f7 75 c4             	divl   -0x3c(%ebp)
+    3a89:	0f b6 92 08 56 00 00 	movzbl 0x5608(%edx),%edx
+    3a90:	89 45 c0             	mov    %eax,-0x40(%ebp)
+    3a93:	89 d8                	mov    %ebx,%eax
+    3a95:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+    3a98:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+    buf[i++] = digits[x % base];
+    3a9b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
+  }while((x /= base) != 0);
+    3a9e:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
+    3aa1:	76 dd                	jbe    3a80 <printint+0x30>
+  if(neg)
+    3aa3:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+    3aa6:	85 c9                	test   %ecx,%ecx
+    3aa8:	74 0c                	je     3ab6 <printint+0x66>
+    buf[i++] = '-';
+    3aaa:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+    3aaf:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+    3ab1:	ba 2d 00 00 00       	mov    $0x2d,%edx
+
+  while(--i >= 0)
+    3ab6:	8b 7d b8             	mov    -0x48(%ebp),%edi
+    3ab9:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+    3abd:	eb 07                	jmp    3ac6 <printint+0x76>
+    3abf:	90                   	nop
+    3ac0:	0f b6 13             	movzbl (%ebx),%edx
+    3ac3:	83 eb 01             	sub    $0x1,%ebx
+  write(fd, &c, 1);
+    3ac6:	83 ec 04             	sub    $0x4,%esp
+    3ac9:	88 55 d7             	mov    %dl,-0x29(%ebp)
+    3acc:	6a 01                	push   $0x1
+    3ace:	56                   	push   %esi
+    3acf:	57                   	push   %edi
+    3ad0:	e8 ce fe ff ff       	call   39a3 <write>
+  while(--i >= 0)
+    3ad5:	83 c4 10             	add    $0x10,%esp
+    3ad8:	39 de                	cmp    %ebx,%esi
+    3ada:	75 e4                	jne    3ac0 <printint+0x70>
+    putc(fd, buf[i]);
+}
+    3adc:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    3adf:	5b                   	pop    %ebx
+    3ae0:	5e                   	pop    %esi
+    3ae1:	5f                   	pop    %edi
+    3ae2:	5d                   	pop    %ebp
+    3ae3:	c3                   	ret    
+    3ae4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  neg = 0;
+    3ae8:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+    3aef:	eb 87                	jmp    3a78 <printint+0x28>
+    3af1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    3af8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    3aff:	90                   	nop
+
+00003b00 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+    3b00:	f3 0f 1e fb          	endbr32 
+    3b04:	55                   	push   %ebp
+    3b05:	89 e5                	mov    %esp,%ebp
+    3b07:	57                   	push   %edi
+    3b08:	56                   	push   %esi
+    3b09:	53                   	push   %ebx
+    3b0a:	83 ec 2c             	sub    $0x2c,%esp
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    3b0d:	8b 75 0c             	mov    0xc(%ebp),%esi
+    3b10:	0f b6 1e             	movzbl (%esi),%ebx
+    3b13:	84 db                	test   %bl,%bl
+    3b15:	0f 84 b4 00 00 00    	je     3bcf <printf+0xcf>
+  ap = (uint*)(void*)&fmt + 1;
+    3b1b:	8d 45 10             	lea    0x10(%ebp),%eax
+    3b1e:	83 c6 01             	add    $0x1,%esi
+  write(fd, &c, 1);
+    3b21:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  state = 0;
+    3b24:	31 d2                	xor    %edx,%edx
+  ap = (uint*)(void*)&fmt + 1;
+    3b26:	89 45 d0             	mov    %eax,-0x30(%ebp)
+    3b29:	eb 33                	jmp    3b5e <printf+0x5e>
+    3b2b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    3b2f:	90                   	nop
+    3b30:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+    3b33:	ba 25 00 00 00       	mov    $0x25,%edx
+      if(c == '%'){
+    3b38:	83 f8 25             	cmp    $0x25,%eax
+    3b3b:	74 17                	je     3b54 <printf+0x54>
+  write(fd, &c, 1);
+    3b3d:	83 ec 04             	sub    $0x4,%esp
+    3b40:	88 5d e7             	mov    %bl,-0x19(%ebp)
+    3b43:	6a 01                	push   $0x1
+    3b45:	57                   	push   %edi
+    3b46:	ff 75 08             	pushl  0x8(%ebp)
+    3b49:	e8 55 fe ff ff       	call   39a3 <write>
+    3b4e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+      } else {
+        putc(fd, c);
+    3b51:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; fmt[i]; i++){
+    3b54:	0f b6 1e             	movzbl (%esi),%ebx
+    3b57:	83 c6 01             	add    $0x1,%esi
+    3b5a:	84 db                	test   %bl,%bl
+    3b5c:	74 71                	je     3bcf <printf+0xcf>
+    c = fmt[i] & 0xff;
+    3b5e:	0f be cb             	movsbl %bl,%ecx
+    3b61:	0f b6 c3             	movzbl %bl,%eax
+    if(state == 0){
+    3b64:	85 d2                	test   %edx,%edx
+    3b66:	74 c8                	je     3b30 <printf+0x30>
+      }
+    } else if(state == '%'){
+    3b68:	83 fa 25             	cmp    $0x25,%edx
+    3b6b:	75 e7                	jne    3b54 <printf+0x54>
+      if(c == 'd'){
+    3b6d:	83 f8 64             	cmp    $0x64,%eax
+    3b70:	0f 84 9a 00 00 00    	je     3c10 <printf+0x110>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+    3b76:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
+    3b7c:	83 f9 70             	cmp    $0x70,%ecx
+    3b7f:	74 5f                	je     3be0 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+    3b81:	83 f8 73             	cmp    $0x73,%eax
+    3b84:	0f 84 d6 00 00 00    	je     3c60 <printf+0x160>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+    3b8a:	83 f8 63             	cmp    $0x63,%eax
+    3b8d:	0f 84 8d 00 00 00    	je     3c20 <printf+0x120>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+    3b93:	83 f8 25             	cmp    $0x25,%eax
+    3b96:	0f 84 b4 00 00 00    	je     3c50 <printf+0x150>
+  write(fd, &c, 1);
+    3b9c:	83 ec 04             	sub    $0x4,%esp
+    3b9f:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
+    3ba3:	6a 01                	push   $0x1
+    3ba5:	57                   	push   %edi
+    3ba6:	ff 75 08             	pushl  0x8(%ebp)
+    3ba9:	e8 f5 fd ff ff       	call   39a3 <write>
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+    3bae:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+    3bb1:	83 c4 0c             	add    $0xc,%esp
+    3bb4:	6a 01                	push   $0x1
+    3bb6:	83 c6 01             	add    $0x1,%esi
+    3bb9:	57                   	push   %edi
+    3bba:	ff 75 08             	pushl  0x8(%ebp)
+    3bbd:	e8 e1 fd ff ff       	call   39a3 <write>
+  for(i = 0; fmt[i]; i++){
+    3bc2:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
+        putc(fd, c);
+    3bc6:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+    3bc9:	31 d2                	xor    %edx,%edx
+  for(i = 0; fmt[i]; i++){
+    3bcb:	84 db                	test   %bl,%bl
+    3bcd:	75 8f                	jne    3b5e <printf+0x5e>
+    }
+  }
+}
+    3bcf:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    3bd2:	5b                   	pop    %ebx
+    3bd3:	5e                   	pop    %esi
+    3bd4:	5f                   	pop    %edi
+    3bd5:	5d                   	pop    %ebp
+    3bd6:	c3                   	ret    
+    3bd7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    3bde:	66 90                	xchg   %ax,%ax
+        printint(fd, *ap, 16, 0);
+    3be0:	83 ec 0c             	sub    $0xc,%esp
+    3be3:	b9 10 00 00 00       	mov    $0x10,%ecx
+    3be8:	6a 00                	push   $0x0
+    3bea:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+    3bed:	8b 45 08             	mov    0x8(%ebp),%eax
+    3bf0:	8b 13                	mov    (%ebx),%edx
+    3bf2:	e8 59 fe ff ff       	call   3a50 <printint>
+        ap++;
+    3bf7:	89 d8                	mov    %ebx,%eax
+    3bf9:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+    3bfc:	31 d2                	xor    %edx,%edx
+        ap++;
+    3bfe:	83 c0 04             	add    $0x4,%eax
+    3c01:	89 45 d0             	mov    %eax,-0x30(%ebp)
+    3c04:	e9 4b ff ff ff       	jmp    3b54 <printf+0x54>
+    3c09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        printint(fd, *ap, 10, 1);
+    3c10:	83 ec 0c             	sub    $0xc,%esp
+    3c13:	b9 0a 00 00 00       	mov    $0xa,%ecx
+    3c18:	6a 01                	push   $0x1
+    3c1a:	eb ce                	jmp    3bea <printf+0xea>
+    3c1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        putc(fd, *ap);
+    3c20:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+  write(fd, &c, 1);
+    3c23:	83 ec 04             	sub    $0x4,%esp
+        putc(fd, *ap);
+    3c26:	8b 03                	mov    (%ebx),%eax
+  write(fd, &c, 1);
+    3c28:	6a 01                	push   $0x1
+        ap++;
+    3c2a:	83 c3 04             	add    $0x4,%ebx
+  write(fd, &c, 1);
+    3c2d:	57                   	push   %edi
+    3c2e:	ff 75 08             	pushl  0x8(%ebp)
+        putc(fd, *ap);
+    3c31:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+    3c34:	e8 6a fd ff ff       	call   39a3 <write>
+        ap++;
+    3c39:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+    3c3c:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+    3c3f:	31 d2                	xor    %edx,%edx
+    3c41:	e9 0e ff ff ff       	jmp    3b54 <printf+0x54>
+    3c46:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    3c4d:	8d 76 00             	lea    0x0(%esi),%esi
+        putc(fd, c);
+    3c50:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+    3c53:	83 ec 04             	sub    $0x4,%esp
+    3c56:	e9 59 ff ff ff       	jmp    3bb4 <printf+0xb4>
+    3c5b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    3c5f:	90                   	nop
+        s = (char*)*ap;
+    3c60:	8b 45 d0             	mov    -0x30(%ebp),%eax
+    3c63:	8b 18                	mov    (%eax),%ebx
+        ap++;
+    3c65:	83 c0 04             	add    $0x4,%eax
+    3c68:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        if(s == 0)
+    3c6b:	85 db                	test   %ebx,%ebx
+    3c6d:	74 17                	je     3c86 <printf+0x186>
+        while(*s != 0){
+    3c6f:	0f b6 03             	movzbl (%ebx),%eax
+      state = 0;
+    3c72:	31 d2                	xor    %edx,%edx
+        while(*s != 0){
+    3c74:	84 c0                	test   %al,%al
+    3c76:	0f 84 d8 fe ff ff    	je     3b54 <printf+0x54>
+    3c7c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+    3c7f:	89 de                	mov    %ebx,%esi
+    3c81:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    3c84:	eb 1a                	jmp    3ca0 <printf+0x1a0>
+          s = "(null)";
+    3c86:	bb fe 55 00 00       	mov    $0x55fe,%ebx
+        while(*s != 0){
+    3c8b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+    3c8e:	b8 28 00 00 00       	mov    $0x28,%eax
+    3c93:	89 de                	mov    %ebx,%esi
+    3c95:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    3c98:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    3c9f:	90                   	nop
+  write(fd, &c, 1);
+    3ca0:	83 ec 04             	sub    $0x4,%esp
+          s++;
+    3ca3:	83 c6 01             	add    $0x1,%esi
+    3ca6:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+    3ca9:	6a 01                	push   $0x1
+    3cab:	57                   	push   %edi
+    3cac:	53                   	push   %ebx
+    3cad:	e8 f1 fc ff ff       	call   39a3 <write>
+        while(*s != 0){
+    3cb2:	0f b6 06             	movzbl (%esi),%eax
+    3cb5:	83 c4 10             	add    $0x10,%esp
+    3cb8:	84 c0                	test   %al,%al
+    3cba:	75 e4                	jne    3ca0 <printf+0x1a0>
+    3cbc:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+      state = 0;
+    3cbf:	31 d2                	xor    %edx,%edx
+    3cc1:	e9 8e fe ff ff       	jmp    3b54 <printf+0x54>
+    3cc6:	66 90                	xchg   %ax,%ax
+    3cc8:	66 90                	xchg   %ax,%ax
+    3cca:	66 90                	xchg   %ax,%ax
+    3ccc:	66 90                	xchg   %ax,%ax
+    3cce:	66 90                	xchg   %ax,%ax
+
+00003cd0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    3cd0:	f3 0f 1e fb          	endbr32 
+    3cd4:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    3cd5:	a1 a0 5f 00 00       	mov    0x5fa0,%eax
+{
+    3cda:	89 e5                	mov    %esp,%ebp
+    3cdc:	57                   	push   %edi
+    3cdd:	56                   	push   %esi
+    3cde:	53                   	push   %ebx
+    3cdf:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    3ce2:	8b 10                	mov    (%eax),%edx
+  bp = (Header*)ap - 1;
+    3ce4:	8d 4b f8             	lea    -0x8(%ebx),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    3ce7:	39 c8                	cmp    %ecx,%eax
+    3ce9:	73 15                	jae    3d00 <free+0x30>
+    3ceb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    3cef:	90                   	nop
+    3cf0:	39 d1                	cmp    %edx,%ecx
+    3cf2:	72 14                	jb     3d08 <free+0x38>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    3cf4:	39 d0                	cmp    %edx,%eax
+    3cf6:	73 10                	jae    3d08 <free+0x38>
+{
+    3cf8:	89 d0                	mov    %edx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    3cfa:	8b 10                	mov    (%eax),%edx
+    3cfc:	39 c8                	cmp    %ecx,%eax
+    3cfe:	72 f0                	jb     3cf0 <free+0x20>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    3d00:	39 d0                	cmp    %edx,%eax
+    3d02:	72 f4                	jb     3cf8 <free+0x28>
+    3d04:	39 d1                	cmp    %edx,%ecx
+    3d06:	73 f0                	jae    3cf8 <free+0x28>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    3d08:	8b 73 fc             	mov    -0x4(%ebx),%esi
+    3d0b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
+    3d0e:	39 fa                	cmp    %edi,%edx
+    3d10:	74 1e                	je     3d30 <free+0x60>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+    3d12:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    3d15:	8b 50 04             	mov    0x4(%eax),%edx
+    3d18:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+    3d1b:	39 f1                	cmp    %esi,%ecx
+    3d1d:	74 28                	je     3d47 <free+0x77>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+    3d1f:	89 08                	mov    %ecx,(%eax)
+  freep = p;
+}
+    3d21:	5b                   	pop    %ebx
+  freep = p;
+    3d22:	a3 a0 5f 00 00       	mov    %eax,0x5fa0
+}
+    3d27:	5e                   	pop    %esi
+    3d28:	5f                   	pop    %edi
+    3d29:	5d                   	pop    %ebp
+    3d2a:	c3                   	ret    
+    3d2b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+    3d2f:	90                   	nop
+    bp->s.size += p->s.ptr->s.size;
+    3d30:	03 72 04             	add    0x4(%edx),%esi
+    3d33:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    3d36:	8b 10                	mov    (%eax),%edx
+    3d38:	8b 12                	mov    (%edx),%edx
+    3d3a:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+    3d3d:	8b 50 04             	mov    0x4(%eax),%edx
+    3d40:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+    3d43:	39 f1                	cmp    %esi,%ecx
+    3d45:	75 d8                	jne    3d1f <free+0x4f>
+    p->s.size += bp->s.size;
+    3d47:	03 53 fc             	add    -0x4(%ebx),%edx
+  freep = p;
+    3d4a:	a3 a0 5f 00 00       	mov    %eax,0x5fa0
+    p->s.size += bp->s.size;
+    3d4f:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    3d52:	8b 53 f8             	mov    -0x8(%ebx),%edx
+    3d55:	89 10                	mov    %edx,(%eax)
+}
+    3d57:	5b                   	pop    %ebx
+    3d58:	5e                   	pop    %esi
+    3d59:	5f                   	pop    %edi
+    3d5a:	5d                   	pop    %ebp
+    3d5b:	c3                   	ret    
+    3d5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00003d60 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    3d60:	f3 0f 1e fb          	endbr32 
+    3d64:	55                   	push   %ebp
+    3d65:	89 e5                	mov    %esp,%ebp
+    3d67:	57                   	push   %edi
+    3d68:	56                   	push   %esi
+    3d69:	53                   	push   %ebx
+    3d6a:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    3d6d:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+    3d70:	8b 3d a0 5f 00 00    	mov    0x5fa0,%edi
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    3d76:	8d 70 07             	lea    0x7(%eax),%esi
+    3d79:	c1 ee 03             	shr    $0x3,%esi
+    3d7c:	83 c6 01             	add    $0x1,%esi
+  if((prevp = freep) == 0){
+    3d7f:	85 ff                	test   %edi,%edi
+    3d81:	0f 84 a9 00 00 00    	je     3e30 <malloc+0xd0>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    3d87:	8b 07                	mov    (%edi),%eax
+    if(p->s.size >= nunits){
+    3d89:	8b 48 04             	mov    0x4(%eax),%ecx
+    3d8c:	39 f1                	cmp    %esi,%ecx
+    3d8e:	73 6d                	jae    3dfd <malloc+0x9d>
+    3d90:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+    3d96:	bb 00 10 00 00       	mov    $0x1000,%ebx
+    3d9b:	0f 43 de             	cmovae %esi,%ebx
+  p = sbrk(nu * sizeof(Header));
+    3d9e:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
+    3da5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+    3da8:	eb 17                	jmp    3dc1 <malloc+0x61>
+    3daa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    3db0:	8b 10                	mov    (%eax),%edx
+    if(p->s.size >= nunits){
+    3db2:	8b 4a 04             	mov    0x4(%edx),%ecx
+    3db5:	39 f1                	cmp    %esi,%ecx
+    3db7:	73 4f                	jae    3e08 <malloc+0xa8>
+    3db9:	8b 3d a0 5f 00 00    	mov    0x5fa0,%edi
+    3dbf:	89 d0                	mov    %edx,%eax
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    3dc1:	39 c7                	cmp    %eax,%edi
+    3dc3:	75 eb                	jne    3db0 <malloc+0x50>
+  p = sbrk(nu * sizeof(Header));
+    3dc5:	83 ec 0c             	sub    $0xc,%esp
+    3dc8:	ff 75 e4             	pushl  -0x1c(%ebp)
+    3dcb:	e8 3b fc ff ff       	call   3a0b <sbrk>
+  if(p == (char*)-1)
+    3dd0:	83 c4 10             	add    $0x10,%esp
+    3dd3:	83 f8 ff             	cmp    $0xffffffff,%eax
+    3dd6:	74 1b                	je     3df3 <malloc+0x93>
+  hp->s.size = nu;
+    3dd8:	89 58 04             	mov    %ebx,0x4(%eax)
+  free((void*)(hp + 1));
+    3ddb:	83 ec 0c             	sub    $0xc,%esp
+    3dde:	83 c0 08             	add    $0x8,%eax
+    3de1:	50                   	push   %eax
+    3de2:	e8 e9 fe ff ff       	call   3cd0 <free>
+  return freep;
+    3de7:	a1 a0 5f 00 00       	mov    0x5fa0,%eax
+      if((p = morecore(nunits)) == 0)
+    3dec:	83 c4 10             	add    $0x10,%esp
+    3def:	85 c0                	test   %eax,%eax
+    3df1:	75 bd                	jne    3db0 <malloc+0x50>
+        return 0;
+  }
+}
+    3df3:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return 0;
+    3df6:	31 c0                	xor    %eax,%eax
+}
+    3df8:	5b                   	pop    %ebx
+    3df9:	5e                   	pop    %esi
+    3dfa:	5f                   	pop    %edi
+    3dfb:	5d                   	pop    %ebp
+    3dfc:	c3                   	ret    
+    if(p->s.size >= nunits){
+    3dfd:	89 c2                	mov    %eax,%edx
+    3dff:	89 f8                	mov    %edi,%eax
+    3e01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+    3e08:	39 ce                	cmp    %ecx,%esi
+    3e0a:	74 54                	je     3e60 <malloc+0x100>
+        p->s.size -= nunits;
+    3e0c:	29 f1                	sub    %esi,%ecx
+    3e0e:	89 4a 04             	mov    %ecx,0x4(%edx)
+        p += p->s.size;
+    3e11:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
+        p->s.size = nunits;
+    3e14:	89 72 04             	mov    %esi,0x4(%edx)
+      freep = prevp;
+    3e17:	a3 a0 5f 00 00       	mov    %eax,0x5fa0
+}
+    3e1c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return (void*)(p + 1);
+    3e1f:	8d 42 08             	lea    0x8(%edx),%eax
+}
+    3e22:	5b                   	pop    %ebx
+    3e23:	5e                   	pop    %esi
+    3e24:	5f                   	pop    %edi
+    3e25:	5d                   	pop    %ebp
+    3e26:	c3                   	ret    
+    3e27:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    3e2e:	66 90                	xchg   %ax,%ax
+    base.s.ptr = freep = prevp = &base;
+    3e30:	c7 05 a0 5f 00 00 a4 	movl   $0x5fa4,0x5fa0
+    3e37:	5f 00 00 
+    base.s.size = 0;
+    3e3a:	bf a4 5f 00 00       	mov    $0x5fa4,%edi
+    base.s.ptr = freep = prevp = &base;
+    3e3f:	c7 05 a4 5f 00 00 a4 	movl   $0x5fa4,0x5fa4
+    3e46:	5f 00 00 
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    3e49:	89 f8                	mov    %edi,%eax
+    base.s.size = 0;
+    3e4b:	c7 05 a8 5f 00 00 00 	movl   $0x0,0x5fa8
+    3e52:	00 00 00 
+    if(p->s.size >= nunits){
+    3e55:	e9 36 ff ff ff       	jmp    3d90 <malloc+0x30>
+    3e5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        prevp->s.ptr = p->s.ptr;
+    3e60:	8b 0a                	mov    (%edx),%ecx
+    3e62:	89 08                	mov    %ecx,(%eax)
+    3e64:	eb b1                	jmp    3e17 <malloc+0xb7>
diff -ruN xv6-public/usertests.d copy-xv6/usertests.d
--- xv6-public/usertests.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/usertests.d	2022-09-05 23:26:12.488781081 +0530
@@ -0,0 +1,2 @@
+usertests.o: usertests.c /usr/include/stdc-predef.h param.h types.h \
+ stat.h user.h fs.h fcntl.h syscall.h traps.h memlayout.h
Binary files xv6-public/usertests.o and copy-xv6/usertests.o differ
diff -ruN xv6-public/usertests.sym copy-xv6/usertests.sym
--- xv6-public/usertests.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/usertests.sym	2022-09-05 23:26:12.516781080 +0530
@@ -0,0 +1,107 @@
+00000000 .text
+00003e68 .rodata
+0000561c .eh_frame
+00005efc .data
+00005f20 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 usertests.c
+00005f20 args.1461
+00000000 ulib.c
+00000000 printf.c
+00003a50 printint
+00005608 digits.1097
+00000000 umalloc.c
+00005fa0 freep
+00005fa4 base
+00003720 strcpy
+00000d60 exitwait
+00003b00 printf
+00005f00 stdout
+00003a3b thread_exit
+00003330 bigargtest
+00003950 memmove
+00000310 openiputtest
+000039cb mknod
+00003840 gets
+00003a03 getpid
+00000a60 pipe1
+00002c00 iref
+00003d60 malloc
+00003a13 sleep
+00000210 exitiputtest
+00003430 fsfull
+00001c60 bigdir
+00002d20 forktest
+00000690 writetest1
+00002490 bigwrite
+00000eb0 sharedfd
+00005efc randstate
+00003993 pipe
+00005fc0 uninit
+00002a00 dirfile
+000039a3 write
+000032c0 bsstest
+00005f04 echoargv
+000039db fstat
+000039b3 kill
+00003200 validatetest
+00002880 rmdot
+000039f3 chdir
+00000a10 exectest
+000039bb exec
+0000398b wait
+00003700 rand
+0000399b read
+00000c00 preempt
+000039d3 unlink
+00003690 argptest
+00000de0 mem
+0000397b fork
+00003a0b sbrk
+00003a1b uptime
+00005f18 __bss_start
+000037e0 memset
+00000860 createtest
+00000000 main
+00001270 createdelete
+00003750 strcmp
+000004b0 writetest
+000039fb dup
+00002dd0 sbrktest
+00000410 opentest
+00001da0 subdir
+00003610 uio
+00001630 linktest
+000086e0 buf
+00000920 dirtest
+00000120 iputtest
+000038c0 stat
+00002570 bigfile
+00005f18 _edata
+0000a6e4 _end
+000014a0 unlinkread
+000039e3 link
+00003983 exit
+00003910 atoi
+00001b50 linkunlink
+00003a23 draw
+0000a6e0 name
+000037a0 strlen
+000039c3 open
+00003800 strchr
+00003a2b thread_create
+00001850 concreate
+00002740 fourteen
+000031f0 validateint
+00001070 fourfiles
+000039eb mkdir
+000039ab close
+00003a33 thread_join
+00003cd0 free
Binary files xv6-public/usys.o and copy-xv6/usys.o differ
diff -ruN xv6-public/usys.S copy-xv6/usys.S
--- xv6-public/usys.S	2022-09-05 23:23:48.536715198 +0530
+++ copy-xv6/usys.S	2022-09-05 21:51:28.110571176 +0530
@@ -29,3 +29,8 @@
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(draw)
+
+SYSCALL(thread_create)
+SYSCALL(thread_join)
+SYSCALL(thread_exit)
Binary files xv6-public/vectors.o and copy-xv6/vectors.o differ
diff -ruN xv6-public/vectors.S copy-xv6/vectors.S
--- xv6-public/vectors.S	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/vectors.S	2022-09-05 23:26:13.744781052 +0530
@@ -0,0 +1,1537 @@
+# generated by vectors.pl - do not edit
+# handlers
+.globl alltraps
+.globl vector0
+vector0:
+  pushl $0
+  pushl $0
+  jmp alltraps
+.globl vector1
+vector1:
+  pushl $0
+  pushl $1
+  jmp alltraps
+.globl vector2
+vector2:
+  pushl $0
+  pushl $2
+  jmp alltraps
+.globl vector3
+vector3:
+  pushl $0
+  pushl $3
+  jmp alltraps
+.globl vector4
+vector4:
+  pushl $0
+  pushl $4
+  jmp alltraps
+.globl vector5
+vector5:
+  pushl $0
+  pushl $5
+  jmp alltraps
+.globl vector6
+vector6:
+  pushl $0
+  pushl $6
+  jmp alltraps
+.globl vector7
+vector7:
+  pushl $0
+  pushl $7
+  jmp alltraps
+.globl vector8
+vector8:
+  pushl $8
+  jmp alltraps
+.globl vector9
+vector9:
+  pushl $0
+  pushl $9
+  jmp alltraps
+.globl vector10
+vector10:
+  pushl $10
+  jmp alltraps
+.globl vector11
+vector11:
+  pushl $11
+  jmp alltraps
+.globl vector12
+vector12:
+  pushl $12
+  jmp alltraps
+.globl vector13
+vector13:
+  pushl $13
+  jmp alltraps
+.globl vector14
+vector14:
+  pushl $14
+  jmp alltraps
+.globl vector15
+vector15:
+  pushl $0
+  pushl $15
+  jmp alltraps
+.globl vector16
+vector16:
+  pushl $0
+  pushl $16
+  jmp alltraps
+.globl vector17
+vector17:
+  pushl $17
+  jmp alltraps
+.globl vector18
+vector18:
+  pushl $0
+  pushl $18
+  jmp alltraps
+.globl vector19
+vector19:
+  pushl $0
+  pushl $19
+  jmp alltraps
+.globl vector20
+vector20:
+  pushl $0
+  pushl $20
+  jmp alltraps
+.globl vector21
+vector21:
+  pushl $0
+  pushl $21
+  jmp alltraps
+.globl vector22
+vector22:
+  pushl $0
+  pushl $22
+  jmp alltraps
+.globl vector23
+vector23:
+  pushl $0
+  pushl $23
+  jmp alltraps
+.globl vector24
+vector24:
+  pushl $0
+  pushl $24
+  jmp alltraps
+.globl vector25
+vector25:
+  pushl $0
+  pushl $25
+  jmp alltraps
+.globl vector26
+vector26:
+  pushl $0
+  pushl $26
+  jmp alltraps
+.globl vector27
+vector27:
+  pushl $0
+  pushl $27
+  jmp alltraps
+.globl vector28
+vector28:
+  pushl $0
+  pushl $28
+  jmp alltraps
+.globl vector29
+vector29:
+  pushl $0
+  pushl $29
+  jmp alltraps
+.globl vector30
+vector30:
+  pushl $0
+  pushl $30
+  jmp alltraps
+.globl vector31
+vector31:
+  pushl $0
+  pushl $31
+  jmp alltraps
+.globl vector32
+vector32:
+  pushl $0
+  pushl $32
+  jmp alltraps
+.globl vector33
+vector33:
+  pushl $0
+  pushl $33
+  jmp alltraps
+.globl vector34
+vector34:
+  pushl $0
+  pushl $34
+  jmp alltraps
+.globl vector35
+vector35:
+  pushl $0
+  pushl $35
+  jmp alltraps
+.globl vector36
+vector36:
+  pushl $0
+  pushl $36
+  jmp alltraps
+.globl vector37
+vector37:
+  pushl $0
+  pushl $37
+  jmp alltraps
+.globl vector38
+vector38:
+  pushl $0
+  pushl $38
+  jmp alltraps
+.globl vector39
+vector39:
+  pushl $0
+  pushl $39
+  jmp alltraps
+.globl vector40
+vector40:
+  pushl $0
+  pushl $40
+  jmp alltraps
+.globl vector41
+vector41:
+  pushl $0
+  pushl $41
+  jmp alltraps
+.globl vector42
+vector42:
+  pushl $0
+  pushl $42
+  jmp alltraps
+.globl vector43
+vector43:
+  pushl $0
+  pushl $43
+  jmp alltraps
+.globl vector44
+vector44:
+  pushl $0
+  pushl $44
+  jmp alltraps
+.globl vector45
+vector45:
+  pushl $0
+  pushl $45
+  jmp alltraps
+.globl vector46
+vector46:
+  pushl $0
+  pushl $46
+  jmp alltraps
+.globl vector47
+vector47:
+  pushl $0
+  pushl $47
+  jmp alltraps
+.globl vector48
+vector48:
+  pushl $0
+  pushl $48
+  jmp alltraps
+.globl vector49
+vector49:
+  pushl $0
+  pushl $49
+  jmp alltraps
+.globl vector50
+vector50:
+  pushl $0
+  pushl $50
+  jmp alltraps
+.globl vector51
+vector51:
+  pushl $0
+  pushl $51
+  jmp alltraps
+.globl vector52
+vector52:
+  pushl $0
+  pushl $52
+  jmp alltraps
+.globl vector53
+vector53:
+  pushl $0
+  pushl $53
+  jmp alltraps
+.globl vector54
+vector54:
+  pushl $0
+  pushl $54
+  jmp alltraps
+.globl vector55
+vector55:
+  pushl $0
+  pushl $55
+  jmp alltraps
+.globl vector56
+vector56:
+  pushl $0
+  pushl $56
+  jmp alltraps
+.globl vector57
+vector57:
+  pushl $0
+  pushl $57
+  jmp alltraps
+.globl vector58
+vector58:
+  pushl $0
+  pushl $58
+  jmp alltraps
+.globl vector59
+vector59:
+  pushl $0
+  pushl $59
+  jmp alltraps
+.globl vector60
+vector60:
+  pushl $0
+  pushl $60
+  jmp alltraps
+.globl vector61
+vector61:
+  pushl $0
+  pushl $61
+  jmp alltraps
+.globl vector62
+vector62:
+  pushl $0
+  pushl $62
+  jmp alltraps
+.globl vector63
+vector63:
+  pushl $0
+  pushl $63
+  jmp alltraps
+.globl vector64
+vector64:
+  pushl $0
+  pushl $64
+  jmp alltraps
+.globl vector65
+vector65:
+  pushl $0
+  pushl $65
+  jmp alltraps
+.globl vector66
+vector66:
+  pushl $0
+  pushl $66
+  jmp alltraps
+.globl vector67
+vector67:
+  pushl $0
+  pushl $67
+  jmp alltraps
+.globl vector68
+vector68:
+  pushl $0
+  pushl $68
+  jmp alltraps
+.globl vector69
+vector69:
+  pushl $0
+  pushl $69
+  jmp alltraps
+.globl vector70
+vector70:
+  pushl $0
+  pushl $70
+  jmp alltraps
+.globl vector71
+vector71:
+  pushl $0
+  pushl $71
+  jmp alltraps
+.globl vector72
+vector72:
+  pushl $0
+  pushl $72
+  jmp alltraps
+.globl vector73
+vector73:
+  pushl $0
+  pushl $73
+  jmp alltraps
+.globl vector74
+vector74:
+  pushl $0
+  pushl $74
+  jmp alltraps
+.globl vector75
+vector75:
+  pushl $0
+  pushl $75
+  jmp alltraps
+.globl vector76
+vector76:
+  pushl $0
+  pushl $76
+  jmp alltraps
+.globl vector77
+vector77:
+  pushl $0
+  pushl $77
+  jmp alltraps
+.globl vector78
+vector78:
+  pushl $0
+  pushl $78
+  jmp alltraps
+.globl vector79
+vector79:
+  pushl $0
+  pushl $79
+  jmp alltraps
+.globl vector80
+vector80:
+  pushl $0
+  pushl $80
+  jmp alltraps
+.globl vector81
+vector81:
+  pushl $0
+  pushl $81
+  jmp alltraps
+.globl vector82
+vector82:
+  pushl $0
+  pushl $82
+  jmp alltraps
+.globl vector83
+vector83:
+  pushl $0
+  pushl $83
+  jmp alltraps
+.globl vector84
+vector84:
+  pushl $0
+  pushl $84
+  jmp alltraps
+.globl vector85
+vector85:
+  pushl $0
+  pushl $85
+  jmp alltraps
+.globl vector86
+vector86:
+  pushl $0
+  pushl $86
+  jmp alltraps
+.globl vector87
+vector87:
+  pushl $0
+  pushl $87
+  jmp alltraps
+.globl vector88
+vector88:
+  pushl $0
+  pushl $88
+  jmp alltraps
+.globl vector89
+vector89:
+  pushl $0
+  pushl $89
+  jmp alltraps
+.globl vector90
+vector90:
+  pushl $0
+  pushl $90
+  jmp alltraps
+.globl vector91
+vector91:
+  pushl $0
+  pushl $91
+  jmp alltraps
+.globl vector92
+vector92:
+  pushl $0
+  pushl $92
+  jmp alltraps
+.globl vector93
+vector93:
+  pushl $0
+  pushl $93
+  jmp alltraps
+.globl vector94
+vector94:
+  pushl $0
+  pushl $94
+  jmp alltraps
+.globl vector95
+vector95:
+  pushl $0
+  pushl $95
+  jmp alltraps
+.globl vector96
+vector96:
+  pushl $0
+  pushl $96
+  jmp alltraps
+.globl vector97
+vector97:
+  pushl $0
+  pushl $97
+  jmp alltraps
+.globl vector98
+vector98:
+  pushl $0
+  pushl $98
+  jmp alltraps
+.globl vector99
+vector99:
+  pushl $0
+  pushl $99
+  jmp alltraps
+.globl vector100
+vector100:
+  pushl $0
+  pushl $100
+  jmp alltraps
+.globl vector101
+vector101:
+  pushl $0
+  pushl $101
+  jmp alltraps
+.globl vector102
+vector102:
+  pushl $0
+  pushl $102
+  jmp alltraps
+.globl vector103
+vector103:
+  pushl $0
+  pushl $103
+  jmp alltraps
+.globl vector104
+vector104:
+  pushl $0
+  pushl $104
+  jmp alltraps
+.globl vector105
+vector105:
+  pushl $0
+  pushl $105
+  jmp alltraps
+.globl vector106
+vector106:
+  pushl $0
+  pushl $106
+  jmp alltraps
+.globl vector107
+vector107:
+  pushl $0
+  pushl $107
+  jmp alltraps
+.globl vector108
+vector108:
+  pushl $0
+  pushl $108
+  jmp alltraps
+.globl vector109
+vector109:
+  pushl $0
+  pushl $109
+  jmp alltraps
+.globl vector110
+vector110:
+  pushl $0
+  pushl $110
+  jmp alltraps
+.globl vector111
+vector111:
+  pushl $0
+  pushl $111
+  jmp alltraps
+.globl vector112
+vector112:
+  pushl $0
+  pushl $112
+  jmp alltraps
+.globl vector113
+vector113:
+  pushl $0
+  pushl $113
+  jmp alltraps
+.globl vector114
+vector114:
+  pushl $0
+  pushl $114
+  jmp alltraps
+.globl vector115
+vector115:
+  pushl $0
+  pushl $115
+  jmp alltraps
+.globl vector116
+vector116:
+  pushl $0
+  pushl $116
+  jmp alltraps
+.globl vector117
+vector117:
+  pushl $0
+  pushl $117
+  jmp alltraps
+.globl vector118
+vector118:
+  pushl $0
+  pushl $118
+  jmp alltraps
+.globl vector119
+vector119:
+  pushl $0
+  pushl $119
+  jmp alltraps
+.globl vector120
+vector120:
+  pushl $0
+  pushl $120
+  jmp alltraps
+.globl vector121
+vector121:
+  pushl $0
+  pushl $121
+  jmp alltraps
+.globl vector122
+vector122:
+  pushl $0
+  pushl $122
+  jmp alltraps
+.globl vector123
+vector123:
+  pushl $0
+  pushl $123
+  jmp alltraps
+.globl vector124
+vector124:
+  pushl $0
+  pushl $124
+  jmp alltraps
+.globl vector125
+vector125:
+  pushl $0
+  pushl $125
+  jmp alltraps
+.globl vector126
+vector126:
+  pushl $0
+  pushl $126
+  jmp alltraps
+.globl vector127
+vector127:
+  pushl $0
+  pushl $127
+  jmp alltraps
+.globl vector128
+vector128:
+  pushl $0
+  pushl $128
+  jmp alltraps
+.globl vector129
+vector129:
+  pushl $0
+  pushl $129
+  jmp alltraps
+.globl vector130
+vector130:
+  pushl $0
+  pushl $130
+  jmp alltraps
+.globl vector131
+vector131:
+  pushl $0
+  pushl $131
+  jmp alltraps
+.globl vector132
+vector132:
+  pushl $0
+  pushl $132
+  jmp alltraps
+.globl vector133
+vector133:
+  pushl $0
+  pushl $133
+  jmp alltraps
+.globl vector134
+vector134:
+  pushl $0
+  pushl $134
+  jmp alltraps
+.globl vector135
+vector135:
+  pushl $0
+  pushl $135
+  jmp alltraps
+.globl vector136
+vector136:
+  pushl $0
+  pushl $136
+  jmp alltraps
+.globl vector137
+vector137:
+  pushl $0
+  pushl $137
+  jmp alltraps
+.globl vector138
+vector138:
+  pushl $0
+  pushl $138
+  jmp alltraps
+.globl vector139
+vector139:
+  pushl $0
+  pushl $139
+  jmp alltraps
+.globl vector140
+vector140:
+  pushl $0
+  pushl $140
+  jmp alltraps
+.globl vector141
+vector141:
+  pushl $0
+  pushl $141
+  jmp alltraps
+.globl vector142
+vector142:
+  pushl $0
+  pushl $142
+  jmp alltraps
+.globl vector143
+vector143:
+  pushl $0
+  pushl $143
+  jmp alltraps
+.globl vector144
+vector144:
+  pushl $0
+  pushl $144
+  jmp alltraps
+.globl vector145
+vector145:
+  pushl $0
+  pushl $145
+  jmp alltraps
+.globl vector146
+vector146:
+  pushl $0
+  pushl $146
+  jmp alltraps
+.globl vector147
+vector147:
+  pushl $0
+  pushl $147
+  jmp alltraps
+.globl vector148
+vector148:
+  pushl $0
+  pushl $148
+  jmp alltraps
+.globl vector149
+vector149:
+  pushl $0
+  pushl $149
+  jmp alltraps
+.globl vector150
+vector150:
+  pushl $0
+  pushl $150
+  jmp alltraps
+.globl vector151
+vector151:
+  pushl $0
+  pushl $151
+  jmp alltraps
+.globl vector152
+vector152:
+  pushl $0
+  pushl $152
+  jmp alltraps
+.globl vector153
+vector153:
+  pushl $0
+  pushl $153
+  jmp alltraps
+.globl vector154
+vector154:
+  pushl $0
+  pushl $154
+  jmp alltraps
+.globl vector155
+vector155:
+  pushl $0
+  pushl $155
+  jmp alltraps
+.globl vector156
+vector156:
+  pushl $0
+  pushl $156
+  jmp alltraps
+.globl vector157
+vector157:
+  pushl $0
+  pushl $157
+  jmp alltraps
+.globl vector158
+vector158:
+  pushl $0
+  pushl $158
+  jmp alltraps
+.globl vector159
+vector159:
+  pushl $0
+  pushl $159
+  jmp alltraps
+.globl vector160
+vector160:
+  pushl $0
+  pushl $160
+  jmp alltraps
+.globl vector161
+vector161:
+  pushl $0
+  pushl $161
+  jmp alltraps
+.globl vector162
+vector162:
+  pushl $0
+  pushl $162
+  jmp alltraps
+.globl vector163
+vector163:
+  pushl $0
+  pushl $163
+  jmp alltraps
+.globl vector164
+vector164:
+  pushl $0
+  pushl $164
+  jmp alltraps
+.globl vector165
+vector165:
+  pushl $0
+  pushl $165
+  jmp alltraps
+.globl vector166
+vector166:
+  pushl $0
+  pushl $166
+  jmp alltraps
+.globl vector167
+vector167:
+  pushl $0
+  pushl $167
+  jmp alltraps
+.globl vector168
+vector168:
+  pushl $0
+  pushl $168
+  jmp alltraps
+.globl vector169
+vector169:
+  pushl $0
+  pushl $169
+  jmp alltraps
+.globl vector170
+vector170:
+  pushl $0
+  pushl $170
+  jmp alltraps
+.globl vector171
+vector171:
+  pushl $0
+  pushl $171
+  jmp alltraps
+.globl vector172
+vector172:
+  pushl $0
+  pushl $172
+  jmp alltraps
+.globl vector173
+vector173:
+  pushl $0
+  pushl $173
+  jmp alltraps
+.globl vector174
+vector174:
+  pushl $0
+  pushl $174
+  jmp alltraps
+.globl vector175
+vector175:
+  pushl $0
+  pushl $175
+  jmp alltraps
+.globl vector176
+vector176:
+  pushl $0
+  pushl $176
+  jmp alltraps
+.globl vector177
+vector177:
+  pushl $0
+  pushl $177
+  jmp alltraps
+.globl vector178
+vector178:
+  pushl $0
+  pushl $178
+  jmp alltraps
+.globl vector179
+vector179:
+  pushl $0
+  pushl $179
+  jmp alltraps
+.globl vector180
+vector180:
+  pushl $0
+  pushl $180
+  jmp alltraps
+.globl vector181
+vector181:
+  pushl $0
+  pushl $181
+  jmp alltraps
+.globl vector182
+vector182:
+  pushl $0
+  pushl $182
+  jmp alltraps
+.globl vector183
+vector183:
+  pushl $0
+  pushl $183
+  jmp alltraps
+.globl vector184
+vector184:
+  pushl $0
+  pushl $184
+  jmp alltraps
+.globl vector185
+vector185:
+  pushl $0
+  pushl $185
+  jmp alltraps
+.globl vector186
+vector186:
+  pushl $0
+  pushl $186
+  jmp alltraps
+.globl vector187
+vector187:
+  pushl $0
+  pushl $187
+  jmp alltraps
+.globl vector188
+vector188:
+  pushl $0
+  pushl $188
+  jmp alltraps
+.globl vector189
+vector189:
+  pushl $0
+  pushl $189
+  jmp alltraps
+.globl vector190
+vector190:
+  pushl $0
+  pushl $190
+  jmp alltraps
+.globl vector191
+vector191:
+  pushl $0
+  pushl $191
+  jmp alltraps
+.globl vector192
+vector192:
+  pushl $0
+  pushl $192
+  jmp alltraps
+.globl vector193
+vector193:
+  pushl $0
+  pushl $193
+  jmp alltraps
+.globl vector194
+vector194:
+  pushl $0
+  pushl $194
+  jmp alltraps
+.globl vector195
+vector195:
+  pushl $0
+  pushl $195
+  jmp alltraps
+.globl vector196
+vector196:
+  pushl $0
+  pushl $196
+  jmp alltraps
+.globl vector197
+vector197:
+  pushl $0
+  pushl $197
+  jmp alltraps
+.globl vector198
+vector198:
+  pushl $0
+  pushl $198
+  jmp alltraps
+.globl vector199
+vector199:
+  pushl $0
+  pushl $199
+  jmp alltraps
+.globl vector200
+vector200:
+  pushl $0
+  pushl $200
+  jmp alltraps
+.globl vector201
+vector201:
+  pushl $0
+  pushl $201
+  jmp alltraps
+.globl vector202
+vector202:
+  pushl $0
+  pushl $202
+  jmp alltraps
+.globl vector203
+vector203:
+  pushl $0
+  pushl $203
+  jmp alltraps
+.globl vector204
+vector204:
+  pushl $0
+  pushl $204
+  jmp alltraps
+.globl vector205
+vector205:
+  pushl $0
+  pushl $205
+  jmp alltraps
+.globl vector206
+vector206:
+  pushl $0
+  pushl $206
+  jmp alltraps
+.globl vector207
+vector207:
+  pushl $0
+  pushl $207
+  jmp alltraps
+.globl vector208
+vector208:
+  pushl $0
+  pushl $208
+  jmp alltraps
+.globl vector209
+vector209:
+  pushl $0
+  pushl $209
+  jmp alltraps
+.globl vector210
+vector210:
+  pushl $0
+  pushl $210
+  jmp alltraps
+.globl vector211
+vector211:
+  pushl $0
+  pushl $211
+  jmp alltraps
+.globl vector212
+vector212:
+  pushl $0
+  pushl $212
+  jmp alltraps
+.globl vector213
+vector213:
+  pushl $0
+  pushl $213
+  jmp alltraps
+.globl vector214
+vector214:
+  pushl $0
+  pushl $214
+  jmp alltraps
+.globl vector215
+vector215:
+  pushl $0
+  pushl $215
+  jmp alltraps
+.globl vector216
+vector216:
+  pushl $0
+  pushl $216
+  jmp alltraps
+.globl vector217
+vector217:
+  pushl $0
+  pushl $217
+  jmp alltraps
+.globl vector218
+vector218:
+  pushl $0
+  pushl $218
+  jmp alltraps
+.globl vector219
+vector219:
+  pushl $0
+  pushl $219
+  jmp alltraps
+.globl vector220
+vector220:
+  pushl $0
+  pushl $220
+  jmp alltraps
+.globl vector221
+vector221:
+  pushl $0
+  pushl $221
+  jmp alltraps
+.globl vector222
+vector222:
+  pushl $0
+  pushl $222
+  jmp alltraps
+.globl vector223
+vector223:
+  pushl $0
+  pushl $223
+  jmp alltraps
+.globl vector224
+vector224:
+  pushl $0
+  pushl $224
+  jmp alltraps
+.globl vector225
+vector225:
+  pushl $0
+  pushl $225
+  jmp alltraps
+.globl vector226
+vector226:
+  pushl $0
+  pushl $226
+  jmp alltraps
+.globl vector227
+vector227:
+  pushl $0
+  pushl $227
+  jmp alltraps
+.globl vector228
+vector228:
+  pushl $0
+  pushl $228
+  jmp alltraps
+.globl vector229
+vector229:
+  pushl $0
+  pushl $229
+  jmp alltraps
+.globl vector230
+vector230:
+  pushl $0
+  pushl $230
+  jmp alltraps
+.globl vector231
+vector231:
+  pushl $0
+  pushl $231
+  jmp alltraps
+.globl vector232
+vector232:
+  pushl $0
+  pushl $232
+  jmp alltraps
+.globl vector233
+vector233:
+  pushl $0
+  pushl $233
+  jmp alltraps
+.globl vector234
+vector234:
+  pushl $0
+  pushl $234
+  jmp alltraps
+.globl vector235
+vector235:
+  pushl $0
+  pushl $235
+  jmp alltraps
+.globl vector236
+vector236:
+  pushl $0
+  pushl $236
+  jmp alltraps
+.globl vector237
+vector237:
+  pushl $0
+  pushl $237
+  jmp alltraps
+.globl vector238
+vector238:
+  pushl $0
+  pushl $238
+  jmp alltraps
+.globl vector239
+vector239:
+  pushl $0
+  pushl $239
+  jmp alltraps
+.globl vector240
+vector240:
+  pushl $0
+  pushl $240
+  jmp alltraps
+.globl vector241
+vector241:
+  pushl $0
+  pushl $241
+  jmp alltraps
+.globl vector242
+vector242:
+  pushl $0
+  pushl $242
+  jmp alltraps
+.globl vector243
+vector243:
+  pushl $0
+  pushl $243
+  jmp alltraps
+.globl vector244
+vector244:
+  pushl $0
+  pushl $244
+  jmp alltraps
+.globl vector245
+vector245:
+  pushl $0
+  pushl $245
+  jmp alltraps
+.globl vector246
+vector246:
+  pushl $0
+  pushl $246
+  jmp alltraps
+.globl vector247
+vector247:
+  pushl $0
+  pushl $247
+  jmp alltraps
+.globl vector248
+vector248:
+  pushl $0
+  pushl $248
+  jmp alltraps
+.globl vector249
+vector249:
+  pushl $0
+  pushl $249
+  jmp alltraps
+.globl vector250
+vector250:
+  pushl $0
+  pushl $250
+  jmp alltraps
+.globl vector251
+vector251:
+  pushl $0
+  pushl $251
+  jmp alltraps
+.globl vector252
+vector252:
+  pushl $0
+  pushl $252
+  jmp alltraps
+.globl vector253
+vector253:
+  pushl $0
+  pushl $253
+  jmp alltraps
+.globl vector254
+vector254:
+  pushl $0
+  pushl $254
+  jmp alltraps
+.globl vector255
+vector255:
+  pushl $0
+  pushl $255
+  jmp alltraps
+
+# vector table
+.data
+.globl vectors
+vectors:
+  .long vector0
+  .long vector1
+  .long vector2
+  .long vector3
+  .long vector4
+  .long vector5
+  .long vector6
+  .long vector7
+  .long vector8
+  .long vector9
+  .long vector10
+  .long vector11
+  .long vector12
+  .long vector13
+  .long vector14
+  .long vector15
+  .long vector16
+  .long vector17
+  .long vector18
+  .long vector19
+  .long vector20
+  .long vector21
+  .long vector22
+  .long vector23
+  .long vector24
+  .long vector25
+  .long vector26
+  .long vector27
+  .long vector28
+  .long vector29
+  .long vector30
+  .long vector31
+  .long vector32
+  .long vector33
+  .long vector34
+  .long vector35
+  .long vector36
+  .long vector37
+  .long vector38
+  .long vector39
+  .long vector40
+  .long vector41
+  .long vector42
+  .long vector43
+  .long vector44
+  .long vector45
+  .long vector46
+  .long vector47
+  .long vector48
+  .long vector49
+  .long vector50
+  .long vector51
+  .long vector52
+  .long vector53
+  .long vector54
+  .long vector55
+  .long vector56
+  .long vector57
+  .long vector58
+  .long vector59
+  .long vector60
+  .long vector61
+  .long vector62
+  .long vector63
+  .long vector64
+  .long vector65
+  .long vector66
+  .long vector67
+  .long vector68
+  .long vector69
+  .long vector70
+  .long vector71
+  .long vector72
+  .long vector73
+  .long vector74
+  .long vector75
+  .long vector76
+  .long vector77
+  .long vector78
+  .long vector79
+  .long vector80
+  .long vector81
+  .long vector82
+  .long vector83
+  .long vector84
+  .long vector85
+  .long vector86
+  .long vector87
+  .long vector88
+  .long vector89
+  .long vector90
+  .long vector91
+  .long vector92
+  .long vector93
+  .long vector94
+  .long vector95
+  .long vector96
+  .long vector97
+  .long vector98
+  .long vector99
+  .long vector100
+  .long vector101
+  .long vector102
+  .long vector103
+  .long vector104
+  .long vector105
+  .long vector106
+  .long vector107
+  .long vector108
+  .long vector109
+  .long vector110
+  .long vector111
+  .long vector112
+  .long vector113
+  .long vector114
+  .long vector115
+  .long vector116
+  .long vector117
+  .long vector118
+  .long vector119
+  .long vector120
+  .long vector121
+  .long vector122
+  .long vector123
+  .long vector124
+  .long vector125
+  .long vector126
+  .long vector127
+  .long vector128
+  .long vector129
+  .long vector130
+  .long vector131
+  .long vector132
+  .long vector133
+  .long vector134
+  .long vector135
+  .long vector136
+  .long vector137
+  .long vector138
+  .long vector139
+  .long vector140
+  .long vector141
+  .long vector142
+  .long vector143
+  .long vector144
+  .long vector145
+  .long vector146
+  .long vector147
+  .long vector148
+  .long vector149
+  .long vector150
+  .long vector151
+  .long vector152
+  .long vector153
+  .long vector154
+  .long vector155
+  .long vector156
+  .long vector157
+  .long vector158
+  .long vector159
+  .long vector160
+  .long vector161
+  .long vector162
+  .long vector163
+  .long vector164
+  .long vector165
+  .long vector166
+  .long vector167
+  .long vector168
+  .long vector169
+  .long vector170
+  .long vector171
+  .long vector172
+  .long vector173
+  .long vector174
+  .long vector175
+  .long vector176
+  .long vector177
+  .long vector178
+  .long vector179
+  .long vector180
+  .long vector181
+  .long vector182
+  .long vector183
+  .long vector184
+  .long vector185
+  .long vector186
+  .long vector187
+  .long vector188
+  .long vector189
+  .long vector190
+  .long vector191
+  .long vector192
+  .long vector193
+  .long vector194
+  .long vector195
+  .long vector196
+  .long vector197
+  .long vector198
+  .long vector199
+  .long vector200
+  .long vector201
+  .long vector202
+  .long vector203
+  .long vector204
+  .long vector205
+  .long vector206
+  .long vector207
+  .long vector208
+  .long vector209
+  .long vector210
+  .long vector211
+  .long vector212
+  .long vector213
+  .long vector214
+  .long vector215
+  .long vector216
+  .long vector217
+  .long vector218
+  .long vector219
+  .long vector220
+  .long vector221
+  .long vector222
+  .long vector223
+  .long vector224
+  .long vector225
+  .long vector226
+  .long vector227
+  .long vector228
+  .long vector229
+  .long vector230
+  .long vector231
+  .long vector232
+  .long vector233
+  .long vector234
+  .long vector235
+  .long vector236
+  .long vector237
+  .long vector238
+  .long vector239
+  .long vector240
+  .long vector241
+  .long vector242
+  .long vector243
+  .long vector244
+  .long vector245
+  .long vector246
+  .long vector247
+  .long vector248
+  .long vector249
+  .long vector250
+  .long vector251
+  .long vector252
+  .long vector253
+  .long vector254
+  .long vector255
diff -ruN xv6-public/vm.d copy-xv6/vm.d
--- xv6-public/vm.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/vm.d	2022-09-05 23:26:13.824781050 +0530
@@ -0,0 +1,2 @@
+vm.o: vm.c /usr/include/stdc-predef.h param.h types.h defs.h x86.h \
+ memlayout.h mmu.h proc.h elf.h
Binary files xv6-public/vm.o and copy-xv6/vm.o differ
diff -ruN xv6-public/.vscode/c_cpp_properties.json copy-xv6/.vscode/c_cpp_properties.json
--- xv6-public/.vscode/c_cpp_properties.json	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/.vscode/c_cpp_properties.json	2022-08-12 12:41:27.685296000 +0530
@@ -0,0 +1,17 @@
+{
+    "configurations": [
+        {
+            "name": "Linux",
+            "includePath": [
+                "${workspaceFolder}/**"
+            ],
+            "defines": [],
+            "compilerPath": "/usr/bin/gcc",
+            "cStandard": "gnu17",
+            "cppStandard": "gnu++14",
+            "intelliSenseMode": "linux-gcc-x86",
+            "configurationProvider": "ms-vscode.makefile-tools"
+        }
+    ],
+    "version": 4
+}
\ No newline at end of file
diff -ruN xv6-public/.vscode/configurationCache.log copy-xv6/.vscode/configurationCache.log
--- xv6-public/.vscode/configurationCache.log	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/.vscode/configurationCache.log	2022-09-05 22:54:41.676428305 +0530
@@ -0,0 +1 @@
+{"buildTargets":["_forktest","bio.o","bochs","bootasm.o","bootblock","bootmain.o","cat.o","clean","console.o","dist","dist-test","drawtest.o","echo.o","entryother","entryother.o","exec.o","file.o","forktest.o","fs.img","fs.o","grep.o","ide.o","init.o","initcode","initcode.o","ioapic.o","kalloc.o","kbd.o","kernel","kernelmemfs","kill.o","lapic.o","ln.o","log.o","ls.o","main.o","mkdir.o","mkfs","mp.o","old_thread.o","picirq.o","pipe.o","print","printf.o","proc.o","qemu","qemu-gdb","qemu-memfs","qemu-nox","qemu-nox-gdb","rm.o","sh.o","sleeplock.o","spinlock.o","stressfs.o","string.o","syscall.o","sysfile.o","sysproc.o","tags","tar","thread.o","trap.o","uart.o","ulib.o","umalloc.o","usertests.o","vectors.S","vm.o","wc.o","xv6.img","xv6.pdf","xv6memfs.img","zombie.o"],"launchTargets":["/home/vatsal/copy-xv6>bootblock.o()","/home/vatsal/copy-xv6>bootblockother.o()","/home/vatsal/copy-xv6>initcode.out()","/home/vatsal/copy-xv6>kernel()"],"customConfigurationProvider":{"workspaceBrowse":{"browsePath":["/home/vatsal/copy-xv6"],"compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","vm.o","vm.c"],"compilerPath":"/usr/bin/gcc","windowsSdkVersion":""},"fileIndex":[["/home/vatsal/copy-xv6/bootmain.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/bootmain.c","path":"/home/vatsal/copy-xv6/bootmain.c","scheme":"file"},"configuration":{"defines":[],"includePath":["/home/vatsal/copy-xv6"],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-fno-pic","-O","-nostdinc","-c","bootmain.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie -fno-pic -O -nostdinc -I. -c bootmain.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/bootmain.c"}}],["/home/vatsal/copy-xv6/bio.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/bio.c","path":"/home/vatsal/copy-xv6/bio.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","bio.o","bio.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o bio.o bio.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/bio.c"}}],["/home/vatsal/copy-xv6/console.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/console.c","path":"/home/vatsal/copy-xv6/console.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","console.o","console.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o console.o console.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/console.c"}}],["/home/vatsal/copy-xv6/exec.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/exec.c","path":"/home/vatsal/copy-xv6/exec.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","exec.o","exec.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o exec.o exec.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/exec.c"}}],["/home/vatsal/copy-xv6/file.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/file.c","path":"/home/vatsal/copy-xv6/file.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","file.o","file.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o file.o file.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/file.c"}}],["/home/vatsal/copy-xv6/fs.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/fs.c","path":"/home/vatsal/copy-xv6/fs.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","fs.o","fs.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o fs.o fs.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/fs.c"}}],["/home/vatsal/copy-xv6/ide.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/ide.c","path":"/home/vatsal/copy-xv6/ide.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","ide.o","ide.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o ide.o ide.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/ide.c"}}],["/home/vatsal/copy-xv6/ioapic.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/ioapic.c","path":"/home/vatsal/copy-xv6/ioapic.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","ioapic.o","ioapic.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o ioapic.o ioapic.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/ioapic.c"}}],["/home/vatsal/copy-xv6/kalloc.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/kalloc.c","path":"/home/vatsal/copy-xv6/kalloc.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","kalloc.o","kalloc.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o kalloc.o kalloc.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/kalloc.c"}}],["/home/vatsal/copy-xv6/kbd.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/kbd.c","path":"/home/vatsal/copy-xv6/kbd.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","kbd.o","kbd.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o kbd.o kbd.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/kbd.c"}}],["/home/vatsal/copy-xv6/lapic.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/lapic.c","path":"/home/vatsal/copy-xv6/lapic.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","lapic.o","lapic.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o lapic.o lapic.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/lapic.c"}}],["/home/vatsal/copy-xv6/log.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/log.c","path":"/home/vatsal/copy-xv6/log.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","log.o","log.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o log.o log.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/log.c"}}],["/home/vatsal/copy-xv6/main.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/main.c","path":"/home/vatsal/copy-xv6/main.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","main.o","main.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o main.o main.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/main.c"}}],["/home/vatsal/copy-xv6/mp.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/mp.c","path":"/home/vatsal/copy-xv6/mp.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","mp.o","mp.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o mp.o mp.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/mp.c"}}],["/home/vatsal/copy-xv6/picirq.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/picirq.c","path":"/home/vatsal/copy-xv6/picirq.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","picirq.o","picirq.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o picirq.o picirq.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/picirq.c"}}],["/home/vatsal/copy-xv6/pipe.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/pipe.c","path":"/home/vatsal/copy-xv6/pipe.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","pipe.o","pipe.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o pipe.o pipe.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/pipe.c"}}],["/home/vatsal/copy-xv6/proc.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/proc.c","path":"/home/vatsal/copy-xv6/proc.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","proc.o","proc.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o proc.o proc.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/proc.c"}}],["/home/vatsal/copy-xv6/sleeplock.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/sleeplock.c","path":"/home/vatsal/copy-xv6/sleeplock.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","sleeplock.o","sleeplock.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o sleeplock.o sleeplock.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/sleeplock.c"}}],["/home/vatsal/copy-xv6/spinlock.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/spinlock.c","path":"/home/vatsal/copy-xv6/spinlock.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","spinlock.o","spinlock.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o spinlock.o spinlock.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/spinlock.c"}}],["/home/vatsal/copy-xv6/string.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/string.c","path":"/home/vatsal/copy-xv6/string.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","string.o","string.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o string.o string.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/string.c"}}],["/home/vatsal/copy-xv6/syscall.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/syscall.c","path":"/home/vatsal/copy-xv6/syscall.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","syscall.o","syscall.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o syscall.o syscall.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/syscall.c"}}],["/home/vatsal/copy-xv6/sysfile.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/sysfile.c","path":"/home/vatsal/copy-xv6/sysfile.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","sysfile.o","sysfile.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o sysfile.o sysfile.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/sysfile.c"}}],["/home/vatsal/copy-xv6/sysproc.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/sysproc.c","path":"/home/vatsal/copy-xv6/sysproc.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","sysproc.o","sysproc.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o sysproc.o sysproc.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/sysproc.c"}}],["/home/vatsal/copy-xv6/trap.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/trap.c","path":"/home/vatsal/copy-xv6/trap.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","trap.o","trap.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o trap.o trap.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/trap.c"}}],["/home/vatsal/copy-xv6/uart.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/uart.c","path":"/home/vatsal/copy-xv6/uart.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","uart.o","uart.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o uart.o uart.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/uart.c"}}],["/home/vatsal/copy-xv6/vm.c",{"uri":{"$mid":1,"fsPath":"/home/vatsal/copy-xv6/vm.c","path":"/home/vatsal/copy-xv6/vm.c","scheme":"file"},"configuration":{"defines":[],"includePath":[],"forcedInclude":[],"intelliSenseMode":"gcc-x86","compilerPath":"/usr/bin/gcc","compilerArgs":["-fno-pic","-static","-fno-builtin","-fno-strict-aliasing","-O2","-Wall","-MD","-ggdb","-m32","-Werror","-fno-omit-frame-pointer","-fno-stack-protector","-fno-pie","-no-pie","-c","-o","vm.o","vm.c"],"windowsSdkVersion":""},"compileCommand":{"command":"gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o vm.o vm.c","directory":"/home/vatsal/copy-xv6","file":"/home/vatsal/copy-xv6/vm.c"}}]]}}
\ No newline at end of file
diff -ruN xv6-public/.vscode/dryrun.log copy-xv6/.vscode/dryrun.log
--- xv6-public/.vscode/dryrun.log	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/.vscode/dryrun.log	2022-09-05 22:54:40.960434654 +0530
@@ -0,0 +1,56 @@
+make --dry-run --always-make --keep-going --print-directory
+make: Entering directory '/home/vatsal/copy-xv6'
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie -fno-pic -O -nostdinc -I. -c bootmain.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie -fno-pic -nostdinc -I. -c bootasm.S
+ld -m    elf_i386 -N -e start -Ttext 0x7c00 -o bootblock.o bootasm.o bootmain.o
+objdump -S bootblock.o > bootblock.asm
+objcopy -S -O binary -j .text bootblock.o bootblock
+./sign.pl bootblock
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o bio.o bio.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o console.o console.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o exec.o exec.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o file.o file.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o fs.o fs.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o ide.o ide.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o ioapic.o ioapic.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o kalloc.o kalloc.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o kbd.o kbd.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o lapic.o lapic.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o log.o log.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o main.o main.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o mp.o mp.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o picirq.o picirq.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o pipe.o pipe.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o proc.o proc.c
+ 
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o sleeplock.o sleeplock.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o spinlock.o spinlock.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o string.o string.c
+gcc -m32 -gdwarf-2 -Wa,-divide   -c -o swtch.o swtch.S
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o syscall.o syscall.c
+ 
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o sysfile.o sysfile.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o sysproc.o sysproc.c
+gcc -m32 -gdwarf-2 -Wa,-divide   -c -o trapasm.o trapasm.S
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o trap.o trap.c
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o uart.o uart.c
+./vectors.pl > vectors.S
+gcc -m32 -gdwarf-2 -Wa,-divide   -c -o vectors.o vectors.S
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie   -c -o vm.o vm.c
+gcc -m32 -gdwarf-2 -Wa,-divide   -c -o entry.o entry.S
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie -fno-pic -nostdinc -I. -c entryother.S
+ld -m    elf_i386 -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+objcopy -S -O binary -j .text bootblockother.o entryother
+objdump -S bootblockother.o > entryother.asm
+gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pie -no-pie -nostdinc -I. -c initcode.S
+ld -m    elf_i386 -N -e start -Ttext 0 -o initcode.out initcode.o
+objcopy -S -O binary initcode.out initcode
+objdump -S initcode.o > initcode.asm
+ld -m    elf_i386 -T kernel.ld -o kernel entry.o bio.o console.o exec.o file.o fs.o ide.o ioapic.o kalloc.o kbd.o lapic.o log.o main.o mp.o picirq.o pipe.o proc.o sleeplock.o spinlock.o string.o swtch.o syscall.o sysfile.o sysproc.o trapasm.o trap.o uart.o vectors.o vm.o  -b binary initcode entryother
+objdump -S kernel > kernel.asm
+objdump -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$/d' > kernel.sym
+dd if=/dev/zero of=xv6.img count=10000
+dd if=bootblock of=xv6.img conv=notrunc
+dd if=kernel of=xv6.img seek=1 conv=notrunc
+make: Leaving directory '/home/vatsal/copy-xv6'
+ 
diff -ruN xv6-public/.vscode/settings.json copy-xv6/.vscode/settings.json
--- xv6-public/.vscode/settings.json	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/.vscode/settings.json	2022-09-05 23:01:48.545320920 +0530
@@ -0,0 +1,15 @@
+{
+    "makefile.extensionOutputFolder": "./.vscode",
+    "files.associations": {
+        "defs.h": "c",
+        "types.h": "c",
+        "syscall.h": "c",
+        "param.h": "c",
+        "mmu.h": "c",
+        "proc.h": "c",
+        "user.h": "c",
+        "spinlock.h": "c",
+        "typeinfo": "c"
+    },
+    "C_Cpp.errorSquiggles": "Disabled"
+}
\ No newline at end of file
diff -ruN xv6-public/.vscode/targets.log copy-xv6/.vscode/targets.log
--- xv6-public/.vscode/targets.log	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/.vscode/targets.log	2022-09-05 22:54:41.676428305 +0530
@@ -0,0 +1,1861 @@
+make all --print-data-base --no-builtin-variables --no-builtin-rules --question
+make: *** No rule to make target 'all'.  Stop.
+
+# GNU Make 4.2.1
+# Built for x86_64-pc-linux-gnu
+# Copyright (C) 1988-2016 Free Software Foundation, Inc.
+# License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
+# This is free software: you are free to change and redistribute it.
+# There is NO WARRANTY, to the extent permitted by law.
+
+# Make data base, printed on Mon Sep  5 22:54:41 2022
+
+# Variables
+
+# 'override' directive
+GNUMAKEFLAGS := 
+# automatic
+<D = $(patsubst %/,%,$(dir $<))
+# automatic
+?F = $(notdir $?)
+# environment
+DESKTOP_SESSION = ubuntu
+# default
+.SHELLFLAGS := -c
+# makefile (from 'Makefile', line 58)
+QEMU = $(shell if which qemu > /dev/null; then echo qemu; exit; elif which qemu-system-i386 > /dev/null; then echo qemu-system-i386; exit; elif which qemu-system-x86_64 > /dev/null; then echo qemu-system-x86_64; exit; else qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; if test -x $$qemu; then echo $$qemu; exit; fi; fi; echo "***" 1>&2; echo "*** Error: Couldn't find a working QEMU executable." 1>&2; echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; echo "***" 1>&2; exit 1)
+# environment
+XDG_SESSION_CLASS = user
+# environment
+SNAP_COMMON = /var/snap/code/common
+# environment
+XDG_SESSION_TYPE = x11
+# automatic
+?D = $(patsubst %/,%,$(dir $?))
+# environment
+IM_CONFIG_PHASE = 1
+# environment
+PLATFORMIO_IDE = 2.5.4
+# automatic
+@D = $(patsubst %/,%,$(dir $@))
+# environment
+XAUTHORITY = /run/user/1000/gdm/Xauthority
+# environment
+GDMSESSION = ubuntu
+# environment
+XMODIFIERS = @im=ibus
+# makefile
+CURDIR := /home/vatsal/copy-xv6
+# makefile
+SHELL = /bin/sh
+# environment
+SNAP_DATA = /var/snap/code/106
+# environment
+VSCODE_NLS_CONFIG = {"locale":"en-gb","availableLanguages":{},"_languagePackSupport":true}
+# environment
+JOURNAL_STREAM = 8:51270
+# makefile (from 'Makefile', line 87)
+CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector) -fno-pie -no-pie
+# environment
+XDG_CONFIG_DIRS = /etc/xdg/xdg-ubuntu:/etc/xdg
+# makefile (from 'Makefile', line 217)
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# environment
+SNAP_INSTANCE_NAME = code
+# environment
+SNAP_ARCH = amd64
+# makefile (from 'zombie.d', line 1)
+MAKEFILE_LIST :=  Makefile thread.d printf.d init.d ioapic.d mp.d kill.d pipe.d bootmain.d mkdir.d umalloc.d bio.d file.d grep.d entryother.d string.d echo.d syscall.d sysfile.d sleeplock.d stressfs.d spinlock.d lapic.d picirq.d kbd.d ln.d exec.d wc.d usertests.d ulib.d initcode.d uart.d rm.d log.d sysproc.d old_thread.d ls.d vm.d forktest.d drawtest.d console.d proc.d fs.d kalloc.d trap.d ide.d sh.d bootasm.d main.d cat.d zombie.d
+# automatic
+@F = $(notdir $@)
+# environment
+GIO_LAUNCHED_DESKTOP_FILE = /var/lib/snapd/desktop/applications/code_code.desktop
+# environment
+QT_IM_MODULE = ibus
+# environment
+USERNAME = vatsal
+# makefile (from 'Makefile', line 219)
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; then echo "-gdb tcp::$(GDBPORT)"; else echo "-s -p $(GDBPORT)"; fi)
+# environment
+XDG_DATA_DIRS = /usr/share/ubuntu:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop
+# environment
+DBUS_SESSION_BUS_ADDRESS = unix:path=/run/user/1000/bus
+# makefile (from 'Makefile', line 253)
+EXTRA = mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c drawtest.c thread.c old_thread.c printf.c umalloc.c README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list .gdbinit.tmpl gdbutil 
+# makefile (from 'Makefile', line 75)
+AS = $(TOOLPREFIX)gas
+# environment
+_ = /snap/code/106/usr/share/code/code
+# makefile (from 'Makefile', line 1)
+OBJS = bio.o console.o exec.o file.o fs.o ide.o ioapic.o kalloc.o kbd.o lapic.o log.o main.o mp.o picirq.o pipe.o proc.o sleeplock.o spinlock.o string.o swtch.o syscall.o sysfile.o sysproc.o trapasm.o trap.o uart.o vectors.o vm.o 
+# environment
+MANAGERPID = 1685
+# environment
+LESSOPEN = | /usr/bin/lesspipe %s
+# environment
+VSCODE_CWD = /home/vatsal
+# environment
+GSETTINGS_SCHEMA_DIR = /snap/code/106/usr/share/glib-2.0/schemas
+# default
+MAKE_HOST := x86_64-pc-linux-gnu
+# environment
+NO_PROXY = 127.0.0.1
+# makefile (from 'Makefile', line 76)
+LD = $(TOOLPREFIX)ld
+# environment
+GPG_AGENT_INFO = /run/user/1000/gnupg/S.gpg-agent:0:1
+# environment
+SESSION_MANAGER = local/vatsal-lab:@/tmp/.ICE-unix/1892,unix/vatsal-lab:/tmp/.ICE-unix/1892
+# environment
+XDG_RUNTIME_DIR = /run/user/1000
+# environment
+GDK_PIXBUF_MODULE_FILE = /home/vatsal/snap/code/common/.cache/gdk-pixbuf-loaders.cache
+# environment
+SNAP = /snap/code/106
+# makefile (from 'Makefile', line 223)
+CPUS := 2
+# environment
+SNAP_VERSION = 784b0177
+# environment
+XDG_MENU_PREFIX = gnome-
+# environment
+ELECTRON_RUN_AS_NODE = 1
+# environment
+INVOCATION_ID = a847e42180a041a6a25e4a6affa702d2
+# makefile (from 'Makefile', line 83)
+LDFLAGS = -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+# environment
+GDK_PIXBUF_MODULEDIR = /snap/code/106/usr/lib/x86_64-linux-gnu/gdk-pixbuf-2.0/2.10.0/loaders
+# makefile (from 'Makefile', line 146)
+ULIB = ulib.o usys.o printf.o umalloc.o
+# default
+.FEATURES := target-specific order-only second-expansion else-if shortest-stem undefine oneshell archives jobserver output-sync check-symlink load
+# environment
+LS_COLORS = 
+# environment
+XDG_SESSION_DESKTOP = ubuntu
+# environment
+SSH_AUTH_SOCK = /run/user/1000/keyring/ssh
+# environment
+GIO_LAUNCHED_DESKTOP_FILE_PID = 26299
+# automatic
+%F = $(notdir $%)
+# environment
+DISPLAY = :1
+# environment
+SNAP_INSTANCE_KEY = 
+# environment
+PWD = /home/vatsal/copy-xv6
+# default
+.LOADED := 
+# environment
+SSH_AGENT_PID = 1857
+# environment
+ORIGINAL_XDG_CURRENT_DESKTOP = ubuntu:GNOME
+# environment
+GTK_MODULES = gail:atk-bridge
+# environment
+VSCODE_AMD_ENTRYPOINT = vs/workbench/api/node/extensionHostProcess
+# environment
+HOME = /home/vatsal
+# environment
+LESSCLOSE = /usr/bin/lesspipe %s %s
+# environment
+VSCODE_CLI = 1
+# environment
+VSCODE_CODE_CACHE_PATH = /home/vatsal/.config/Code/CachedData/784b0177c56c607789f9638da7b6bf3230d47a8c
+# environment
+LOGNAME = vatsal
+# environment
+APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL = 1
+# environment
+SNAP_LIBRARY_PATH = /var/lib/snapd/lib/gl:/var/lib/snapd/lib/gl32:/var/lib/snapd/void
+# environment
+SNAP_CONTEXT = zkV2bDMb-ANUcWPrya-USEcHdAj-qoJI5ZF3J8dk6RTAiFReBUwh
+# environment
+ELECTRON_NO_ATTACH_CONSOLE = 1
+# environment
+SNAP_USER_COMMON = /home/vatsal/snap/code/common
+# environment
+VSCODE_HANDLES_UNCAUGHT_ERRORS = true
+# environment
+GNOME_DESKTOP_SESSION_ID = this-is-deprecated
+# automatic
+^D = $(patsubst %/,%,$(dir $^))
+# environment
+MAKELEVEL := 0
+# environment
+SNAP_REAL_HOME = /home/vatsal
+# environment
+PLATFORMIO_PATH = /home/vatsal/.platformio/python3/bin:/home/vatsal/.local/bin:/home/vatsal/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
+# default
+MAKE = $(MAKE_COMMAND)
+# default
+MAKECMDGOALS := all
+# environment
+PATH = /home/vatsal/.local/bin:/home/vatsal/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
+# environment
+SNAP_USER_DATA = /home/vatsal/snap/code/106
+# environment
+SHLVL = 0
+# makefile (from 'Makefile', line 74)
+CC = $(TOOLPREFIX)gcc
+# makefile (from 'Makefile', line 39)
+TOOLPREFIX := 
+# environment
+GNOME_SHELL_SESSION_MODE = ubuntu
+# makefile (from 'Makefile', line 81)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# default
+MAKE_VERSION := 4.2.1
+# environment
+USER = vatsal
+# environment
+SNAP_REVISION = 106
+# makefile (from 'Makefile', line 202)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+# makefile
+.DEFAULT_GOAL := xv6.img
+# environment
+XDG_CURRENT_DESKTOP = Unity
+# environment
+LIBVIRT_DEFAULT_URI = qemu:///system
+# automatic
+%D = $(patsubst %/,%,$(dir $%))
+# default
+MAKE_COMMAND := make
+# default
+.VARIABLES := 
+# automatic
+*F = $(notdir $*)
+# environment
+LANGUAGE = en_IN:en
+# environment
+VSCODE_IPC_HOOK = /run/user/1000/vscode-09f386c8-1.71.0-main.sock
+# environment
+BAMF_DESKTOP_FILE_HINT = /var/lib/snapd/desktop/applications/code_code.desktop
+# makefile
+MAKEFLAGS = pqrR
+# environment
+MFLAGS = -pqrR
+# automatic
+*D = $(patsubst %/,%,$(dir $*))
+# makefile (from 'Makefile', line 134)
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+# automatic
++D = $(patsubst %/,%,$(dir $+))
+# makefile (from 'Makefile', line 78)
+OBJDUMP = $(TOOLPREFIX)objdump
+# environment
+GDK_BACKEND = x11
+# automatic
++F = $(notdir $+)
+# environment
+QT_ACCESSIBILITY = 1
+# makefile (from 'Makefile', line 225)
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+# 'override' directive
+.SHELLSTATUS := 0
+# default
+MAKEFILES := 
+# environment
+SNAP_COOKIE = zkV2bDMb-ANUcWPrya-USEcHdAj-qoJI5ZF3J8dk6RTAiFReBUwh
+# automatic
+<F = $(notdir $<)
+# environment
+PLATFORMIO_CALLER = vscode
+# environment
+SNAP_NAME = code
+# environment
+LC_ALL = C
+# environment
+GJS_DEBUG_TOPICS = JS ERROR;JS LOG
+# automatic
+^F = $(notdir $^)
+# makefile (from 'Makefile', line 77)
+OBJCOPY = $(TOOLPREFIX)objcopy
+# default
+SUFFIXES := 
+# makefile (from 'Makefile', line 168)
+UPROGS = _cat _echo _forktest _grep _init _kill _ln _ls _mkdir _rm _sh _stressfs _usertests _wc _zombie _drawtest _thread _old_thread
+# environment
+SNAP_REEXEC = 
+# environment
+CHROME_DESKTOP = code-url-handler.desktop
+# environment
+WINDOWPATH = 2
+# default
+.INCLUDE_DIRS = /usr/include /usr/local/include /usr/include
+# environment
+GJS_DEBUG_OUTPUT = stderr
+# default
+.RECIPEPREFIX := 
+# environment
+LANG = C
+# environment
+VSCODE_PID = 26346
+# makefile (from 'Makefile', line 201)
+FILES = $(shell grep -v '^#' runoff.list)
+# variable set hash-table stats:
+ 
+# Load=142/1024=14%, Rehash=0, Collisions=27/303=9%
+
+# Pattern-specific Variable Values
+
+# No pattern-specific variable values.
+
+# Directories
+
+# . (device 2050, inode 51910168): 287 files, no impossibilities.
+
+# 287 files, no impossibilities in 1 directories.
+
+# Implicit Rules
+
+_%: %.o ulib.o usys.o printf.o umalloc.o
+#  recipe to execute (from 'Makefile', line 149):
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+# 1 implicit rules, 0 (0.0%) terminal.
+
+# Files
+
+# Not a target:
+mmu.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+types.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+memlayout.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+xv6.pdf: runoff.list runoff.spec README toc.hdr toc.ftr types.h param.h memlayout.h defs.h x86.h asm.h mmu.h elf.h date.h entry.S entryother.S main.c spinlock.h spinlock.c vm.c proc.h proc.c swtch.S kalloc.c traps.h vectors.pl trapasm.S trap.c syscall.h syscall.c sysproc.c buf.h sleeplock.h fcntl.h stat.h fs.h file.h ide.c bio.c sleeplock.c log.c fs.c file.c sysfile.c exec.c pipe.c string.c mp.h mp.c lapic.c ioapic.c kbd.h kbd.c console.c uart.c initcode.S usys.S init.c sh.c bootasm.S bootmain.c kernel.ld
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 205):
+	./runoff
+	ls -l xv6.pdf
+
+wc.o: wc.c /usr/include/stdc-predef.h types.h stat.h user.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+_grep:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+console.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.429681406
+#  File has been updated.
+#  Successfully updated.
+
+qemu: fs.img xv6.img
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 228):
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+kbd.o: kbd.c /usr/include/stdc-predef.h types.h x86.h defs.h kbd.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+pipe.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+kbd.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+picirq.o: picirq.c /usr/include/stdc-predef.h types.h x86.h traps.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+qemu-memfs: xv6memfs.img
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 231):
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+# Not a target:
+stressfs.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 244):
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+spinlock.o: spinlock.c /usr/include/stdc-predef.h types.h defs.h param.h x86.h memlayout.h mmu.h proc.h spinlock.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+init.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+sleeplock.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+x86.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+all:
+#  Command line target.
+#  Implicit rule search has been done.
+#  File does not exist.
+#  File has not been updated.
+
+# Not a target:
+_ln:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+bio.o: bio.c /usr/include/stdc-predef.h types.h defs.h param.h spinlock.h sleeplock.h fs.h buf.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+sysfile.o: sysfile.c /usr/include/stdc-predef.h types.h defs.h param.h stat.h mmu.h proc.h fs.h spinlock.h sleeplock.h file.h fcntl.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+fcntl.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+proc.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:20.013680226
+#  File has been updated.
+#  Successfully updated.
+
+.PHONY: dist-test dist
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+forktest.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:18.505683274
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+vm.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:20.413679417
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+string.c:
+ 
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+thread.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+syscall.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+stat.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+bootblock: bootasm.S bootmain.c
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 104):
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7c00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+# Not a target:
+zombie.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+cat.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+bio.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+main.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+grep.o: grep.c /usr/include/stdc-predef.h types.h stat.h user.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+.PRECIOUS: %.o
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+kalloc.o: kalloc.c /usr/include/stdc-predef.h types.h defs.h param.h memlayout.h mmu.h spinlock.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+README:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+trapasm.S:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+umalloc.o: umalloc.c /usr/include/stdc-predef.h types.h stat.h user.h param.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+string.o: string.c /usr/include/stdc-predef.h types.h x86.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+mkdir.o: mkdir.c /usr/include/stdc-predef.h types.h stat.h user.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+file.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.505681252
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+_mkdir:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+rm.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:18.721682838
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+uart.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:20.325679595
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+sh.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+mp.o: mp.c /usr/include/stdc-predef.h types.h defs.h param.h memlayout.h mp.h x86.h mmu.h proc.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+ide.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+printf.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:18.405683477
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+ulib.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:18.365683556
+#  File has been updated.
+#  Successfully updated.
+
+lapic.o: lapic.c /usr/include/stdc-predef.h param.h types.h defs.h date.h memlayout.h traps.h mmu.h x86.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+ioapic.o: ioapic.c /usr/include/stdc-predef.h types.h defs.h traps.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+initcode.o: initcode.S syscall.h traps.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+exec.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+traps.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+fs.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+_init:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+usertests.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+ln.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:18.629683023
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+_thread:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+drawtest.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+tags: bio.o console.o exec.o file.o fs.o ide.o ioapic.o kalloc.o kbd.o lapic.o log.o main.o mp.o picirq.o pipe.o proc.o sleeplock.o spinlock.o string.o swtch.o syscall.o sysfile.o sysproc.o trapasm.o trap.o uart.o vectors.o vm.o entryother.S _init
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 141):
+	etags *.S *.c
+
+print: xv6.pdf
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+%.o:
+#  Precious file (prerequisite of .PRECIOUS).
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+Makefile:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:16:52.450992409
+#  File has been updated.
+#  Successfully updated.
+
+kernel: bio.o console.o exec.o file.o fs.o ide.o ioapic.o kalloc.o kbd.o lapic.o log.o main.o mp.o picirq.o pipe.o proc.o sleeplock.o spinlock.o string.o swtch.o syscall.o sysfile.o sysproc.o trapasm.o trap.o uart.o vectors.o vm.o entry.o entryother initcode kernel.ld
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 124):
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+# Not a target:
+rm.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+ls.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+stressfs.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:18.837682603
+#  File has been updated.
+#  Successfully updated.
+
+kernelmemfs: bio.o console.o exec.o file.o fs.o ioapic.o kalloc.o kbd.o lapic.o log.o main.o mp.o picirq.o pipe.o proc.o sleeplock.o spinlock.o string.o swtch.o syscall.o sysfile.o sysproc.o trapasm.o trap.o uart.o vectors.o vm.o memide.o entry.o entryother initcode kernel.ld fs.img
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 136):
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+# Not a target:
+old_thread.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+sleeplock.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:20.037680177
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+kill.d:
+#  Implicit rule search has been done.
+ 
+#  Last modified 2022-09-05 22:28:18.605683072
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+sysproc.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+.gdbinit.tmpl:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+log.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+_stressfs:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+rm.o: rm.c /usr/include/stdc-predef.h types.h stat.h user.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+console.o: console.c /usr/include/stdc-predef.h types.h defs.h param.h traps.h spinlock.h sleeplock.h fs.h file.h memlayout.h mmu.h proc.h x86.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+elf.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+syscall.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:20.145679959
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+echo.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:18.47768333
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+asm.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+thread.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:49:37.671670724
+#  File has been updated.
+#  Successfully updated.
+
+_forktest: forktest.o ulib.o usys.o printf.o umalloc.o
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 154):
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+# Not a target:
+ide.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.653680954
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+_kill:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+wc.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+fs.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+bootmain.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.313681641
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+_drawtest:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+entry.o:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+picirq.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+vm.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+proc.o: proc.c /usr/include/stdc-predef.h types.h defs.h param.h memlayout.h mmu.h x86.h proc.h spinlock.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+pipe.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.913680428
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+param.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+forktest.o: forktest.c /usr/include/stdc-predef.h types.h stat.h user.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+spinlock.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+trap.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+vectors.o:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+init.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:18.577683128
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+sysfile.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+vm.o: vm.c /usr/include/stdc-predef.h param.h types.h defs.h x86.h memlayout.h mmu.h proc.h elf.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+usys.o:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+_rm:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+file.o: file.c /usr/include/stdc-predef.h types.h defs.h param.h fs.h spinlock.h sleeplock.h file.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+toc.hdr:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+uart.o: uart.c /usr/include/stdc-predef.h types.h defs.h param.h traps.h spinlock.h sleeplock.h fs.h file.h mmu.h proc.h x86.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+vectors.pl:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+user.h:
+#  Implicit rule search has not been done.
+ 
+#  Modification time never checked.
+#  File has not been updated.
+
+initcode: initcode.S
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 118):
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+# Not a target:
+swtch.S:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+printf.o: printf.c /usr/include/stdc-predef.h types.h stat.h user.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+ulib.o: ulib.c /usr/include/stdc-predef.h types.h stat.h fcntl.h user.h x86.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+grep.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+fs.img: mkfs README _cat _echo _forktest _grep _init _kill _ln _ls _mkdir _rm _sh _stressfs _usertests _wc _zombie _drawtest _thread _old_thread
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 189):
+	./mkfs fs.img README $(UPROGS)
+
+# Not a target:
+zombie.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.177681915
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+cat.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:18.449683387
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+main.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.829680598
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+kalloc.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+bootasm.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.321681624
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+umalloc.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+ln.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+mkdir.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+bochs: fs.img xv6.img
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 213):
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# Not a target:
+_sh:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+kbd.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+bootmain.o: bootmain.c types.h elf.h x86.h memlayout.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+mp.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+_cat:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+sh.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:18.809682659
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+runoff.list:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+_echo:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+spinlock.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+lapic.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+trap.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:20.297679652
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+ioapic.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+ln.o: ln.c /usr/include/stdc-predef.h types.h stat.h user.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+stressfs.o: stressfs.c /usr/include/stdc-predef.h types.h stat.h user.h fs.h fcntl.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+.DEFAULT:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+mkfs: mkfs.c fs.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 160):
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+xv6.img: bootblock kernel
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 94):
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+sleeplock.o: sleeplock.c /usr/include/stdc-predef.h types.h defs.h param.h x86.h memlayout.h mmu.h proc.h spinlock.h sleeplock.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+kill.o: kill.c /usr/include/stdc-predef.h types.h stat.h user.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+entry.S:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+fs.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.613681034
+#  File has been updated.
+#  Successfully updated.
+
+xv6memfs.img: bootblock kernelmemfs
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 99):
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+# Not a target:
+usertests.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.105682061
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+drawtest.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.201681867
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+entryother.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:20.429679385
+#  File has been updated.
+#  Successfully updated.
+
+dist-test:
+#  Phony target (prerequisite of .PHONY).
+#  Implicit rule search has not been done.
+#  File does not exist.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 272):
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+syscall.o: syscall.c /usr/include/stdc-predef.h types.h defs.h param.h memlayout.h mmu.h proc.h x86.h syscall.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+ 
+
+echo.o: echo.c /usr/include/stdc-predef.h types.h stat.h user.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+qemu-gdb: fs.img xv6.img .gdbinit
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 240):
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+entryother.o: entryother.S asm.h memlayout.h mmu.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+ls.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:18.669682943
+#  File has been updated.
+#  Successfully updated.
+
+entryother: entryother.S
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 112):
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+# Not a target:
+old_thread.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.273681721
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+sysproc.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:20.261679724
+#  File has been updated.
+#  Successfully updated.
+
+clean:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 194):
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# Not a target:
+console.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+log.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.805680646
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+kill.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+mp.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+pipe.o: pipe.c /usr/include/stdc-predef.h types.h defs.h param.h mmu.h proc.h fs.h spinlock.h sleeplock.h file.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+tar:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 284):
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+dist:
+#  Phony target (prerequisite of .PHONY).
+#  Implicit rule search has not been done.
+#  File does not exist.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 261):
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+# Not a target:
+runoff.spec:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+wc.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.157681956
+#  File has been updated.
+#  Successfully updated.
+
+init.o: init.c /usr/include/stdc-predef.h types.h stat.h user.h fcntl.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+proc.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+kbd.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.725680808
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+picirq.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.877680501
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+buf.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+forktest.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+memide.o:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+vectors.S: vectors.pl
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+ 
+#  recipe to execute (from 'Makefile', line 144):
+	./vectors.pl > vectors.S
+
+thread.o: thread.c /usr/include/stdc-predef.h types.h stat.h user.h x86.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+spinlock.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:20.073680104
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+usys.S:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+qemu-nox: fs.img xv6.img
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 234):
+	$(QEMU) -nographic $(QEMUOPTS)
+
+# Not a target:
+_zombie:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+zombie.o: zombie.c /usr/include/stdc-predef.h types.h stat.h user.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+bio.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.357681552
+#  File has been updated.
+#  Successfully updated.
+
+cat.o: cat.c /usr/include/stdc-predef.h types.h stat.h user.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+main.o: main.c /usr/include/stdc-predef.h types.h defs.h param.h memlayout.h mmu.h proc.h x86.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+sysfile.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:20.229679789
+#  File has been updated.
+#  Successfully updated.
+
+bootasm.o: bootasm.S asm.h memlayout.h mmu.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+file.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+defs.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+uart.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+initcode.S:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+bootasm.S:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+trapasm.o:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+string.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:20.109680032
+#  File has been updated.
+#  Successfully updated.
+
+sh.o: sh.c /usr/include/stdc-predef.h types.h user.h fcntl.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+printf.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+ulib.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+ide.o: ide.c /usr/include/stdc-predef.h types.h defs.h param.h memlayout.h mmu.h proc.h x86.h traps.h spinlock.h sleeplock.h fs.h buf.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+trap.o: trap.c /usr/include/stdc-predef.h types.h defs.h param.h memlayout.h mmu.h proc.h x86.h traps.h spinlock.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+grep.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:18.545683193
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+_usertests:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+exec.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.469681325
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+kalloc.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.701680857
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+umalloc.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:18.429683427
+#  File has been updated.
+#  Successfully updated.
+
+exec.o: exec.c /usr/include/stdc-predef.h types.h param.h memlayout.h mmu.h proc.h defs.h x86.h elf.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+mkdir.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:18.693682895
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+toc.ftr:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+_wc:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+bootmain.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+fs.o: fs.c /usr/include/stdc-predef.h types.h defs.h param.h stat.h mmu.h proc.h spinlock.h sleeplock.h fs.h buf.h file.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+proc.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+usertests.o: usertests.c /usr/include/stdc-predef.h param.h types.h stat.h user.h fs.h fcntl.h syscall.h traps.h memlayout.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+initcode.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:20.445679353
+#  File has been updated.
+#  Successfully updated.
+
+drawtest.o: drawtest.c /usr/include/stdc-predef.h types.h stat.h user.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+mp.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.861680533
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+date.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+/usr/include/stdc-predef.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+mkfs.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+lapic.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.761680736
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+ioapic.d:
+#  Implicit rule search has been done.
+#  Last modified 2022-09-05 22:28:19.673680913
+#  File has been updated.
+#  Successfully updated.
+
+# Not a target:
+_old_thread:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+ls.o: ls.c /usr/include/stdc-predef.h types.h stat.h user.h fs.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+ 
+#  File has not been updated.
+
+# Not a target:
+sleeplock.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+_ls:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+kernel.ld:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+old_thread.o: old_thread.c /usr/include/stdc-predef.h types.h stat.h user.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+sysproc.o: sysproc.c /usr/include/stdc-predef.h types.h x86.h defs.h date.h param.h memlayout.h mmu.h proc.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+file.h:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+.gdbinit: .gdbinit.tmpl
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+#  recipe to execute (from 'Makefile', line 237):
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+log.o: log.c /usr/include/stdc-predef.h types.h defs.h param.h spinlock.h sleeplock.h fs.h buf.h
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+entryother.S:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+syscall.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+echo.c:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# Not a target:
+swtch.o:
+#  Implicit rule search has not been done.
+#  Modification time never checked.
+#  File has not been updated.
+
+# files hash-table stats:
+# Load=241/1024=24%, Rehash=0, Collisions=106/924=11%
+# VPATH Search Paths
+
+# No 'vpath' search paths.
+
+# No general ('VPATH' variable) search path.
+
+# strcache buffers: 1 (0) / strings = 314 / storage = 2720 B / avg = 8 B
+# current buf: size = 8162 B / used = 2720 B / count = 314 / avg = 8 B
+
+# strcache performance: lookups = 1146 / hit rate = 72%
+# hash-table stats:
+# Load=314/8192=4%, Rehash=0, Collisions=151/1146=13%
+# Finished Make data base on Mon Sep  5 22:54:41 2022
+
+ 
Binary files xv6-public/_wc and copy-xv6/_wc differ
diff -ruN xv6-public/wc.asm copy-xv6/wc.asm
--- xv6-public/wc.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/wc.asm	2022-09-05 23:26:12.548781080 +0530
@@ -0,0 +1,1360 @@
+
+_wc:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+  printf(1, "%d %d %d %s\n", l, w, c, name);
+}
+
+int
+main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	57                   	push   %edi
+  12:	56                   	push   %esi
+  13:	be 01 00 00 00       	mov    $0x1,%esi
+  18:	53                   	push   %ebx
+  19:	51                   	push   %ecx
+  1a:	83 ec 18             	sub    $0x18,%esp
+  1d:	8b 01                	mov    (%ecx),%eax
+  1f:	8b 59 04             	mov    0x4(%ecx),%ebx
+  22:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  25:	83 c3 04             	add    $0x4,%ebx
+  int fd, i;
+
+  if(argc <= 1){
+  28:	83 f8 01             	cmp    $0x1,%eax
+  2b:	7e 52                	jle    7f <main+0x7f>
+  2d:	8d 76 00             	lea    0x0(%esi),%esi
+    wc(0, "");
+    exit();
+  }
+
+  for(i = 1; i < argc; i++){
+    if((fd = open(argv[i], 0)) < 0){
+  30:	83 ec 08             	sub    $0x8,%esp
+  33:	6a 00                	push   $0x0
+  35:	ff 33                	pushl  (%ebx)
+  37:	e8 f7 03 00 00       	call   433 <open>
+  3c:	83 c4 10             	add    $0x10,%esp
+  3f:	89 c7                	mov    %eax,%edi
+  41:	85 c0                	test   %eax,%eax
+  43:	78 26                	js     6b <main+0x6b>
+      printf(1, "wc: cannot open %s\n", argv[i]);
+      exit();
+    }
+    wc(fd, argv[i]);
+  45:	83 ec 08             	sub    $0x8,%esp
+  48:	ff 33                	pushl  (%ebx)
+  for(i = 1; i < argc; i++){
+  4a:	83 c6 01             	add    $0x1,%esi
+  4d:	83 c3 04             	add    $0x4,%ebx
+    wc(fd, argv[i]);
+  50:	50                   	push   %eax
+  51:	e8 4a 00 00 00       	call   a0 <wc>
+    close(fd);
+  56:	89 3c 24             	mov    %edi,(%esp)
+  59:	e8 bd 03 00 00       	call   41b <close>
+  for(i = 1; i < argc; i++){
+  5e:	83 c4 10             	add    $0x10,%esp
+  61:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
+  64:	75 ca                	jne    30 <main+0x30>
+  }
+  exit();
+  66:	e8 88 03 00 00       	call   3f3 <exit>
+      printf(1, "wc: cannot open %s\n", argv[i]);
+  6b:	50                   	push   %eax
+  6c:	ff 33                	pushl  (%ebx)
+  6e:	68 fb 08 00 00       	push   $0x8fb
+  73:	6a 01                	push   $0x1
+  75:	e8 f6 04 00 00       	call   570 <printf>
+      exit();
+  7a:	e8 74 03 00 00       	call   3f3 <exit>
+    wc(0, "");
+  7f:	52                   	push   %edx
+  80:	52                   	push   %edx
+  81:	68 ed 08 00 00       	push   $0x8ed
+  86:	6a 00                	push   $0x0
+  88:	e8 13 00 00 00       	call   a0 <wc>
+    exit();
+  8d:	e8 61 03 00 00       	call   3f3 <exit>
+  92:	66 90                	xchg   %ax,%ax
+  94:	66 90                	xchg   %ax,%ax
+  96:	66 90                	xchg   %ax,%ax
+  98:	66 90                	xchg   %ax,%ax
+  9a:	66 90                	xchg   %ax,%ax
+  9c:	66 90                	xchg   %ax,%ax
+  9e:	66 90                	xchg   %ax,%ax
+
+000000a0 <wc>:
+{
+  a0:	f3 0f 1e fb          	endbr32 
+  a4:	55                   	push   %ebp
+  a5:	89 e5                	mov    %esp,%ebp
+  a7:	57                   	push   %edi
+  a8:	56                   	push   %esi
+  a9:	53                   	push   %ebx
+  l = w = c = 0;
+  aa:	31 db                	xor    %ebx,%ebx
+{
+  ac:	83 ec 1c             	sub    $0x1c,%esp
+  inword = 0;
+  af:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+  l = w = c = 0;
+  b6:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  bd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+  c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+  c8:	83 ec 04             	sub    $0x4,%esp
+  cb:	68 00 02 00 00       	push   $0x200
+  d0:	68 20 0c 00 00       	push   $0xc20
+  d5:	ff 75 08             	pushl  0x8(%ebp)
+  d8:	e8 2e 03 00 00       	call   40b <read>
+  dd:	83 c4 10             	add    $0x10,%esp
+  e0:	89 c6                	mov    %eax,%esi
+  e2:	85 c0                	test   %eax,%eax
+  e4:	7e 62                	jle    148 <wc+0xa8>
+    for(i=0; i<n; i++){
+  e6:	31 ff                	xor    %edi,%edi
+  e8:	eb 14                	jmp    fe <wc+0x5e>
+  ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        inword = 0;
+  f0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+    for(i=0; i<n; i++){
+  f7:	83 c7 01             	add    $0x1,%edi
+  fa:	39 fe                	cmp    %edi,%esi
+  fc:	74 42                	je     140 <wc+0xa0>
+      if(buf[i] == '\n')
+  fe:	0f be 87 20 0c 00 00 	movsbl 0xc20(%edi),%eax
+        l++;
+ 105:	31 c9                	xor    %ecx,%ecx
+ 107:	3c 0a                	cmp    $0xa,%al
+ 109:	0f 94 c1             	sete   %cl
+      if(strchr(" \r\t\n\v", buf[i]))
+ 10c:	83 ec 08             	sub    $0x8,%esp
+ 10f:	50                   	push   %eax
+        l++;
+ 110:	01 cb                	add    %ecx,%ebx
+      if(strchr(" \r\t\n\v", buf[i]))
+ 112:	68 d8 08 00 00       	push   $0x8d8
+ 117:	e8 54 01 00 00       	call   270 <strchr>
+ 11c:	83 c4 10             	add    $0x10,%esp
+ 11f:	85 c0                	test   %eax,%eax
+ 121:	75 cd                	jne    f0 <wc+0x50>
+      else if(!inword){
+ 123:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+ 126:	85 d2                	test   %edx,%edx
+ 128:	75 cd                	jne    f7 <wc+0x57>
+    for(i=0; i<n; i++){
+ 12a:	83 c7 01             	add    $0x1,%edi
+        w++;
+ 12d:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+        inword = 1;
+ 131:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
+    for(i=0; i<n; i++){
+ 138:	39 fe                	cmp    %edi,%esi
+ 13a:	75 c2                	jne    fe <wc+0x5e>
+ 13c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 140:	01 75 dc             	add    %esi,-0x24(%ebp)
+ 143:	eb 83                	jmp    c8 <wc+0x28>
+ 145:	8d 76 00             	lea    0x0(%esi),%esi
+  if(n < 0){
+ 148:	75 24                	jne    16e <wc+0xce>
+  printf(1, "%d %d %d %s\n", l, w, c, name);
+ 14a:	83 ec 08             	sub    $0x8,%esp
+ 14d:	ff 75 0c             	pushl  0xc(%ebp)
+ 150:	ff 75 dc             	pushl  -0x24(%ebp)
+ 153:	ff 75 e0             	pushl  -0x20(%ebp)
+ 156:	53                   	push   %ebx
+ 157:	68 ee 08 00 00       	push   $0x8ee
+ 15c:	6a 01                	push   $0x1
+ 15e:	e8 0d 04 00 00       	call   570 <printf>
+}
+ 163:	83 c4 20             	add    $0x20,%esp
+ 166:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 169:	5b                   	pop    %ebx
+ 16a:	5e                   	pop    %esi
+ 16b:	5f                   	pop    %edi
+ 16c:	5d                   	pop    %ebp
+ 16d:	c3                   	ret    
+    printf(1, "wc: read error\n");
+ 16e:	50                   	push   %eax
+ 16f:	50                   	push   %eax
+ 170:	68 de 08 00 00       	push   $0x8de
+ 175:	6a 01                	push   $0x1
+ 177:	e8 f4 03 00 00       	call   570 <printf>
+    exit();
+ 17c:	e8 72 02 00 00       	call   3f3 <exit>
+ 181:	66 90                	xchg   %ax,%ax
+ 183:	66 90                	xchg   %ax,%ax
+ 185:	66 90                	xchg   %ax,%ax
+ 187:	66 90                	xchg   %ax,%ax
+ 189:	66 90                	xchg   %ax,%ax
+ 18b:	66 90                	xchg   %ax,%ax
+ 18d:	66 90                	xchg   %ax,%ax
+ 18f:	90                   	nop
+
+00000190 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 190:	f3 0f 1e fb          	endbr32 
+ 194:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+ 195:	31 c0                	xor    %eax,%eax
+{
+ 197:	89 e5                	mov    %esp,%ebp
+ 199:	53                   	push   %ebx
+ 19a:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 19d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+ 1a0:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+ 1a4:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+ 1a7:	83 c0 01             	add    $0x1,%eax
+ 1aa:	84 d2                	test   %dl,%dl
+ 1ac:	75 f2                	jne    1a0 <strcpy+0x10>
+    ;
+  return os;
+}
+ 1ae:	89 c8                	mov    %ecx,%eax
+ 1b0:	5b                   	pop    %ebx
+ 1b1:	5d                   	pop    %ebp
+ 1b2:	c3                   	ret    
+ 1b3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 1ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000001c0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 1c0:	f3 0f 1e fb          	endbr32 
+ 1c4:	55                   	push   %ebp
+ 1c5:	89 e5                	mov    %esp,%ebp
+ 1c7:	53                   	push   %ebx
+ 1c8:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 1cb:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+ 1ce:	0f b6 01             	movzbl (%ecx),%eax
+ 1d1:	0f b6 1a             	movzbl (%edx),%ebx
+ 1d4:	84 c0                	test   %al,%al
+ 1d6:	75 19                	jne    1f1 <strcmp+0x31>
+ 1d8:	eb 26                	jmp    200 <strcmp+0x40>
+ 1da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 1e0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+ 1e4:	83 c1 01             	add    $0x1,%ecx
+ 1e7:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+ 1ea:	0f b6 1a             	movzbl (%edx),%ebx
+ 1ed:	84 c0                	test   %al,%al
+ 1ef:	74 0f                	je     200 <strcmp+0x40>
+ 1f1:	38 d8                	cmp    %bl,%al
+ 1f3:	74 eb                	je     1e0 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+ 1f5:	29 d8                	sub    %ebx,%eax
+}
+ 1f7:	5b                   	pop    %ebx
+ 1f8:	5d                   	pop    %ebp
+ 1f9:	c3                   	ret    
+ 1fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+ 200:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+ 202:	29 d8                	sub    %ebx,%eax
+}
+ 204:	5b                   	pop    %ebx
+ 205:	5d                   	pop    %ebp
+ 206:	c3                   	ret    
+ 207:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 20e:	66 90                	xchg   %ax,%ax
+
+00000210 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 210:	f3 0f 1e fb          	endbr32 
+ 214:	55                   	push   %ebp
+ 215:	89 e5                	mov    %esp,%ebp
+ 217:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 21a:	80 3a 00             	cmpb   $0x0,(%edx)
+ 21d:	74 21                	je     240 <strlen+0x30>
+ 21f:	31 c0                	xor    %eax,%eax
+ 221:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 228:	83 c0 01             	add    $0x1,%eax
+ 22b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+ 22f:	89 c1                	mov    %eax,%ecx
+ 231:	75 f5                	jne    228 <strlen+0x18>
+    ;
+  return n;
+}
+ 233:	89 c8                	mov    %ecx,%eax
+ 235:	5d                   	pop    %ebp
+ 236:	c3                   	ret    
+ 237:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 23e:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+ 240:	31 c9                	xor    %ecx,%ecx
+}
+ 242:	5d                   	pop    %ebp
+ 243:	89 c8                	mov    %ecx,%eax
+ 245:	c3                   	ret    
+ 246:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 24d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000250 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 250:	f3 0f 1e fb          	endbr32 
+ 254:	55                   	push   %ebp
+ 255:	89 e5                	mov    %esp,%ebp
+ 257:	57                   	push   %edi
+ 258:	8b 55 08             	mov    0x8(%ebp),%edx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+ 25b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 25e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 261:	89 d7                	mov    %edx,%edi
+ 263:	fc                   	cld    
+ 264:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+ 266:	89 d0                	mov    %edx,%eax
+ 268:	5f                   	pop    %edi
+ 269:	5d                   	pop    %ebp
+ 26a:	c3                   	ret    
+ 26b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 26f:	90                   	nop
+
+00000270 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 270:	f3 0f 1e fb          	endbr32 
+ 274:	55                   	push   %ebp
+ 275:	89 e5                	mov    %esp,%ebp
+ 277:	8b 45 08             	mov    0x8(%ebp),%eax
+ 27a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+ 27e:	0f b6 10             	movzbl (%eax),%edx
+ 281:	84 d2                	test   %dl,%dl
+ 283:	75 16                	jne    29b <strchr+0x2b>
+ 285:	eb 21                	jmp    2a8 <strchr+0x38>
+ 287:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 28e:	66 90                	xchg   %ax,%ax
+ 290:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+ 294:	83 c0 01             	add    $0x1,%eax
+ 297:	84 d2                	test   %dl,%dl
+ 299:	74 0d                	je     2a8 <strchr+0x38>
+    if(*s == c)
+ 29b:	38 d1                	cmp    %dl,%cl
+ 29d:	75 f1                	jne    290 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+ 29f:	5d                   	pop    %ebp
+ 2a0:	c3                   	ret    
+ 2a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+ 2a8:	31 c0                	xor    %eax,%eax
+}
+ 2aa:	5d                   	pop    %ebp
+ 2ab:	c3                   	ret    
+ 2ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000002b0 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 2b0:	f3 0f 1e fb          	endbr32 
+ 2b4:	55                   	push   %ebp
+ 2b5:	89 e5                	mov    %esp,%ebp
+ 2b7:	57                   	push   %edi
+ 2b8:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 2b9:	31 f6                	xor    %esi,%esi
+{
+ 2bb:	53                   	push   %ebx
+ 2bc:	89 f3                	mov    %esi,%ebx
+ 2be:	83 ec 1c             	sub    $0x1c,%esp
+ 2c1:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+ 2c4:	eb 33                	jmp    2f9 <gets+0x49>
+ 2c6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 2cd:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+ 2d0:	83 ec 04             	sub    $0x4,%esp
+ 2d3:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ 2d6:	6a 01                	push   $0x1
+ 2d8:	50                   	push   %eax
+ 2d9:	6a 00                	push   $0x0
+ 2db:	e8 2b 01 00 00       	call   40b <read>
+    if(cc < 1)
+ 2e0:	83 c4 10             	add    $0x10,%esp
+ 2e3:	85 c0                	test   %eax,%eax
+ 2e5:	7e 1c                	jle    303 <gets+0x53>
+      break;
+    buf[i++] = c;
+ 2e7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ 2eb:	83 c7 01             	add    $0x1,%edi
+ 2ee:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+ 2f1:	3c 0a                	cmp    $0xa,%al
+ 2f3:	74 23                	je     318 <gets+0x68>
+ 2f5:	3c 0d                	cmp    $0xd,%al
+ 2f7:	74 1f                	je     318 <gets+0x68>
+  for(i=0; i+1 < max; ){
+ 2f9:	83 c3 01             	add    $0x1,%ebx
+ 2fc:	89 fe                	mov    %edi,%esi
+ 2fe:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+ 301:	7c cd                	jl     2d0 <gets+0x20>
+ 303:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+ 305:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+ 308:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 30b:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 30e:	5b                   	pop    %ebx
+ 30f:	5e                   	pop    %esi
+ 310:	5f                   	pop    %edi
+ 311:	5d                   	pop    %ebp
+ 312:	c3                   	ret    
+ 313:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 317:	90                   	nop
+ 318:	8b 75 08             	mov    0x8(%ebp),%esi
+ 31b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 31e:	01 de                	add    %ebx,%esi
+ 320:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+ 322:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 325:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 328:	5b                   	pop    %ebx
+ 329:	5e                   	pop    %esi
+ 32a:	5f                   	pop    %edi
+ 32b:	5d                   	pop    %ebp
+ 32c:	c3                   	ret    
+ 32d:	8d 76 00             	lea    0x0(%esi),%esi
+
+00000330 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 330:	f3 0f 1e fb          	endbr32 
+ 334:	55                   	push   %ebp
+ 335:	89 e5                	mov    %esp,%ebp
+ 337:	56                   	push   %esi
+ 338:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 339:	83 ec 08             	sub    $0x8,%esp
+ 33c:	6a 00                	push   $0x0
+ 33e:	ff 75 08             	pushl  0x8(%ebp)
+ 341:	e8 ed 00 00 00       	call   433 <open>
+  if(fd < 0)
+ 346:	83 c4 10             	add    $0x10,%esp
+ 349:	85 c0                	test   %eax,%eax
+ 34b:	78 2b                	js     378 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+ 34d:	83 ec 08             	sub    $0x8,%esp
+ 350:	ff 75 0c             	pushl  0xc(%ebp)
+ 353:	89 c3                	mov    %eax,%ebx
+ 355:	50                   	push   %eax
+ 356:	e8 f0 00 00 00       	call   44b <fstat>
+  close(fd);
+ 35b:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+ 35e:	89 c6                	mov    %eax,%esi
+  close(fd);
+ 360:	e8 b6 00 00 00       	call   41b <close>
+  return r;
+ 365:	83 c4 10             	add    $0x10,%esp
+}
+ 368:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 36b:	89 f0                	mov    %esi,%eax
+ 36d:	5b                   	pop    %ebx
+ 36e:	5e                   	pop    %esi
+ 36f:	5d                   	pop    %ebp
+ 370:	c3                   	ret    
+ 371:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+ 378:	be ff ff ff ff       	mov    $0xffffffff,%esi
+ 37d:	eb e9                	jmp    368 <stat+0x38>
+ 37f:	90                   	nop
+
+00000380 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 380:	f3 0f 1e fb          	endbr32 
+ 384:	55                   	push   %ebp
+ 385:	89 e5                	mov    %esp,%ebp
+ 387:	53                   	push   %ebx
+ 388:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 38b:	0f be 02             	movsbl (%edx),%eax
+ 38e:	8d 48 d0             	lea    -0x30(%eax),%ecx
+ 391:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+ 394:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+ 399:	77 1a                	ja     3b5 <atoi+0x35>
+ 39b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 39f:	90                   	nop
+    n = n*10 + *s++ - '0';
+ 3a0:	83 c2 01             	add    $0x1,%edx
+ 3a3:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+ 3a6:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+ 3aa:	0f be 02             	movsbl (%edx),%eax
+ 3ad:	8d 58 d0             	lea    -0x30(%eax),%ebx
+ 3b0:	80 fb 09             	cmp    $0x9,%bl
+ 3b3:	76 eb                	jbe    3a0 <atoi+0x20>
+  return n;
+}
+ 3b5:	89 c8                	mov    %ecx,%eax
+ 3b7:	5b                   	pop    %ebx
+ 3b8:	5d                   	pop    %ebp
+ 3b9:	c3                   	ret    
+ 3ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+000003c0 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 3c0:	f3 0f 1e fb          	endbr32 
+ 3c4:	55                   	push   %ebp
+ 3c5:	89 e5                	mov    %esp,%ebp
+ 3c7:	57                   	push   %edi
+ 3c8:	8b 45 10             	mov    0x10(%ebp),%eax
+ 3cb:	8b 55 08             	mov    0x8(%ebp),%edx
+ 3ce:	56                   	push   %esi
+ 3cf:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 3d2:	85 c0                	test   %eax,%eax
+ 3d4:	7e 0f                	jle    3e5 <memmove+0x25>
+ 3d6:	01 d0                	add    %edx,%eax
+  dst = vdst;
+ 3d8:	89 d7                	mov    %edx,%edi
+ 3da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+ 3e0:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+ 3e1:	39 f8                	cmp    %edi,%eax
+ 3e3:	75 fb                	jne    3e0 <memmove+0x20>
+  return vdst;
+}
+ 3e5:	5e                   	pop    %esi
+ 3e6:	89 d0                	mov    %edx,%eax
+ 3e8:	5f                   	pop    %edi
+ 3e9:	5d                   	pop    %ebp
+ 3ea:	c3                   	ret    
+
+000003eb <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 3eb:	b8 01 00 00 00       	mov    $0x1,%eax
+ 3f0:	cd 40                	int    $0x40
+ 3f2:	c3                   	ret    
+
+000003f3 <exit>:
+SYSCALL(exit)
+ 3f3:	b8 02 00 00 00       	mov    $0x2,%eax
+ 3f8:	cd 40                	int    $0x40
+ 3fa:	c3                   	ret    
+
+000003fb <wait>:
+SYSCALL(wait)
+ 3fb:	b8 03 00 00 00       	mov    $0x3,%eax
+ 400:	cd 40                	int    $0x40
+ 402:	c3                   	ret    
+
+00000403 <pipe>:
+SYSCALL(pipe)
+ 403:	b8 04 00 00 00       	mov    $0x4,%eax
+ 408:	cd 40                	int    $0x40
+ 40a:	c3                   	ret    
+
+0000040b <read>:
+SYSCALL(read)
+ 40b:	b8 05 00 00 00       	mov    $0x5,%eax
+ 410:	cd 40                	int    $0x40
+ 412:	c3                   	ret    
+
+00000413 <write>:
+SYSCALL(write)
+ 413:	b8 10 00 00 00       	mov    $0x10,%eax
+ 418:	cd 40                	int    $0x40
+ 41a:	c3                   	ret    
+
+0000041b <close>:
+SYSCALL(close)
+ 41b:	b8 15 00 00 00       	mov    $0x15,%eax
+ 420:	cd 40                	int    $0x40
+ 422:	c3                   	ret    
+
+00000423 <kill>:
+SYSCALL(kill)
+ 423:	b8 06 00 00 00       	mov    $0x6,%eax
+ 428:	cd 40                	int    $0x40
+ 42a:	c3                   	ret    
+
+0000042b <exec>:
+SYSCALL(exec)
+ 42b:	b8 07 00 00 00       	mov    $0x7,%eax
+ 430:	cd 40                	int    $0x40
+ 432:	c3                   	ret    
+
+00000433 <open>:
+SYSCALL(open)
+ 433:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 438:	cd 40                	int    $0x40
+ 43a:	c3                   	ret    
+
+0000043b <mknod>:
+SYSCALL(mknod)
+ 43b:	b8 11 00 00 00       	mov    $0x11,%eax
+ 440:	cd 40                	int    $0x40
+ 442:	c3                   	ret    
+
+00000443 <unlink>:
+SYSCALL(unlink)
+ 443:	b8 12 00 00 00       	mov    $0x12,%eax
+ 448:	cd 40                	int    $0x40
+ 44a:	c3                   	ret    
+
+0000044b <fstat>:
+SYSCALL(fstat)
+ 44b:	b8 08 00 00 00       	mov    $0x8,%eax
+ 450:	cd 40                	int    $0x40
+ 452:	c3                   	ret    
+
+00000453 <link>:
+SYSCALL(link)
+ 453:	b8 13 00 00 00       	mov    $0x13,%eax
+ 458:	cd 40                	int    $0x40
+ 45a:	c3                   	ret    
+
+0000045b <mkdir>:
+SYSCALL(mkdir)
+ 45b:	b8 14 00 00 00       	mov    $0x14,%eax
+ 460:	cd 40                	int    $0x40
+ 462:	c3                   	ret    
+
+00000463 <chdir>:
+SYSCALL(chdir)
+ 463:	b8 09 00 00 00       	mov    $0x9,%eax
+ 468:	cd 40                	int    $0x40
+ 46a:	c3                   	ret    
+
+0000046b <dup>:
+SYSCALL(dup)
+ 46b:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 470:	cd 40                	int    $0x40
+ 472:	c3                   	ret    
+
+00000473 <getpid>:
+SYSCALL(getpid)
+ 473:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 478:	cd 40                	int    $0x40
+ 47a:	c3                   	ret    
+
+0000047b <sbrk>:
+SYSCALL(sbrk)
+ 47b:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 480:	cd 40                	int    $0x40
+ 482:	c3                   	ret    
+
+00000483 <sleep>:
+SYSCALL(sleep)
+ 483:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 488:	cd 40                	int    $0x40
+ 48a:	c3                   	ret    
+
+0000048b <uptime>:
+SYSCALL(uptime)
+ 48b:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 490:	cd 40                	int    $0x40
+ 492:	c3                   	ret    
+
+00000493 <draw>:
+SYSCALL(draw)
+ 493:	b8 16 00 00 00       	mov    $0x16,%eax
+ 498:	cd 40                	int    $0x40
+ 49a:	c3                   	ret    
+
+0000049b <thread_create>:
+
+SYSCALL(thread_create)
+ 49b:	b8 17 00 00 00       	mov    $0x17,%eax
+ 4a0:	cd 40                	int    $0x40
+ 4a2:	c3                   	ret    
+
+000004a3 <thread_join>:
+SYSCALL(thread_join)
+ 4a3:	b8 18 00 00 00       	mov    $0x18,%eax
+ 4a8:	cd 40                	int    $0x40
+ 4aa:	c3                   	ret    
+
+000004ab <thread_exit>:
+SYSCALL(thread_exit)
+ 4ab:	b8 19 00 00 00       	mov    $0x19,%eax
+ 4b0:	cd 40                	int    $0x40
+ 4b2:	c3                   	ret    
+ 4b3:	66 90                	xchg   %ax,%ax
+ 4b5:	66 90                	xchg   %ax,%ax
+ 4b7:	66 90                	xchg   %ax,%ax
+ 4b9:	66 90                	xchg   %ax,%ax
+ 4bb:	66 90                	xchg   %ax,%ax
+ 4bd:	66 90                	xchg   %ax,%ax
+ 4bf:	90                   	nop
+
+000004c0 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 4c0:	55                   	push   %ebp
+ 4c1:	89 e5                	mov    %esp,%ebp
+ 4c3:	57                   	push   %edi
+ 4c4:	56                   	push   %esi
+ 4c5:	53                   	push   %ebx
+ 4c6:	83 ec 3c             	sub    $0x3c,%esp
+ 4c9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+ 4cc:	89 d1                	mov    %edx,%ecx
+{
+ 4ce:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  if(sgn && xx < 0){
+ 4d1:	85 d2                	test   %edx,%edx
+ 4d3:	0f 89 7f 00 00 00    	jns    558 <printint+0x98>
+ 4d9:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
+ 4dd:	74 79                	je     558 <printint+0x98>
+    neg = 1;
+ 4df:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+    x = -xx;
+ 4e6:	f7 d9                	neg    %ecx
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 4e8:	31 db                	xor    %ebx,%ebx
+ 4ea:	8d 75 d7             	lea    -0x29(%ebp),%esi
+ 4ed:	8d 76 00             	lea    0x0(%esi),%esi
+  do{
+    buf[i++] = digits[x % base];
+ 4f0:	89 c8                	mov    %ecx,%eax
+ 4f2:	31 d2                	xor    %edx,%edx
+ 4f4:	89 cf                	mov    %ecx,%edi
+ 4f6:	f7 75 c4             	divl   -0x3c(%ebp)
+ 4f9:	0f b6 92 18 09 00 00 	movzbl 0x918(%edx),%edx
+ 500:	89 45 c0             	mov    %eax,-0x40(%ebp)
+ 503:	89 d8                	mov    %ebx,%eax
+ 505:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+ 508:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+    buf[i++] = digits[x % base];
+ 50b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
+  }while((x /= base) != 0);
+ 50e:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
+ 511:	76 dd                	jbe    4f0 <printint+0x30>
+  if(neg)
+ 513:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+ 516:	85 c9                	test   %ecx,%ecx
+ 518:	74 0c                	je     526 <printint+0x66>
+    buf[i++] = '-';
+ 51a:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+ 51f:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+ 521:	ba 2d 00 00 00       	mov    $0x2d,%edx
+
+  while(--i >= 0)
+ 526:	8b 7d b8             	mov    -0x48(%ebp),%edi
+ 529:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+ 52d:	eb 07                	jmp    536 <printint+0x76>
+ 52f:	90                   	nop
+ 530:	0f b6 13             	movzbl (%ebx),%edx
+ 533:	83 eb 01             	sub    $0x1,%ebx
+  write(fd, &c, 1);
+ 536:	83 ec 04             	sub    $0x4,%esp
+ 539:	88 55 d7             	mov    %dl,-0x29(%ebp)
+ 53c:	6a 01                	push   $0x1
+ 53e:	56                   	push   %esi
+ 53f:	57                   	push   %edi
+ 540:	e8 ce fe ff ff       	call   413 <write>
+  while(--i >= 0)
+ 545:	83 c4 10             	add    $0x10,%esp
+ 548:	39 de                	cmp    %ebx,%esi
+ 54a:	75 e4                	jne    530 <printint+0x70>
+    putc(fd, buf[i]);
+}
+ 54c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 54f:	5b                   	pop    %ebx
+ 550:	5e                   	pop    %esi
+ 551:	5f                   	pop    %edi
+ 552:	5d                   	pop    %ebp
+ 553:	c3                   	ret    
+ 554:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  neg = 0;
+ 558:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+ 55f:	eb 87                	jmp    4e8 <printint+0x28>
+ 561:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 568:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 56f:	90                   	nop
+
+00000570 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 570:	f3 0f 1e fb          	endbr32 
+ 574:	55                   	push   %ebp
+ 575:	89 e5                	mov    %esp,%ebp
+ 577:	57                   	push   %edi
+ 578:	56                   	push   %esi
+ 579:	53                   	push   %ebx
+ 57a:	83 ec 2c             	sub    $0x2c,%esp
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 57d:	8b 75 0c             	mov    0xc(%ebp),%esi
+ 580:	0f b6 1e             	movzbl (%esi),%ebx
+ 583:	84 db                	test   %bl,%bl
+ 585:	0f 84 b4 00 00 00    	je     63f <printf+0xcf>
+  ap = (uint*)(void*)&fmt + 1;
+ 58b:	8d 45 10             	lea    0x10(%ebp),%eax
+ 58e:	83 c6 01             	add    $0x1,%esi
+  write(fd, &c, 1);
+ 591:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  state = 0;
+ 594:	31 d2                	xor    %edx,%edx
+  ap = (uint*)(void*)&fmt + 1;
+ 596:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 599:	eb 33                	jmp    5ce <printf+0x5e>
+ 59b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 59f:	90                   	nop
+ 5a0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+ 5a3:	ba 25 00 00 00       	mov    $0x25,%edx
+      if(c == '%'){
+ 5a8:	83 f8 25             	cmp    $0x25,%eax
+ 5ab:	74 17                	je     5c4 <printf+0x54>
+  write(fd, &c, 1);
+ 5ad:	83 ec 04             	sub    $0x4,%esp
+ 5b0:	88 5d e7             	mov    %bl,-0x19(%ebp)
+ 5b3:	6a 01                	push   $0x1
+ 5b5:	57                   	push   %edi
+ 5b6:	ff 75 08             	pushl  0x8(%ebp)
+ 5b9:	e8 55 fe ff ff       	call   413 <write>
+ 5be:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+      } else {
+        putc(fd, c);
+ 5c1:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; fmt[i]; i++){
+ 5c4:	0f b6 1e             	movzbl (%esi),%ebx
+ 5c7:	83 c6 01             	add    $0x1,%esi
+ 5ca:	84 db                	test   %bl,%bl
+ 5cc:	74 71                	je     63f <printf+0xcf>
+    c = fmt[i] & 0xff;
+ 5ce:	0f be cb             	movsbl %bl,%ecx
+ 5d1:	0f b6 c3             	movzbl %bl,%eax
+    if(state == 0){
+ 5d4:	85 d2                	test   %edx,%edx
+ 5d6:	74 c8                	je     5a0 <printf+0x30>
+      }
+    } else if(state == '%'){
+ 5d8:	83 fa 25             	cmp    $0x25,%edx
+ 5db:	75 e7                	jne    5c4 <printf+0x54>
+      if(c == 'd'){
+ 5dd:	83 f8 64             	cmp    $0x64,%eax
+ 5e0:	0f 84 9a 00 00 00    	je     680 <printf+0x110>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+ 5e6:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
+ 5ec:	83 f9 70             	cmp    $0x70,%ecx
+ 5ef:	74 5f                	je     650 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+ 5f1:	83 f8 73             	cmp    $0x73,%eax
+ 5f4:	0f 84 d6 00 00 00    	je     6d0 <printf+0x160>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 5fa:	83 f8 63             	cmp    $0x63,%eax
+ 5fd:	0f 84 8d 00 00 00    	je     690 <printf+0x120>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+ 603:	83 f8 25             	cmp    $0x25,%eax
+ 606:	0f 84 b4 00 00 00    	je     6c0 <printf+0x150>
+  write(fd, &c, 1);
+ 60c:	83 ec 04             	sub    $0x4,%esp
+ 60f:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
+ 613:	6a 01                	push   $0x1
+ 615:	57                   	push   %edi
+ 616:	ff 75 08             	pushl  0x8(%ebp)
+ 619:	e8 f5 fd ff ff       	call   413 <write>
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+ 61e:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 621:	83 c4 0c             	add    $0xc,%esp
+ 624:	6a 01                	push   $0x1
+ 626:	83 c6 01             	add    $0x1,%esi
+ 629:	57                   	push   %edi
+ 62a:	ff 75 08             	pushl  0x8(%ebp)
+ 62d:	e8 e1 fd ff ff       	call   413 <write>
+  for(i = 0; fmt[i]; i++){
+ 632:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
+        putc(fd, c);
+ 636:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 639:	31 d2                	xor    %edx,%edx
+  for(i = 0; fmt[i]; i++){
+ 63b:	84 db                	test   %bl,%bl
+ 63d:	75 8f                	jne    5ce <printf+0x5e>
+    }
+  }
+}
+ 63f:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 642:	5b                   	pop    %ebx
+ 643:	5e                   	pop    %esi
+ 644:	5f                   	pop    %edi
+ 645:	5d                   	pop    %ebp
+ 646:	c3                   	ret    
+ 647:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 64e:	66 90                	xchg   %ax,%ax
+        printint(fd, *ap, 16, 0);
+ 650:	83 ec 0c             	sub    $0xc,%esp
+ 653:	b9 10 00 00 00       	mov    $0x10,%ecx
+ 658:	6a 00                	push   $0x0
+ 65a:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+ 65d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 660:	8b 13                	mov    (%ebx),%edx
+ 662:	e8 59 fe ff ff       	call   4c0 <printint>
+        ap++;
+ 667:	89 d8                	mov    %ebx,%eax
+ 669:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 66c:	31 d2                	xor    %edx,%edx
+        ap++;
+ 66e:	83 c0 04             	add    $0x4,%eax
+ 671:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 674:	e9 4b ff ff ff       	jmp    5c4 <printf+0x54>
+ 679:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        printint(fd, *ap, 10, 1);
+ 680:	83 ec 0c             	sub    $0xc,%esp
+ 683:	b9 0a 00 00 00       	mov    $0xa,%ecx
+ 688:	6a 01                	push   $0x1
+ 68a:	eb ce                	jmp    65a <printf+0xea>
+ 68c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        putc(fd, *ap);
+ 690:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+  write(fd, &c, 1);
+ 693:	83 ec 04             	sub    $0x4,%esp
+        putc(fd, *ap);
+ 696:	8b 03                	mov    (%ebx),%eax
+  write(fd, &c, 1);
+ 698:	6a 01                	push   $0x1
+        ap++;
+ 69a:	83 c3 04             	add    $0x4,%ebx
+  write(fd, &c, 1);
+ 69d:	57                   	push   %edi
+ 69e:	ff 75 08             	pushl  0x8(%ebp)
+        putc(fd, *ap);
+ 6a1:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 6a4:	e8 6a fd ff ff       	call   413 <write>
+        ap++;
+ 6a9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+ 6ac:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 6af:	31 d2                	xor    %edx,%edx
+ 6b1:	e9 0e ff ff ff       	jmp    5c4 <printf+0x54>
+ 6b6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 6bd:	8d 76 00             	lea    0x0(%esi),%esi
+        putc(fd, c);
+ 6c0:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 6c3:	83 ec 04             	sub    $0x4,%esp
+ 6c6:	e9 59 ff ff ff       	jmp    624 <printf+0xb4>
+ 6cb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 6cf:	90                   	nop
+        s = (char*)*ap;
+ 6d0:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 6d3:	8b 18                	mov    (%eax),%ebx
+        ap++;
+ 6d5:	83 c0 04             	add    $0x4,%eax
+ 6d8:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        if(s == 0)
+ 6db:	85 db                	test   %ebx,%ebx
+ 6dd:	74 17                	je     6f6 <printf+0x186>
+        while(*s != 0){
+ 6df:	0f b6 03             	movzbl (%ebx),%eax
+      state = 0;
+ 6e2:	31 d2                	xor    %edx,%edx
+        while(*s != 0){
+ 6e4:	84 c0                	test   %al,%al
+ 6e6:	0f 84 d8 fe ff ff    	je     5c4 <printf+0x54>
+ 6ec:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 6ef:	89 de                	mov    %ebx,%esi
+ 6f1:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 6f4:	eb 1a                	jmp    710 <printf+0x1a0>
+          s = "(null)";
+ 6f6:	bb 0f 09 00 00       	mov    $0x90f,%ebx
+        while(*s != 0){
+ 6fb:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 6fe:	b8 28 00 00 00       	mov    $0x28,%eax
+ 703:	89 de                	mov    %ebx,%esi
+ 705:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 708:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 70f:	90                   	nop
+  write(fd, &c, 1);
+ 710:	83 ec 04             	sub    $0x4,%esp
+          s++;
+ 713:	83 c6 01             	add    $0x1,%esi
+ 716:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 719:	6a 01                	push   $0x1
+ 71b:	57                   	push   %edi
+ 71c:	53                   	push   %ebx
+ 71d:	e8 f1 fc ff ff       	call   413 <write>
+        while(*s != 0){
+ 722:	0f b6 06             	movzbl (%esi),%eax
+ 725:	83 c4 10             	add    $0x10,%esp
+ 728:	84 c0                	test   %al,%al
+ 72a:	75 e4                	jne    710 <printf+0x1a0>
+ 72c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+      state = 0;
+ 72f:	31 d2                	xor    %edx,%edx
+ 731:	e9 8e fe ff ff       	jmp    5c4 <printf+0x54>
+ 736:	66 90                	xchg   %ax,%ax
+ 738:	66 90                	xchg   %ax,%ax
+ 73a:	66 90                	xchg   %ax,%ax
+ 73c:	66 90                	xchg   %ax,%ax
+ 73e:	66 90                	xchg   %ax,%ax
+
+00000740 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 740:	f3 0f 1e fb          	endbr32 
+ 744:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 745:	a1 00 0c 00 00       	mov    0xc00,%eax
+{
+ 74a:	89 e5                	mov    %esp,%ebp
+ 74c:	57                   	push   %edi
+ 74d:	56                   	push   %esi
+ 74e:	53                   	push   %ebx
+ 74f:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 752:	8b 10                	mov    (%eax),%edx
+  bp = (Header*)ap - 1;
+ 754:	8d 4b f8             	lea    -0x8(%ebx),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 757:	39 c8                	cmp    %ecx,%eax
+ 759:	73 15                	jae    770 <free+0x30>
+ 75b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 75f:	90                   	nop
+ 760:	39 d1                	cmp    %edx,%ecx
+ 762:	72 14                	jb     778 <free+0x38>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 764:	39 d0                	cmp    %edx,%eax
+ 766:	73 10                	jae    778 <free+0x38>
+{
+ 768:	89 d0                	mov    %edx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 76a:	8b 10                	mov    (%eax),%edx
+ 76c:	39 c8                	cmp    %ecx,%eax
+ 76e:	72 f0                	jb     760 <free+0x20>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 770:	39 d0                	cmp    %edx,%eax
+ 772:	72 f4                	jb     768 <free+0x28>
+ 774:	39 d1                	cmp    %edx,%ecx
+ 776:	73 f0                	jae    768 <free+0x28>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 778:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ 77b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
+ 77e:	39 fa                	cmp    %edi,%edx
+ 780:	74 1e                	je     7a0 <free+0x60>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+ 782:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 785:	8b 50 04             	mov    0x4(%eax),%edx
+ 788:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 78b:	39 f1                	cmp    %esi,%ecx
+ 78d:	74 28                	je     7b7 <free+0x77>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+ 78f:	89 08                	mov    %ecx,(%eax)
+  freep = p;
+}
+ 791:	5b                   	pop    %ebx
+  freep = p;
+ 792:	a3 00 0c 00 00       	mov    %eax,0xc00
+}
+ 797:	5e                   	pop    %esi
+ 798:	5f                   	pop    %edi
+ 799:	5d                   	pop    %ebp
+ 79a:	c3                   	ret    
+ 79b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 79f:	90                   	nop
+    bp->s.size += p->s.ptr->s.size;
+ 7a0:	03 72 04             	add    0x4(%edx),%esi
+ 7a3:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 7a6:	8b 10                	mov    (%eax),%edx
+ 7a8:	8b 12                	mov    (%edx),%edx
+ 7aa:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 7ad:	8b 50 04             	mov    0x4(%eax),%edx
+ 7b0:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 7b3:	39 f1                	cmp    %esi,%ecx
+ 7b5:	75 d8                	jne    78f <free+0x4f>
+    p->s.size += bp->s.size;
+ 7b7:	03 53 fc             	add    -0x4(%ebx),%edx
+  freep = p;
+ 7ba:	a3 00 0c 00 00       	mov    %eax,0xc00
+    p->s.size += bp->s.size;
+ 7bf:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 7c2:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ 7c5:	89 10                	mov    %edx,(%eax)
+}
+ 7c7:	5b                   	pop    %ebx
+ 7c8:	5e                   	pop    %esi
+ 7c9:	5f                   	pop    %edi
+ 7ca:	5d                   	pop    %ebp
+ 7cb:	c3                   	ret    
+ 7cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+000007d0 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 7d0:	f3 0f 1e fb          	endbr32 
+ 7d4:	55                   	push   %ebp
+ 7d5:	89 e5                	mov    %esp,%ebp
+ 7d7:	57                   	push   %edi
+ 7d8:	56                   	push   %esi
+ 7d9:	53                   	push   %ebx
+ 7da:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 7dd:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+ 7e0:	8b 3d 00 0c 00 00    	mov    0xc00,%edi
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 7e6:	8d 70 07             	lea    0x7(%eax),%esi
+ 7e9:	c1 ee 03             	shr    $0x3,%esi
+ 7ec:	83 c6 01             	add    $0x1,%esi
+  if((prevp = freep) == 0){
+ 7ef:	85 ff                	test   %edi,%edi
+ 7f1:	0f 84 a9 00 00 00    	je     8a0 <malloc+0xd0>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7f7:	8b 07                	mov    (%edi),%eax
+    if(p->s.size >= nunits){
+ 7f9:	8b 48 04             	mov    0x4(%eax),%ecx
+ 7fc:	39 f1                	cmp    %esi,%ecx
+ 7fe:	73 6d                	jae    86d <malloc+0x9d>
+ 800:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+ 806:	bb 00 10 00 00       	mov    $0x1000,%ebx
+ 80b:	0f 43 de             	cmovae %esi,%ebx
+  p = sbrk(nu * sizeof(Header));
+ 80e:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
+ 815:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+ 818:	eb 17                	jmp    831 <malloc+0x61>
+ 81a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 820:	8b 10                	mov    (%eax),%edx
+    if(p->s.size >= nunits){
+ 822:	8b 4a 04             	mov    0x4(%edx),%ecx
+ 825:	39 f1                	cmp    %esi,%ecx
+ 827:	73 4f                	jae    878 <malloc+0xa8>
+ 829:	8b 3d 00 0c 00 00    	mov    0xc00,%edi
+ 82f:	89 d0                	mov    %edx,%eax
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 831:	39 c7                	cmp    %eax,%edi
+ 833:	75 eb                	jne    820 <malloc+0x50>
+  p = sbrk(nu * sizeof(Header));
+ 835:	83 ec 0c             	sub    $0xc,%esp
+ 838:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 83b:	e8 3b fc ff ff       	call   47b <sbrk>
+  if(p == (char*)-1)
+ 840:	83 c4 10             	add    $0x10,%esp
+ 843:	83 f8 ff             	cmp    $0xffffffff,%eax
+ 846:	74 1b                	je     863 <malloc+0x93>
+  hp->s.size = nu;
+ 848:	89 58 04             	mov    %ebx,0x4(%eax)
+  free((void*)(hp + 1));
+ 84b:	83 ec 0c             	sub    $0xc,%esp
+ 84e:	83 c0 08             	add    $0x8,%eax
+ 851:	50                   	push   %eax
+ 852:	e8 e9 fe ff ff       	call   740 <free>
+  return freep;
+ 857:	a1 00 0c 00 00       	mov    0xc00,%eax
+      if((p = morecore(nunits)) == 0)
+ 85c:	83 c4 10             	add    $0x10,%esp
+ 85f:	85 c0                	test   %eax,%eax
+ 861:	75 bd                	jne    820 <malloc+0x50>
+        return 0;
+  }
+}
+ 863:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return 0;
+ 866:	31 c0                	xor    %eax,%eax
+}
+ 868:	5b                   	pop    %ebx
+ 869:	5e                   	pop    %esi
+ 86a:	5f                   	pop    %edi
+ 86b:	5d                   	pop    %ebp
+ 86c:	c3                   	ret    
+    if(p->s.size >= nunits){
+ 86d:	89 c2                	mov    %eax,%edx
+ 86f:	89 f8                	mov    %edi,%eax
+ 871:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+ 878:	39 ce                	cmp    %ecx,%esi
+ 87a:	74 54                	je     8d0 <malloc+0x100>
+        p->s.size -= nunits;
+ 87c:	29 f1                	sub    %esi,%ecx
+ 87e:	89 4a 04             	mov    %ecx,0x4(%edx)
+        p += p->s.size;
+ 881:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
+        p->s.size = nunits;
+ 884:	89 72 04             	mov    %esi,0x4(%edx)
+      freep = prevp;
+ 887:	a3 00 0c 00 00       	mov    %eax,0xc00
+}
+ 88c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return (void*)(p + 1);
+ 88f:	8d 42 08             	lea    0x8(%edx),%eax
+}
+ 892:	5b                   	pop    %ebx
+ 893:	5e                   	pop    %esi
+ 894:	5f                   	pop    %edi
+ 895:	5d                   	pop    %ebp
+ 896:	c3                   	ret    
+ 897:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 89e:	66 90                	xchg   %ax,%ax
+    base.s.ptr = freep = prevp = &base;
+ 8a0:	c7 05 00 0c 00 00 04 	movl   $0xc04,0xc00
+ 8a7:	0c 00 00 
+    base.s.size = 0;
+ 8aa:	bf 04 0c 00 00       	mov    $0xc04,%edi
+    base.s.ptr = freep = prevp = &base;
+ 8af:	c7 05 04 0c 00 00 04 	movl   $0xc04,0xc04
+ 8b6:	0c 00 00 
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 8b9:	89 f8                	mov    %edi,%eax
+    base.s.size = 0;
+ 8bb:	c7 05 08 0c 00 00 00 	movl   $0x0,0xc08
+ 8c2:	00 00 00 
+    if(p->s.size >= nunits){
+ 8c5:	e9 36 ff ff ff       	jmp    800 <malloc+0x30>
+ 8ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        prevp->s.ptr = p->s.ptr;
+ 8d0:	8b 0a                	mov    (%edx),%ecx
+ 8d2:	89 08                	mov    %ecx,(%eax)
+ 8d4:	eb b1                	jmp    887 <malloc+0xb7>
diff -ruN xv6-public/wc.d copy-xv6/wc.d
--- xv6-public/wc.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/wc.d	2022-09-05 23:26:12.536781081 +0530
@@ -0,0 +1 @@
+wc.o: wc.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/wc.o and copy-xv6/wc.o differ
diff -ruN xv6-public/wc.sym copy-xv6/wc.sym
--- xv6-public/wc.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/wc.sym	2022-09-05 23:26:12.548781080 +0530
@@ -0,0 +1,63 @@
+00000000 .text
+000008d8 .rodata
+0000092c .eh_frame
+00000c00 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 wc.c
+00000000 ulib.c
+00000000 printf.c
+000004c0 printint
+00000918 digits.1097
+00000000 umalloc.c
+00000c00 freep
+00000c04 base
+00000190 strcpy
+00000570 printf
+000004ab thread_exit
+000003c0 memmove
+0000043b mknod
+000002b0 gets
+00000473 getpid
+000007d0 malloc
+00000483 sleep
+00000403 pipe
+00000413 write
+0000044b fstat
+00000423 kill
+00000463 chdir
+0000042b exec
+000003fb wait
+0000040b read
+00000443 unlink
+000000a0 wc
+000003eb fork
+0000047b sbrk
+0000048b uptime
+00000c00 __bss_start
+00000250 memset
+00000000 main
+000001c0 strcmp
+0000046b dup
+00000c20 buf
+00000330 stat
+00000c00 _edata
+00000e20 _end
+00000453 link
+000003f3 exit
+00000380 atoi
+00000493 draw
+00000210 strlen
+00000433 open
+00000270 strchr
+0000049b thread_create
+0000045b mkdir
+0000041b close
+000004a3 thread_join
+00000740 free
Binary files xv6-public/xv6.img and copy-xv6/xv6.img differ
Binary files xv6-public/_zombie and copy-xv6/_zombie differ
diff -ruN xv6-public/zombie.asm copy-xv6/zombie.asm
--- xv6-public/zombie.asm	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/zombie.asm	2022-09-05 23:26:12.572781080 +0530
@@ -0,0 +1,1190 @@
+
+_zombie:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(void)
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	51                   	push   %ecx
+  12:	83 ec 04             	sub    $0x4,%esp
+  if(fork() > 0)
+  15:	e8 71 02 00 00       	call   28b <fork>
+  1a:	85 c0                	test   %eax,%eax
+  1c:	7e 0d                	jle    2b <main+0x2b>
+    sleep(5);  // Let child exit before parent.
+  1e:	83 ec 0c             	sub    $0xc,%esp
+  21:	6a 05                	push   $0x5
+  23:	e8 fb 02 00 00       	call   323 <sleep>
+  28:	83 c4 10             	add    $0x10,%esp
+  exit();
+  2b:	e8 63 02 00 00       	call   293 <exit>
+
+00000030 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+  30:	f3 0f 1e fb          	endbr32 
+  34:	55                   	push   %ebp
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  35:	31 c0                	xor    %eax,%eax
+{
+  37:	89 e5                	mov    %esp,%ebp
+  39:	53                   	push   %ebx
+  3a:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  3d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  while((*s++ = *t++) != 0)
+  40:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
+  44:	88 14 01             	mov    %dl,(%ecx,%eax,1)
+  47:	83 c0 01             	add    $0x1,%eax
+  4a:	84 d2                	test   %dl,%dl
+  4c:	75 f2                	jne    40 <strcpy+0x10>
+    ;
+  return os;
+}
+  4e:	89 c8                	mov    %ecx,%eax
+  50:	5b                   	pop    %ebx
+  51:	5d                   	pop    %ebp
+  52:	c3                   	ret    
+  53:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000060 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  60:	f3 0f 1e fb          	endbr32 
+  64:	55                   	push   %ebp
+  65:	89 e5                	mov    %esp,%ebp
+  67:	53                   	push   %ebx
+  68:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  6b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  while(*p && *p == *q)
+  6e:	0f b6 01             	movzbl (%ecx),%eax
+  71:	0f b6 1a             	movzbl (%edx),%ebx
+  74:	84 c0                	test   %al,%al
+  76:	75 19                	jne    91 <strcmp+0x31>
+  78:	eb 26                	jmp    a0 <strcmp+0x40>
+  7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  80:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
+    p++, q++;
+  84:	83 c1 01             	add    $0x1,%ecx
+  87:	83 c2 01             	add    $0x1,%edx
+  while(*p && *p == *q)
+  8a:	0f b6 1a             	movzbl (%edx),%ebx
+  8d:	84 c0                	test   %al,%al
+  8f:	74 0f                	je     a0 <strcmp+0x40>
+  91:	38 d8                	cmp    %bl,%al
+  93:	74 eb                	je     80 <strcmp+0x20>
+  return (uchar)*p - (uchar)*q;
+  95:	29 d8                	sub    %ebx,%eax
+}
+  97:	5b                   	pop    %ebx
+  98:	5d                   	pop    %ebp
+  99:	c3                   	ret    
+  9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  a0:	31 c0                	xor    %eax,%eax
+  return (uchar)*p - (uchar)*q;
+  a2:	29 d8                	sub    %ebx,%eax
+}
+  a4:	5b                   	pop    %ebx
+  a5:	5d                   	pop    %ebp
+  a6:	c3                   	ret    
+  a7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  ae:	66 90                	xchg   %ax,%ax
+
+000000b0 <strlen>:
+
+uint
+strlen(const char *s)
+{
+  b0:	f3 0f 1e fb          	endbr32 
+  b4:	55                   	push   %ebp
+  b5:	89 e5                	mov    %esp,%ebp
+  b7:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  for(n = 0; s[n]; n++)
+  ba:	80 3a 00             	cmpb   $0x0,(%edx)
+  bd:	74 21                	je     e0 <strlen+0x30>
+  bf:	31 c0                	xor    %eax,%eax
+  c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  c8:	83 c0 01             	add    $0x1,%eax
+  cb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
+  cf:	89 c1                	mov    %eax,%ecx
+  d1:	75 f5                	jne    c8 <strlen+0x18>
+    ;
+  return n;
+}
+  d3:	89 c8                	mov    %ecx,%eax
+  d5:	5d                   	pop    %ebp
+  d6:	c3                   	ret    
+  d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  de:	66 90                	xchg   %ax,%ax
+  for(n = 0; s[n]; n++)
+  e0:	31 c9                	xor    %ecx,%ecx
+}
+  e2:	5d                   	pop    %ebp
+  e3:	89 c8                	mov    %ecx,%eax
+  e5:	c3                   	ret    
+  e6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  ed:	8d 76 00             	lea    0x0(%esi),%esi
+
+000000f0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+  f0:	f3 0f 1e fb          	endbr32 
+  f4:	55                   	push   %ebp
+  f5:	89 e5                	mov    %esp,%ebp
+  f7:	57                   	push   %edi
+  f8:	8b 55 08             	mov    0x8(%ebp),%edx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+  fb:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  fe:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 101:	89 d7                	mov    %edx,%edi
+ 103:	fc                   	cld    
+ 104:	f3 aa                	rep stos %al,%es:(%edi)
+  stosb(dst, c, n);
+  return dst;
+}
+ 106:	89 d0                	mov    %edx,%eax
+ 108:	5f                   	pop    %edi
+ 109:	5d                   	pop    %ebp
+ 10a:	c3                   	ret    
+ 10b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 10f:	90                   	nop
+
+00000110 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 110:	f3 0f 1e fb          	endbr32 
+ 114:	55                   	push   %ebp
+ 115:	89 e5                	mov    %esp,%ebp
+ 117:	8b 45 08             	mov    0x8(%ebp),%eax
+ 11a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
+  for(; *s; s++)
+ 11e:	0f b6 10             	movzbl (%eax),%edx
+ 121:	84 d2                	test   %dl,%dl
+ 123:	75 16                	jne    13b <strchr+0x2b>
+ 125:	eb 21                	jmp    148 <strchr+0x38>
+ 127:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 12e:	66 90                	xchg   %ax,%ax
+ 130:	0f b6 50 01          	movzbl 0x1(%eax),%edx
+ 134:	83 c0 01             	add    $0x1,%eax
+ 137:	84 d2                	test   %dl,%dl
+ 139:	74 0d                	je     148 <strchr+0x38>
+    if(*s == c)
+ 13b:	38 d1                	cmp    %dl,%cl
+ 13d:	75 f1                	jne    130 <strchr+0x20>
+      return (char*)s;
+  return 0;
+}
+ 13f:	5d                   	pop    %ebp
+ 140:	c3                   	ret    
+ 141:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  return 0;
+ 148:	31 c0                	xor    %eax,%eax
+}
+ 14a:	5d                   	pop    %ebp
+ 14b:	c3                   	ret    
+ 14c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000150 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 150:	f3 0f 1e fb          	endbr32 
+ 154:	55                   	push   %ebp
+ 155:	89 e5                	mov    %esp,%ebp
+ 157:	57                   	push   %edi
+ 158:	56                   	push   %esi
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 159:	31 f6                	xor    %esi,%esi
+{
+ 15b:	53                   	push   %ebx
+ 15c:	89 f3                	mov    %esi,%ebx
+ 15e:	83 ec 1c             	sub    $0x1c,%esp
+ 161:	8b 7d 08             	mov    0x8(%ebp),%edi
+  for(i=0; i+1 < max; ){
+ 164:	eb 33                	jmp    199 <gets+0x49>
+ 166:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 16d:	8d 76 00             	lea    0x0(%esi),%esi
+    cc = read(0, &c, 1);
+ 170:	83 ec 04             	sub    $0x4,%esp
+ 173:	8d 45 e7             	lea    -0x19(%ebp),%eax
+ 176:	6a 01                	push   $0x1
+ 178:	50                   	push   %eax
+ 179:	6a 00                	push   $0x0
+ 17b:	e8 2b 01 00 00       	call   2ab <read>
+    if(cc < 1)
+ 180:	83 c4 10             	add    $0x10,%esp
+ 183:	85 c0                	test   %eax,%eax
+ 185:	7e 1c                	jle    1a3 <gets+0x53>
+      break;
+    buf[i++] = c;
+ 187:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+ 18b:	83 c7 01             	add    $0x1,%edi
+ 18e:	88 47 ff             	mov    %al,-0x1(%edi)
+    if(c == '\n' || c == '\r')
+ 191:	3c 0a                	cmp    $0xa,%al
+ 193:	74 23                	je     1b8 <gets+0x68>
+ 195:	3c 0d                	cmp    $0xd,%al
+ 197:	74 1f                	je     1b8 <gets+0x68>
+  for(i=0; i+1 < max; ){
+ 199:	83 c3 01             	add    $0x1,%ebx
+ 19c:	89 fe                	mov    %edi,%esi
+ 19e:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
+ 1a1:	7c cd                	jl     170 <gets+0x20>
+ 1a3:	89 f3                	mov    %esi,%ebx
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+ 1a5:	8b 45 08             	mov    0x8(%ebp),%eax
+  buf[i] = '\0';
+ 1a8:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 1ab:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 1ae:	5b                   	pop    %ebx
+ 1af:	5e                   	pop    %esi
+ 1b0:	5f                   	pop    %edi
+ 1b1:	5d                   	pop    %ebp
+ 1b2:	c3                   	ret    
+ 1b3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 1b7:	90                   	nop
+ 1b8:	8b 75 08             	mov    0x8(%ebp),%esi
+ 1bb:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1be:	01 de                	add    %ebx,%esi
+ 1c0:	89 f3                	mov    %esi,%ebx
+  buf[i] = '\0';
+ 1c2:	c6 03 00             	movb   $0x0,(%ebx)
+}
+ 1c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 1c8:	5b                   	pop    %ebx
+ 1c9:	5e                   	pop    %esi
+ 1ca:	5f                   	pop    %edi
+ 1cb:	5d                   	pop    %ebp
+ 1cc:	c3                   	ret    
+ 1cd:	8d 76 00             	lea    0x0(%esi),%esi
+
+000001d0 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 1d0:	f3 0f 1e fb          	endbr32 
+ 1d4:	55                   	push   %ebp
+ 1d5:	89 e5                	mov    %esp,%ebp
+ 1d7:	56                   	push   %esi
+ 1d8:	53                   	push   %ebx
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 1d9:	83 ec 08             	sub    $0x8,%esp
+ 1dc:	6a 00                	push   $0x0
+ 1de:	ff 75 08             	pushl  0x8(%ebp)
+ 1e1:	e8 ed 00 00 00       	call   2d3 <open>
+  if(fd < 0)
+ 1e6:	83 c4 10             	add    $0x10,%esp
+ 1e9:	85 c0                	test   %eax,%eax
+ 1eb:	78 2b                	js     218 <stat+0x48>
+    return -1;
+  r = fstat(fd, st);
+ 1ed:	83 ec 08             	sub    $0x8,%esp
+ 1f0:	ff 75 0c             	pushl  0xc(%ebp)
+ 1f3:	89 c3                	mov    %eax,%ebx
+ 1f5:	50                   	push   %eax
+ 1f6:	e8 f0 00 00 00       	call   2eb <fstat>
+  close(fd);
+ 1fb:	89 1c 24             	mov    %ebx,(%esp)
+  r = fstat(fd, st);
+ 1fe:	89 c6                	mov    %eax,%esi
+  close(fd);
+ 200:	e8 b6 00 00 00       	call   2bb <close>
+  return r;
+ 205:	83 c4 10             	add    $0x10,%esp
+}
+ 208:	8d 65 f8             	lea    -0x8(%ebp),%esp
+ 20b:	89 f0                	mov    %esi,%eax
+ 20d:	5b                   	pop    %ebx
+ 20e:	5e                   	pop    %esi
+ 20f:	5d                   	pop    %ebp
+ 210:	c3                   	ret    
+ 211:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+    return -1;
+ 218:	be ff ff ff ff       	mov    $0xffffffff,%esi
+ 21d:	eb e9                	jmp    208 <stat+0x38>
+ 21f:	90                   	nop
+
+00000220 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 220:	f3 0f 1e fb          	endbr32 
+ 224:	55                   	push   %ebp
+ 225:	89 e5                	mov    %esp,%ebp
+ 227:	53                   	push   %ebx
+ 228:	8b 55 08             	mov    0x8(%ebp),%edx
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 22b:	0f be 02             	movsbl (%edx),%eax
+ 22e:	8d 48 d0             	lea    -0x30(%eax),%ecx
+ 231:	80 f9 09             	cmp    $0x9,%cl
+  n = 0;
+ 234:	b9 00 00 00 00       	mov    $0x0,%ecx
+  while('0' <= *s && *s <= '9')
+ 239:	77 1a                	ja     255 <atoi+0x35>
+ 23b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 23f:	90                   	nop
+    n = n*10 + *s++ - '0';
+ 240:	83 c2 01             	add    $0x1,%edx
+ 243:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
+ 246:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
+  while('0' <= *s && *s <= '9')
+ 24a:	0f be 02             	movsbl (%edx),%eax
+ 24d:	8d 58 d0             	lea    -0x30(%eax),%ebx
+ 250:	80 fb 09             	cmp    $0x9,%bl
+ 253:	76 eb                	jbe    240 <atoi+0x20>
+  return n;
+}
+ 255:	89 c8                	mov    %ecx,%eax
+ 257:	5b                   	pop    %ebx
+ 258:	5d                   	pop    %ebp
+ 259:	c3                   	ret    
+ 25a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+
+00000260 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 260:	f3 0f 1e fb          	endbr32 
+ 264:	55                   	push   %ebp
+ 265:	89 e5                	mov    %esp,%ebp
+ 267:	57                   	push   %edi
+ 268:	8b 45 10             	mov    0x10(%ebp),%eax
+ 26b:	8b 55 08             	mov    0x8(%ebp),%edx
+ 26e:	56                   	push   %esi
+ 26f:	8b 75 0c             	mov    0xc(%ebp),%esi
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+ 272:	85 c0                	test   %eax,%eax
+ 274:	7e 0f                	jle    285 <memmove+0x25>
+ 276:	01 d0                	add    %edx,%eax
+  dst = vdst;
+ 278:	89 d7                	mov    %edx,%edi
+ 27a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+    *dst++ = *src++;
+ 280:	a4                   	movsb  %ds:(%esi),%es:(%edi)
+  while(n-- > 0)
+ 281:	39 f8                	cmp    %edi,%eax
+ 283:	75 fb                	jne    280 <memmove+0x20>
+  return vdst;
+}
+ 285:	5e                   	pop    %esi
+ 286:	89 d0                	mov    %edx,%eax
+ 288:	5f                   	pop    %edi
+ 289:	5d                   	pop    %ebp
+ 28a:	c3                   	ret    
+
+0000028b <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 28b:	b8 01 00 00 00       	mov    $0x1,%eax
+ 290:	cd 40                	int    $0x40
+ 292:	c3                   	ret    
+
+00000293 <exit>:
+SYSCALL(exit)
+ 293:	b8 02 00 00 00       	mov    $0x2,%eax
+ 298:	cd 40                	int    $0x40
+ 29a:	c3                   	ret    
+
+0000029b <wait>:
+SYSCALL(wait)
+ 29b:	b8 03 00 00 00       	mov    $0x3,%eax
+ 2a0:	cd 40                	int    $0x40
+ 2a2:	c3                   	ret    
+
+000002a3 <pipe>:
+SYSCALL(pipe)
+ 2a3:	b8 04 00 00 00       	mov    $0x4,%eax
+ 2a8:	cd 40                	int    $0x40
+ 2aa:	c3                   	ret    
+
+000002ab <read>:
+SYSCALL(read)
+ 2ab:	b8 05 00 00 00       	mov    $0x5,%eax
+ 2b0:	cd 40                	int    $0x40
+ 2b2:	c3                   	ret    
+
+000002b3 <write>:
+SYSCALL(write)
+ 2b3:	b8 10 00 00 00       	mov    $0x10,%eax
+ 2b8:	cd 40                	int    $0x40
+ 2ba:	c3                   	ret    
+
+000002bb <close>:
+SYSCALL(close)
+ 2bb:	b8 15 00 00 00       	mov    $0x15,%eax
+ 2c0:	cd 40                	int    $0x40
+ 2c2:	c3                   	ret    
+
+000002c3 <kill>:
+SYSCALL(kill)
+ 2c3:	b8 06 00 00 00       	mov    $0x6,%eax
+ 2c8:	cd 40                	int    $0x40
+ 2ca:	c3                   	ret    
+
+000002cb <exec>:
+SYSCALL(exec)
+ 2cb:	b8 07 00 00 00       	mov    $0x7,%eax
+ 2d0:	cd 40                	int    $0x40
+ 2d2:	c3                   	ret    
+
+000002d3 <open>:
+SYSCALL(open)
+ 2d3:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 2d8:	cd 40                	int    $0x40
+ 2da:	c3                   	ret    
+
+000002db <mknod>:
+SYSCALL(mknod)
+ 2db:	b8 11 00 00 00       	mov    $0x11,%eax
+ 2e0:	cd 40                	int    $0x40
+ 2e2:	c3                   	ret    
+
+000002e3 <unlink>:
+SYSCALL(unlink)
+ 2e3:	b8 12 00 00 00       	mov    $0x12,%eax
+ 2e8:	cd 40                	int    $0x40
+ 2ea:	c3                   	ret    
+
+000002eb <fstat>:
+SYSCALL(fstat)
+ 2eb:	b8 08 00 00 00       	mov    $0x8,%eax
+ 2f0:	cd 40                	int    $0x40
+ 2f2:	c3                   	ret    
+
+000002f3 <link>:
+SYSCALL(link)
+ 2f3:	b8 13 00 00 00       	mov    $0x13,%eax
+ 2f8:	cd 40                	int    $0x40
+ 2fa:	c3                   	ret    
+
+000002fb <mkdir>:
+SYSCALL(mkdir)
+ 2fb:	b8 14 00 00 00       	mov    $0x14,%eax
+ 300:	cd 40                	int    $0x40
+ 302:	c3                   	ret    
+
+00000303 <chdir>:
+SYSCALL(chdir)
+ 303:	b8 09 00 00 00       	mov    $0x9,%eax
+ 308:	cd 40                	int    $0x40
+ 30a:	c3                   	ret    
+
+0000030b <dup>:
+SYSCALL(dup)
+ 30b:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 310:	cd 40                	int    $0x40
+ 312:	c3                   	ret    
+
+00000313 <getpid>:
+SYSCALL(getpid)
+ 313:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 318:	cd 40                	int    $0x40
+ 31a:	c3                   	ret    
+
+0000031b <sbrk>:
+SYSCALL(sbrk)
+ 31b:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 320:	cd 40                	int    $0x40
+ 322:	c3                   	ret    
+
+00000323 <sleep>:
+SYSCALL(sleep)
+ 323:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 328:	cd 40                	int    $0x40
+ 32a:	c3                   	ret    
+
+0000032b <uptime>:
+SYSCALL(uptime)
+ 32b:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 330:	cd 40                	int    $0x40
+ 332:	c3                   	ret    
+
+00000333 <draw>:
+SYSCALL(draw)
+ 333:	b8 16 00 00 00       	mov    $0x16,%eax
+ 338:	cd 40                	int    $0x40
+ 33a:	c3                   	ret    
+
+0000033b <thread_create>:
+
+SYSCALL(thread_create)
+ 33b:	b8 17 00 00 00       	mov    $0x17,%eax
+ 340:	cd 40                	int    $0x40
+ 342:	c3                   	ret    
+
+00000343 <thread_join>:
+SYSCALL(thread_join)
+ 343:	b8 18 00 00 00       	mov    $0x18,%eax
+ 348:	cd 40                	int    $0x40
+ 34a:	c3                   	ret    
+
+0000034b <thread_exit>:
+SYSCALL(thread_exit)
+ 34b:	b8 19 00 00 00       	mov    $0x19,%eax
+ 350:	cd 40                	int    $0x40
+ 352:	c3                   	ret    
+ 353:	66 90                	xchg   %ax,%ax
+ 355:	66 90                	xchg   %ax,%ax
+ 357:	66 90                	xchg   %ax,%ax
+ 359:	66 90                	xchg   %ax,%ax
+ 35b:	66 90                	xchg   %ax,%ax
+ 35d:	66 90                	xchg   %ax,%ax
+ 35f:	90                   	nop
+
+00000360 <printint>:
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 360:	55                   	push   %ebp
+ 361:	89 e5                	mov    %esp,%ebp
+ 363:	57                   	push   %edi
+ 364:	56                   	push   %esi
+ 365:	53                   	push   %ebx
+ 366:	83 ec 3c             	sub    $0x3c,%esp
+ 369:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+ 36c:	89 d1                	mov    %edx,%ecx
+{
+ 36e:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  if(sgn && xx < 0){
+ 371:	85 d2                	test   %edx,%edx
+ 373:	0f 89 7f 00 00 00    	jns    3f8 <printint+0x98>
+ 379:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
+ 37d:	74 79                	je     3f8 <printint+0x98>
+    neg = 1;
+ 37f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+    x = -xx;
+ 386:	f7 d9                	neg    %ecx
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 388:	31 db                	xor    %ebx,%ebx
+ 38a:	8d 75 d7             	lea    -0x29(%ebp),%esi
+ 38d:	8d 76 00             	lea    0x0(%esi),%esi
+  do{
+    buf[i++] = digits[x % base];
+ 390:	89 c8                	mov    %ecx,%eax
+ 392:	31 d2                	xor    %edx,%edx
+ 394:	89 cf                	mov    %ecx,%edi
+ 396:	f7 75 c4             	divl   -0x3c(%ebp)
+ 399:	0f b6 92 80 07 00 00 	movzbl 0x780(%edx),%edx
+ 3a0:	89 45 c0             	mov    %eax,-0x40(%ebp)
+ 3a3:	89 d8                	mov    %ebx,%eax
+ 3a5:	8d 5b 01             	lea    0x1(%ebx),%ebx
+  }while((x /= base) != 0);
+ 3a8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+    buf[i++] = digits[x % base];
+ 3ab:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
+  }while((x /= base) != 0);
+ 3ae:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
+ 3b1:	76 dd                	jbe    390 <printint+0x30>
+  if(neg)
+ 3b3:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+ 3b6:	85 c9                	test   %ecx,%ecx
+ 3b8:	74 0c                	je     3c6 <printint+0x66>
+    buf[i++] = '-';
+ 3ba:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)
+    buf[i++] = digits[x % base];
+ 3bf:	89 d8                	mov    %ebx,%eax
+    buf[i++] = '-';
+ 3c1:	ba 2d 00 00 00       	mov    $0x2d,%edx
+
+  while(--i >= 0)
+ 3c6:	8b 7d b8             	mov    -0x48(%ebp),%edi
+ 3c9:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx
+ 3cd:	eb 07                	jmp    3d6 <printint+0x76>
+ 3cf:	90                   	nop
+ 3d0:	0f b6 13             	movzbl (%ebx),%edx
+ 3d3:	83 eb 01             	sub    $0x1,%ebx
+  write(fd, &c, 1);
+ 3d6:	83 ec 04             	sub    $0x4,%esp
+ 3d9:	88 55 d7             	mov    %dl,-0x29(%ebp)
+ 3dc:	6a 01                	push   $0x1
+ 3de:	56                   	push   %esi
+ 3df:	57                   	push   %edi
+ 3e0:	e8 ce fe ff ff       	call   2b3 <write>
+  while(--i >= 0)
+ 3e5:	83 c4 10             	add    $0x10,%esp
+ 3e8:	39 de                	cmp    %ebx,%esi
+ 3ea:	75 e4                	jne    3d0 <printint+0x70>
+    putc(fd, buf[i]);
+}
+ 3ec:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 3ef:	5b                   	pop    %ebx
+ 3f0:	5e                   	pop    %esi
+ 3f1:	5f                   	pop    %edi
+ 3f2:	5d                   	pop    %ebp
+ 3f3:	c3                   	ret    
+ 3f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  neg = 0;
+ 3f8:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
+ 3ff:	eb 87                	jmp    388 <printint+0x28>
+ 401:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 408:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 40f:	90                   	nop
+
+00000410 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 410:	f3 0f 1e fb          	endbr32 
+ 414:	55                   	push   %ebp
+ 415:	89 e5                	mov    %esp,%ebp
+ 417:	57                   	push   %edi
+ 418:	56                   	push   %esi
+ 419:	53                   	push   %ebx
+ 41a:	83 ec 2c             	sub    $0x2c,%esp
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+ 41d:	8b 75 0c             	mov    0xc(%ebp),%esi
+ 420:	0f b6 1e             	movzbl (%esi),%ebx
+ 423:	84 db                	test   %bl,%bl
+ 425:	0f 84 b4 00 00 00    	je     4df <printf+0xcf>
+  ap = (uint*)(void*)&fmt + 1;
+ 42b:	8d 45 10             	lea    0x10(%ebp),%eax
+ 42e:	83 c6 01             	add    $0x1,%esi
+  write(fd, &c, 1);
+ 431:	8d 7d e7             	lea    -0x19(%ebp),%edi
+  state = 0;
+ 434:	31 d2                	xor    %edx,%edx
+  ap = (uint*)(void*)&fmt + 1;
+ 436:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 439:	eb 33                	jmp    46e <printf+0x5e>
+ 43b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 43f:	90                   	nop
+ 440:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+ 443:	ba 25 00 00 00       	mov    $0x25,%edx
+      if(c == '%'){
+ 448:	83 f8 25             	cmp    $0x25,%eax
+ 44b:	74 17                	je     464 <printf+0x54>
+  write(fd, &c, 1);
+ 44d:	83 ec 04             	sub    $0x4,%esp
+ 450:	88 5d e7             	mov    %bl,-0x19(%ebp)
+ 453:	6a 01                	push   $0x1
+ 455:	57                   	push   %edi
+ 456:	ff 75 08             	pushl  0x8(%ebp)
+ 459:	e8 55 fe ff ff       	call   2b3 <write>
+ 45e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+      } else {
+        putc(fd, c);
+ 461:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; fmt[i]; i++){
+ 464:	0f b6 1e             	movzbl (%esi),%ebx
+ 467:	83 c6 01             	add    $0x1,%esi
+ 46a:	84 db                	test   %bl,%bl
+ 46c:	74 71                	je     4df <printf+0xcf>
+    c = fmt[i] & 0xff;
+ 46e:	0f be cb             	movsbl %bl,%ecx
+ 471:	0f b6 c3             	movzbl %bl,%eax
+    if(state == 0){
+ 474:	85 d2                	test   %edx,%edx
+ 476:	74 c8                	je     440 <printf+0x30>
+      }
+    } else if(state == '%'){
+ 478:	83 fa 25             	cmp    $0x25,%edx
+ 47b:	75 e7                	jne    464 <printf+0x54>
+      if(c == 'd'){
+ 47d:	83 f8 64             	cmp    $0x64,%eax
+ 480:	0f 84 9a 00 00 00    	je     520 <printf+0x110>
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+ 486:	81 e1 f7 00 00 00    	and    $0xf7,%ecx
+ 48c:	83 f9 70             	cmp    $0x70,%ecx
+ 48f:	74 5f                	je     4f0 <printf+0xe0>
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+ 491:	83 f8 73             	cmp    $0x73,%eax
+ 494:	0f 84 d6 00 00 00    	je     570 <printf+0x160>
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+ 49a:	83 f8 63             	cmp    $0x63,%eax
+ 49d:	0f 84 8d 00 00 00    	je     530 <printf+0x120>
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+ 4a3:	83 f8 25             	cmp    $0x25,%eax
+ 4a6:	0f 84 b4 00 00 00    	je     560 <printf+0x150>
+  write(fd, &c, 1);
+ 4ac:	83 ec 04             	sub    $0x4,%esp
+ 4af:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
+ 4b3:	6a 01                	push   $0x1
+ 4b5:	57                   	push   %edi
+ 4b6:	ff 75 08             	pushl  0x8(%ebp)
+ 4b9:	e8 f5 fd ff ff       	call   2b3 <write>
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+ 4be:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 4c1:	83 c4 0c             	add    $0xc,%esp
+ 4c4:	6a 01                	push   $0x1
+ 4c6:	83 c6 01             	add    $0x1,%esi
+ 4c9:	57                   	push   %edi
+ 4ca:	ff 75 08             	pushl  0x8(%ebp)
+ 4cd:	e8 e1 fd ff ff       	call   2b3 <write>
+  for(i = 0; fmt[i]; i++){
+ 4d2:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx
+        putc(fd, c);
+ 4d6:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 4d9:	31 d2                	xor    %edx,%edx
+  for(i = 0; fmt[i]; i++){
+ 4db:	84 db                	test   %bl,%bl
+ 4dd:	75 8f                	jne    46e <printf+0x5e>
+    }
+  }
+}
+ 4df:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 4e2:	5b                   	pop    %ebx
+ 4e3:	5e                   	pop    %esi
+ 4e4:	5f                   	pop    %edi
+ 4e5:	5d                   	pop    %ebp
+ 4e6:	c3                   	ret    
+ 4e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 4ee:	66 90                	xchg   %ax,%ax
+        printint(fd, *ap, 16, 0);
+ 4f0:	83 ec 0c             	sub    $0xc,%esp
+ 4f3:	b9 10 00 00 00       	mov    $0x10,%ecx
+ 4f8:	6a 00                	push   $0x0
+ 4fa:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+ 4fd:	8b 45 08             	mov    0x8(%ebp),%eax
+ 500:	8b 13                	mov    (%ebx),%edx
+ 502:	e8 59 fe ff ff       	call   360 <printint>
+        ap++;
+ 507:	89 d8                	mov    %ebx,%eax
+ 509:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 50c:	31 d2                	xor    %edx,%edx
+        ap++;
+ 50e:	83 c0 04             	add    $0x4,%eax
+ 511:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ 514:	e9 4b ff ff ff       	jmp    464 <printf+0x54>
+ 519:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+        printint(fd, *ap, 10, 1);
+ 520:	83 ec 0c             	sub    $0xc,%esp
+ 523:	b9 0a 00 00 00       	mov    $0xa,%ecx
+ 528:	6a 01                	push   $0x1
+ 52a:	eb ce                	jmp    4fa <printf+0xea>
+ 52c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+        putc(fd, *ap);
+ 530:	8b 5d d0             	mov    -0x30(%ebp),%ebx
+  write(fd, &c, 1);
+ 533:	83 ec 04             	sub    $0x4,%esp
+        putc(fd, *ap);
+ 536:	8b 03                	mov    (%ebx),%eax
+  write(fd, &c, 1);
+ 538:	6a 01                	push   $0x1
+        ap++;
+ 53a:	83 c3 04             	add    $0x4,%ebx
+  write(fd, &c, 1);
+ 53d:	57                   	push   %edi
+ 53e:	ff 75 08             	pushl  0x8(%ebp)
+        putc(fd, *ap);
+ 541:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 544:	e8 6a fd ff ff       	call   2b3 <write>
+        ap++;
+ 549:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+ 54c:	83 c4 10             	add    $0x10,%esp
+      state = 0;
+ 54f:	31 d2                	xor    %edx,%edx
+ 551:	e9 0e ff ff ff       	jmp    464 <printf+0x54>
+ 556:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 55d:	8d 76 00             	lea    0x0(%esi),%esi
+        putc(fd, c);
+ 560:	88 5d e7             	mov    %bl,-0x19(%ebp)
+  write(fd, &c, 1);
+ 563:	83 ec 04             	sub    $0x4,%esp
+ 566:	e9 59 ff ff ff       	jmp    4c4 <printf+0xb4>
+ 56b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 56f:	90                   	nop
+        s = (char*)*ap;
+ 570:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 573:	8b 18                	mov    (%eax),%ebx
+        ap++;
+ 575:	83 c0 04             	add    $0x4,%eax
+ 578:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        if(s == 0)
+ 57b:	85 db                	test   %ebx,%ebx
+ 57d:	74 17                	je     596 <printf+0x186>
+        while(*s != 0){
+ 57f:	0f b6 03             	movzbl (%ebx),%eax
+      state = 0;
+ 582:	31 d2                	xor    %edx,%edx
+        while(*s != 0){
+ 584:	84 c0                	test   %al,%al
+ 586:	0f 84 d8 fe ff ff    	je     464 <printf+0x54>
+ 58c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 58f:	89 de                	mov    %ebx,%esi
+ 591:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 594:	eb 1a                	jmp    5b0 <printf+0x1a0>
+          s = "(null)";
+ 596:	bb 78 07 00 00       	mov    $0x778,%ebx
+        while(*s != 0){
+ 59b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
+ 59e:	b8 28 00 00 00       	mov    $0x28,%eax
+ 5a3:	89 de                	mov    %ebx,%esi
+ 5a5:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 5a8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 5af:	90                   	nop
+  write(fd, &c, 1);
+ 5b0:	83 ec 04             	sub    $0x4,%esp
+          s++;
+ 5b3:	83 c6 01             	add    $0x1,%esi
+ 5b6:	88 45 e7             	mov    %al,-0x19(%ebp)
+  write(fd, &c, 1);
+ 5b9:	6a 01                	push   $0x1
+ 5bb:	57                   	push   %edi
+ 5bc:	53                   	push   %ebx
+ 5bd:	e8 f1 fc ff ff       	call   2b3 <write>
+        while(*s != 0){
+ 5c2:	0f b6 06             	movzbl (%esi),%eax
+ 5c5:	83 c4 10             	add    $0x10,%esp
+ 5c8:	84 c0                	test   %al,%al
+ 5ca:	75 e4                	jne    5b0 <printf+0x1a0>
+ 5cc:	8b 75 d4             	mov    -0x2c(%ebp),%esi
+      state = 0;
+ 5cf:	31 d2                	xor    %edx,%edx
+ 5d1:	e9 8e fe ff ff       	jmp    464 <printf+0x54>
+ 5d6:	66 90                	xchg   %ax,%ax
+ 5d8:	66 90                	xchg   %ax,%ax
+ 5da:	66 90                	xchg   %ax,%ax
+ 5dc:	66 90                	xchg   %ax,%ax
+ 5de:	66 90                	xchg   %ax,%ax
+
+000005e0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 5e0:	f3 0f 1e fb          	endbr32 
+ 5e4:	55                   	push   %ebp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 5e5:	a1 28 0a 00 00       	mov    0xa28,%eax
+{
+ 5ea:	89 e5                	mov    %esp,%ebp
+ 5ec:	57                   	push   %edi
+ 5ed:	56                   	push   %esi
+ 5ee:	53                   	push   %ebx
+ 5ef:	8b 5d 08             	mov    0x8(%ebp),%ebx
+ 5f2:	8b 10                	mov    (%eax),%edx
+  bp = (Header*)ap - 1;
+ 5f4:	8d 4b f8             	lea    -0x8(%ebx),%ecx
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 5f7:	39 c8                	cmp    %ecx,%eax
+ 5f9:	73 15                	jae    610 <free+0x30>
+ 5fb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 5ff:	90                   	nop
+ 600:	39 d1                	cmp    %edx,%ecx
+ 602:	72 14                	jb     618 <free+0x38>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 604:	39 d0                	cmp    %edx,%eax
+ 606:	73 10                	jae    618 <free+0x38>
+{
+ 608:	89 d0                	mov    %edx,%eax
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 60a:	8b 10                	mov    (%eax),%edx
+ 60c:	39 c8                	cmp    %ecx,%eax
+ 60e:	72 f0                	jb     600 <free+0x20>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 610:	39 d0                	cmp    %edx,%eax
+ 612:	72 f4                	jb     608 <free+0x28>
+ 614:	39 d1                	cmp    %edx,%ecx
+ 616:	73 f0                	jae    608 <free+0x28>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 618:	8b 73 fc             	mov    -0x4(%ebx),%esi
+ 61b:	8d 3c f1             	lea    (%ecx,%esi,8),%edi
+ 61e:	39 fa                	cmp    %edi,%edx
+ 620:	74 1e                	je     640 <free+0x60>
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+ 622:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 625:	8b 50 04             	mov    0x4(%eax),%edx
+ 628:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 62b:	39 f1                	cmp    %esi,%ecx
+ 62d:	74 28                	je     657 <free+0x77>
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+ 62f:	89 08                	mov    %ecx,(%eax)
+  freep = p;
+}
+ 631:	5b                   	pop    %ebx
+  freep = p;
+ 632:	a3 28 0a 00 00       	mov    %eax,0xa28
+}
+ 637:	5e                   	pop    %esi
+ 638:	5f                   	pop    %edi
+ 639:	5d                   	pop    %ebp
+ 63a:	c3                   	ret    
+ 63b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+ 63f:	90                   	nop
+    bp->s.size += p->s.ptr->s.size;
+ 640:	03 72 04             	add    0x4(%edx),%esi
+ 643:	89 73 fc             	mov    %esi,-0x4(%ebx)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 646:	8b 10                	mov    (%eax),%edx
+ 648:	8b 12                	mov    (%edx),%edx
+ 64a:	89 53 f8             	mov    %edx,-0x8(%ebx)
+  if(p + p->s.size == bp){
+ 64d:	8b 50 04             	mov    0x4(%eax),%edx
+ 650:	8d 34 d0             	lea    (%eax,%edx,8),%esi
+ 653:	39 f1                	cmp    %esi,%ecx
+ 655:	75 d8                	jne    62f <free+0x4f>
+    p->s.size += bp->s.size;
+ 657:	03 53 fc             	add    -0x4(%ebx),%edx
+  freep = p;
+ 65a:	a3 28 0a 00 00       	mov    %eax,0xa28
+    p->s.size += bp->s.size;
+ 65f:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 662:	8b 53 f8             	mov    -0x8(%ebx),%edx
+ 665:	89 10                	mov    %edx,(%eax)
+}
+ 667:	5b                   	pop    %ebx
+ 668:	5e                   	pop    %esi
+ 669:	5f                   	pop    %edi
+ 66a:	5d                   	pop    %ebp
+ 66b:	c3                   	ret    
+ 66c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+
+00000670 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 670:	f3 0f 1e fb          	endbr32 
+ 674:	55                   	push   %ebp
+ 675:	89 e5                	mov    %esp,%ebp
+ 677:	57                   	push   %edi
+ 678:	56                   	push   %esi
+ 679:	53                   	push   %ebx
+ 67a:	83 ec 1c             	sub    $0x1c,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 67d:	8b 45 08             	mov    0x8(%ebp),%eax
+  if((prevp = freep) == 0){
+ 680:	8b 3d 28 0a 00 00    	mov    0xa28,%edi
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 686:	8d 70 07             	lea    0x7(%eax),%esi
+ 689:	c1 ee 03             	shr    $0x3,%esi
+ 68c:	83 c6 01             	add    $0x1,%esi
+  if((prevp = freep) == 0){
+ 68f:	85 ff                	test   %edi,%edi
+ 691:	0f 84 a9 00 00 00    	je     740 <malloc+0xd0>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 697:	8b 07                	mov    (%edi),%eax
+    if(p->s.size >= nunits){
+ 699:	8b 48 04             	mov    0x4(%eax),%ecx
+ 69c:	39 f1                	cmp    %esi,%ecx
+ 69e:	73 6d                	jae    70d <malloc+0x9d>
+ 6a0:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
+ 6a6:	bb 00 10 00 00       	mov    $0x1000,%ebx
+ 6ab:	0f 43 de             	cmovae %esi,%ebx
+  p = sbrk(nu * sizeof(Header));
+ 6ae:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
+ 6b5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+ 6b8:	eb 17                	jmp    6d1 <malloc+0x61>
+ 6ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 6c0:	8b 10                	mov    (%eax),%edx
+    if(p->s.size >= nunits){
+ 6c2:	8b 4a 04             	mov    0x4(%edx),%ecx
+ 6c5:	39 f1                	cmp    %esi,%ecx
+ 6c7:	73 4f                	jae    718 <malloc+0xa8>
+ 6c9:	8b 3d 28 0a 00 00    	mov    0xa28,%edi
+ 6cf:	89 d0                	mov    %edx,%eax
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 6d1:	39 c7                	cmp    %eax,%edi
+ 6d3:	75 eb                	jne    6c0 <malloc+0x50>
+  p = sbrk(nu * sizeof(Header));
+ 6d5:	83 ec 0c             	sub    $0xc,%esp
+ 6d8:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 6db:	e8 3b fc ff ff       	call   31b <sbrk>
+  if(p == (char*)-1)
+ 6e0:	83 c4 10             	add    $0x10,%esp
+ 6e3:	83 f8 ff             	cmp    $0xffffffff,%eax
+ 6e6:	74 1b                	je     703 <malloc+0x93>
+  hp->s.size = nu;
+ 6e8:	89 58 04             	mov    %ebx,0x4(%eax)
+  free((void*)(hp + 1));
+ 6eb:	83 ec 0c             	sub    $0xc,%esp
+ 6ee:	83 c0 08             	add    $0x8,%eax
+ 6f1:	50                   	push   %eax
+ 6f2:	e8 e9 fe ff ff       	call   5e0 <free>
+  return freep;
+ 6f7:	a1 28 0a 00 00       	mov    0xa28,%eax
+      if((p = morecore(nunits)) == 0)
+ 6fc:	83 c4 10             	add    $0x10,%esp
+ 6ff:	85 c0                	test   %eax,%eax
+ 701:	75 bd                	jne    6c0 <malloc+0x50>
+        return 0;
+  }
+}
+ 703:	8d 65 f4             	lea    -0xc(%ebp),%esp
+        return 0;
+ 706:	31 c0                	xor    %eax,%eax
+}
+ 708:	5b                   	pop    %ebx
+ 709:	5e                   	pop    %esi
+ 70a:	5f                   	pop    %edi
+ 70b:	5d                   	pop    %ebp
+ 70c:	c3                   	ret    
+    if(p->s.size >= nunits){
+ 70d:	89 c2                	mov    %eax,%edx
+ 70f:	89 f8                	mov    %edi,%eax
+ 711:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+      if(p->s.size == nunits)
+ 718:	39 ce                	cmp    %ecx,%esi
+ 71a:	74 54                	je     770 <malloc+0x100>
+        p->s.size -= nunits;
+ 71c:	29 f1                	sub    %esi,%ecx
+ 71e:	89 4a 04             	mov    %ecx,0x4(%edx)
+        p += p->s.size;
+ 721:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
+        p->s.size = nunits;
+ 724:	89 72 04             	mov    %esi,0x4(%edx)
+      freep = prevp;
+ 727:	a3 28 0a 00 00       	mov    %eax,0xa28
+}
+ 72c:	8d 65 f4             	lea    -0xc(%ebp),%esp
+      return (void*)(p + 1);
+ 72f:	8d 42 08             	lea    0x8(%edx),%eax
+}
+ 732:	5b                   	pop    %ebx
+ 733:	5e                   	pop    %esi
+ 734:	5f                   	pop    %edi
+ 735:	5d                   	pop    %ebp
+ 736:	c3                   	ret    
+ 737:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+ 73e:	66 90                	xchg   %ax,%ax
+    base.s.ptr = freep = prevp = &base;
+ 740:	c7 05 28 0a 00 00 2c 	movl   $0xa2c,0xa28
+ 747:	0a 00 00 
+    base.s.size = 0;
+ 74a:	bf 2c 0a 00 00       	mov    $0xa2c,%edi
+    base.s.ptr = freep = prevp = &base;
+ 74f:	c7 05 2c 0a 00 00 2c 	movl   $0xa2c,0xa2c
+ 756:	0a 00 00 
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 759:	89 f8                	mov    %edi,%eax
+    base.s.size = 0;
+ 75b:	c7 05 30 0a 00 00 00 	movl   $0x0,0xa30
+ 762:	00 00 00 
+    if(p->s.size >= nunits){
+ 765:	e9 36 ff ff ff       	jmp    6a0 <malloc+0x30>
+ 76a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+        prevp->s.ptr = p->s.ptr;
+ 770:	8b 0a                	mov    (%edx),%ecx
+ 772:	89 08                	mov    %ecx,(%eax)
+ 774:	eb b1                	jmp    727 <malloc+0xb7>
diff -ruN xv6-public/zombie.d copy-xv6/zombie.d
--- xv6-public/zombie.d	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/zombie.d	2022-09-05 23:26:12.560781080 +0530
@@ -0,0 +1 @@
+zombie.o: zombie.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/zombie.o and copy-xv6/zombie.o differ
diff -ruN xv6-public/zombie.sym copy-xv6/zombie.sym
--- xv6-public/zombie.sym	1970-01-01 05:30:00.000000000 +0530
+++ copy-xv6/zombie.sym	2022-09-05 23:26:12.572781080 +0530
@@ -0,0 +1,61 @@
+00000000 .text
+00000778 .rodata
+00000794 .eh_frame
+00000a28 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 zombie.c
+00000000 ulib.c
+00000000 printf.c
+00000360 printint
+00000780 digits.1097
+00000000 umalloc.c
+00000a28 freep
+00000a2c base
+00000030 strcpy
+00000410 printf
+0000034b thread_exit
+00000260 memmove
+000002db mknod
+00000150 gets
+00000313 getpid
+00000670 malloc
+00000323 sleep
+000002a3 pipe
+000002b3 write
+000002eb fstat
+000002c3 kill
+00000303 chdir
+000002cb exec
+0000029b wait
+000002ab read
+000002e3 unlink
+0000028b fork
+0000031b sbrk
+0000032b uptime
+00000a28 __bss_start
+000000f0 memset
+00000000 main
+00000060 strcmp
+0000030b dup
+000001d0 stat
+00000a28 _edata
+00000a34 _end
+000002f3 link
+00000293 exit
+00000220 atoi
+00000333 draw
+000000b0 strlen
+000002d3 open
+00000110 strchr
+0000033b thread_create
+000002fb mkdir
+000002bb close
+00000343 thread_join
+000005e0 free
